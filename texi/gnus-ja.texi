\input texinfo                  @c -*-texinfo-*-

@setfilename gnus-ja
@settitle Semi-gnus 6.10 Manual
@synindex fn cp
@synindex vr cp
@synindex pg cp
@c @direntry
@c * Semi-gnus-ja: (gnus-ja).   The news reader Semi-gnus (日本語版).
@c @end direntry
@iftex
@finalout
@end iftex
@setchapternewpage odd

@iftex
@end iftex


@ifinfo

This file documents gnus, the GNU Emacs newsreader.

このファイルは GNU Emacs のニュースリーダである gnus に関する説明書です。

Copyright (C) 1995,96 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

@ignore
Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

この段落が取り除かれているのを除き、これと同じ複製に関する許可文が表示さ
れている限り、このファイルを Tex にかけて、その結果を印刷することを許可
する (この段落は印刷されたマニュアルでは参照されません)。

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果もこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

@end ifinfo

@tex

@titlepage
@title Semi-gnus 6.10 Manual

@author by Lars Magne Ingebrigtsen
@author by members of Semi-gnus mailing-list
@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1995,96,97 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果をこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

@end titlepage
@page

@end tex


@node Top
@top The gnus Newsreader

@ifinfo

Gnus を使うことによって Emacs でニュース (news) を（それにメール (mail) 
も）読むことができます。ニュースは @sc{nntp}、ローカルスプール、mbox ファ
イルなどのあらゆる極悪な手段を駆使して手に入れることができます。運試しを
してみようと思うならば、全てを同時に用いることもできます。

Semi-gnus は SEMI API に基づく MIME 機能を提供します。そういう訳で、
Semi-gnus は、大きな絵が入っていたりさまざまな形式を用いたりしているちょっ
と変わった記事を読む権利を擁護します。Semi-gnus は MULE API に基づく国際
化・地域化、および、多字化機能を提供します。よって、Semi-gnus はさまざま
な言語圏を差別しません。ああ、クリンゴンの方は Unicode Next Generationを
お待ちください。

この説明書は Semi-gnus 6.10 に対応します。

@end ifinfo

@iftex

Gnus は GNU Emacs の先進的で、説明のある、カスタマイズ可能で、拡張可能な、
リアルタイムでないニュースリーダーです。

おおっと。不思議なことに以前にも似たようなことを聞いたことがあるような気
がします。真似をしたと非難されないうちに説明を始めましょう：

Gnus はメッセージを読むことに関する実験場です。Gnus はすべてをニュースグ
ループのように表示します。Gnus でメールを読み、ディレクトリーをブラウズ
し、@code{ftp} をすることができます。ああ、それに、ニュースを読むことさ
えできます！

Emacs が文章を編集する人に力を与えるように、gnus はニュースを読む人に力
を与えようとしています。Gnus は利用者が実行可能なことに制限を設けません。
利用者が自分で望む動作をするように gnus を拡張することを奨励しています。
プログラムが人を操作するべきではありません。人がプログラムを使う（もしく
は濫用する）ことによって、やりたいことをできるようになっているべきなので
す。

@end iftex


@menu
* Starting Up::           ニュースを見つけるのには苦労が伴うかも知れない
* The Group Buffer::      グループを選択し、購読し、削除する
* The Summary Buffer::    記事を読み、保存し、投稿する
* The Article Buffer::    記事を表示し、扱う
* Composing Messages::    メールとニュースを送るための情報
* Select Methods::        Gnus は全てのメッセージをいろいろな選択方法で読む
* Scoring::               記事に値をつける
* Various::               一般的な設定
* The End::               さらば、そしてさようなら
* Appendices::            用語、Emacs 入門、FAQ、歴史、内部構造
* Index::                 変数、関数、概念の索引
* Key Index::             キー索引
@end menu

@node Starting Up
@chapter gnus の起動
@cindex starting up

@kindex M-x gnus
@findex gnus
システム管理者が適切な設定をしていたならば、gnus を起動してニュースを読
むのは非常に簡単です。そう、Emacs で @kbd{M-x gnus} と打つだけです。

@findex gnus-other-frame
@kindex M-x gnus-other-frame
別のフレーム (frame) で gnus を起動したいときは、命令 @kbd{M-x
gnus-other-frame} を使うことができます。

開始時に何かがうまくいかないときは @file{~/.gnus} ファイルの中で変数をい
くつかいじくりまわさなければならないでしょう。このファイルは 
@file{~/.emacs} と似ていますが、こちらは gnus が起動するときに読み込まれ
ます。

この説明書でよくわからない用語がでてきたときは、用語の項 
(@pxref{Terminology}) を参照してください。

@menu
* Finding the News::    ニュースを取得する方法を選ぶ
* The First Time::      最初に起動したときに gnus は何をするか
* The Server is Down::  どうすればそのようなときにメールを手に入れることができるか
* Slave Gnusae::        同時に一つ以上の gnus を作動させることができる
* Fetching a Group::    グループを読むためだけに gnus を起動する
* New Groups::          Gnus が新しいグループに対して何をするか
* Startup Files::       やっかいなスタートアップファイル--@file{.newsrc}
* Auto Save::           クラッシュからの回復
* The Active File::     遅い回線からのファイルの取得には時間がかかる
* Changing Servers::    あるサーバから別のサーバへ移りたいかもしれない
* Startup Variables::   変更したいと思うかもしれない変数
@end menu


@node Finding the News
@section ニュースを見つける
@cindex finding news

@vindex gnus-select-method
@c @head
変数 @code{gnus-select-method} は gnus がどこでニュースを探すべきかを示
します。この変数ははじめの要素が @dfn{方法}、2 番目の要素が @dfn{場所} 
を表すリストである必要があります。この方法はあなたの基本方法 (native
method) になります。この方法で取ってこないグループは全て外部 (foreign) 
グループです。

たとえば、@sc{nntp} サーバー @samp{news.somewhere.edu} から毎日（薬のよ
うに）一定の量のニュースを摂取したいのであれば、

@lisp
(setq gnus-select-method '(nntp "news.somewhere.edu"))
@end lisp

@noindent
のようにすることができます。

ローカル・スプールのディレクトリを読み込みたい場合は、

@lisp
(setq gnus-select-method '(nnspool ""))
@end lisp

@noindent
のようにできます。

ローカルのスプールを使えるのであれば、かなりの確率でその方がずっと速いで
しょうし、それを使うべきでしょう。

@vindex gnus-nntpserver-file
@cindex NNTPSERVER
@cindex @sc{nntp} server
もしこの変数が設定されていなければ、gnus は @code{NNTPSERVER} 環境変数を
読みにいきます。もしその変数が設定されていなければ、gnus は
@code{gnus-nntpserver-file}（設定されていない場合は 
@file{/etc/nntpserver}）がこの件に関して何かを言っていないかを調べます。
もしそれも失敗したなら、gnusは Emacs が動作しているサーバーを @sc{nntp} 
サーバーとして使おうとします。随分な当て推量ですけどね。

@vindex gnus-nntp-server
@code{gnus-nntp-server} が設定されていると、この変数は
@code{gnus-select-method} を上書きします。ですから、
@code{gnus-nntp-server} は @code{nil} に設定するべきで、初期設定でもその
ようになっています。

@vindex gnus-secondary-servers
Gnus に @sc{nntp} サーバーの名前の入力を対話的に指定することもできます。
@code{gnus} に数値でない接頭引数を渡すと（例：@kbd{C-u M-x gnus}）、gnus 
は @code{gnus-secondary-servers} リスト（もし存在するならば）からサーバー
を選ぶことができるようにします。ただ単に接続したいと思ったサーバーの名前
を打つこともできます。

@findex gnus-group-browse-foreign-server
@kindex B (Group)
しかし、普段日常的には一つの @sc{nntp} サーバを使い、違ったサーバーには興
味のあるグループが少ししかない場合、グループバッファで @kbd{B} 命令を使う
ことの方が良いでしょう。それは、選択可能なグループを表示し、その中からどれ
でも好きなものを購読することができます。これは、@file{.newsrc} の保持をずっ
とやりやすくします。@xref{Foreign Groups, 外部グループ}.

@vindex gnus-secondary-select-methods
@c @head
外部グループに対する少し違ったやり方は、変数 
@code{gnus-secondary-select-methods} を設定する方法です。この変数に表さ
れている選択方法は、多くの点で @code{gnus-select-method} サーバーの択方
法と同じように扱われます。起動中にアクティブファイルを探しにいき （もし
要求されていれば）、これらのサーバー上にできた新しいニュースグループは元々
のグループと同じように購読（もしくは非購読）されます。

たとえば、メールを読むために @code{nnmbox} バックエンド (backend) を使い
たいときは、普通、この変数を、

@lisp
(setq gnus-secondary-select-methods '((nnmbox "")))
@end lisp

@noindent
と設定します。

@node The First Time
@section 一番初め
@cindex first time usage

起動用ファイルが存在しないときは、gnus はディフォルトでどのグループが購
読されているべきかを決定しようとします。

@vindex gnus-default-subscribed-newsgroups
変数 @code{gnus-default-subscribed-newsgroups} が設定されていると、gnus
はそのリストの中のグループを購読し、残りを削除します。システム管理者はこ
の変数を何か役に立つものに設定しておくことが望まれます。

そうでないときは、gnus は少しの任意のグループを購読します（例：
@samp{*.newusers}）。（@dfn{任意}はここでは、@dfn{Lars さんが読むべきで
あると考えるもの}というように定義されています）

また、たいていの共通の問題の解決の手助けになるよう、gnus に関する文書の
グループも購読することになるでしょう。

@code{gnus-default-subscribed-newsgroups} が @code{t} のときは、gnus は新
しいグループを扱うのに普通の関数を使い、特別なことは何もしません。


@node The Server is Down
@section サーバーが落ちている
@cindex server errors

初期設定 (default) のサーバーが落ちているときは、当然 gnus の起動にいく
つかの問題が発生します。しかし、ニュースグループの他にいくつかメールのグ
ループがあれば、それにもかかわらず gnus を起動したいと思うかもしれません。

Gnus は、信頼できるプログラムの一つとして、サーバーと接続できないときは
基本選択方法なしで続けるかどうかを尋ねます。これは実際にはサーバーが存在
しないとき（例えば、アドレスを間違えた場合）やサーバーが何らかの理由で一
時的に調子がおかしくなっているときに起こります。もしそのまま続行すること
にして、外部グループが一つも無い場合、実はグループバッファではほとんど何
もできないということに気がつくでしょう。でも、ねぇ、それはあなたの問題で
す。ハハハッ。

@findex gnus-no-server
@kindex M-x gnus-no-server
@c @head
サーバーが完全に落ちているのを知っているか、サーバーでわずらうことなくメー
ルだけを読みたいときは、gnus を起動するのに、@code{gnus-no-server} 命令
を使うことができます。急いでいるときにもぴったりでしょう。この命令は本来
のサーバーには接続しません――その代わりに、レベル 1 と 2 にあるすべての
グループを活動状態にします（基本グループでないグループはその 2 つのレベ
ルにしておくのが望ましいでしょう）。


@node Slave Gnusae
@section gnus をスレーブにする
@cindex slave

あなたは 2 つ以上の Emacs と、2 つ以上の gnus を同時に動かしたいと思うか
もしれません。違った @file{.newsrc} ファイルを使っているなら（例えば、2 
つの違ったサーバーから読み込むために、2 つの違った gnus を動作させている
場合）、まったく問題はありません。それを行えば良いだけです。

問題は、同じ @code{.newsrc} ファイルを使う2つの gnus を動かそうとしたと
きに起こります。

この問題に対処するために、gnus タワーのシンクタンクにいる我々は新しい概
念にたどりつきました。@dfn{マスター} と @dfn{スレーブ} です。（我々はこ
の概念に特許を申請しました。そして、その言葉の著作権を得ました。お互いに
関連してこれらの言葉を使いたいなら、１回使う毎に、私に $1 を送らなければ
なりません。もっちろん、@dfn{コンピューターアプリケーションのマスター／
スレーブ関係} の使用料はもっと高くなります。）

とにかく、@kbd{M-x gnus}（もしくは、普段やっている方法）で gnus を普通に
起動します。その後のスレーブ gnus はそれぞれ @kbd{M-x gnus-slave} で起動
します。スレーブは普通の @file{.newsrc} は保存しませんが、代わりに 
@dfn{スレーブファイル} にスレーブの起動中にどのようなグループが読まれた
かという情報だけを保存します。マスター gnus が起動するとき、それはそれら
のスレーブファイルを読み込み（そして消し）、それらからすべての情報を取り
込みます。（スレーブファイルは、最終的な変更が優先されるようにそれらが作
られた順番で読まれます。） 

もちろん、スレーブファイルからの情報は普通の（すなわち、マスターの）ファ
イルよりも優先されます。


@node Fetching a Group
@section グループを取得する
@cindex fetching a group

@findex gnus-fetch-group
時々、“このグループを読みたいのであって、gnus が起動しているかどうかを
気にしたくない。”ということができれば便利なことがあります。これは、利用
者よりもプログラムのコードを書く人に便利な機能ですが、どちらにしろ、コマ
ンド @code{gnus-fetch-group} はこの機能を提供します。そのコマンドは、グ
ループの名前を引数としてとります。


@node New Groups
@section 新しいグループ
@cindex new groups
@cindex subscription

@vindex gnus-check-new-newsgroups
新しいニュースグループを全く見ないで満足であるならば、
@code{gnus-check-new-newsgroups} を @code{nil} に設定することができます。
これを設定した場合、起動にかかる時間が短くなります。この変数が nil に設
定されていても、グループバッファで @kbd{U} を押せばいつでも新しいグルー
プを購読することができます (@pxref{Group Maintenance})。初期設定ではこの
変数は @code{ask-server} です。この変数が @code{always} に設定されている
と、命令 @kbd{g} を実行したときでも gnus はバックエンドに新しいグループ
を探すことを求めます (@pxref{Scanning New Messages})。

@menu
* Checking New Groups::      どのグループが新しいかを決定する。
* Subscription Methods::     新しいグループに対して gnus は何をすべきか
* Filtering New Groups::     Gnus に特定の新しいグループを無視させる
@end menu


@node Checking New Groups
@subsection 新しいグループを調べる

Gnus は、普通はグループが新しいかどうかを、購読しているグループと削除さ
れているグループのリストとアクティブファイルを比較することにより決定して
います。この方法は特に速いというわけではありません。
@code{gnus-check-new-newsgroups} が @code{ask-server} であると、gnus は
サーバーに、最後に接続してから新しいグループができているかどうかを尋ねま
す。この方法は速いし、安上がりです。これにより、削除されたグループのリス
トを保持しておくことからから完全に開放されます。ですから、
@code{gnus-save-killed-list} を @code{nil} にすることができるでしょう。
そうすれば、起動、終了の両方、そして全体にわたって時間を節約できます。ディ
スク消費量も少なくなります。それなら、どうしてこれが初期設定ではないので
しょう？残念ながら、すべてのサーバーがこの命令を理解するわけではないので
す。

私は今あなたが何を考えているかを当てられます。どうすればサーバーが 
@code{ask-server} を理解するかがわかるのでしょう？え、違うのですか？あぁ、
良かった。というのは、確実な答は存在しないのです。私に言えることは、この
変数を @code{ask-server} に設定して、数日間新しいグループが現れるかどう
かを調べてください、ということだけです。もしいくつかのグループが現れたな
ら、それで動作しています。一つも現れなければ、それは動作していません。私
は、gnus にサーバーが @code{ask-server} を理解するかどうかを推量させる関
数を書くこともできますが、それは単に推量しているにすぎません。ですから、
その関数を書くことはないでしょう。他の方法としては、サーバーに 
@code{telnet} をして、@code{HELP} と打ち、サーバーが理解するコマンドの中
に @samp{NEWGROUPS} があるかどうかを調べることもできます。もしあれば、お
そらく動作するでしょう（しかし、適切に機能を提供することなく 
@samp{NEWGROUPS} をリストに含めるサーバーもあります）。

この変数は、選択方法のリストであることもできます。そのときは、gnus は命
令 @code{ask-server} をそれぞれの選択方法に対して実行し、普通の方法で購
読（もしくは、非購読）します。これの副作用は、起動にかなり時間がかかるの
で、待っている間に瞑想できることです。永久の幸福を達成するために、マント
ラ ``dingnusdingnusdingnus'' を使ってください。


@node Subscription Methods
@subsection 購読方法

@vindex gnus-subscribe-newsgroup-method
新しいグループに遭遇したときに gnus が何をするかは、変数 
@code{gnus-subscribe-newsgroup-method} によって決定されます。

この変数は関数を含んでいる必要があります。この関数は新しいグループの名前
を唯一の引数として呼ばれます。

いくつかの手軽なプレハブ関数は、以下のようになっています。

@table @code

@item gnus-subscribe-zombies
@vindex gnus-subscribe-zombies
すべての新しいグループをゾンビ (zombie) にします。これが初期設定 になっ
ています。後でゾンビを (@kbd{A z} によって) 概観したり、（@kbd{S z} によっ
て）適切に全てを削除したり、（@kbd{u} によって）購読したりできます。

@item gnus-subscribe-randomly
@vindex gnus-subscribe-randomly
任意の順番ですべての新しいグループを購読します。実際には、すべての新しい
グループはグループバッファの『一番上』に加えられます。

@item gnus-subscribe-alphabetically
@vindex gnus-subscribe-alphabetically
すべての新しいグループをアルファベット順に購読します。

@item gnus-subscribe-hierarchically
@vindex gnus-subscribe-hierarchically
すべての新しいグループを階層的に購読します。この関数と 
@code{gnus-subscribe-alphabetically} の違いは少ししかありません。
@code{gnus-subscribe-alphabetically} は新しいグループを厳密にアルファベッ
ト順にならべますが、この関数はグループをその階層の中に入れます。ですから、
@samp{rec} の階層を @samp{comp} の階層の前に持ってきたい場合、この関数は
その配置をぐちゃぐちゃにはしません。もしくは、そのようなものです。

@item gnus-subscribe-interactively
@vindex gnus-subscribe-interactively
新しいグループを対話的に購読します。これは gnus が @strong{全て} のグルー
プに対して尋ねることを意味しています。購読するグループは階層的に購読され
ます。

@item gnus-subscribe-killed
@vindex gnus-subscribe-killed
すべての新しいグループを削除します。

@end table

@vindex gnus-subscribe-hierarchical-interactive
上の変数と良く関係した変数は、
@code{gnus-subscribe-hierarchical-interactive} です。この変数が 
@code{nil} でないと、gnus は階層的な方法で新しいグループを購読するかどうか
を尋ねます。gnus はそれぞれの階層で、それを下に降りるかどうかを尋ねます。

よくある間違いは、数段落前の変数 
(@code{gnus-subscribe-newsgroup-method}) を 
@code{gnus-subscribe-herarchical-interactive} に設定することです。これは
誤りです。これは動作しません。これはおめでたい人のすることです。ですから、
絶対にしないでください。


@node Filtering New Groups
@subsection 新しいグループを選別する

どの新しいグループが購読（もしくは、無視）されるべきかを管理する快適で手
軽な方法は、ファイル @file{.newsrc} の先頭に @dfn{options} 行を挿入する
ことです。次は、例です。

@example
options -n !alt.all !rec.all sci.all
@end example

@vindex gnus-subscribe-options-newsgroup-method
この行は、明らかにまじめで理知的で科学的な人間（もしくは単なる古く退屈な
人間）が書いたものです。なぜなら、これは @samp{alt} と @samp{rec} で始ま
る名前を持つグループは全て無視され、@samp{sci} で始まる名前を持つグルー
プは全て購読する、ということを表しているからです。Gnus はこれらのグルー
プを購読するのに、普通の購読方法を用いません。代わりに、
@code{gnus-subscribe-options-newsgroup-method} が用いられます。この変数
は初期設定では @code{gnus-subscribe-alphabetically} です。

@vindex gnus-options-not-subscribe
@vindex gnus-options-subscribe
ファイル @file{.newsrc} をいじりたくない場合は、
@code{gnus-options-subscribe} と @code{gnus-options-not-subscribe} の2
つの変数だけを設定することもできます。この2つの変数はファイル 
@file{.newsrc} の @samp{optinos -n} 行と全く同じことをします。どちらの変
数も正規表現で、新しいグループは前者に合致すれば無条件に購読され、後者に
合致すると無視されます。

@vindex gnus-auto-subscribed-groups
さらにここでおせっかいをする変数は、@code{gnus-auto-subscribed-groups} 
です。それは @code{gnus-options-subscribe} と全く同じように動作しますの
で、本当は余分なものです。しかし、私はこの二つがあった方が良いと思いまし
た。もう一方の変数はユーザがいじくるのに使われるのに対して、この変数はい
くつかの基本的な規則を設定するためのものです。初期設定ではこの変数はメー
ルバックエンド (@code{nnml} 、@code{nnbabyl} 、@code{nnfolder} 、
@code{nnmbox} と@code{nnmh}) からできる全ての新しいグループを購読するよ
うになっています。それが嫌であれば、この変数を @code{nil} に設定してくだ
さい。

この正規表現に合致する新しいグループは 
@code{gnus-subscribe-options-newsgroup-method} を使って購読されます。


@node Changing Servers
@section サーバーを換える
@cindex changing servers

ときどき、ある @sc{nntp} サーバーから別のサーバーへ移動しなければならな
いことがあります。このようなことはめったにおきませんが、おそらくあなたが
仕事を変えたり、使っているサーバーがとても不安定で、別のものに乗り換えた
いというときに必要になるでしょう。

サーバーを変更するのはとても簡単ですよね？
@code{gnus-select-method} を新しいサーバーを指し示すように変更すればいい
だけですね？

@emph{違います！}

記事の番号は違った @sc{nntp} サーバーでも (どうにかして) 同じにしてある、
ということはありません。そして、 guns がどの記事を読んだかを記録する唯一
の方法は、記事番号を記録することです。ですから、
@code{gnus-select-method} を変更したときは、ファイル @file{.newsrc} は意
味がなくなります。

Gnusはファイル @file{.newsrc} をあるサーバー用から別のサーバー用に変換す
る関数を2、3用意しています。それらには一つ共通点があります---実行にながーー
い時間がかかることです。おそらく、どうしても必要になったとき以外にこの関
数を使おうとは思わないでしょう。

@kindex M-x gnus-change-server
@findex gnus-change-server
もし両方のサーバーに接続できるなら、gnusはあなたが読んだ記事全てに対して
ヘッダー (headers) を要求して、@code{Message-ID} を比較し、読んだ記事と
記事の印を新しく記録します。コマンド @kbd{M-x gnus-change-server} はこれ
をすべての基本グループに対して行います。そのコマンドは移動先の方法の入力
を促します。

@kindex M-x gnus-group-move-group-to-server
@findex gnus-group-move-group-to-server
個々のグループを命令 @kbd{M-x gnus-group-move-group-to-server} で移
動することもできます。これはあるサーバーから別のサーバーへ一つの (外部) 
グループを移動したいときに役に立ちます。

@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
古いサーバーと新しいサーバーの両方に接続することができないとき、印と読ん
だ範囲はすべて意味が無くなります。そのようなときは、コマンド @kbd{M-x
gnus-group-clear-data-on-native-groups} を使って、基本グループに関するデー
タをすべて消去することができます。このコマンドは注意して使ってください。 


@node Startup Files
@section 起動ファイル
@cindex startup files
@cindex .newsrc
@cindex .newsrc.el
@cindex .newsrc.eld

今や、あなたはファイル @file{.newsrc} についてすべて知っています。すべて
の購読情報は伝統的にこのファイルに蓄積されます。

@sc{GNUS} では物事が少々複雑になっています。ファイル @file{.newsrc} を最
新のものにするだけではなく、ファイル @file{.newsrc} には合わない情報を保
存しておくために @file{.newsrc.el} と呼ばれるファイルを使います。 (実際
は、ファイル @file{.newsrc} の全ての情報を複製して保持しています。)
@sc{gnus}はこれらの中で一番最後に保存されたものを使います。これをするこ
とにより、@sc{GNUS} と他のニュースリーダーを切り替えて使うことができます。

これはちょっとばかな方法なので、gnus はもっと良い方法を編み出しました。
@file{.newsrc} と @file{.newsrc.el} ファイルに加えて、gnus は 
@file{.newsrc.eld} と呼ばれるファイルも持っています。Gnus はこれらの中で
一番新しいファイルを読みますが、ファイル @file{.newsrc.el} に書き込むこ
とはありません。ファイル @file{.newsrc.eld} は絶対に消すべきではありませ
ん。---それはファイル @file{.newsrc} にはないたくさんの情報を保持してい
ます。 


@vindex gnus-save-newsrc-file
@code{gnus-save-newsrc-file} を @code{nil} にすることによってファイル
@file{.newsrc} に書き込むのを止めることができます。そうすれば、そのファ
イルを削除することができ、ディスク容量を節約することができ、gnus の終了
が速くなります。しかし、そうすると他のニュースリーダーを使えなくなります。
でも、ちょっと、誰かそうしたい人がいるでしょうか。 

@vindex gnus-save-killed-list
@code{gnus-save-killed-list} (初期設定では @code{t}) が @code{nil} であ
ると、gnus は削除されたグループを起動ファイルに保存しません。これは、(起
動時と終了時の) 時間と、(ディスクの) 容量を節約します。こうすると、gnus
がどのグループが新しいかの記録を持っていないことになりますので、新しいグ
ループの自動購読方法は意味が無くなります。この変数を @code{nil} にしたと
きは、@code{gnus-check-new-newsgroups} を常に @code{nil} か 
@code{ask-server} にしておくべきでしょう (@pxref{New Groups})。この変数
は正規表現であることもできます。そのような場合は、ファイルを保存する直前
にその正規表現に合致しないすべてのグループを消去します。これは、すべての
サーバーが @code{ask-server} を理解するわけではない、といったような、特
定のあいまいな状況のときに役に立つでしょう。

@vindex gnus-startup-file
変数 @code{gnus-startup-file} は起動ファイルがどこにあるかを指定します。
初期値は @file{~/.newsrc} で、それがどのようなものであれ、末尾に 
@samp{.eld} をつけたものが gnus (El Dingo) の起動ファイルになります。

@vindex gnus-save-newsrc-hook
@vindex gnus-save-quick-newsrc-hook
@vindex gnus-save-standard-newsrc-hook
@code{gnus-save-newsrc-hook} は newsrc ファイルの中のどれかを保存する前
に実行されるのに対し、@code{gnus-save-quick-newsrc-hook} はファイル 
@file{.newsrc.eld} を保存する前に実行され、
@code{gnus-save-standard-newsrc-hook} はファイル @file{.newsrc} を保存す
る前に実行されます。後の二つは普通は版管理を入れたり切ったりするのに使わ
れます。初期設定では、起動ファイルを保存するときに版管理に入ります。バッ
クアップファイルの作成を止めたいときは、次のようにしてください。

@lisp
(defun turn-off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'gnus-save-quick-newsrc-hook 'turn-off-backup)
(add-hook 'gnus-save-standard-newsrc-hook 'turn-off-backup)
@end lisp

@vindex gnus-init-file
Gnus が起動すると、@code{gnus-site-init-file} (初期設定では 
@file{.../site-lisp/gnus}) と @code{gnus-init-file} (初期設定では 
@file{~/.gnus}) のファイルを読み込みます。これらは普通の Emacs Lisp ファ
イルで、@file{~/.emacs} や @file{site-init} ファイルを gnus 関係のもので
乱雑にしないようにするために使うことができます。Gnus はこれらと同じ名前
のファイルを調べますが、接尾語 @file{.elc} と @file{.el} がついているも
のも調べます。言い換えれば、@code{gnus-init-file} を @file{~/.gnus} に設
定すると、gnus は (この順番に) @file{~/.gnus.elc} 、@file{~/.gnus.el} を
探し、最後に @file{~/.gnus} を探します。



@node Auto Save
@section 自動保存
@cindex dribble file
@cindex auto-save

何か gnus のデータを変更すること (記事を読む、印を付ける、グループを削除
または購読する) をしたとき、変更は特別な@dfn{ドリブルバッファ (dribble
buffer)} に書き込まれます。このバッファはEmacs が普通するように自動保存
されます。ファイル @file{.newsrc} を保存する前に Emacsが落ちたときは、す
べての変更をこのファイルから回復することができるでしょう。

起動時に gnus がこのファイルの存在を発見すると、gnus はそれを読み込むか
どうかを利用者に尋ねます。本当の起動ファイルが保存されれば、自動保存ファ
イルは削除されます。 

@vindex gnus-use-dribble-file
@code{gnus-use-dribble-file} が @code{nil} であると、gnus はドリブルバッ
ファをつくったり、維持したりしません。初期値は @code{t} です。

@vindex gnus-dribble-directory
Gnus はドリブルファイルを @code{gnus-dribble-directory} に置きます。ディ
フォルトではそのようになっていますが、この変数が @code{nil} であると、
gnus はファイル@file{.newsrc} の置かれているディレクトリ (これは普通は利
用者のホームディレクトリです) に入っていってドリブルファイルを作ります。
ドリブルファイルは @code{.newsrc} と同じ許可属性を与えられます。 

@vindex gnus-always-read-dribble-file
もし @code{gnus-always-read-dribble-file} が @code{nil} でなければ、gnus 
は利用者に尋ねる事無く、ドリブルファイルを起動時に読み込みます。



@node The Active File
@section アクティブファイル
@cindex active file
@cindex ignored groups

Gnus は起動したときや、実際に新しい記事が到着しているかを決定しようとす
るときに、アクティブファイルを読み込みます。これはとても大きなファイルで、
そのサーバーの活動中のグループと記事のすべてのリストが入っています。

@vindex gnus-ignored-newsgroups
アクティブファイルを検査する前に、gnus は正規表現 
@code{gnus-ignored-newsgroups} に合うすべての行を削除します。これは主に
偽の名前を持つグループを排除するために使われてきましたが、興味の無いグルー
プの階層を無視するために使うこともできます。しかし、これはお勧めできませ
ん。本当のことを言うと、全く賛成できません。代わりに、そのような用途に用
いられる変数の概略を知るために、@pxref{New Groups} を参照してください。

@c This variable is
@c @code{nil} by default, and will slow down active file handling somewhat
@c if you set it to anything else.

@vindex gnus-read-active-file
@c @head
アクティブファイルは比較的大きくなる傾向があるので、遅い回線を使っている
ときは、アクティブファイルを読み込まないように 
@code{gnus-read-active-file} を @code{nil} に設定することができます。こ
の変数は初期設定では @code{some} です。

そのような時は、gnus は実際に購読されているグループに関する情報だけを得
てやっていこうとします。

気を付けてほしいのは、あなたが山ほどのたくさんのグループを購読していると
きにこの変数を @code{nil} 設定すると、gnus は速くなるどころか、遅くなっ
てしまうということです。現状では、ニュースを 2400bps 以上のモデムを通し
て読んでいるのでない限り、gnus の速度はかなり遅くなるでしょう。

この変数は @code{some} という値も取ることができます。その時は、gnus は現
状の情報を購読されているグループのものだけを得ようとします。いくつかのサー
バー (命令@code{LIST ACTIVE group} を使うことのできる、最新鋭の INN サー
バー) では、非常に早くなるでしょうが、他のサーバーでは速くはありません。
どのようにせよ、遅い回線では @code{some} は @code{nil} よりも速く、それ
はもちろん@code{t} よりも速くなります。

もしこの変数が @code{nil} であると、gnus は完全にがんじがらめの方法でグ
ループの情報を得ようとします。そして、これはあまり速くありません。もしそ
れが @code{some} で @sc{nntp} サーバーを使っているときは、gnus はできる
だけ速く命令を出し、一撃ですべての返答を読み込みます。この方が普通はより
良い結果をもたらしますが、サーバーが命令 @code{LIST ACTIVE group} を理解
しないなら、サーバーにとってはあまり良いとは言えません。

@code{some} か @code{nil} を使うのであれば、どちらにしろ速度を上げるため
にすべての興味の無いグループを必ず削除するべきでしょう。

この変数は2次 (secondary) 選択方法のアクティブファイル取得にも影響するこ
とに気を付けてください。


@node Startup Variables
@section 起動変数

@table @code

@item gnus-load-hook
@vindex gnus-load-hook
Gnus が読み込まれているときに実行されるフックです。何度 gnus を起動しても、
Emacs が起動してから終了するまでに普通はこのフックは一回しか実行されないこ
とに注意してください。

@item gnus-before-startup-hook
@vindex gnus-before-startup-hook
Gnus の起動に成功した後に実行されるフックです。

@item gnus-startup-hook
@vindex gnus-startup-hook
Gnus が起動された後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook
Gnus の起動に成功した後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook

ファイル @file{.newsrc} を読み込んだ後で、グループバッファを作成する前に
実行されるフックです。

@item gnus-check-bogus-newsgroups
@vindex gnus-check-bogus-newsgroups
もし @code{nil} でないと、gnus は起動時に調べてすべての偽グループを削除
します。@dfn{偽グループ (bogus group)} はあなたの @file{.newsrc} ファイ
ルには存在するけれど、ニュースサーバーには実際には存在しない、というグルー
プのことです。偽グループを調べるのにはかなり時間がかかりますので、時間と
資源を節約するために、この機能は使わないほうがいいでしょう。そして、代わ
りにグループバッファで時々偽グループを調べるのが良いでしょう
(@pxref{Group Maintenance})。

@item gnus-inhibit-startup-message
@vindex gnus-inhibit-startup-message
もし @code{nil} でないと、起動時のメッセージは表示されません。そのように
すれば、仕事の代わりにニュースを読んでいるのを上司に気付かれにくくなるで
しょう。この変数は @file{.gnus.el} がロードされる前に使われますので、
@code{.emacs} に設定するべきである点を注意してください。

@item gnus-no-groups-message
@vindex gnus-no-groups-message
グループが一つも存在しないときに gnus が表示するメッセージです。

@item gnus-play-startup-jingle
@vindex gnus-play-startup-jingle
もし @code{nil} でないと、起動時に gnus の短い曲を演奏します。

@item gnus-startup-jingle
@vindex gnus-startup-jingle
上の変数が @code{nil} でないときに演奏される短い曲です。初期値は 
@samp{Tuxdemoon.Jingle4.au} です。

@end table


@node The Group Buffer
@chapter グループバッファ
@cindex group buffer

グループバッファ (@dfn{group buffer}) は有効なグループを全部（あるいは一
部を）一覧表示します。これは gnus を起動したときに最初に表示されるバッファ
で、gnus が生きている限り決して消されることはありません。



@menu
* Group Buffer Format::    表示されている情報と変更の方法。
* Group Maneuvering::      グループバッファを移動するコマンド。
* Selecting a Group::      実際にニュースを読む。
* Group Data::             グループの情報を変更する。
* Subscription Commands::  購読、購読中止、消去。
* Group Levels::           レベル？それって何？
* Group Score::            あなたの好きなグループを見つけ出す方法。
* Marking Groups::         グループに印をつけておいて、後で処理できます。
* Foreign Groups::         グループの作成と修正。
* Group Parameters::       グループ毎に違ったパラメータを持たせられます。
* Listing Groups::         Gnus はグループをいろいろな分け方で表示できます。
* Sorting Groups::         グループの順番の配置替え。
* Group Maintenance::      きれいな @file{.newsrc} の保ち方。
* Browse Foreign Server::  サーバを概観できる。何が読めるのか見てみよう。
* Exiting Gnus::           ニュース読むのをやめて、仕事をしよう。
* Group Topics::           グループを切り混ぜて、トピックごとに分割する。
* Misc Group Stuff::       他にできること。
@end menu


@node Group Buffer Format
@section グループバッファの形式

@menu
* Group Line Specification::       グループバッファの見え方を決める。
* Group Modeline Specification::   グループバッファのモード行。
* Group Highlighting::             グループバッファにきれいに色をつける。
@end menu


@node Group Line Specification
@subsection グループ行の仕様
@cindex group buffer format

グループバッファの初期設定形式はきれいでつまんないけど、こ
れは君の好きなように、サイコーにダサくすることもできます。

これがグループ行の例です。

@example
     25: news.announce.newusers
 *    0: alt.fan.andrea-dworkin
@end example

とっても簡単でしょ？

@samp{news.announce.newusers} には 25 の未読記事があるのがわかります。
@samp{alt.fan.andrea-dworkin} には未読記事はないけれども、印をつけた記事が
いくつかあります（行頭のちっちゃなアスタリスクが見える？）。

@vindex gnus-group-line-format
この形式は @code{gnus-group-line-format} 変数をいじることで、どんな風にで
も変えられます。この変数は @code{format} の仕様風に動作します。つまり（あ
のクソ）C 言語を使う人たちのため、printf の仕様とほぼ同じです。
@xref{Formatting Variables}

@samp{%M%S%5y: %(%g%)\n} という値で上記の行を生成します。

コロンは、この行の中に必ず無くてはいけません。カーソルは、何かの操作をした
後は常にコロンのところに移動するからです。他には何も必要ではありません――
グループ名さえもです。表示されている文字は全てただの画面の飾りであり、
gnus がそれを調べることはありません。Gnus は必要とする全ての実情報を、テキ
スト属性を使って憶えています。


（もし君が、すごくヘンな、素晴らしい、表計算風のレイアウトを作ったとしたら、
みんな、君は会計の仕事が忙しくって、ニュースを読んで時間を無駄使いしたりな
んかしてない、って信じてくれるよ。）

以下が使用できるフォーマット文字のリストです。

@table @samp

@item M
そのグループが印のついた記事だけのときは、アスタリスク文字。

@item S
そのグループが購読されているかどうか。

@item L
購読度のレベル。

@item N
未読記事の数。

@item I
保留記事の数。

@item T
印付き記事の数。

@item R
既読記事の数。

@item t
推定全記事数（これは実際は @var{max-number} - @var{min-number} + 1）。

@item y
未読でも、印付きでも、保留でもない記事の数。

@item i
印付き記事と保留記事の数。

@item g
グループ名のフルネーム。

@item G
グループ名。

@item D
ニュースグループの説明。

@item o
司会者付きの場合 @samp{m}.

@item O
司会者付きの場合 @samp{(m)}.

@item s
選択方法。

@item n
どこからの選択か。

@item z
外部選択方法が使われている場合、@samp{<%s:%n>} と同じ文字列。

@item P
トピック (@pxref{Group Topics}) のレベルに応じた字下げ。

@item c
@vindex gnus-group-uncollapsed-levels
短い（省略した）グループ名。@code{gnus-group-uncollapsed-levels} 変数は、
どのレベルまでグループ名を全部残すかを示します。初期値は 1 です――こ
の意味は、@samp{gnu.emacs.gnus} のようなグループ名を @samp{g.emacs.gnus} 
に短縮するということです。

@item m
@vindex gnus-new-mail-mark
@cindex %
そのグループに最近新着メールが届いている場合は @samp{%}
(@code{gnus-new-mail-mark})。

@item d
最後にいつこのグループを読んだかを示す文字列 (@pxref{Group Timestamp})。

@item u
利用者定義指定。フォーマット文字列中で、この次の文字はアルファベット文字で
なければいけません。Gnus は @code{gnus-user-format-function-}@samp{X} 関数
を呼び出します。ここで @samp{X} は @samp{%u} に続いている文字です。この関
数は引数に、一つのダミーパラメータを渡されます。この関数は、他の各指定文字
の情報と同様に、バッファに挿入される文字列を返さなければなりません。
@end table

@cindex *
全ての「〜の数」の指定で、もしその情報が利用できない場合にはアスタリスク 
(@samp{*}) が埋められます――例えば、起動されていない外部グループや、不正
な基本グループの場合です。


@node Group Modeline Specification
@subsection グループモード行の仕様
@cindex group modeline

@vindex gnus-group-mode-line-format
モード行は @code{gnus-group-mode-line-format} (@pxref{Mode Line
Formatting}) を設定することで変更できます。こいつは指定文字をあんまりた
くさん知ってません。

@table @samp
@item S
基本ニュースサーバー。
@item M
基本選択方法。
@end table


@node Group Highlighting
@subsection グループのハイライト
@cindex highlighting
@cindex group highlighting

@vindex gnus-group-highlight
グループバッファのハイライトは @code{gnus-group-highlight} 変数
によって制御されています。これは @var{(form . face)} のようなも
のを要素に持つ連想リストです。@var{form} が何か @code{nil} 以外
に評価されるものなら、その行に対して @var{face} が使用されます。

以下がこの変数の値の例です。これは背景が暗い設定ではきれいに見え
るかも知れません。

@lisp
(face-spec-set 'my-group-face-1 
               '((t (:foreground "Red" :bold t))))
(face-spec-set 'my-group-face-2 
               '((t (:foreground "SeaGreen" :bold t))))
(face-spec-set 'my-group-face-3 
               '((t (:foreground "SpringGreen" :bold t))))
(face-spec-set 'my-group-face-4 
               '((t (:foreground "SteelBlue" :bold t))))
(face-spec-set 'my-group-face-5 
               '((t (:foreground "SkyBlue" :bold t))))

(setq gnus-group-highlight
      '(((> unread 200) . my-group-face-1)
	((and (< level 3) (zerop unread)) . my-group-face-2)
	((< level 3) . my-group-face-3)
	((zerop unread) . my-group-face-4)
	(t . my-group-face-5)))
@end lisp

@pxref{Faces and Fonts} も参照してください。

この form が評価されるときに動的に束縛されている変数には以下のも
のがあります。


@table @code
@item group
グループ名。
@item unread
そのグループの未読記事の数。
@item method
選択方法。
@item mailp
そのグループがメールのグループかどうか。
@item level
そのグループのレベル。
@item score
そのグループのスコア。
@item ticked
そのグループ中の印の付いた記事の数。
@item total
そのグループ中の全記事数。もっと正確に言うと、MAX-NUMBER - MIN_NUMBER +
1.
@item topic
トピックマイナーモードを使用している時、この変数は挿入されてい
る現在のトピックに束縛されます。 
@end table

この form が評価 (@code{eval}) されるときは、ポイントは問題のグループの行
頭にあります。従って、通常の gnus の関数のほとんどを使ってそのグループの情
報を取ってくることができます。

@vindex gnus-group-update-hook
@findex gnus-group-highlight-line
@code{gnus-group-update-hook} はグループ行が変更されたときに呼び
出されます。これは @code{gnus-visual} が @code{nil} のときは呼び
出されません。このフックは初期設定では 
@code{gnus-group-highlight-line} を呼び出します。

@node Group Maneuvering
@section グループ操作
@cindex group movement

全ての移動コマンドは数字接頭引数を理解するので、期待する通
りの動作をします。たぶんね。

@table @kbd

@item n
@kindex n (Group)
@findex gnus-group-next-unread-group
次の未読記事のあるグループに移動します
(@code{gnus-group-next-unread-group})。

@item p
@itemx DEL
@kindex DEL (Group)
@kindex p (Group)
@findex gnus-group-prev-unread-group
一つ前の未読記事のあるグループに移動します
(@code{gnus-group-prev-unread-group})。

@item N
@kindex N (Group)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item P
@kindex P (Group)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item M-n
@kindex M-n (Group)
@findex gnus-group-prev-unread-group-same-level
一つ前の同じレベル（もしくはそれより小さいレベル）の未読グループに移動しま
す(@code{gnus-group-prev-unread-group-same-level})。

@item M-p
@kindex M-p (Group)
@findex gnus-group-next-unread-group-same-level
次の同じレベル(もしくはそれより小さいレベル)の未読グループに移動します
(@code{gnus-group-next-unread-group-same-level})。
@end table

次の３つの命令はグループにジャンプするためのものです：

@table @kbd

@item j
@kindex j (Group)
@findex gnus-group-jump-to-group
グループにジャンプします（それが見えるようになっていなかったら見えるように
します）(@code{gnus-group-jump-to-group})。kill されているグループも、生き
ているグループと同様にジャンプできます。

@item ,
@kindex , (Group)
@findex gnus-group-best-unread-group
最も小さいレベルの未読グループにジャンプします
(@code{gnus-group-best-unread-group})。

@item .
@kindex . (Group)
@findex gnus-group-first-unread-group
最初の未読記事のあるグループにジャンプします
(@code{gnus-group-first-unread-group})。
@end table

@vindex gnus-group-goto-unread
@code{gnus-group-goto-unread} を @code{nil} にすると、全ての移動
コマンドは、次の未読グループではなく次のグループに移動するように
なります。そのコマンドが次の未読グループに移動する、と言い張って
いても、です。初期値は @code{t} です。


@node Selecting a Group
@section グループの選択
@cindex group selection

@table @kbd

@item SPACE
@kindex SPACE (Group)
@findex gnus-group-read-group
現在のグループを選択し、概略バッファに切り替えて最初の未読記事を表示しま
す (@code{gnus-group-read-group})。もしそのグループに未読記事が無い、もし
くはこの命令に数字以外のプレフィックスを与えると、gnus はサーバからこ
のグループの全ての古い記事を取得しようとします。@var{N} の数字接頭引数を
与えると、gnus の取得する記事数は @var{N} になります。@var{N} が正の数
であれば gnusは新しい方から @var{N} 個の記事を取得し、 @var{N} が負の数で
あれば gnus は古い方から @var{N} 個の記事を取得します。

@item RET
@kindex RET (Group)
@findex gnus-group-select-group
現在のグループを選択し、概略バッファに切り替えます
(@code{gnus-group-select-group})。@code{gnus-group-read-group} と同じ引数
を取ります――唯一の違いは、グループに入ったときに最初の未読記事を表示しな
い、ということです。

@item M-RET
@kindex M-RET (Group)
@findex gnus-group-quick-select-group
これは上記のコマンドと同じ動作をしますが、「ゴタゴタ」は最低限にしようとし
ます (@code{gnus-group-quick-select-group})。スコア・kill の処理は行われず、
ハイライトも記事消去もしません。これは、あなたが本当に急いでいて、どっかの
やたらでっかいグループに入らなければいけないときに役に立つかもしれません。
また、接頭辞に 0 を与えれば（すなわち @kbd{0 M-RET}）、gnus は概略バッファ
を作ろうとさえしません。これは概略バッファを作る前にスレッド表
示を切り替えたいとき役に立ちます (@pxref{Summary Generation Commands})。

@item M-SPACE
@kindex M-SPACE (Group)
@findex gnus-group-visible-select-group
これは @kbd{RET} コマンドと同じ動作をするさらにもう一つのコマン
ドですが、このコマンドは記事消去と保留記事を隠す処理を行いません
(@code{gnus-group-visible-select-group})。

@item M-C-RET
@kindex M-C-RET (Group)
@findex gnus-group-select-group-ephemerally
最後にこのコマンドは、現在のグループを一度限り、その内容に一切の
処理をすることのないように選択します
(@code{gnus-group-select-group-ephemerally})。 スレッド表示さ
えも行われません。この方法で選択した後にこのグループに対して行っ
たことは全て、その後に影響を与えることはありません。

@end table

@vindex gnus-large-newsgroup
@code{gnus-large-newsgroup} 変数は、何を大きなグループと考えるべきか、を 
gnus に与えます。これは初期設定では 200 です。グループに（未読と印付き
の）記事がこの数以上あれば、gnus はそのグループに入る前に利用者に確認を求
めます。利用者はサーバからいくつの記事を取得するかを指定できます。もし利用
者が負の数 (@code{-n}) を指定すれば、古い方から @code{n} 個の記事を取得し
ます。正の数であれば、新しく到着した方から @code{n} 個の記事を取得します。

@vindex gnus-select-group-hook
@vindex gnus-auto-select-first
@code{gnus-auto-select-first} は、@kbd{SPACE} コマンドでグループ
に入ったときに、自動的に記事を選択するかどうかを制御します。

@table @code

@item nil
グループに入ったときにどの記事も選択しない。ただ概略バッファを
表示するだけ。

@item t
グループに入ったときに、最初の未読記事を選択する。

@item best
グループに入ったときに、そのグループで最も高いスコアの記事を選択
する。 
@end table

もしあるグループで自動記事選択をやめたいのであれば（例えばでっかい記事のあ
るバイナリグループでは、とか）、グループが選択されたときに呼び出される
@code{gnus-select-group-hook} の中でこの変数を @code{nil} に設定することが
できます。


@node Subscription Commands
@section 購読制御コマンド
@cindex subscription

@table @kbd

@item S t
@itemx u
@kindex S t (Group)
@kindex u (Group)
@findex gnus-group-unsubscribe-current-group
@c @icon{gnus-group-unsubscribe}
現在のグループの購読を切り替えます
(@code{gnus-group-unsubscribe-current-group})。

@item S s
@itemx U
@kindex S s (Group)
@kindex U (Group)
@findex gnus-group-unsubscribe-group
グループを購読するかどうかを確認し、購読します。すでに購読するよ
うになっている場合には、購読を止めます
(@code{gnus-group-unsubscribe-group})。

@item S k
@itemx C-k
@kindex S k (Group)
@kindex C-k (Group)
@findex gnus-group-kill-group
@c @icon{gnus-group-kill-group}
現在のグループを kill します (@code{gnus-group-kill-group})。

@item S y
@itemx C-y
@kindex S y (Group)
@kindex C-y (Group)
@findex gnus-group-yank-group
最後に kill したグループを yank します
(@code{gnus-group-yank-group})。

@item C-x C-t
@kindex C-x C-t (Group)
@findex gnus-group-transpose-groups
二つのグループの順序を置き換えます
(@code{gnus-group-transpose-groups})。 これはホントは購読コマン
ドではありませんが、kill と yank を何度か続ける代わりにこのコマ
ンドが使えます。

@item S w
@itemx C-w
@kindex S w (Group)
@kindex C-w (Group)
@findex gnus-group-kill-region
リージョン内の全てのグループを kill します
(@code{gnus-group-kill-region})。

@item S z
@kindex S z (Group)
@findex gnus-group-kill-all-zombies
全てのゾンビグループを kill します
(@code{gnus-group-kill-all-zombies})。

@item S C-k
@kindex S C-k (Group)
@findex gnus-group-kill-level
あるレベルのグループを全て kill します
(@code{gnus-group-kill-level})。 kill した後、これらのグループを
yank で戻すことはできないので、このコマンドはいくらか注意して使っ
てください。このコマンドが本当に便利になるのは、@file{.newsrc} 
に捨てちゃいたい未購読のグループがたくさんあるときだけです。レベ
ル 7で @kbd{S C-k} を行うと、@file{.newsrc} ファイル中にメッセー
ジ番号がない未購読グループを全て kill します。

@end table

@ref{Group Levels} も参照してくください。


@node Group Data
@section グループデータ

@table @kbd

@item c
@kindex c (Group)
@findex gnus-group-catchup-current
@vindex gnus-group-catchup-group-hook
@c @icon{gnus-group-catchup-current}
そのグループ内の全ての無印の記事を既読にする
(@code{gnus-group-catchup-current})。グループバッファから既読にした場合は
@code{gnus-group-catchup-group-hook} が呼び出されます。

@item C
@kindex C (Group)
@findex gnus-group-catchup-current-all
そのグループの全記事を、印付きの記事も含めて既読にします
(@code{gnus-group-catchup-current-all})。

@item M-c
@kindex M-c (Group)
@findex gnus-group-clear-data
現在のグループの全てのデータをクリアします――マークと既読記事のリストを消
し去ります (@code{gnus-group-clear-data})。

@item M-x gnus-group-clear-data-on-native-groups
@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
もし @sc{nntp} サーバを別のものに切り替えたとすると、全てのマークと既読情
報はもう役には立ちません。このコマンドを使って基本グループの全てのデー
タをクリアすることができます。注意して使ってね。

@end table


@node Group Levels
@section グループレベル
@cindex group level
@cindex level

全てのグループは @dfn{購読度} (@dfn{subscribedness}) のレベルを持ちます。
例えば、あるグループがレベル 2 だとすれば、それはレベル 5 のグルー
プよりも「より購読している」ということです。Gnus に対して、ある
レベルかそれより小さいレベルのグループのみ一覧表示するように頼む
こともできるし (@pxref{Listing Groups})、あるレベルかそれより小
さいレベルのグループの新着記事のみを確認することもできます
(@pxref{Scanning New Messages})。

忘れないで: グループのレベルが大きいほど、重要度は低くなるということ。

@table @kbd

@item S l
@kindex S l (Group)
@findex gnus-group-set-current-level
現在のグループのレベルを設定する。数字プレフィックスが与えられる
と、そこから @var{n} 個のグループのレベルが設定されます。レベル
を入力するためのプロンプトが出ます。

@end table

@vindex gnus-level-killed
@vindex gnus-level-zombie
@vindex gnus-level-unsubscribed
@vindex gnus-level-subscribed
Gnus はレベル 1 から @code{gnus-level-subscribed}（この値を含む）（初期
値は 5）までのグループを購読、@code{gnus-level-subscribed}（この値を含ま
ない）から@code{gnus-level-unsubscribed}（この値を含む）（初期値は 7）
までのグループを非購読、@code{gnus-level-zombie} をゾンビ（歩く屍）（初
期値は 8）、@code{gnus-level-killed} を kill されている（完全に死んでる）
（初期値は 9）と判断します。Gnus は購読と非購読のグループは全く同様に
扱いますが、ゾンビと kill グループは、どの記事を読んだか、存在するかなどの
情報を一切持ちません。この死んでるグループと生きてるグループの区別は、別に
それがきれいだからとか賢いからというわけではなく、純粋に効率的な理由のため
です。

メール用のグループは（もしあれば）非常に小さいレベル（例えば 1 か 2）にし
ておくことをお勧めします。

もしレベル変数で遊びたいのであれば、多少注意をしてまわる必要があ
ります。一旦それを設定したら、二度とそれに触らないでください。さ
らに言えば、自分で何をやっているかを正確に理解していない限り、一
切触らないでください。

@vindex gnus-level-default-unsubscribed
@vindex gnus-level-default-subscribed
身近に関係する2つの変数は @code{gnus-level-default-subscribed}（初期値
は 3）と @code{gnus-level-default-unsubscribed}（初期値は 6）です。こ
れらは新しいグループが（非）購読されたときのレベルです。もちろ
ん、これら2つの変数の値は、意味のある正しい範囲でなくてはなりません。

@vindex gnus-keep-same-level
@code{gnus-keep-same-level} が @code{nil} 以外であれば、移動コマンドのいく
つかは同一（あるいはそれより小さい）レベルのグループのみの移動になります。
特に、あるグループの最後の記事から次のグループに移るとき、次の同一（あるい
はそれより小さい）レベルのグループに移動します。これは残りのグループを読む
より先に、より重要なグループを読んでおきたいときには便利かもしれません。

@vindex gnus-group-default-list-level
初期設定では @code{gnus-group-default-list-level} と同じかそれ
より小さいレベルのグループが、グループバッファに一覧表示されます。

@vindex gnus-group-list-inactive-groups
@code{gnus-group-list-inactive-groups} が @code{nil} 以外であれ
ば、未読のグループに一緒にアクティブでないグループも表示します。
この変数は初期設定では @code{t} です。もしこれが @code{nil} であ
れば、アクティブでないグループは表示されません。

@vindex gnus-group-use-permanent-levels
@code{gnus-group-use-permanent-levels} が @code{nil} 以外であれ
ば、一旦レベルを @kbd{g} や @kbd{l} のプレフィックスに与えると、
その後の全てのコマンドにおいてそのレベルが「作用する」レベルにな
ります。


@vindex gnus-activate-level
Gnus は通常、@code{gnus-activate-level} かそれより小さいレベルのグループの
みを起動します（つまりサーバに問い合わせをする）。購読していないグループを
起動したくなければ、この変数を例えば 5 に設定するとよいかもしれません。デ
フォルトは 6 です。

@node Group Score
@section グループのスコア
@cindex group score
@cindex group rank
@cindex rank

普通は重要なグループは高レベルにしておくでしょうけれども、この方
法では少々制限がきついですよね。ひょっとしたら、グループをどれく
らい頻繁に読むかによってグループバッファをソートしたいなあ、なん
て思わない？理にかなってるでしょ？

@dfn{グループスコア} (@dfn{group score}) はそのためのものです。それぞれ
のグループに対してスコアを指定することができます。そしてグループバッファ
をこのスコアを基にソートすることができます。あるいは、スコア順でソートし
てその後レベルでソートすることもできます。（レベルとスコアをひとまとめに
して、グループの@dfn{ランク} (@dfn{rank}) と呼びます。レベルが 4 でスコ
アが 1 のグループは、レベルが 5 でスコアが 300 のグループよりも高いラン
クとなります。（レベルの方が重要度が高く、スコアの方は重要度が低くなりま
す。））

@findex gnus-summary-bubble-group
頻繁に読むグループに、めったに読まないグループよりも高いスコアを与えたいと
きは、@code{gnus-summary-exit-hook} フックに
@code{gnus-summary-bubble-group} 関数を追加することができます。これでバブ
ルソートの実行結果が（ソートの後で）得られるでしょう。概略モードを終了す
るたびにこの活動をさせたいのであれば、同じフックに 
@code{gnus-group-sort-groups-by-rank} か
@code{gnus-group-sort-groups-by-score} を追加できますが、いくらか遅くなる
でしょう。


@node Marking Groups
@section グループへの印
@cindex marking groups

もしいくつかのグループに対して何らかの命令を実行したい場合で、それらがグ
ループバッファに連続してある場合には、通常通り命令に対して数字接頭辞を与
えるだけです。そうすればほとんどのグループ命令は、これらのグループに対し
てあなたの命令に従います。

しかしそれらのグループが順番に並んでいない場合においても、いくつかのグルー
プに対して命令を実行することができます。単に始めにプロセス印でグループに
印をつけておき、そして命令を実行するだけです。

@table @kbd

@item #
@kindex # (Group)
@itemx M m
@kindex M m (Group)
@findex gnus-group-mark-group
現在のグループに印をつける (@code{gnus-group-mark-group})。

@item M-#
@kindex M-# (Group)
@itemx M u
@kindex M u (Group)
@findex gnus-group-unmark-group
現在のグループから印を削除する (@code{gnus-group-unmark-group})。

@item M U
@kindex M U (Group)
@findex gnus-group-unmark-all-groups
全てのグループから印を削除する (@code{gnus-group-unmark-all-groups})。

@item M w
@kindex M w (Group)
@findex gnus-group-mark-region
ポイントとマークの間の全てのグループに印をつける 
(@code{gnus-group-mark-region})。

@item M b
@kindex M b (Group)
@findex gnus-group-mark-buffer
バッファ内の全てのグループに印をつける 
(@code{gnus-group-mark-buffer})。

@item M r
@kindex M r (Group)
@findex gnus-group-mark-regexp
ある正規表現に合致する全てのグループに印をつける 
(@code{gnus-group-mark-regexp})。
@end table

@ref{Process/Prefix} も参照してください。

@findex gnus-group-universal-argument
プロセス印が付けられている全てのグループに対して何かの命令を実行したい
ときは、@kbd{M-&} (@code{gnus-group-universal-argument}) 命令を使うことが
できます。プロンプトから実行したい命令を入力します。


@node Foreign Groups
@section 外部グループ
@cindex foreign groups

以下では、一般的な外部グループの作成、変更を行うグループモードの命令をい
くつか、および特別な目的のグループを簡単に作成する命令を紹介します。これ
らの命令は全て、新規に作成したグループをポイント位置に挿入します――
@code{gnus-subscribe-newsgroup-method} は参照されません。

@table @kbd

@item G m
@kindex G m (Group)
@findex gnus-group-make-group
@cindex making groups
新しいグループを作成します (@code{gnus-group-make-group})。Gnus はプロン
プトを表示して、名前と方法と、場合によっては @dfn{address} の入力を
求めてきます。より簡単に @sc{nntp} グループを購読する方法は、 
@pxref{Browse Foreign Server}。

@item G r
@kindex G r (Group)
@findex gnus-group-rename-group
@cindex renaming groups
現在のグループの名前を、何か別のものに変更します
(@code{gnus-group-rename-group})。これはある種のグループ――主にメールグルー
プに対してのみ有効です。このコマンドはバックエンドによっては非常に遅いこと
も有り得ます。

@item G c
@kindex G c (Group)
@cindex customizing
@findex gnus-group-customize
グループパラメータをカスタマイズする (@code{gnus-group-customize})。

@item G e
@kindex G e (Group)
@findex gnus-group-edit-group-method
@cindex renaming groups
現在のグループの選択方法を修正するためのバッファに移動します
(@code{gnus-group-edit-group-method})。

@item G p
@kindex G p (Group)
@findex gnus-group-edit-group-parameters
グループパラメータを修正するためのバッファに移動します
(@code{gnus-group-edit-group-parameters})。

@item G E
@kindex G E (Group)
@findex gnus-group-edit-group
グループ情報を修正するためのバッファに移動します
(@code{gnus-group-edit-group})。

@item G d
@kindex G d (Group)
@findex gnus-group-make-directory-group
@cindex nndir
ディレクトリグループを作成します (@pxref{Directory Groups})。ディレクトリ
名をプロンプトで入力します (@code{gnus-group-make-directory-group})。

@item G h
@kindex G h (Group)
@cindex help group
@findex gnus-group-make-help-group

Gnus ヘルプグループを作成します (@code{gnus-group-make-help-group})。

@item G a
@kindex G a (Group)
@cindex (ding) archive
@cindex archive group
@findex gnus-group-make-archive-group
@vindex gnus-group-archive-directory
@vindex gnus-group-recent-archive-directory
Gnus アーカイブグループを作成します
(@code{gnus-group-make-archive-group})。初期設定では最も最近の記事を指
しているグループが作成されますが 
(@code{gnus-group-recent-archive-directory})、接頭引数を与えると全
ての記事を含むグループが @code{gnus-group-archive-directory} を基に作成
されます。

@item G k
@kindex G k (Group)
@findex gnus-group-make-kiboze-group
@cindex nnkiboze
kiboze グループを作成します。プロンプトで名前と、kiboze グループに「含め
たい」グループに合う正規表現と、ヘッダーに合う文字列の組を入力します 
(@code{gnus-group-make-kiboze-group})。@xref{Kibozed Groups}.

@item G D
@kindex G D (Group)
@findex gnus-group-enter-directory
@cindex nneething
任意のディレクトリを @code{nneething} バックエンドニュースグループである
かのように読み込みます (@code{gnus-group-enter-directory})。
@xref{Anything Groups}.

@item G f
@kindex G f (Group)
@findex gnus-group-make-doc-group
@cindex ClariNet Briefs
@cindex nndoc
ファイルなどをもとにグループを作成します
(@code{gnus-group-make-doc-group})。このコマンドに接頭辞を与えた場合、ファ
イル名とファイルタイプをプロンプトで入力します。現在サポートされているファ
イルタイプは、@code{babyl}, @code{mbox}, @code{digest}, @code{mmdf},
@code{news}, @code{rnews}, @code{clari-briefs}, @code{rfc934},
@code{rfc822-forward}, @code{forward} です。接頭辞なしでこのコマ
ンドを実行すると、gnus はファイルタイプを推測します。@xref{Document
Groups}。

@item G u
@kindex G u (Group)
@vindex gnus-useful-groups
@findex gnus-group-make-useful-group
@code{gnus-useful-groups} にあるグループの一つをつくります 
(@code{gnus-group-make-useful-group})。

@item G w
@kindex G w (Group)
@findex gnus-group-make-web-group
@cindex DejaNews
@cindex Alta Vista
@cindex InReference
@cindex nnweb
ウェブ検索結果をもとに一時的なグループを作成します
(@code{gnus-group-make-web-group})。このコマンドに接頭辞を与えると、
一時的ではなく固定したグループを作成します。プロンプトで検索機関の種類 
(search engine type) と検索文字列を入力します。有効な検索機関の種類には
@code{dejanews}, @code{altavista}, @code{reference} があります。
@xref{Web Searches}.

もし、@code{dejanews} 検索機関を用いる場合には、@samp{~g
alt.sysadmin.recovery shaving} のような合致する文字列を用いることによっ
て、検索対象を特定のグループに限定することが可能です。

@item G DEL
@kindex G DEL (Group)
@findex gnus-group-delete-group
この関数は現在のグループを削除します (@code{gnus-group-delete-group})。
接頭辞が与えられると、この関数はそのグループ内の全記事を本当に削除し、
グループ自身をこの世から強制的に抹殺してしまいます。接頭辞は、あな
たが何をやろうとしているか、本当に自信があるときにのみ使ってください。まあ、
このコマンドは（@code{nntp} グループのような）読み出し専用グループには使え
ませんけど。

@item G V
@kindex G V (Group)
@findex gnus-group-make-empty-virtual
新しい、新鮮な、空の @code{nnvirtual} グループを作成します
(@code{gnus-group-make-empty-virtual})。@xref{Virtual Groups}.

@item G v
@kindex G v (Group)
@findex gnus-group-add-to-virtual
現在のグループを @code{nnvirtual} グループに追加します
(@code{gnus-group-add-to-virtual})。これはプロセス印/接頭引数の習慣に従
います。

@end table

さまざまな選択方法に関するさらなる情報は @xref{Select Methods} を参
照してください。

@vindex gnus-activate-foreign-newsgroups
もし @code{gnus-activate-foreign-newsgroups} が正の数であれば、gnus は起
動時に、この数かそれよりも小さいレベルの外部グループを全てチェックします。
これは特に違った @sc{nntp} サーバからたくさんのグループを購読している場
合など、しばらく時間がかかるかもしれません。@pxref{Group Levels} も参照
して下さい。@code{gnus-activate-level} も外部ニュースグループの活動化に
影響を及ぼします。


@node Group Parameters
@section グループパラメータ
@cindex group parameters

グループパラメータは、ある特定のグループに固有な情報を格納します。以下は
グループパラメータリストの例です：

@example
((to-address . "ding@@gnus.org")
 (auto-expire . t))
@end example

それぞれの要素は『点対』(dotted pair)――つまり点 (dot) の前に鍵、点の後ろ
に値があるもの、で構成されます。全てのパラメータはこの形式を取りますが、
@emph{例外}として局所変数の指定は点対ではなく通常のリストになります。

以下は利用可能なグループパラメータです：

@table @code
@item to-address
@cindex to-address
フォローアップとニュースへの投稿をするときに使用されるアドレス。

@example
(to-address .  "some@@where.com")
@end example

これは主に、閉じたメーリングリストを表わすメールグループにおいて便利なも
のです――すなわちメーリングリストに投稿する人は全てそれを購読しているは
ず、というメーリングリストのことです。このパラメータを使用すると、メール
はそのメーリングリストにしか投稿されないことが保証されるので、参加者はあ
なたのフォローアップ記事を2通受け取ることはありません。

@code{to-address} を指定すると、そのグループが外部グループであるかどうか
に関わらず有効になります。例えば @samp{fa.4ad-l} というグループがサーバ
上にあったとしましょう。これは本当のニュースグループですが、サーバはメー
ルニュースゲートウェイを通して記事を受け付けます。つまりこのグループに対
して直接投稿することは不可能で、代わりにそのメーリングリストにメールを送
信しなければなりません。

@item to-list
@cindex to-list
そのグループで @kbd{a} を押したときに使用されるアドレス。

@example
(to-list . "some@@where.com")
@end example

これはフォローアップをしたときは完全に無視されます――例外はそれがニュース
グループを表わしているときは、@kbd{f} を押したときにメールグループのルール
が適用されるということです。

もし @kbd{a} コマンドをメールグループで実行したときに、@code{to-list} グ
ループパラメータも @code{to-address} もグループパラメータも無ければ、
@code{to-list} グループパラメータは、@code{gnus-add-to-list} が @code{t}
に設定されていればメッセージ送信時に自動的に付加されます。
@vindex gnus-add-to-list

もし @kbd{a} コマンドをメールグループで実行したとき、@code{to-list} グルー
プパラメータがなければ、送信時に自動的に付加されます。


@item visible
@cindex visible
グループパラメータのリスト中に @code{(visible . t)} という要素があれば、
そのグループはグループバッファにおいて、未読記事があるかどうかに関わらず、
常に表示されます。

@item broken-reply-to
@cindex broken-reply-to
@code{(broken-reply-to . t)} という要素があれば、そのグループでは
@code{Reply-To} は無視される、という意味です。これはある listserv によるメー
リングリストを購読していて、それが @code{Reply-To} 欄を listserv 自身に返
すようにつけられている場合に有効でしょう。これはおかしな振る舞いです。だか
らこれが要るんです！

@item to-group
@cindex to-group
@code{(to-group . "some.group.name")} という要素は、そのグループへの投稿
は全て @code{some.group.name} に送られる、という意味です。

@item newsgroup
@cindex newsgroup
グループパラメータリストに @code{(newsgroup . t)} があれば、gnus は全て
の応答をニュース記事に対する応答であるかのように扱います。これは実際には
ニュースグループのミラーであるメールグループに対して有効です。

@item gcc-self
@cindex gcc-self
グループパラメータリストに @code{(gcc-self . t)} があれば、新しく作成する
メッセージは現在のグループに @code{Gcc} されます。もし @code{(gcc-self
. none)} があれば、@code{Gcc:} 欄は生成されず、@code{(gcc-self
. "string")} があればこの文字列はそのまま @code{gcc} 欄に挿入されます。こ
のパラメータは以下で説明する全ての @code{Gcc} の初期規則よりも優先
されます (@pxref{Archived Messages})。

@item auto-expire
@cindex auto-expire
グループパラメータに @code{(auto-expire . t)} のような要素があれば、全て
の既読記事は時限消去されるように印を付けられます。他の方法は、
@pxref{Expiring Mail}。

@item total-expire
@cindex total-expire
グループパラメータに @code{(total-expire . t)} のような要素があれば、既
読記事は、時限消去の印がついていなくとも全て時限消去処理を施されます。注
意して使用してください。未読記事、印付き記事、保留記事は時限消去されませ
ん。

@item expiry-wait
@cindex expiry-wait
@vindex nnmail-expiry-wait-function
グループパラメータに @code{(expiry-wait . 10)} のような要素があれば、こ
の値は記事を時限消去するときに @code{nnmail-expiry-wait} と 
@code{nnmail-expiry-wait-function} の設定よりも優先されます。この値は時
限消去の日数（整数である必要はない）かもしくは @code{never} か 
@code{immediate} のシンボルを指定できます。

@item score-file
@cindex score file group parameter
@code{(score-file . "file")} のような要素は、@file{file} を現在のグルー
プに適用されるスコアファイルにします。適用されるスコア登録は全てこのファ
イルに入ります。

@item adapt-file
@cindex adapt file group parameter
@code{(adapt-file . "file")} のような要素は、@file{file} を現在のグループ
の適応ファイルにします。全ての適応スコア登録はこのファイルに入ります。

@item admin-address
メーリングリストから脱会するときは、脱会通知メールをそのメーリングリスト
自身に送信してはいけません。代わりに管理用アドレスにメッセージを送信しま
す。このパラメータにはどこか便利な管理用アドレスを書いておくことができます。

@item display
 @code{(display . MODE)} のような要素は、グループに入るときにどの記事を
表示するかを指定します。有効な値は、

@table @code
@item all
未読、既読記事の両方を全て表示します。

@item default
初期設定での表示記事を表示します。これは通常は未読記事と印付き記事です。
@end table

@item comment
@code{(comment . "This is a comment")} のような要素は、そのグループに対す
る任意のコメントです。これは現在の gnus では無視されますが、特定のグループ
に対する情報を格納する場所を提供します。

@item @var{(variable form)}
グループに入るときに、そのグループローカルの変数を設定するグループパラメー
タを使用することができます。@samp{news.answers} においてスレッド表示を行
いたくないときは、そのグループにグループパラメータに 
@code{(gnus-show-threads nil)} と書けます。 @code{gnus-show-threads} は、
その概略バッファの中のローカル変数になり、form の @code{nil} はそこで
評価されます。

これはもし必要であれば、グループ毎のフック関数としても使用できます。もしあ
るグループに入ったときにビープ音を鳴らしたければ、そのグループのパラメータ
に @code{(dummy-variable (ding))} みたいなものを書いておくこともできます。
@code{dummy-variable} という変数に @code{(ding)} の評価結果が設定されます
が、まあ、誰も気にしないでしょ？

@end table

グループパラメータの修正には @kbd{G p} 命令を使ってください。トピックパラ
メータについて読んでみることも面白いでしょう (@pxref{Topic Parameters})。


@node Listing Groups
@section グループの一覧表示
@cindex group listing

これらのコマンドは、利用できるグループをいろいろに切り分けて表示します。

@table @kbd

@item l
@itemx A s
@kindex A s (Group)
@kindex l (Group)
@findex gnus-group-list-groups
未読記事を持つ全てのグループを表示します (@code{gnus-group-list-groups})。
数字接頭引数を使うと、このコマンドは引数の数かそれよりも小さいレベル
のグループのみを表示します。初期設定では、これはレベル 5（つまり
@code{gnus-group-default-list-level}）かそれより小さいレベル（すなわち購読
しているグループのみ）を表示します。

@item L
@itemx A u
@kindex A u (Group)
@kindex L (Group)
@findex gnus-group-list-all-groups
未読記事のあるなしに関わらず、全てのグループを表示します 
(@code{gnus-group-list-all-groups})。数字接頭引数を使用すると、こ
のコマンドは引数の数かそれよりも小さいレベルのグループのみを表示します。
初期設定では 7 かそれよりも小さいレベルのグループ（すなわち購読、非購読
のグループのみ）が表示されます。

@item A l
@kindex A l (Group)
@findex gnus-group-list-level
ある特定のレベルの未読記事のあるグループを表示します 
(@code{gnus-group-list-level})。接頭辞を与えると、未読記事のない
グループも含めて表示します。

@item A k
@kindex A k (Group)
@findex gnus-group-list-killed
kill されたグループを全て表示します (@code{gnus-group-list-killed})。接
頭引数を与えると、現在購読、非購読となっていない全ての利用可能
なグループを表示します。これはサーバからアクティブファイルを読むことにな
るでしょう。

@item A z
@kindex A z (Group)
@findex gnus-group-list-zombies
全てのゾンビグループを表示します (@code{gnus-group-list-zombies})。

@item A m
@kindex A m (Group)
@findex gnus-group-list-matching
正規表現に合致する名前を持つグループで、未読記事のある購読グループを全
て表示します (@code{gnus-group-list-matching})。

@item A M
@kindex A M (Group)
@findex gnus-group-list-all-matching
正規表現に合致するグループを表示する
(@code{gnus-group-list-all-matching})。

@item A A
@kindex A A (Group)
@findex gnus-group-list-active
今接続しているサーバのアクティブファイルにあるグループを、本当に全部表示し
ます (@code{gnus-group-list-active})。これはしばらく時間がかかることも有り
得ます。たぶん @kbd{A M} を実行して、合致させたい部分を @samp{.} として
全ての合致するリストを表示させた方が良いでしょう。また、このコマンドは
（まだ）存在しないグループも表示するかも知れません――これは kill されたグ
ループであるかのように表示されます。出力は多少割り引いて受け取ってね。

@item A a
@kindex A a (Group)
@findex gnus-group-apropos
正規表現に合致する名前を持つグループを全て表示する
(@code{gnus-group-apropos})。

@item A d
@kindex A d (Group)
@findex gnus-group-description-apropos
正規表現に合致する名前か説明文を持つグループを全て表示する
(@code{gnus-group-description-apropos})。

@end table

@vindex gnus-permanently-visible-groups
@cindex visible group parameter
@code{gnus-permanently-visible-groups} 正規表現に合致するグループは、
未読記事があるかないかに関わらず常に表示されます。あるいはグループパラメー
タにおいて @code{visible} 要素を追加することでも同様の効果を得ることがで
きます。

@vindex gnus-list-groups-with-ticked-articles
印付きの記事のみを持つグループは通常グループバッファに表示されます。もし
@code{gnus-list-groups-with-ticked-articles} が @code{nil} であれば、そ
のグループは完全に空のグループであるかのように扱われます。初期値は
@code{t} です。


@node Sorting Groups
@section グループのソート
@cindex sorting groups

@kindex C-c C-s (Group)
@findex gnus-group-sort-groups
@vindex gnus-group-sort-function
@kbd{C-c C-s} (@code{gnus-group-sort-groups}) 命令は、グループバッファを
@code{gnus-group-sort-function} 変数で与えられる関数に従って並べ替えます。
利用可能な並べ替え関数 (sorting function) には以下のものがあります：

@table @code

@item gnus-group-sort-by-alphabet
@findex gnus-group-sort-by-alphabet
グループ名でアルファベット順に並べ替えます。これが初期設定です。

@item gnus-group-sort-by-real-name
@findex gnus-group-sort-by-real-name
グループを本当の（前に何もついていない）グループ名でアルファベット順に並べ
変えます。

@item gnus-group-sort-by-level
@findex gnus-group-sort-by-level
グループレベルで並べ替えます。

@item gnus-group-sort-by-score
@findex gnus-group-sort-by-score
グループのスコアで並べ替えます。@xref{Group Score}.

@item gnus-group-sort-by-rank
@findex gnus-group-sort-by-rank
グループのスコアで並べ替え、次にグループレベルで並べ替えます。レベルとスコ
アは、ひとまとめにして@dfn{ランク}と呼ばれます。@xref{Group Score}.

@item gnus-group-sort-by-unread
@findex gnus-group-sort-by-unread
未読記事の数で並べ替えます。

@item gnus-group-sort-by-method
@findex gnus-group-sort-by-method
選択方法のアルファベット順で並べ替えます。


@end table

@code{gnus-group-sort-function} は並べ替え関数のリストであっても構いません。
この場合、もっとも重要な並べ替えの鍵を持つ関数は最後でなくてはなりません。


ある種の並べ替え用には、直接並べ替える命令もいくつかあります。

@table @kbd
@item G S a
@kindex G S a (Group)
@findex gnus-group-sort-groups-by-alphabet
グループバッファをグループ名のアルファベット順で並べ替えます
(@code{gnus-group-sort-groups-by-alphabet})。

@item G S u
@kindex G S u (Group)
@findex gnus-group-sort-groups-by-unread
グループバッファを未読記事の数で並べ替えます
(@code{gnus-group-sort-groups-by-unread})。

@item G S l
@kindex G S l (Group)
@findex gnus-group-sort-groups-by-level
グループバッファをグループレベルで並べ替えます
(@code{gnus-group-sort-groups-by-level})。

@item G S v
@kindex G S v (Group)
@findex gnus-group-sort-groups-by-score
グループバッファをグループのスコアで並べ替えます
(@code{gnus-group-sort-groups-by-score})。@xref{Group Score}.

@item G S r
@kindex G S r (Group)
@findex gnus-group-sort-groups-by-rank
グループバッファをグループのランクで並べ替えます
(@code{gnus-group-sort-groups-by-rank})。@xref{Group Score}.

@item G S m
@kindex G S m (Group)
@findex gnus-group-sort-groups-by-method
グループバッファをバックエンドの名前でアルファベット順に並べ替えます
(@code{gnus-group-sort-groups-by-method})。

@end table

接頭辞を与えたときは、これらの命令は全て逆順に並べ替えます。

また、グループの一部を並べ替えることもできます。

@table @kbd
@item G P a
@kindex G P a (Group)
@findex gnus-group-sort-selected-groups-by-alphabet
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループ名のアルファベット順で並べ替えます
(@code{gnus-group-sort-selected-groups-by-alphabet})。

@item G P u
@kindex G P u (Group)
@findex gnus-group-sort-selected-groups-by-unread
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、未
読記事の数で並べ替えます
(@code{gnus-group-sort-selected-groups-by-unread})。

@item G P l
@kindex G P l (Group)
@findex gnus-group-sort-selected-groups-by-level
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループレベルで並べ替えます 
(@code{gnus-group-sort-selected-groups-by-level})。

@item G P v
@kindex G P v (Group)
@findex gnus-group-sort-selected-groups-by-score
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループのスコアで並べ替えます 
(@code{gnus-group-sort-selected-groups-by-score})。@xref{Group Score}.

@item G P r
@kindex G P r (Group)
@findex gnus-group-sort-selected-groups-by-rank
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループのランクで並べ替えます
(@code{gnus-group-sort-selected-groups-by-rank})。@xref{Group Score}.

@item G P m
@kindex G P m (Group)
@findex gnus-group-sort-selected-groups-by-method
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、バッ
クエンドの名前でアルファベット順に並べ替えます
(@code{gnus-group-sort-selected-groups-by-method})。

@end table



@node Group Maintenance
@section グループの管理
@cindex bogus groups

@table @kbd
@item b
@kindex b (Group)
@findex gnus-group-check-bogus-groups
不正なグループを見つけて、削除します
(@code{gnus-group-check-bogus-groups})。

@item F
@kindex F (Group)
@findex gnus-group-find-new-groups
新しいグループを見つけて、それらを処理します 
(@code{gnus-group-find-new-groups})。1回の @kbd{C-u} の後で押されると、
サーバーに新しいグループを尋ねるために方法 @code{ask-server} を使います。
2回の @kbd{C-u} の後で押されると、サーバーに新しいグループを尋ねるために
最も完全であると思われる方法を用い、新しいグループをゾンビとして購読しま
す。

@item C-c C-x
@kindex C-c C-x (Group)
@findex gnus-group-expire-articles
現在のグループのエクスパイア記事に対して（もしあれば）全てエクスパイア処理
を行います (@code{gnus-group-expire-articles})。

@item C-c M-C-x
@kindex C-c M-C-x (Group)
@findex gnus-group-expire-all-groups
全てのグループの全ての記事に対して、エクスパイア処理を行います
(@code{gnus-group-expire-all-groups})。

@end table


@node Browse Foreign Server
@section 外部サーバの閲覧
@cindex foreign servers
@cindex browsing servers

@table @kbd
@item B
@kindex B (Group)
@findex gnus-group-browse-foreign-server
選択方法とサーバ名を聞かれます。Gnus はこのサーバに接続し、そこにある
グループを閲覧しようとします (@code{gnus-group-browse-foreign-server})。
@end table

@findex gnus-browse-mode
利用可能なグループのリストを持った新しいバッファが現れます。このバッファ
は @code{gnus-browse-mode} を使用します。このバッファは通常のグループバッ
ファにちょっと（というか、とっても）似ています。

以下が閲覧モード (browse mode) で使用できるキー操作のリストです：

@table @kbd
@item n
@kindex n (Browse)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item p
@kindex p (Browse)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item SPACE
@kindex SPACE (Browse)
@findex gnus-browse-read-group
現在のグループに入り、最初に記事を表示します
(@code{gnus-browse-read-group})。

@item RET
@kindex RET (Browse)
@findex gnus-browse-select-group
現在のグループに入ります (@code{gnus-browse-select-group})。

@item u
@kindex u (Browse)
@findex gnus-browse-unsubscribe-current-group
現在のグループを非購読にする、つまりこの場合は購読することになるのだけれ
ど (@code{gnus-browse-unsubscribe-current-group})。

@item l
@itemx q
@kindex q (Browse)
@kindex l (Browse)
@findex gnus-browse-exit
閲覧モード (browse mode) を終了します (@code{gnus-browse-exit})。

@item ?
@kindex ? (Browse)
@findex gnus-browse-describe-briefly
閲覧モード (browse mode) を簡単に説明します（まあ、大して説明することもな
いんだけどさ）(@code{gnus-browse-describe-briefly})。
@end table


@node Exiting gnus
@section Gnus の終了
@cindex exiting gnus

そう、gnus は最後（サイコー）です（訳注: く、苦しい。原文は ``Yes, gnus
is ex(c)iting.''）。

@table @kbd
@item z
@kindex z (Group)
@findex gnus-group-suspend
Gnus を中断します (@code{gnus-group-suspend})。これは gnus を実際には終了
させず、グループバッファ以外の全てのバッファを消すだけです。僕はこれのうれ
しさがよくわかんないんだけど、誰か分かる人いる？

@item q
@kindex q (Group)
@findex gnus-group-exit
@c @icon{gnus-group-exit}
Gnus を終了します(@code{gnus-group-exit})。

@item Q
@kindex Q (Group)
@findex gnus-group-quit
@file{.newsrc} ファイルをセーブせずに gnus を終了します
(@code{gnus-group-quit})。ドリブルファイルはセーブされますけど
(@pxref{Auto Save})。
@end table

@vindex gnus-exit-gnus-hook
@vindex gnus-suspend-gnus-hook
Gnus を中断するときは @code{gnus-suspend-gnus-hook} が呼び出されます。
Gnusを終了するときは @code{gnus-exit-gnus-hook} が呼び出され、さらに 
gnus を終了するときの最後として @code{gnus-after-exiting-gnus-hook} が呼び
出されます。

@findex gnus-unload
@cindex unloading
もし gnus とそれに関連するものを完全に処分したいのであれば、
@code{gnus-unload} コマンドが使えます。このコマンドは、メタ変数をカスタマ
イズしようとしているときにも便利です。

Note:  

@quotation
ミス Lisa Cannifax は英語の授業中、後ろに座っている少年が彼女の
プラスティックの椅子の背越しに、鉛筆で繰り返し線を描くのにつられ
て、足がしびれて重くなり、意識が朦朧としてきました。
@end quotation


@node Group Topics
@section Group Topics
@cindex topics

もしあなたがたーくさんのグループを読んでいるのであれば、グループをトピック
毎に階層分けできると便利でしょう。Emacs のグループをこっちへ、セックスのグ
ループをあっちへ、で、残りを（え？グループが2つくらいしかないの？）邪魔に
ならないようにその他のセクションに入れましょう。あるいは Emacs セックスの
グループを Emacs グループ、セックスグループのどちらかの副トピックとするこ
とさえもできます――あるいは両方に！すんごいでしょう！

これが例です：

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

@findex gnus-topic-mode
@kindex t (Group)
この@emph{素晴らしい}機能を使うには、@code{gnus-topic} マイナーモードを
（何と！）単にスイッチオンするだけ――グループバッファで、@kbd{t} を押して
ください（これはトグルコマンドです）。

さあやってみよう。とにかく試してみて。君が戻ってくるまで、僕はここで待って
るからさ。ララ、タララン…ん、いい曲だね、これ…ラ、ラ、ラ…え? 戻ってきた？
よし、じゃ次は @kbd{l} を押してみて。ほら。これで全てのグループが 
@samp{misc} の下に表示されました。興奮してクラクラしてこない？アツくって、
いまいましいくらいでしょ？

これをずっと有効にしたければ、グループモードのフックにこのマイナーモード
を追加してください。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@menu
* Topic Variables::    Lisp でトピックをカスタマイズする方法。
* Topic Commands::     超簡単対話型命令。
* Topic Sorting::      トピック毎別々に並べ替える。
* Topic Topology::     全世界の地図。
* Topic Parameters::   あるトピックの全てのグループに適用されるパラメータ。
@end menu


@node Topic Variables
@subsection トピック変数
@cindex topic variables

さて、トピックを選ぶと、トピックは折り畳まれます。これ、とっても
ステキだと思うんだけど。

@vindex gnus-topic-line-format
トピック行は、@code{gnus-topic-line-format} 変数の値に従って作成されます
(@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item i
字下げ。
@item n
トピック名。
@item v
見えるかどうか。
@item l
レベル。
@item g
トピック中のグループの数。
@item a
トピック中の未読記事の数。
@item A
トピックと全ての副トピックの未読記事の数。
@end table

@vindex gnus-topic-indent-level
各副トピック（と副トピック内のグループ）は、トピックレベル数の
@code{gnus-topic-indent-level} 倍の空白分の字下げが行われます。初期値
は 2 です。

@vindex gnus-topic-mode-hook
@code{gnus-topic-mode-hook} はトピックマイナーモードバッファで呼び出され
ます。

@vindex gnus-topic-display-empty-topics
@code{gnus-topic-display-empty-topics} はトピックの中に未読記事
が無い場合でもそのトピックを表示するようにします。初期値は
@code{t} です。

@node Topic Commands
@subsection トピック命令
@cindex topic commands

トピックマイナーモードが有効であるときは、@kbd{T} サブマップが新
しく利用できるようになります。さらに標準キーの中でも、定義がちょっ
と変わるものが少しあります。

@table @kbd

@item T n
@kindex T n (Topic)
@findex gnus-topic-create-topic
新しいトピックの名前をプロンプト入力し、それを作成します
(@code{gnus-topic-create-topic})。

@item T m
@kindex T m (Topic)
@findex gnus-topic-move-group
現在のグループを、どこか他のトピックに移動させます
(@code{gnus-topic-move-group})。このコマンドはプロセスマーク・プ
レフィックスルールに従います (@pxref{Process/Prefix})。

@item T c
@kindex T c (Topic)
@findex gnus-topic-copy-group
現在のグループを、どこか他のトピックにコピーします
(@code{gnus-topic-copy-group})。このコマンドはプロセスマーク・プ
レフィックスルールに従います (@pxref{Process/Prefix})。

@item T D
@kindex T D (Topic)
@findex gnus-topic-remove-group
グループを現在のトピックから削除します(@code{gnus-topic-remove-group})。
この命令は主にいくつかのトピックに同じグループがあって、それをトピックの
一つから取り除きたいときに役立ちます。あなたはグループを全てのトピックか
ら取り除きたいと思うかも知れませんが、その場合は、gnus はあなたが次回に 
gnus を起動したときにそれをルートトピックに付け加えます。実際のところ、
全ての新しいグループ (もちろん、それはどのトピックにも属していません) は
ルートトピックに現われます。

この命令はプロセス印/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item T M
@kindex T M (Topic)
@findex gnus-topic-move-matching
正規表現にマッチする全てのグループを、あるトピックに移動させます
(@code{gnus-topic-move-matching})。 

@item T C
@kindex T C (Topic)
@findex gnus-topic-copy-matching
正規表現にマッチする全てのグループを、あるトピックにコピーします
(@code{gnus-topic-copy-matching})。

@item T h
@kindex T h (Topic)
@findex gnus-topic-toggle-display-empty-topics
空のトピックの表示・非表示を切り替えます
(@code{gnus-topic-toggle-display-empty-topics})。

@item T #
@kindex T # (Topic)
@findex gnus-topic-mark-topic
現在のトピックにあるグループ全てにプロセスマークをつけます
(@code{gnus-topic-mark-topic})。

@item T M-#
@kindex T M-# (Topic)
@findex gnus-topic-unmark-topic
現在のトピックにある全てのグループからプロセスマークを消します
(@code{gnus-topic-unmark-topic})。

@item RET
@kindex RET (Topic)
@findex gnus-topic-select-group
@itemx SPACE
グループを選択するか、あるいはトピックを折りたたみます
(@code{gnus-topic-select-group})。グループの上でこのコマンドを実行すると、
通常通りそのグループに入ります。トピック行の上で行うと、そのトピックは（既
に表示されているときは）折りたたまれるか、（既に折りたたまれているときは）
展開されます。つまりトピックに対してはこれはトグルコマンドです。さらに、数
字プレフィックスを与えると、そのレベル（とそれよりも小さいレベル）のグルー
プが表示されます。

@item T TAB
@itemx TAB
@kindex T TAB (Topic)
@kindex TAB (Topic)
@findex gnus-topic-indent
現在のトピックの ``字下げ'' を行い、その前のトピックの副トピックにします 
(@code{gnus-topic-indent})。接頭引数を与えると、反対にそのトピック
の字下げを戻します。

@item M-TAB
@kindex M-TAB (Topic)
@findex gnus-topic-unindent
現在のトピックの ``字下げ回復'' (un-indent) を行い、それが現在の親の親の
副トピックになるようにします (@code{gnus-topic-unindent})。

@item C-k
@kindex C-k (Topic)
@findex gnus-topic-kill-group
グループあるいはトピックを kill します(@code{gnus-topic-kill-group})。ト
ピック内にあったグループも全て、トピックと一緒に削除されます。

@item C-y
@kindex C-y (Topic)
@findex gnus-topic-yank-group
直前の kill されたグループあるいはトピックを yank します
(@code{gnus-topic-yank-group})。全てのトピックは、全てのグループ
の前に yank されることに気をつけてください。

@item T r
@kindex T r (Topic)
@findex gnus-topic-rename
トピックの名前を変更する (@code{gnus-topic-rename})。

@item T DEL
@kindex T DEL (Topic)
@findex gnus-topic-delete
空のトピックを削除する (@code{gnus-topic-delete})。

@item A T
@kindex A T (Topic)
@findex gnus-topic-list-active
Gnus が知っているトピック化されたグループを全て表示します
(@code{gnus-topic-list-active})。

@item G p
@kindex G p (Topic)
@findex gnus-topic-edit-parameters
@cindex group parameters
@cindex topic parameters
@cindex parameters
トピックパラメータを修正します (@code{gnus-topic-edit-parameters})。
@xref{Topic Parameters}.

@end table


@node Topic Sorting
@subsection トピックの並べ替え
@cindex topic sorting

以下に示す命令で、各トピック毎に別々にグループを並べ替えることができます：


@table @kbd
@item T S a
@kindex T S a (Topic)
@findex gnus-topic-sort-groups-by-alphabet
現在のトピックをグループ名のアルファベット順に並べ替えます
(@code{gnus-topic-sort-groups-by-alphabet})。

@item T S u
@kindex T S u (Topic)
@findex gnus-topic-sort-groups-by-unread
現在のトピックを未読記事の数で並べ替えます
(@code{gnus-topic-sort-groups-by-unread})。

@item T S l
@kindex T S l (Topic)
@findex gnus-topic-sort-groups-by-level
現在のトピックをグループのレベルで並べ替えます
(@code{gnus-topic-sort-groups-by-level})。

@item T S v
@kindex T S v (Topic)
@findex gnus-topic-sort-groups-by-score
現在のトピックをグループのスコアで並べ替えます
(@code{gnus-topic-sort-groups-by-score})。@xref{Group Score}.

@item T S r
@kindex T S r (Topic)
@findex gnus-topic-sort-groups-by-rank
現在のトピックをグループのランクで並べ替えます
(@code{gnus-topic-sort-groups-by-rank})。@xref{Group Score}.

@item T S m
@kindex T S m (Topic)
@findex gnus-topic-sort-groups-by-method
現在のトピックをバックエンドの名前でアルファベット順に並べ替えます 
(@code{gnus-topic-sort-groups-by-method})。

@end table

グループのソートについてのさらなる情報は @xref{Sorting Groups} を参照して
ください。


@node Topic Topology
@subsection トピックの位相構造
@cindex topic topology
@cindex topology

それでは、グループバッファの例を見ていきましょう。

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

つまり、ここでは一つのトップレベルのトピック (@samp{Gnus}) があり、その下
に2つのトピックがあり、そのうちの一方の副トピック中に一つ副トピックがあり
ます（トップレベルトピックは常に一つしかありません）。この構造は、以下のよ
うに表現できます：

@lisp
(("Gnus" visible)
 (("Emacs -- こいつはすげーぜ!" visible)
  (("えっちな Emacs" visible)))
 (("その他" visible)))
@end lisp

@vindex gnus-topic-topology
これは実に、上記の表示を行うための、変数 @code{gnus-topic-topology} の値そ
のものなのです。この変数は@file{.newsrc.eld} ファイルに保存され、手でいじ
くり回してはいけません――本当にやりたいときは別ですが。この変数は
@file{.newsrc.eld} ファイルから読み込まれるので、その他のスタートアップファ
イルの設定には全く影響を与えません。

この構造は、どのトピックがどのトピックの副トピックであるかと、どのトピック
が表示されているかを示しています。現在は二つの設定値――@code{visible} と 
@code{invisible} が許されています。


@node Topic Parameters
@subsection トピックパラメータ
@cindex topic parameters

トピック内の全てのグループはグループパラメータを、その親（と先祖）のトピッ
クパラメータから継承します。グループパラメータとして正しいものは全て、トピッ
クパラメータとしても正しいものです(@pxref{Group Parameters})。

グループパラメータは（もちろん）トピックパラメータよりも優先され、副トピッ
クのトピックパラメータは親トピックのトピックパラメータよりも優先されます。
分かるよね。ごく普通の継承ルールです（ルール (@dfn{Rules}) はここでは名詞
であって、動詞の「線を引く」ではありません。このルールには反対したくなるか
も知れないけど、それはご自由に）。

@example
Gnus
  Emacs
     3: comp.emacs
     2: alt.religion.emacs
   452: alt.sex.emacs
    息抜き
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
   452: alt.sex.emacs
@end example

@samp{Emacs} トピックはトピックパラメータ @code{(score-file
. "emacs.SCORE")} を持っています。@samp{息抜き} トピックはトピッ
クパラメータ @code{(score-file . "relief.SCORE")} を持ち、
@samp{その他} トピックはトピックパラメータ @code{(score-file
. "emacs.SCORE")} を持っています。さらに、
@samp{alt.religion.emacs} はグループパラメータ @code{(score-file
. "religion.SCORE")} を持っています。

さて、ここで @samp{息抜き} トピックの @samp{alt.sex.emacs} グルー
プに入ったとき、@file{relief.SCORE} が基本スコアファイルとなりま
す。もし @samp{Emacs} トピックの同じグループに入ると、
@file{emacs.SCORE} が基本スコアファイルになるでしょう。
@* @samp{alt.religion.emacs} グループに入れば、
@file{religion.SCORE} が基本スコアファイルになるでしょう。

これってとっても簡単で自明のことのように見えるでしょ？まあ、その通りです。
ですが問題がある場合もあります。特に@code{total-expiry} パラメータに関して
です。例えばあるメールグループを二つのトピックの中に、一方は 
@code{total-expiry} ありで、もう一方はそれなしで持っているとしましょう。こ
こで @kbd{M-x gnus-expire-all-expirable-groups} を実行すると、何が起こるで
しょうか？Gnus は、あなたがどちらのトピックから記事をエクスパイアしたいの
かを知る方法がないため、最悪の事態が発生するかもしれません。実際、私はこの
とき何が起こるのかは「未定義 @dfn{undefined}」である、とここに宣言します。
この手のことをやりたい場合には十分注意しなければなりません。


@node Misc Group Stuff
@section その他のグループ関連

@menu
* Scanning New Messages:: Gnus に新しいメッセージが到着したかどうかを聞く。
* Group Information::     グループと gnus に関する情報とヘルプ。
* Group Timestamp::       Gnus に最後にいつグループを読んだかを記録させる。
* File Commands::         Gnus のファイルの読み書き。
@end menu

@table @kbd

@item ^
@kindex ^ (Group)
@findex gnus-group-enter-server-mode
サーババッファモードに入る (@code{gnus-group-enter-server-mode})。
@xref{The Server Buffer}。

@item a
@kindex a (Group)
@findex gnus-group-post-news
あるグループに記事を投稿する (@code{gnus-group-post-news})。プレ
フィックスを与えると、現在のグループ名が初期値として使用されます。

@item m
@kindex m (Group)
@findex gnus-group-mail
メールをどこかに送る (@code{gnus-group-mail})。

@end table

以下はグループバッファのための変数です：

@table @code

@item gnus-group-mode-hook
@vindex gnus-group-mode-hook
グループバッファが作成された時に呼び出されます。

@item gnus-group-prepare-hook
@vindex gnus-group-prepare-hook
グループバッファが生成されたあとに呼び出されます。これはバッファを何か変な、
自然じゃない方法で修正したいときに使われるかもしれません。

@item gnus-group-prepared-hook
@vindex gnus-group-prepare-hook
グループバッファが生成された後の一番最後に呼び出されます。例えば
ポイントをどこかに移動させたいときなどに使えます。

@item gnus-permanently-visible-groups
@vindex gnus-permanently-visible-groups
この正規表現にマッチするグループは、それが空であるかどうかに関わ
らず、常にグループバッファに表示されます。

@end table


@node Scanning New Messages
@subsection 新着メッセージを探す
@cindex new messages
@cindex scanning new news

@table @kbd

@item g
@kindex g (Group)
@findex gnus-group-get-new-news
@c @icon{gnus-group-get-new-news}
サーバの新着記事をチェックします。数字プレフィックスを使用すると、この命令
は引数 @var{arg} かそれより小さいレベルのグループのみをチェックします 
(@code{gnus-group-get-new-news})。数字以外のプレフィックスを与えると、この
命令はそのバックエンドからアクティブファイルを強制的に全部読み直します。

@item M-g
@kindex M-g (Group)
@findex gnus-group-get-new-news-this-group
@vindex gnus-goto-next-group-when-activating
@c @icon{gnus-group-get-new-news-this-group}
現在のグループに新着記事があるかどうかをチェックします
(@code{gnus-group-get-new-news-this-group})。
@code{gnus-goto-next-group-when-activating} はこの命令が次のグループ位置へ
移動するかどうかを決めます。初期値は @code{t} です。

@findex gnus-activate-all-groups
@cindex activating groups
@item C-c M-g
@kindex C-c M-g (Group)
無条件に全てのグループを起動します (@code{gnus-activate-all-groups})。

@item R
@kindex R (Group)
@cindex restarting
@findex gnus-group-restart
Gnus をリスタートします (@code{gnus-group-restart})。これは
@file{.newsrc} ファイルをセーブし、全てのサーバの接続を閉じ、全ての gnus 
ランタイム変数をクリアした後、gnus をもう一度最初から開始します。

@end table

@vindex gnus-get-new-news-hook
@code{gnus-get-new-news-hook} は新着ニュースをチェックする直前に
実行されます。

@vindex gnus-after-getting-new-news-hook
@code{gnus-after-getting-new-news-hook} 新着ニュースをチェックし
た後に実行されます。


@node Group Information
@subsection グループ情報
@cindex group information
@cindex information on groups

@table @kbd


@item H f
@kindex H f (Group)
@findex gnus-group-fetch-faq
@vindex gnus-group-faq-directory
@cindex FAQ
@cindex ange-ftp
現在のグループの FAQ を取得しようとします(@code{gnus-group-fetch-faq})。
Gnus は FAQ を@code{gnus-group-faq-directory} から取得しようとします。これ
は通常リモートマシン上のディレクトリです。この変数はディレクトリのリストで
あっても構いません。この場合、このコマンドにプレフィックスを与えることでい
くつかのサイトの中から選ぶことができます。ファイルの取得には 
@code{ange-ftp}（または @code{efs}）が使用されます。

もし最初のサイトからの取得が失敗した場合、gnus は
@code{gnus-group-faq-directory} の値を全て、一つ一つオープンしてみようとし
ます。

@item H d
@itemx C-c C-d
@c @icon{gnus-group-describe-group}
@kindex H d (Group)
@kindex C-c C-d (Group)
@cindex describing groups
@cindex group description
@findex gnus-group-describe-group
現在のグループの説明を表示する
(@code{gnus-group-describe-group})。プレフィックスを与えると、説
明文をサーバから強制的に再読み込みします。

@item M-d
@kindex M-d (Group)
@findex gnus-group-describe-all-groups
全てのグループの説明を表示します
(@code{gnus-group-describe-all-groups})。プレフィックスを与える
と、説明文ファイルをサーバから強制的に再読み込みします。

@item H v
@itemx V
@kindex V (Group)
@kindex H v (Group)
@cindex version
@findex gnus-version
現在の gnus のバージョン番号を表示します (@code{gnus-version})。

@item ?
@kindex ? (Group)
@findex gnus-group-describe-briefly
とても短いヘルプメッセージを与えます (@code{gnus-group-describe-briefly})。

@item C-c C-i
@kindex C-c C-i (Group)
@cindex info
@cindex manual
@findex gnus-info-find-node
Gnus の info ノードに移動します (@code{gnus-info-find-node}).。

@end table


@node Group Timestamp
@subsection グループの日付
@cindex timestamps
@cindex group timestamps

Gnus に、あなたが最後にいつグループを読んだかを記録させると便利
かもしれません。この活動を始めさせるには、
@code{gnus-group-set-timestamp}を @code{gnus-select-group-hook}
に追加してください。

@lisp
(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)
@end lisp

これを行った後、あなたがグループに入るたびにそれが記録されます。

この情報はさまざまな方法で表示できます――もっとも簡単なのは、グループ行フォー
マットで @samp{%d} 指定を使う方法です：

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %d\n")
@end lisp

この結果として、各行は以下のように表示されます：

@example
*        0: mail.ding                                19961002T012943
         0: custom                                   19961002T012713
@end example

見て分かるとおり、日付はコンパクトな ISO 8601 形式で表示されます。
これではちょっとあんまりなので、以下のような感じにすると日付だけ
を表示できます。

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %6,6~(cut 2)d\n")
@end lisp


@node File Commands
@subsection ファイル命令
@cindex file commands

@table @kbd

@item r
@kindex r (Group)
@findex gnus-group-read-init-file
@vindex gnus-init-file
@cindex reading init file
初期化ファイルの再読み込みを行う (@code{gnus-init-file}、このデ
フォルトは @file{~/.gnus}) (@code{gnus-group-read-init-file})。

@item s
@kindex s (Group)
@findex gnus-group-save-newsrc
@cindex saving .newsrc
@file{.newsrc.eld}ファイル（と、もしそうしたければ@file{.newsrc} ファイル）
をセーブする(@code{gnus-group-save-newsrc})。

@c @item Z
@c @kindex Z (Group)
@c @findex gnus-group-clear-dribble
@c ドリブルファイルをクリアする
@c (@code{gnus-group-clear-dribble})。

@end table


@node The Summary Buffer
@chapter 概略バッファ
@cindex summary buffer

概略バッファ (summary buffer) ではそれぞれの記事が一行で表示されます。そ
の中を動き回り、記事を読み、投稿し、返答をすることができます。

概略バッファに移る一番普通の方法は、グループバッファでグループを選択する
ことです (@pxref{Selecting a Group})。

概略バッファは望むだけたくさん開いた状態にしておくことができます。

@menu
* Summary Buffer Format::       概略バッファの外観を決定する。
* Summary Maneuvering::         概略バッファを動き回る。
* Choosing Articles::           記事を読む。
* Paging the Article::          読んでいる記事をスクロールする。
* Reply Followup and Post::     記事を投稿する。
* Canceling and Superseding::   『あぁ、あんなふうに言うんじゃなかった。』
* Marking Articles::            記事に既読や期限切れ削除可能等の印を付ける。
* Limiting::                    概略バッファに制限を加えることができる。
* Threading::                   スレッドがどのように作られるか。
* Sorting::                     スレッドと記事がどのように並びかえられるか。
* Asynchronous Fetching::       Gnus は記事を先に取得することができる。
* Article Caching::             キャッシュに記事を貯めておける。
* Persistent Articles::         記事を期限切れ消去しなくさせる。
* Article Backlog::             既に読んだ記事を残しておく。
* Saving Articles::             記事の保存をカスタマイズする方法。
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える。
* Article Treatment::           記事バッファはお望みどおりに目茶苦茶にできる。
* Article Commands::            記事バッファでいろいろなことをする。
* Summary Sorting::             いろいろな方法で概略バッファを並べ替える。
* Finding the Parent::          子記事に援助が無いって? 親記事を取得しなさい。
* Alternative Approaches::      初期設定でない概略を使って読む。
* Tree Display::                もっと視覚的なスレッドの表示。
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる。
* Various Summary Stuff::       他のどの場所にも合わなかったもの。
* Exiting the Summary Buffer::  グループバッファに戻る。
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか。
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段。
@end menu


@node Summary Buffer Format
@section 概略バッファの様式
@cindex summary buffer format

@menu
* Summary Buffer Lines::     概略バッファがどのように見えるべきかを指定できる。
* Summary Buffer Mode Line:: モード行の見え方を決められる。
* Summary Highlighting::     概略バッファをきれいで素敵にする。
@end menu

@findex std11-extract-address-components
@findex mail-extract-address-components
@findex gnus-extract-address-components
@vindex gnus-extract-address-components
Gnus は変数 @code{gnus-extract-address-components} の値を @code{From} ヘッ
ダーの名前とアドレスの部分を手に入れるための関数として使います。すでに定
義されている関数が３つ存在します：@code{gnus-extract-address-components} 
は初期値ですが、とても簡単に割り切った解決法で、非常に速く動作します。
@code{mail-extract-address-components} は良く動作しますが、やや遅くなり
ます。そして、@code{std11-extract-address-components} はとても良く動作し
ますが、遅くなります。ディフォルトの関数は 5% の割合で間違って答えます。
もしこれに我慢ならないのであれば、他の関数を代わりに使うことができます。

@vindex gnus-summary-same-subject
@code{gnus-summary-same-subject} は今読んでいる記事が、その前の記事と同
じ表題 (subject) であることを示す文字列です。この文字列は仕様がこれを要
求するときに使われます。初期設定では @code{""} です。


@node Summary Buffer Lines
@subsection 概略バッファの行

@vindex gnus-summary-line-format
変数 @code{gnus-summary-line-format} の値を変えることによって、概略バッ
ファでの行の様式 (format) を変更することができます。いくつかの拡張 
(@pxref{Formatting Variables}) を除いて、普通の @code{format} 文字列と同
じように動作します。

初期値の文字列は @samp{%U%R%z%I%(%[%4L: %-20,20n%]%) %s\n} です。

以下の様式指示文字を使うことができます:

@table @samp
@item N
記事数。
@item S
表題の文字列。
@item s
スレッド (thread) の基記事であるときか直前の記事が違う表題のときはその題
名で、それ以外は @code{gnus-summary-same-subject}。
(@code{gnus-summary-same-subject} の初期値は @code{""}。)
@item F
完全な @code{From} 欄。
@item n
名前（@code{From} 欄より）。
@item a
名前（@code{From} 欄より）。これと @code{n} との違いは、これは変数
@code{gnus-extract-address-components} で指定されている関数を使って名前を
取得することです。この方が遅いですが、おそらくより完全に近いでしょう。
@item A
名前（@code{From} 欄より）。これは @code{a} と同じように動作します。
@item L
記事の行数。
@item c
記事の文字数。
@item I
スレッドのレベルによる字下げ (@pxref{Customizing Threading})。
@item T
記事が本記事であれば何も表示せず、そうでない場合はたくさんの空白です（後の
ものをすべて画面の外に追い出してしまいます）。
@item [
開き括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます (@pxref{Customizing Threading})。
@item ]
閉じ括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます。
@item >
それぞれのスレッドのレベルに対して一つの空白。
@item <
二十引くスレッドレベルの空白。
@item U
未読。

@item R
この紛らわしい名前指定子は @dfn{secondary mark} によって定義されます。この
マークは記事が既に返答済みのものか、キャッシュされたものか、あるいは保存さ
れたものかを表します。

@item i
数字としてのスコア (@pxref{Scoring})。
@item z
@vindex gnus-summary-zcore-fuzz
これは、zcore で初期設定のレベルよりも上であれば @samp{+} で、初期設定の
レベルよりも下であれば @samp{-} です。@code{gnus-summary-default-score} 
との差が @code{gnus-summary-zcore-fuzz}よりも小さいと、この仕様は使われ
ません。
@item V
スレッド全体のスコア。
@item x
@code{Xref}.
@item D
@code{日付} (@code{Date})。
@item d
@code{DD-MM}様式による@code{日付}。
@item o
@var{YYYYMMDD}@code{T}@var{HHMMSS}様式による@code{日付}。
@item M
@code{Message-ID}.
@item r
@code{References}.
@item t
現在の副スレッドの記事の数。この仕様を使うと概略バッファの生成が幾分遅く
なります。
@item e
記事に子記事があると、@samp{=} (@code{gnus-not-empty-thread-mark}) が表
示されます。
@item P
行数。
@item O
ダウンロードの印。
@item u
利用者定義指定子。フォーマット文字列の中の次の文字が英字である必要がありま
す。これにより gnus は関数 @code{gnus-user-format-function-}@samp{X} を呼
び出しますが、ここで @samp{X} は @samp{%U} の次の文字です。関数には現在の
記事のヘッダーが引数として渡されます。関数は文字列を返し、他の概略指定と同
様に概略に挿入されます。
@end table

@samp{%U}（状態）、@samp{%R}（返答済み）、@samp{%z} (zcore) の扱いには気を
付ける必要があります。効率のために、gnus はこれらの文字がどの桁に現れるか
を計算し、『ハード・コード』します。これは、可変長の仕様の後では、これらは
意味を持たないということです。まぁ、さすがに逮捕はされないでしょうが、概略
バッファは変になります。それでも十分悲しいでしょうけど。

賢い選択はこれらの指定をできるだけ左に持ってくることです。（でも、そうい
うことはすべてに当てはまるのではないでしょうか。閑話休題。）

この制限は将来の版では無くなるかも知れません。


@node Summary Buffer Mode Line
@subsection 概略バッファのモード行

@vindex gnus-summary-mode-line-format
概略のモード行の様式も変更することができます (@pxref{Mode Line
Formatting})。@code{gnus-summary-mode-line-format} を何でも好きなものに
変更してください。初期値は @samp{Gnus: %%b [%A] %Z} です。

以下があなたが遊ぶことのできるそれぞれの要素です：

@table @samp
@item G
グループ名。
@item p
接頭語を取り除いた名前。
@item A
現在の記事番号。
@item z
現在の記事スコア。
@item V
Gnus バージョン。
@item U
そのグループでの未読記事の数。
@item e
概略バッファに表示されていない未読記事の数。
@item Z
未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記事があ
る場合は @samp{<%U(+%e) more>} で、未読記事のみの場合は @samp{<%U more>}
です。
@item g
短縮グループ名。例えば、@samp{rec.arts.anime} は @samp{r.a.anime} に短縮
されます。
@item S
現在の記事の表題。
@item u
利用者定義の仕様 (@pxref{User-Defined Specs})。
@item s
現在のスコアファイルの名前 (@pxref{Scoring})。
@item d
保留記事の数 (@pxref{Unread Articles})。
@item t
可視印付き記事の数 (@pxref{Unread Articles})。
@item r
その一連の動作の間に既読として印がついた記事の数。
@item E
スコアファイルによって抹消された記事の数。
@end table


@node Summary Highlighting
@subsection 概略のハイライト

@table @code

@item gnus-visual-mark-article-hook
@vindex gnus-visual-mark-article-hook
このフックは記事を選択した後に実行されます。これは何らかの方法で記事をハ
イライトするように意図されています。もし @code{gnus-visual} が
@code{nil} である場合は実行されません。

@item gnus-summary-update-hook
@vindex gnus-summary-update-hook
このフックは概略行が変更されたときに呼ばれます。もし @code{gnus-visual} が
@code{nil} である場合は実行されません。

@item gnus-summary-selected-face
@vindex gnus-summary-selected-face
これは概略バッファでの現在の記事をハイライトするために使われるフェイス 
(face)（もしくは、いくらかの人々が @dfn{フォント} (font) と呼ぶよ
うなもの）です。

@item gnus-summary-highlight
@vindex gnus-summary-highlight
概略行はこの変数にしたがってハイライトされます。この変数は要素が
@var{(FORM . FACE)} の形式のリストです。例えば、もし印付きの記事をイタリッ
ク、高いスコアの記事をボールドにしたければ、この変数を次のようにできます。
@lisp
(((eq mark gnus-ticked-mark) . italic)
 ((> score default) . bold))
@end lisp
ご想像のとおり、もし @var{FORM} が @code{nil} でない値を返すと、
@var{FACE} がその行に適用されます。
@end table


@node Summary Maneuvering
@section 概略間の移動
@cindex summary movement

すべての直接移動命令は数値接頭引数を受け付け、あなたの期待によくしたがっ
て動作するでしょう。

これらの命令はどれも記事を選択しません。

@table @kbd
@item G M-n
@item M-n
@kindex M-n （概略）
@kindex G M-n （概略）
@findex gnus-summary-next-unread-subject
概略行の次の未読記事に移る (@code{gnus-summary-next-unread-subject})。

@item G M-p
@itemx M-p
@kindex M-p （概略）
@kindex G M-p （概略）
@findex gnus-summary-prev-unread-subject
概略行の前の未読記事に移る
(@code{gnus-summary-prev-unread-subject})。

@item G j
@item j
@kindex j （概略）
@kindex G j （概略）
@findex gnus-summary-goto-article
記事番号か @code{Message-ID} を尋ね、それからその記事に行く。
(@code{gnus-summary-goto-article})。

@item G g
@kindex G g （概略）
@findex gnus-summary-goto-subject
記事番号か @code{Message-ID} を尋ね、それからその記事を表示すること無く、
概略行に行く (@code{gnus-summary-goto-subject})。
@end table

Gnus が次のグループに移動することを確認をするために、キーを押すことを要求
するときがあります。その時は、@kbd{C-n} と @kbd{C-p} を使って、グループバッ
ファに戻ること無く次に読むグループを探すことができます。

概略の移動に関連した変数:

@table @code

@vindex gnus-auto-select-next
@item gnus-auto-select-next
もし移動命令の一つ（@kbd{n} のような）を出し、現在の記事の後に未読が無けれ
ば、gnus は次のグループに移動することを奨めます。この変数が @code{t}で次の
グループが空であると、gnus は概略モードを終了して、グループバッファに戻り
ます。この変数が @code{t} や @code{nil} でないと、次のグループに記事があろ
うが無かろうが、gnus はそれを選択します。特別な場合として、この変数が 
@code{quietly} であると、gnus は確認をせずに、次のグループを選択します。こ
の変数が @code{almost-quietly} であると、グループの一番最後の記事を読んで
いたときに限り同じことが起こります。最後に、もしこの変数が
@code{slightly-quietly} であると、命令 @kbd{Z n} は確認をせずに次のグルー
プに移ります。@pxref{Group Levels} も参照してください。

@item gnus-auto-select-same
@vindex gnus-auto-select-same
@code{nil} でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
しようとします。(@dfn{同じ} はここでは @dfn{大体同じ} という意味かも知れ
ません。詳細は @code{gnus-summary-gather-subject-limit} を見てください
(@pxref{Customizing Threading} も参照してください)。) 同じ表題の記事が無
いときは最初の未読記事に移動します。

この変数は、スレッド表示を行っているときはあまり役に立たないでしょう。

@item gnus-summary-check-current
@vindex gnus-summary-check-current
@code{nil} でないと、すべての『未読』移動命令は、次（もしくは前）の記事に
移動しません。その代わりに、それらは現在の記事を選びます。

@item gnus-auto-center-summary
@vindex gnus-auto-center-summary
@code{nil} でないと、gnus は概略バッファでのポイントを常に真中に保ちます。
これをすると、とてもこぎれいになりますが、遅いネットワーク接続であったり、
単にこの Emacsism でない行為を好きになれないのであれば、普通の Emacs の
スクロールにするために、この変数を @code{nil} にすることができます。これ
は概略バッファの水平方向の真中への再移動も禁止しますので、非常に長いスレッ
ドを読むときは不便かもしれません。

@end table


@node Choosing Articles
@section 記事の選択
@cindex selecting articles

@menu
* Choosing Commands::        記事を選択するための命令。
* Choosing Variables::       これらの命令に影響を及ぼす変数。
@end menu


@node Choosing Commands
@subsection 命令の選択

以下の移動コマンドはどれも数値接頭引数を受け付けず、記事を選択し、表示しま
す。

@table @kbd
@item SPACE
@kindex SPACE （概略）
@findex gnus-summary-next-page
現在の記事か、それが既に読まれている場合は次の未読記事を選択します
(@code{gnus-summary-next-page})。

@item G n
@itemx n
@kindex n（概略）
@kindex G n（概略）
@findex gnus-summary-next-unread-article
@c @icon{gnus-summary-next-unread}
次の未読記事に移動します (@code{gnus-summary-next-unread-article})。

@item G p
@itemx p
@kindex p（概略）
@findex gnus-summary-prev-unread-article
@c @icon{gnus-summary-prev-unread}
前の未読記事に移動します (@code{gnus-summary-prev-unread-article})。

@item G N
@itemx N
@kindex N （概略）
@kindex G N （概略）
@findex gnus-summary-next-article
次の記事に移動します (@code{gnus-summary-next-article})。

@item G P
@itemx P
@kindex P （概略）
@kindex G P （概略）
@findex gnus-summary-prev-article
前の記事に移動します (@code{gnus-summary-prev-article})。

@item G C-n
@kindex G C-n（概略）
@findex gnus-summary-next-same-subject
同じ表題の次の記事に移動します (@code{gnus-summary-next-same-subject})。

@item G C-p
@kindex G C-p（概略）
@findex gnus-summary-prev-same-subject
同じ表題の前の記事に移動します (@code{gnus-summary-prev-same-subject})。

@item G f
@itemx .
@kindex G f （概略）
@kindex . （概略）
@findex gnus-summary-first-unread-article
最初の未読記事に移動します (@code{gnus-summary-first-unread-article})。

@item G b
@item ,
@kindex G b （概略）
@kindex , （概略）
@findex gnus-summary-best-unread-article
最高スコアの記事に移動します (@code{gnus-summary-best-unread-article})。

@item G l
@itemx l
@kindex l （概略）
@kindex G l （概略）
@findex gnus-summary-goto-last-article
直前の記事に移動します (@code{gnus-summary-goto-last-article})。

@item G o
@kindex G o（概略）
@findex gnus-summary-pop-article
概略の履歴 (history) から最後の記事を一つ取り出して選択します。
(@code{gnus-summary-pop-article})。この命令が上の命令と違うのは、@kbd{l} 
が最終2つの記事の間を移動するのに対して、これは好きなだけ前の記事を履歴か
ら選び出すことができる点です。何らかのこれに関係したことは（もしこれらの命
令をたくさん使うのであれば）、@pxref{Article Backlog} を参照してください。
@end table


@node Choosing Variables
@subsection 選ぶための変数

記事を移動し、選択するのに関連したいくつかの変数:

@table @code
@item gnus-auto-extended-newsgroup
@vindex gnus-auto-extend-newsgroup
この変数が @code{nil} でないと、すべての移動命令は、もしその記事が概略バッ
ファに表示されていない場合でも、前（もしくは次）の記事に移動しようとします。
その命令の後で、gnus はサーバーから記事を取得して、記事バッファに表示しま
す。

@item gnus-select-article-hook
@vindex gnus-select-article-hook
このフックは記事が選択されたときに常に呼ばれます。初期設定では、選択され
た記事の下に隠れているスレッドを見せるようになっています。

@item gnus-mark-article-hook
@vindex gnus-mark-article-hook
@findex gnus-summary-mark-unread-as-read
@findex gnus-summary-mark-read-and-unread-as-read
@findex gnus-unread-mark
このフックは記事が選択されたときに常に呼ばれます。それは記事に既読の印を
付けるためにあります。初期値は 
@code{gnus-summary-mark-read-and-unread-as-read} で、ほとんどすべての読
んだ記事の印を @code{gnus-read-mark} に変更します。この関数に影響されな
い記事は、可視、保留、期限切れ削除可能記事だけです。もし、未読に既読の印
を付けたいだけであれば、代わりに @code{gnus-summary-mark-unread-as-read} 
を使うことができます。それは、@code{gnus-low-score-mark} や 
@code{gnus-del-mark}（などなど）の印をそのまま残します。

@end table


@node Paging the Article
@section 記事のスクロール
@cindex article scrolling

@table @kbd

@item SPACE
@kindex SPACE （概略）
@findex gnus-summary-next-page
@kbd{SPACE} は記事を一ページ先にスクロールします。記事の最後にいる場合は
次の記事を選択します (@code{gnus-summary-next-page})。

@item DEL
@kindex DEL （概略）
@findex gnus-summary-prev-page
現在の記事を一ページ前にスクロールします (@code{gnus-summary-prev-page})。

@item RET
@kindex RET （概略）
@findex gnus-summary-scroll-up
現在の記事を一行先にスクロールします (@code{gnus-summary-scroll-up})。

@item M-RET
@kindex M-RET (概略)
@findex gnus-summary-scroll-down
現在の記事を一行後ろへスクロールします (@code{gnus-summary-scroll-down})。

@item A g
@itemx g
@kindex A g （概略）
@kindex g （概略）
@findex gnus-summary-show-article
現在の記事を（再）取得します。もし接頭引数が与えられると、現在の記事を取得
しますが、記事を扱う関数は実行しません。これは、サーバーからきたままの、 
『生の』記事を与えます。

@item A <
@itemx <
@kindex < （概略）
@kindex A < （概略）
@findex gnus-summary-beginning-of-article
記事の最初までスクロールします。
(@code{gnus-summary-beginning-of-article})。

@item A >
@itemx >
@kindex > （概略）
@kindex A > （概略）
@findex gnus-summary-end-of-article
記事の最後までスクロールします (@code{gnus-summary-end-of-article})。

@item A s
@itemx s
@kindex A s （概略）
@kindex s （概略）
@findex gnus-summary-isearch-article
記事バッファでインクリメンタルサーチ (isearch) を行います
(@code{gnus-summary-isearch-article})。

@item h
@kindex h （概略）
@findex gnus-summary-select-article-buffer
記事バッファを選択します (@code{gnus-summary-select-article-buffer})。

@end table


@node Reply Followup and Post
@section 返答、フォローアップ、投稿

@menu
* Summary Mail Commands::            メールを送る。
* Summary Post Commands::            ニュースを送る。
@end menu


@node Summary Mail Commands
@subsection 概略でのメールの命令
@cindex mail
@cindex composing mail

メールメッセージを作成するための命令:

@table @kbd

@item S r
@item r
@kindex S r （概略）
@kindex r （概略）
@findex gnus-summary-reply
@c @icon{gnus-summary-mail-reply}
@c @icon{gnus-summary-reply}
現在の記事を書いた人に返答のメールを送ります (@code{gnus-summary-reply})。

@item S R
@itemx R
@kindex R （概略）
@kindex S R （概略）
@findex gnus-summary-reply-with-original
@c @icon{gnus-summary-reply-with-original}
現在の記事を書いた人に、本記事を含んだ返答のメールを出します
(@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引数の習
慣を使います。

@item S w
@kindex S w （概略）
@findex gnus-summary-wide-reply
現在の記事を書いた人に対して、広い返答 (wide reply) をします
(@code{gnus-summary-wide-reply})。@dfn{広い返答} とはヘッダーの
@code{To}, @code{From},（もしくは @code{Reply-to}) と @code{Cc}）のすべて
の人に返答をすることです。

@item S W
@kindex S W （概略）
@findex gnus-summary-wide-reply-with-original
現在の記事に本記事を含んだ広い返答のメールを送ります
(@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引数の
習慣を使います。

@item S o m
@kindex S o m （概略）
@findex gnus-summary-mail-forward
@c @icon{gnus-summary-mail-forward}
誰か他の人に現在の記事を転送します (@code{gnus-summary-mail-forward})。
接頭引数があると、転送記事の完全なヘッダーを取り込みます。

@item S m
@itemx m
@kindex m （概略）
@kindex S m （概略）
@findex gnus-summary-mail-other-window
@c @icon{gnus-summary-mail-originate}
誰か他の人にメールを送ります (@code{gnus-summary-mail-other-window})。

@item S D b
@kindex S D b （概略）
@findex gnus-summary-resend-bounced-mail
@cindex bouncing mail
メールを送ったのに、何らかの理由（アドレスの間違い、転送の不調）で戻ってき
たときに、この命令を使って戻ってきたメールをもう一回送ることができます 
(@code{gnus-summary-resend-bonced-mail})。もう一度メールを送る前にヘッダー
を編集できるように、メールバッファにそのメールが現れるでしょう。この命令に
接頭引数を与えて、戻ってきたメールが誰かへの返答であった場合、gnus はその
メールを取得して、それのヘッダーの精密調査ができるように画面に表示します。
ま、これはとてもよく失敗しますけど。

@item S D r
@kindex S D r （概略）
@findex gnus-summary-resend-message
上の命令と混同しないように、@code{gnus-summary-resend-message} は現在のメッ
セージを送る先のアドレスの入力を促し、それからその場所にメールを送ります。
メッセージのヘッダーは変更されません――しかし、@code{Resent-To},
@code{Resent-From} 等のヘッダーが付け加えられます。これは、（おそらく）あ
なた自身を @code{To} 欄に書いた本人にもメールを送ってしまうということです。
これは混乱を招くでしょう。ですから、もちろん、本当に 邪悪 な気分のときにだ
けこれを使うでしょう。

この命令は主に、あなたがいくつかのメールアカウント (account) を持ってい
て、自分自身の違ったアカウントにメールを転送したいときに用いられます。
(もしあなたが、@code{ルート} (root) であり、@code{ポストマスター}
(postmaster) でもあり、@code{ルート} に @code{ポストマスター} へのメール
を受け取った場合は、それを @code{ポストマスター} にも再送したいと思うで
しょう。Ordnung mu,A_ sein!)

この命令はプロセス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S O m
@kindex S O m （概略）
@findex gnus-uu-digest-mail-forward
現在の一連の記事 (@pxref{Decoding Articles}) の要約を作り、メールでその結
果を送ります (@code{gnus-uu-digest-mail-forward})。この命令はプロセス/接頭
引数の習慣に従います (@pxref{Process/Prefix})。

@item S M-c
@kindex S M-c （概略）
@findex gnus-summary-mail-crosspost-complaint
@cindex crossposting
@cindex excessive crossposting
現在の記事の書き手に、過剰クロスポストへの苦情のメールを送ります
(@code{gnus-summary-mail-crosspost-complaint})。

@findex gnus-crosspost-complaint
この命令は、現在 Usenet に横行している、クロスポストの世界的流行に対して
反撃を行う手段として提供されています。これは変数
@code{gnus-crosspost-complaint} を序文にして、返答を作成します。この命令
はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) に従い、それぞれのメー
ルを送る前に送信するかどうかの確認をします。

@end table

また @pxref{(message)Header Commands} にさらなる情報があります。


@node Summary Post Commands
@subsection 概略の投稿命令
@cindex post
@cindex composing news

ニュースの記事を投稿するための命令：

@table @kbd
@item S p
@itemx a
@kindex a （概略）
@kindex S p （概略）
@findex gnus-summary-post-news
@c @icon{gnus-summary-post-news}
現在のグループに記事を投稿します (@code{gnus-summary-post-news})。

@item S f
@itemx f
@kindex f （概略）
@kindex S f （概略）
@findex gnus-summary-followup
@c @icon{gnus-summary-followup}
現在の記事のフォローアップを投稿します (@code{gnus-summary-followup})。

@item S F
@itemx F
@kindex S F （概略）
@kindex F （概略）
@c @icon{gnus-summary-followup-with-original}
@findex gnus-summary-followup-with-original
本記事を取り込んで、現在の記事にフォローアップをします
(@code{ggnus-summary-followup-with-original})。この命令はプロセス/接頭引数
の習慣を用います。

@item S n
@kindex S n （概略）
@findex gnus-summary-followup-to-mail
メールのメッセージを受け取っていたとしても、現在の記事
のフォローアップをニュースに投稿します 
(@code{gnus-summary-followup-to-mail})。
この命令はプロセス/接頭引数の習慣を用います。

@item S N
@kindex S N (概略)
@findex gnus-summary-followup-to-mail-with-original
メールのメッセージを受け取っていたとしても、本記事を引用して、現在の記事
のフォローアップをニュースに投稿します 
(@code{gnus-summary-followup-to-mail-with-original}).  
この命令はプロセス/接頭引数の習慣を用います。

@item S o p
@kindex S o p （概略）
@findex gnus-summary-post-forward
現在の記事をニュースグループに転送します
(@code{gnus-summary-post-forward})。接頭引数が与えられたときは、転送記事
のヘッダーを完全に取り込みます。

@item S O p
@kindex S O p （概略）
@findex gnus-uu-digest-summary-post-forward
@cindex digests
@cindex making digests
現在の一連の記事を要約して、その結果をニュースグループに送ります
(@code{gnus-uu-digest-mail-forward})。この命令はプロセス/接頭引数の習慣
を用います。

@item S u
@kindex S u （概略）
@findex gnus-uu-post-news
@c @icon{gnus-uu-post-news}
ファイルを Uuencode し、分割して、組にして投稿します
(@code{gnus-uu-post-news})。(@pxref{Uuencoding and Posting})。
@end table

また @pxref{(message)Header Commands} にさらなる情報があります。


@node Canceling and Superseding
@section 記事を取り消す
@cindex canceling articles
@cindex superseding articles

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなければ
なぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニュースの投稿は取り消す
ことができます。

@findex gnus-summary-cancel-article
@kindex C （概略）
@c @icon{gnus-summary-cancel-article}
取り消したい記事を見つけてください（取り消すことができるのは自分の記事だけ
です。変なことは試さないでください）。それから、 @kbd{C} か @kbd{S c}を押
してください (@code{gnus-summary-cancel-article})。あなたの記事が取り消さ
れます――世界中の機械があなたの記事を取り消します。この命令はプロセス/接
頭引数の習慣を用います (@pxref{Process/Prefix})。

しかし、注意してほしいのはすべてのサイト (site) が取り消しを扱っているわ
けではないことです。ですから、たいていのサイトが問題の記事を取り消しても、
あちこちであなたの記事は生き残るかもしれません。

Gnus は、取り消すときに『現在』の選択方法を使います。標準の投稿方法を使い
たいのであれば、文字接頭引数 @samp{a} を使ってください(@pxref{Symbolic
Prefixes})。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、@dfn{代替}
(@dfn{superseding}) 記事を投稿して本記事を置き換えることができます。

@findex gnus-summary-supersede-article
@kindex S （概略）
本記事のところへ移動して、@kbd{S s} を押してください
(@code{gnus-summary-supersede-article})。普通の方法でそれを送る前に、記事
を好きなように編集することができます。代替に関しても、取り消しと同じことが
当てはまります。こちらの方がもっとよく当てはまるかもしれません：いくつかの
サイトは代替を受け付けません。これらのサイトでは、あなたがほとんど同じ記事
を2回投稿したようになります。

もしさっき記事を投稿したばかりですぐに変更したくなた場合、記事が最初にあ
なたのサイトに現れる前に取り消し/代替をするための巧妙な手段があります。
まず、投稿バッファ（@code{*sent ... *} のようになっています）に戻ります。
そこにはあなたがちょうど投稿した記事があり、すべてのヘッダーがそのままあ
ります。それらの中の @code{Message-ID} という語のところを変更することに
よって @code{Message-ID} ヘッダーを @code{Cancel} もしくは
@code{Supersedes} に変更してください。

ちょっと覚えておいてください：`supersede'（代替）という語の中に `c' は無い
ということを。


@node Marking Articles
@section 記事に印を付ける
@cindex article marking
@cindex article ticking
@cindex marks

記事に付けられる印はいくつかあります。

記事の @dfn{購読度}（おぉ、すんごい新語句だ！）を決定する印がありま
す。英字の印は一般的には @dfn{既読}を意味し、英字でない文字は一般的に
@dfn{未読}を意味します。

加えて、購読度に影響しない印もあります。

@menu
* Unread Articles::      未読記事への印
* Read Articles::        既読記事への印
* Other Marks::          購読度に影響しない印
@end menu

@ifinfo
これらの印を操作する過剰なくらいの命令があります：
@end ifinfo

@menu
* Setting Marks::           印の付け方と消し方
* Setting Process Marks::   後の実行のための記事の印の付け方
@end menu


@node Unread Articles
@subsection 未読記事

以下の印はいろいろな方法で記事に未読の（ような）印を付けます。

@table @samp
@item !
@vindex gnus-ticked-mark
可視記事 (Ticked) として印をつけます (@code{gnus-ticked-mark})。

@dfn{可視記事}とは、常に可視状態である記事のことです。おもしろいと思う記事
があった場合や、単に読むのを先に延ばしたいときや、後で返答をしたいときに、
普通は可視印を付けます。しかし、記事は期限切れ消去されることもありますので、
永遠に記事を保存しておきたい場合は、その記事を永続にする必要があります 
(@pxref{Persistent Articles})。

@item ?
@vindex gnus-dormant-mark
保留として印を付けます (@code{gnus-dormant-mark})。

@dfn{保留記事}はフォローアップがあったときにだけ概略バッファに現れます。フォ
ローアップが無いときも表示させたいときは、命令 @kbd{/ D} を使うことができ
ます。

@item SPACE
@vindex gnus-unread-mark
未読として印を付けます (@code{gnus-unread-mark})。

@dfn{未読記事}は今まで全く読まれていない記事のことです。
@end table


@node Read Articles
@subsection 既読記事
@cindex expirable mark

以下のすべての印は記事に既読の印を付けます。

@table @samp

@item r
@vindex gnus-del-mark
利用者が手動やそのようなもので命令 @kbd{d} によって既読の印を付けた記事
です (@code{gnus-del-mark})。

@item R
@vindex gnus-read-mark
実際に読まれた記事 (@code{gnus-read-mark})。

@item O
@vindex gnus-ancient-mark
前回のセッションで既読の印を付けて、今は@dfn{古く}なってしまった記事。

@item K
@vindex gnus-killed-mark
削除の印 (@code{gnus-killed-mark})。

@item X
@vindex gnus-kill-file-mark
削除ファイルによって削除の印がついた記事
(@code{gnus-kill-file-mark})。

@item Y
@vindex gnus-low-score-mark
低すぎるスコアのために既読の印がついた記事
(@code{gnus-low-score-mark})。

@item C
@vindex gnus-catchup-mark
キャッチアップによって既読の印がついた記事
(@code{gnus-catchup-mark})。

@item G
@vindex gnus-canceled-mark
取り消された記事 (@code{gnus-canceled-mark})。

@item F
@vindex gnus-souped-mark
@sc{SOUP} されている記事 (@code{gnus-souped-mark})。 @xref{SOUP}.

@item Q
@vindex gnus-sparse-mark
まばらに参照された記事 (@code{gnus-sparse-mark})。
@xref{Customizing Threading}.

@item M
@vindex gnus-duplicate-mark
重複抑制により既読の印のついた記事 (@code{gnus-duplicated-mark})。
@xref{Duplicate Suppression}.

@end table

これらのすべての印は、本当はただ記事が既読として印がついていることを意味
するだけです。適応スコアリングをしたときには違ったように解釈されますけれ
ど。

もう一つ、特別な印があります：

@table @samp
@item E
@vindex gnus-expirable-mark
期限切れ削除可能として印のついた記事 (@code{gnus-expirable-mark})。

記事を@dfn{期限切れ削除可能}として印を付ける（もしくは、自動的にそのように
印を付ける）ことは、普通のグループではあまり意味がありません――利用者はニュー
ズ記事の期限による削除を制御していません。しかし、例えばメールグループでは、
@dfn{期限切れ削除可能}として印のついた記事は、いつでも gnus によって削除さ
れることがあります。
@end table


@node Other Marks
@subsection 他の印
@cindex process mark
@cindex bookmarks

記事が読まれたかどうかには関係しない印がいくつかあります。

@itemize @bullet

@item
現在の記事にしおりを挟むことができます。あなたは猫の尿の習慣に関する長い
論文を読んでいて、それを読み終わる前に夕食を食べるために家に帰らなければ
ならなかったとしましょう。そのときに、記事にしおりを挟むことができ、次に
その記事に出くわしたときに、gnus はそのしおりのところへ移動するでしょう。
@xref{Setting Marks}.

@item
@vindex gnus-replied-mark
返答をしたか、フォローアップをした（例えば、答えた）記事はすべて2桁目に
@samp{A} の印がつきます (@code{gnus-replied-mark})。

@item
@vindex gnus-cached-mark
記事キャッシュに貯められている記事は2桁目に @samp{*} の印がつきます
(@code{gnus-replied-mark})。 @xref{Article Caching}.

@item
@vindex gnus-saved-mark
（何らかの方法によって；必ずしも宗教的というわけではなく）『保存された』記
事は2桁目に @samp{S} の印がつきます (@code{gnus-saved-mark})。

@item
@vindex gnus-not-empty-thread-mark
@vindex gnus-empty-thread-mark
もし @samp{%e} の仕様が使われると、スレッドがあるかどうかは、３桁目に
@code{gnus-not-empty-thread-mark} と @code{gnus-empty-thread-mark} のそれ
ぞれによって印がつきます。

@item
@vindex gnus-process-mark
最後に @dfn{プロセス印} があります(@code{gnus-process-mark})。いろいろな種
類の命令がプロセス印があるとそれに対して実行されます。例えば、@kbd{X u}
(@code{gnus-uu-decode-uu}) はプロセス印の付いたすべての記事を uudecode し
て、表示します。プロセス印の付いた記事は2桁目に @samp{#} があります。

@end itemize

これらの『非購読度』の印は初期設定ではたいてい2桁目に現れるということに
気付いたかもしれません。ですから、キャッシュされていて、保存されていて、
返答をした記事にプロセス印が付いている場合、どのようになるのでしょう？

たいしたことはありません。優先順位は次のようになっています： プロセス → 
キャッシュ → 返答済み → 保存。ですから、ある記事がキャッシュに入っていて、
返答されていた場合、キャッシュ印があるだけで、返答済み印はありません。


@node Setting Marks
@subsection 印を付ける
@cindex setting marks

すべての印つけ命令は数値接頭引数を受け付けます。

@table @kbd
@item M c
@itemx M-u
@kindex M c （概略）
@kindex M-u （概略）
@findex gnus-summary-clear-mark-forward
@cindex mark as read
現在の記事から、すべての購読度印を消去します
(@code{gnus-summary-clear-mark-forward})。要するに、記事に未読の印を付け
ます。

@item M t
@itemx !
@kindex ! （概略）
@kindex M t （概略）
@findex gnus-summary-tick-article-forward
現在の記事に可視記事印を付けます
(@code{gnus-summary-tick-article-forward})。 @xref{Article Caching}.

@item M ?
@itemx ?
@kindex ? （概略）
@kindex M ? （概略）
@findex gnus-summary-mark-as-dormant
現在の記事に保留記事印を付けます
(@code{gnus-summary-mark-as-read-forward})。

@item D
@kindex D （概略）
@findex gnus-summary-mark-as-read-backward
現在の記事に既読の印を付け、前の行にポイントを移動します
(@code{gnus-summary-mark-as-read-backward})。

@item M k
@itemx k
@kindex k （概略）
@kindex M k （概略）
@findex gnus-summary-kill-same-subject-and-select
現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未読記事
を選択します (@code{gnus-summary-kill-same-subject-and-select})。

@item M K
@itemx C-k
@kindex M K （概略）
@kindex C-k （概略）
@findex gnus-summary-kill-same-subject
現在の記事と同じ表題を持つすべての記事を既読として印を付けます
(@code{gnus-summary-kill-same-subject})。

@item M C
@kindex M C （概略）
@findex gnus-summary-catchup
@c @icon{gnus-summary-catchup}
すべての未読記事に既読の印を付けます (@code{gnus-summary-catchup})。

@item M C-c
@kindex M C-c （概略）
@findex gnus-summary-catchup-all
グループのすべての記事に――可視記事や保留記事でさえも、既読の印を付けます 
(@code{gnus-summary-catchup-all})。

@item M H
@kindex M H （概略）
@findex gnus-summary-catchup-to-here
現在のグループのポイントまでを既読として印を付けます
(@code{gnus-summary-catchup-to-here})。

@item C-w
@kindex C-w （概略）
@findex gnus-summary-mark-region-as-read
ポイントとマークの間の記事に既読の印を付けます
(@code{gnus-summary-mark-region-as-read})。

@item M V k
@kindex M V k （概略）
@findex gnus-summary-kill-below
初期設定のスコア（もしくは数値接頭引数）よりも低いスコアの記事を削除しま
す。

@item M e
@itemx E
@kindex M e （概略）
@kindex E （概略）
@findex gnus-summary-mark-as-expirable
現在の記事を期限切れ削除可能として印を付けます
(@code{gnus-summary-mark-as-expirable})。

@item M b
@kindex M b （概略）
@findex gnus-summary-set-bookmark
現在の記事にしおりを設定します (@code{gnus-summary-set-bookmark})。

@item M B
@kindex M B （概略）
@findex gnus-summary-remove-bookmark
現在の記事のしおりを削除します (@code{gnus-summary-remobe-bookmark})。

@item M V c
@kindex M V c （概略）
@findex gnus-summary-clear-above
初期設定のスコア（もしくは数値接頭引数）よりも大きいスコアを持つ記事のす
べての印を消去します (@code{gnus-summary-clar-above})。

@item M V u
@kindex M V u （概略）
@findex gnus-summary-tick-above
初期設定のスコア（もしくは数値接頭引数）よりも大きいスコアを持つすべての
記事に可視印を付けます (@code{gnus-summary-tick-above})。

@item M V m
@kindex M V m （概略）
@findex gnus-summary-mark-above
印の入力を促し、初期設定のスコア（もしくは数値接頭引数）よりも大きなスコ
アを持つすべての記事にその印を付けます (@code{gnus-summary-mark-above})。
@end table

@vindex gnus-summary-goto-unread
変数 @code{gnus-summary-goto-unread} は印が付けられた後にどのような動作が
なされるかを決定します。もし @code{nil} でないと、ポイントは次/前の未読記
事に移動します。もし @code{nil} であると、ポイントは一行上か下に行くだけで
す。特別な場合として、この変数が @code{never} であると、すべての印を付ける
命令と（@kbd{SPACE} のような）他の命令は次の記事が未読であろうが無かろうが
その記事に移動します。初期値 @code{t} です。


@node Setting Process Marks
@subsection プロセス印を付ける
@cindex setting process marks

@table @kbd

@item M P p
@itemx #
@kindex # （概略）
@kindex M P p （概略）
@findex gnus-pick-unmark-article-or-thread
スレッドか記事を未選択にします 
@code{gnus-pick-unmark-article-or-thread})。変数 
@code{gnus-thread-hide-subtree} が true であれば、このキーはスレッドの最
初の記事で使われたときはスレッドを未選択にします。そうでない場合は、その
記事だけを未選択にします。その行のスレッドか記事を未選択にするためにこの
キーに数値接頭引数を与える事ができます。

@item M P u
@itemx M-#
@kindex M P u （概略）
@kindex M-# （概略）
もし現在の記事にプロセス印があれば取り除きます
(@code{gnus-summary-unmark-as-processable})。

@item M P U
@kindex M P U （概略）
@findex gnus-summary-unmark-all-processable
すべての記事からプロセス印を取り除きます
(@code{gnus-summary-unmark-all-processable})。

@item M P i
@kindex M P i （概略）
@findex gnus-uu-invert-processable
プロセス印の付いている記事とそうでない記事を逆にします
(@code{gnus-uu-mark-by-regexp})。

@item M P R
@kindex M P R （概略）
@findex gnus-uu-mark-by-regexp
正規表現によって記事に印を付けます (@code{gnus-uu-mark-by-regexp})。

@item M P r
@kindex M P r （概略）
@findex gnus-uu-mark-region
リージョンの記事に印を付けます (@code{gnus-uu-mark-region})。

@item M P t
@kindex M P t （概略）
@findex gnus-uu-mark-thread
現在の（副）スレッドのすべての記事に印を付けます
(@code{gnus-uu-mark-thread})。

@item M P T
@kindex M P T （概略）
@findex gnus-uu-unmark-thread
現在の（副）スレッドのすべての記事から印を取り除きます
(@code{gnus-uu-unamrk-thread})。

@item M P v
@kindex M P v （概略）
@findex gnus-uu-mark-over
接頭引数よりも大きなスコアを持つすべての記事に印を付けます
(@code{gnus-uu-mark-over})。

@item M P s
@kindex M P s （概略）
@findex gnus-uu-mark-series
現在の一連の記事に印を付けます (@code{gnus-uu-mark-series})。

@item M P S
@kindex M P S （概略）
@findex gnus-uu-mark-sparse
既にいくつか印の付いた記事を持つ一連の記事群全てに印を付けます
(@code{gnus-uu-mark-sparse})。

@item M P a
@kindex M P a （概略）
@findex gnus-uu-mark-all
一連の記事が出てくる順番にそれに属するすべての記事に印を付けます
(@code{gnus-uu-mark-all})。

@item M P b
@kindex M P b （概略）
@findex gnus-uu-mark-buffer
バッファのすべての記事を現れている順番に印を付けます
(@code{gnus-uu-mark-buffer})。

@item M P k
@kindex M P k （概略）
@findex gnus-summary-kill-process-mark
現在のプロセス印をスタックに積んで、すべての記事を無印にします
(@code{gnus-summary-kill-process-mark})。

@item M P y
@kindex M P y （概略）
@findex gnus-summary-yank-process-mark
スタックから前回のプロセス印を取り出して、それを復元します
(@code{gnus-summary-yank-process-mark})。

@item M P w
@kindex M P w （概略）
@findex gnus-summary-save-process-mark
現在のプロセス印をスタックに積みます
(@code{gnus-summary-save-process-mark})。

@end table


@node Limiting
@section 制限をする
@cindex  limiting

概略バッファが現在グループにある記事の一部だけを表示するように制限できれば
便利なことがあります。多くの制限命令が持つ効果は概略バッファから少し（もし
くは多く）の記事を概略バッファから削除することです。

すべての制限命令はサーバーから既に取得された記事の一部分に作用します。こ
れらの命令はどれもサーバーに追加の記事を要求しません。

@table @kbd

@item / /
@itemx / s
@kindex / / （概略）
@findex gnus-summary-limit-to-subject
概略バッファをいくつかの表題と合致するものだけに制限します
(@code{gnus-summary-limit-to-subject})。

@item / a
@kindex / a （概略）
@findex gnus-summary-limit-to-author
概略バッファを何人かの著者に合致するものだけに制限します
(@code{gnus-summary-limit-to-author})。

@item / u
@itemx x
@kindex / u （概略）
@kindex x （概略）
@findex gnus-summary-limit-to-unread
概略バッファを既読の印が付いていない記事に制限します
(@code{gnus-summary-limit-to-unread})。もし接頭引数が与えられれば、バッ
ファを厳密に未読記事のみに制限します。これは、可視と保留の記事は含まれな
いということです。

@item / m
@kindex / m （概略）
@findex gnus-summary-limit-to-marks
印を尋ねて、その印が付いていない記事に制限します
(@code{gnus-summary-limit-to-marks})。

@item / t
@kindex / t （概略）
@findex gnus-summary-limit-to-age
数字を尋ねて、概略バッファをその数字の日より古い（もしくは同じ）記事に制限
します (@code{gnus-summary-limit-to-marks})。もし接頭引数が与えられれば、
その数字の日よりも新しい記事に制限します。

@item / n
@kindex / n （概略）
@findex gnus-summary-limit-to-articles
概略バッファを現在の記事に制限します
(@code{gnus-summary-limit-to-articles})。プロセス/接頭引数の習慣を使いま
す (@pxref{Process/Prefix})。

@item / w
@kindex / w （概略）
@findex gnus-summary-pop-limit
前の制限をスタックから取り出して、復元します
(@code{gnus-summary-pop-limit})。もし接頭引数を与えられれば、すべての制
限をスタックから取り出します。

@item / v
@kindex / v （概略）
@findex gnus-summary-limit-to-score
概略バッファをあるスコアと同じか、それより大きなスコアを持つ記事に制限し
ます (@code{gnus-summary-limit-to-score})。

@item / E
@itemx M S
@kindex M S （概略）
@kindex / E （概略）
@findex gnus-summary-limit-include-expunged
すべての消去された記事を表示します
(@code{gnus-summary-limit-include-expunged})。

@item / D
@kindex / D （概略）
@findex gnus-summary-limit-include-dormant
すべての保留記事を表示します (@code{gnus-summary-limit-include-dormant})。

@item / *
@kindex / * （概略）
@findex gnus-summary-limit-include-cached
すべてのキャッシュに入っている記事を表示します
(@code{gnus-summary-limit-include-cached})。

@item / d
@kindex / d （概略）
@findex gnus-summary-limit-exclude-dormant
すべての保留記事を隠します (@code{gnus-summary-limit-exclude-dormant})。

@item / T
@kindex / T （概略）
@findex gnus-summary-limit-include-thread
現在のスレッドのすべての記事を表示します
(@code{gnus-summary-limit-include-thread})。

@item / c
@kindex / c （概略）
@findex gnus-summary-limit-exclude-childless-dormant
子記事の無いすべての保留記事を隠します
(@code{gnus-summary-limit-exclude-childless-dormant})。


@item / C
@kindex / C （概略）
@findex gnus-summary-limit-mark-excluded-as-read
すべての未読のみの印の記事を既読として印を付けます
(@code{gnus-summary-limit-mark-excluded-as-read})。もし接頭引数が与えら
れれば、可視と保留のみの印の記事も既読として印を付けます。

@end table


@node Threading
@section スレッド
@cindex threading
@cindex article threading

Gnus は初期設定で記事をスレッドにします。@dfn{スレッドにする} とは、ある
記事への応答を応答した記事の直後に置く――階層的流儀で ということです。

スレッドは記事の @code{References} 欄を調べることによって行われます。完全
な世界では、これだけで良い木を作り上げるのに十分なのですが、不運なことに、
@code{References} 欄はしばしば壊れているか、時には単にないということがあり
ます。不思議なニュースの増殖が問題を増やしますので、喜ばしい結果を得るため
には他の発見法を採用しなければなりません。過剰な対策法は存在していて、その
恐るべき詳細は @pxref{Customizing Threading} に詳しく書いてあります。

まず、概念の概観です：

@table @dfn
@item 根本 (root)
スレッドで一番頂点にある記事です；スレッドの最初の記事です。

@item スレッド (thread)
木のような記事の構成です。

@item 部分スレッド (sub-thread)
木のような構造の（より）小さな部分です。

@item 無束縛スレッド (loose threads)
記事の期限切れ削除や、根本が既に前回のセッションで読まれたことにより概略バッ
ファに表示されない、等の理由により、スレッドはしばしば根本を失います。その
ようなときには、普通は多くの部分スレッドがあって、本当は１つのスレッドに属
しているのですが、根本にはつながっていない、ということになります。こういう
スレッドが無束縛スレッドと呼ばれています。

@item スレッド集め (thread gathering)
まばらスレッドを大きなスレッドに集めようとする試みです。

@item まばらスレッド (sparse threads)
無い記事が『推測された』スレッドで、概略バッファに空行で表示されます。

@end table


@menu
* Customizing Threading::     変更可能なスレッドに影響する変数
* Thread Commands::           概略バッファでのスレッドに基づいた命令
@end menu


@node Customizing Threading
@subsection スレッドをカスタマイズする
@cindex customizing threading

@menu
* Loose Threads::        Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::   スレッドを埋める
* More Threading::       スレッドをいじくるさらに多くの変数
* Low-Level Threading::  これで終わったと思ったでしょう... でもあなたは間違っていた！
@end menu


@node Loose Threads
@subsubsection 無束縛スレッド
@cindex <
@cindex >
@cindex loose threads

@table @code
@item gnus-summary-make-false-root
@vindex gnus-summary-make-false-root
もし @code{nil} でないと、gnus は全てのつながっていない部分木を１つの大き
な木にして、頂上にみせかけの根本を作ります。（ちょっと待ってください。頂
上に根元 (root) ですって？ええ、そうなのです。）つながっていない部分木は本
当の根本が期限切れ削除されたか、前回のセッションで根本を読んだり削除し
たときにできます。

本当のスレッドが無いときは、gnus は何かでっち上げをする必要があります。こ
の変数は gnus が使うべきごまかしの方法を示しています。値としてとることがで
きる４つの候補があります。

@cindex adopting articles

@table @code

@item 養子 (adopt)
Gnus は最初の孤児を親にします。この親はすべての他の記事を養子にします。
この養子記事は、標準の角括弧 (@samp{[]}) の代わりに、先の尖った括弧
(@samp{<>}) で印付けられます。これが初期設定の方法です。

@item みせかけ (dummy)
@vindex gnus-summary-dummy-line-format
Gnus は親のふりをするみせかけの概略行をつくります。みせかけの行はどの本
当の記事にも対応しませんので、それを選択することは、みせかけの記事の後の
最初の本当の記事を選択をするだけになります。みせかけの根本の様式を指定
するために、 @code{gnus-summary-dummy-line-format} が使われます。これは
たった一つだけのフォーマットの仕様を受け付けます: @samp{S} で、これは記
事の表題です。 @xref{Formatting Variables}.

@item 空 (empty)
Gnus は実際にはどの記事も親にはせず、単に最初の孤児を除いてすべての孤児の
表題欄を空のままにします。（実際は、@code{gnus-summary-same-subject} を表
題として使います。 (@pxref{Summary Buffer Format}).）

@item none
全くどの記事も親にしません。スレッドを集めて、一つの記事の後に他の記事を
表示するだけです。

@item nil
無束縛スレッドを集めません。
@end table

@item gnus-summary-gather-subject-limit
@vindex gnus-summary-gather-subject-limit
無束縛スレッドは記事の表題を比較することによって集められます。もしこの変数
が @code{nil} であると、gnus は無束縛スレッドを一つの大きな超スレッドに集
める前に、無束縛スレッドの表題が完全に一致することを要求します。これは、長
い表題の行を切り落としてしまう間抜けなニュースリーダーが存在する現在では、
あまりに厳しい要求かも知れません。もしそう思うのなら、この変数を例えば 
20 に設定して、表題の最初の 20 文字だけが一致することを要求するようにする
ことができます。この変数を本当に低い数字に設定すると、gnus が目に入る全て
を一つのスレッドに集めるのを見ることができるでしょう。そして、それはあまり
有用ではありません。

@cindex fuzzy article gathering
この変数を特別な値 @code{fuzzy} に設定すれば、gnus は表題にあいまいな文
字列比較アルゴリズムを使います (@pxref{Fuzzy Matching})。

@item gnus-sumplify-subject-fuzzy-regexp
@vindex gnus-simplify-subject-fuzzy-regexp
これは正規表現か、あいまい表題指定が使われているときに表題から合致したも
のが取り除かれる、正規表現のリストであることができます。

@item gnus-simplify-ignored-prefixes
@vindex gnus-simplify-igonored-prefixes
もし @code{gnus-summary-gather-subject-limit} を 10 くらいに低く設定したな
らば、この変数を何か意味のあるものに設定することを考えるでしょう：

@c Written by Michael Ernst <mernst@cs.rice.edu>
@lisp
(setq gnus-simplify-ignored-prefixes
      (concat
       "\\`\\[?\\("
       (mapconcat
        'identity
        '("looking"
          "wanted" "followup" "summary\\( of\\)?"
          "help" "query" "problem" "question"
          "answer" "reference" "announce"
          "How can I" "How to" "Comparison of"
          ;; ...
          )
        "\\|")
       "\\)\\s *\\("
       (mapconcat 'identity
                  '("for" "for reference" "with" "about")
                  "\\|")
       "\\)?\\]?:?[ \t]*"))
@end lisp

この正規表現に合致するすべての語は、2つの表題を比較する前に取り除かれます。

@item gnus-simplify-subject-functions
@vindex gnus-simplify-subject-functions
@code{nil} でないと、この変数は @code{gnus-summary-gather-subject-limit} 
を上書きします。この変数は文字列 @code{Subject} を反復して簡単な形にたど
り着くために適用する関数のリストである必要があります。

このリストに入れて役に立つような関数は次のようなものです：

@table @code
@item gnus-simplify-subject-re
@findex gnus-simplify-subject-re
前の方にある @samp{Re:} を取り除きます。

@item gnus-simplify-subject-fuzzy
@findex gnus-simplify-subject-fuzzy
あいまいに簡単にします。

@item gnus-simplify-whitespace
@findex gnus-simplify-whitespace
余分な空白 (whitespace) を取り除きます。
@end table

もちろん、あなた自身の関数を書くこともできます。


@item gnus-summary-gather-exclude-subject
@vindex gnus-summary-gather-exclude-subject
無束縛スレッド集めは表題のみに行われますので、特に @samp{} や 
@samp{(none)}のような良くある表題のときは、多くの間違いを起こす可能性が
あります。この状況を少しよくするために、どの表題が集める過程から除かれる
かを決める正規表現 @code{gnus-summary-gather-exclude-subject} を使うこと
ができます。ディフォルトは @samp{^ *$\\|^(none)$} です。

@item gnus-summary-thread-gathering-function
@vindex gnus-summmary-thread-gathering-function
Gnus は @code{Subject} 欄を見ることによってスレッドを集めます。これは、結
果的に全く関係の無い記事が同じ『スレッド』に含まれることがあるということで、
これは混乱の元です。代替手段は、合致するものを見つけるために 
@code{References} 欄にある @code{Message-ID} をすべて探すことです。これは
関係の無い記事が集められたスレッドに含まれることは全く無いことを保証します
が、こわれたニュースリーダーで投稿した記事は適切に集められないということで
もあります。選択権はあなたにあります――疫病かコレラか。

@table @code
@item gnus-gather-threads-by-subject
@findex gnus-gather-threads-by-subject
この関数はディフォルトの収集関数で、排他的に @code{Subject} を見ます。

@item gnus-gather-threads-by-references
この関数は排他的に @code{References} 欄を見ます。
@end table

@code{References} によって集めることを試してみたいのであれば、次のように
することができます：

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp

@end table


@node Filling In Threads
@subsubsection スレッドを埋める

@table @code
@item gnus-fetch-old-headers
@vindex gnus-fetch-old-headers
もし @code{nil} でないと、gnus は古いスレッドをもっと古いヘッダー――既読
印の付いている記事のヘッダー を取得することで大きくしようとします。もしで
きるだけ少ない概略行を表示したいけれど、できるだけたくさんの非密スレッドに
接続しておきたいときは、この変数を @code{some} か数字に設定することができ
ます。もし数字に設定したときは、それより多い追加のヘッダーは取得されません。
どちらの場合でも、古いヘッダーの取得が動作するのは、使っているバックエンド 
(backend) が overview ファイルを使っているかどうかです――これは普通は 
@code{nntp}, @code{nnspool} と @code{nnml} です。スレッドのルートがサーバー
によって期限切れ削除されたときは、gnus はどうしようもないことを覚えておい
てください。

この変数は @code{invisible} に設定することもできます。これは視覚的な効果
は何もありませんが、命令 @kbd{A T} をよく使うのであれば役に立つでしょう
(@pxref{Finding the Parent})。

@item gnus-build-sparse-threads
@vindex gnus-build-sparse-threads
古いヘッダーを取得すると遅くなることがあります。同じような低賃金の効果を得
るために、この変数を @code{some} に設定することができます。そうすると、
gnus は全ての記事の完全な @code{References} 欄を見て、同じスレッドに属する
記事をつなごうとします。これは gnus が記事がスレッドから失われていると推測
したところのスレッド表示に@dfn{ずれ}を残すでしょう。（これらのずれは普通の
概略行のように現れます。もしずれを選択したときは、gnus はその当の記事を取
得しようとします。）この変数が @code{t} であると、gnusは全ての『ずれ』をス
レッドを補完するのに役に立つかを考慮せずに表示します。最後に、この変数が 
@code{more} であると、 gnus はどこにもつながっていない枝葉のまばらな節を切
り落としません。この変数はディフォルトでは @code{nil} です。

@end table


@node More Threading
@subsubsection もっとスレッドを

@table @code
@item gnus-show-threads
@vindex gnus-show-threads
この変数が @code{nil} であると、スレッドは作られず、ここにある残りのすべ
ての変数は全く効果が無くなります。スレッド作りを止めるとグループの選択が
少し速くなりますが、記事を読むのがもっと遅く、不便になることは確実です。

@item gnus-thread-hide-subtree
@vindex gnus-thread-hide-subtree
これが @code{nil} でないと、すべてのスレッドは概略バッファが生成されたと
きに隠れます。

@item gnus-thread-expunge-below
@vindex gnus-thread-expunge-below
この数字より少ない総合的スコア (@code{gnus-thread-score-function}) を持
つすべてのスレッドは消去されます。この変数はディフォルトでは @code{nil}
で、これはどのスレッドも消去されないということです。

@item gnus-thread-hide-killed
@vindex gnus-thread-hide-killed
もしスレッドを削除して、この変数が @code{nil} でないと、部分木は隠されます。

@item gnus-thread-ignore-subject
@vindex gnus-thread-ignore-subject
時々、誰かがスレッドの真中で表題を変更することがあります。もしこの変数が
@code{nil} でないと、表題の変更は無視されます。もし @code{nil} だと、こ
れがディフォルトですが、表題の変更をすると別のスレッドになります。

@item gnus-thread-indent-level
@vindex gnus-thread-indent-level
この数字は部分スレッドがどれくらい字下げ (indent) されるべきかを決めます。
ディフォルトは 4 です。

@end table


@node Low-Level Threading
@subsubsection 低レベルにおけるスレッド作成

@table @code

@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
すべてのヘッダーを解析する前に実行されるフックです。ディフォルトの値は
@code{(gnus-set-summary-default-charset)} です。これは変数 
@code{gnus-newsgroup-default-charset-alist} で指定されている値から概略バッ
ファの @code{default-mime-charset} を設定します。

@item gnus-alter-header-function
@vindex gnus-alter-header-function
これが @code{nil} でないと、ヘッダー構造の交換を可能にするようにこの関数が
呼ばれます。関数は一つの引数、記事ヘッダーのベクトル、とともに呼ばれ、それ
が何らかの方法で交換されます。例えば、（接頭語やその他のものを付け加えるこ
とによる）体系的な方法で @code{Message-ID} を交換するメールからニュースへ
のゲートウェイがある場合、@code{Message-ID} がもっと意味のあるものにするた
めに、この変数を設定して元に戻すことができます。これは一つの例です：

@lisp
(setq gnus-alter-header-function 'my-alter-message-id)

(defun my-alter-message-id (header)
  (let ((id (mail-header-id header)))
    (when (string-match
           "\\(<[^<>@@]*\\)\\.?cygnus\\..*@@\\([^<>@@]*>\\)" id)
      (mail-header-set-id
       (concat (match-string 1 id) "@@" (match-string 2 id))
       header))))
@end lisp

@end table


@node Thread Commands
@subsection スレッドの命令
@cindex thread commands

@table @kbd

@item T k
@itemx M-C-k
@kindex T k （概略）
@kindex M-C-k （概略）
@findex gnus-summary-kill-thread
現在の（部分）スレッドに既読の印を付けます
(@code{gnus-summary-kill-thread})。もし接頭引数が正であると、代わりにすべ
ての印を取り除きます。接頭引数が負であると、代わりに記事を可視にします。

@item T l
@itemx M-C-l
@kindex T l （概略）
@kindex M-C-l （概略）
@findex gnus-summary-lower-thread
現在の（部分）スレッドのスコアを下げます
(@code{gnus-summary-lower-thread})。

@item T i
@kindex T i （概略）
@kindex gnus-summary-raise-thread
現在の（部分）スレッドのスコアを上げます
(@code{gnus-summary-raise-thread})。

@item T #
@kindex T # （概略）
@findex gnus-uu-mark-thread
プロセス印を現在の（部分）スレッドに付けます 
(@code{gnus-uu-mark-thread})。

@item T M-#
@kindex T M-# （概略）
@findex gnus-uu-unmark-thread
現在の（部分）スレッドからプロセス印を取り除きます
(@code{gnus-uu-unmark-thread})。

@item T T
@kindex T T （概略）
@findex gnus-summary-toggle-threads
スレッド表示を切り替えます (@code{gnus-summary-toggle-threads})。

@item T s
@kindex T s （概略）
@findex gnus-summary-show-thread
もしあれば、現在の記事の下に隠れているスレッドを表示します
(@code{gnus-summary-show-thread})。

@item T h
@kindex T h （概略）
@findex gnus-summary-hide-thread
現在の（部分）スレッドを隠します (@code{gnus-summary-hide-thread})。

@item T S
@kindex T S （概略）
@findex gnus-summary-show-all-threads
すべての隠されているスレッドを表示します
(@code{gnus-summary-show-all-threads})。

@item T h
@kindex T h （概略）
@findex gnus-summary-hide-all-threads
すべてのスレッドを隠します (@code{gnus-summary-hide-all-threads})。

@item T t
@kindex T t （概略）
@findex gnus-summary-rethread-current
現在の記事のスレッドをもう一度作り直します
(@code{gnus-summary-rethread-current})。これは概略バッファがスレッド表示さ
れていないときでも動作します。

@item T ^
@kindex T ^ （概略）
@findex gnus-summary-reparent-thread
現在の記事を印付き（もしくは前の）記事の子記事にします
(@code{gnus-summary-reparent-thread})。

@end table

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付けま
す。

@table @kbd

@item T n
@kindex T n （概略）
@findex gnus-summary-next-thread
次のスレッドに移動します (@code{gnus-summary-next-thread})。

@item T p
@kindex T p （概略）
@findex gnus-summary-prev-thread
前のスレッドに移動します (@code{gnus-summary-prev-thread})。

@item T d
@kindex T d （概略）
@findex gnus-summary-down-thread
スレッドを降下します (@code{gnus-summary-down-thread})。

@item T u
@kindex T u （概略）
@findex gnus-summary-up-thread
スレッドを上昇します (@code{gnus-summary-up-thread})。

@item T o
@kindex T o （概略）
@findex gnus-summary-top-thread
スレッドの頂上に移動します (@code{gnus-summary-top-thread})。
@end table

@vindex gnus-thread-operation-ignore-subject
スレッドを作成するときに表題を無視すると、自然にスレッドにはいくつかの違っ
た表題があることになります。それから `T k'
(@code{gnus-summary-kill-thread}) のような命令を発するときに、全体のスレッ
ドを削除するのではなく、現在の記事と同じ表題を持つ部分だけを削除したいとき
があるかもしれません。もしこの発想が良いと思うのであれば、
@code{gnus-thread-operation-ignore-subject} をいじくることができます。これ
が @code{nil} でないと（これがディフォルトですが）、スレッドの命令を実行し
ているときに表題は無視されます。この変数が @code{fuzzy} であると、あいまい
に等しい表題を持つ記事だけが含まれます (@pxref{Fuzzy Matching})。


@node Sorting
@section 並び替え

@findex gnus-thread-sort-by-total-score
@findex gnus-thread-sort-by-date
@findex gnus-thread-sort-by-score
@findex gnus-thread-sort-by-subject
@findex gnus-thread-sort-by-author
@findex gnus-thread-sort-by-number
@vindex gnus-thread-sort-functions
もしスレッドの概略表示を使っているのであれば、関数のリストである
@code{gnus-thread-sort-functions} を設定することでスレッドを並び替えること
ができます。ディフォルトでは、並び替えは記事番号によってなされます。既に作
られている並び替え述語関数は @code{gnus-thread-sort-by-number},
@code{gnus-thread-sort-by-author}, @code{gnus-thread-sort-by-subject},
@code{gnus-thread-sort-by-date}, @code{gnus-thread-sort-by-score} と 
@code{gnus-thread-sort-by-total-score} です。


各関数は2つのスレッドをとり、最初のスレッドが他のスレッドより先に並び替え
られるべきであれば、@code{nil} でない値をかえします。普通、並び替えは本当
はそれぞれのスレッドの根本を見るだけによりなされることに気を付けてください。
もし2つ以上の関数を使う場合、優先的並び替えキーはリストの最後の関数です。
おそらくいつも @code{gnus-thread-sort-by-number} を並び替え関数のリスト――
最初が好ましい に入れておくべきでしょう。これは他の並び替え基準に関して等
しいスレッドは記事が上がっていく順番に表示されることを保証します。

スコア、表題、そして最後に番号、の順に並び替えたいのであれば、次のように
できます：

@lisp
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-number
        gnus-thread-sort-by-subject
        gnus-thread-sort-by-total-score))
@end lisp

最高スコアのスレッドが概略バッファの最初に表示されます。スレッドが同じス
コアの場合は、英字順に並びかえられます。スコアと表題が同じスレッドは番号
で並び替えられ、（普通は）記事が到着した順番になります。

スコア、到着の逆順に並び替えたいのであれば、次のようにできます：

@lisp
(setq gnus-thread-sort-functions
      '((lambda (t1 t2)
          (not (gnus-thread-sort-by-number t1 t2)))
        gnus-thread-sort-by-score))
@end lisp

@vindex gnus-thread-score-function
変数 @code{gnus-thread-score-function}（ディフォルトは @code{+}）に入って
いる関数はスレッドの総合のスコアを計算するために用いられます。役に立つ関数
は、@code{max}, @code{min}, もしくは2乗、もしくはあなたの好奇心をくすぐる
ような何かでしょう。

@findex gnus-article-sort-functions
@findex gnus-article-sort-by-date
@findex gnus-article-sort-by-score
@findex gnus-article-sort-by-subject
@findex gnus-article-sort-by-author
@findex gnus-article-sort-by-number
何か奇妙な理由などでスレッド表示を使っていないのなら、変数
@code{gnus-article-sort-functions} をいじくる必要があります。これは
@code{gnus-thread-sort-functions} と非常に似ていますが、記事の比較には少々
違った関数を使います。使用可能な並び替え述語関数は
@code{gnus-article-sort-by-number}, @code{gnus-article-sort-by-author},
@code{gnus-article-sort-by-subject}, @code{gnus-article-sort-by-date} およ
び @code{gnus-article-sort-by-score} です。

スレッドを使っていない表題の概略表示を並び替えたいのであれば、次のような
ことをすることができます：

@lisp
(setq gnus-article-sort-functions
      '(gnus-article-sort-by-number
        gnus-article-sort-by-subject))
@end lisp



@node Asynchronous Fetching
@section 非同期記事取得
@cindex asynchronous article fetching
@cindex article pre-fetch
@cindex pre-fetch

もしニュースを遠くの @sc{nntp} サーバーから取得しているのであれば、ネット
ワークの待ち時間が記事を読むことは骨の折れることにしてしまうかもしれません。
@kbd{n} を押して次の記事が現れるまで、しばらく待たなければなりません。どう
して前の記事を読んでいる間に gnus が先に行って記事を取得しないのでしょう？
本当に、そうした方が良いのではないのでしょうか。

まず、いくつかの警告です。非同期記事取得、特に gnus がそれを行っている方
法にはいくつかの落とし穴があります。

例えば、あなたは短い記事 1 を読んでいて、記事 2 はとても長くあなたはそれを
読むことには興味が無いとしましょう。Gnus はこのことはわからないので、先に
行って記事 2 を取得します。あなたは記事 3 を読むことにしますが、gnus は記
事 2 を取得している最中なので、接続は封鎖されています。

この状況を避けるために、gnus はサーバーに2つの（それは2と数えてください）
接続を張ることができます。これはあまりして良いことではないと考える人もいる
でしょうが、私には実際の代替手段が見つからないのです。余分な接続をするため
には何らかの時間がかかりますので、gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先-取得を使わないときよりも、あなたのマシンと @sc{nntp} サーバー間
にもっと負荷がかかるということになるでしょう。サーバー自身ももっと負荷が
かかるようになります――余分な記事の要求と、余分な接続で。

はい、これで本当はこのようなことをすべきで無い事が分かったでしょう... 本
当にそうしたいと思わない限りは。

@vindex gnus-asynchronous
これが方法です： @code{gnus-asynchronous} を @code{t} に設定してください。
残りのことは自動的に起こります。

@vindex gnus-use-article-prefetch
@code{gnus-use-article-prefetch} を設定することにより、どれくらいの記事が
先に取得されるべきかを操作することができます。これはディフォルトでは 30で、
グループの記事を読んでいるときに、バックエンドが次の 30 記事を先-取得する
ということです。この変数が @code{t} であると、バックエンドは制限無く取得で
きるすべての記事を先-取得しようとします。これが @code{nil} であると、先-取
得は行われません。

@vindex gnus-async-prefetch-article-p
@findex gnus-async-read-p
おそらく、先-取得をしたくない記事がいくつかあるでしょう――例えば、既読記
事。変数 @code{gnus-async-prefetch-article-p} は記事が先に取得されるべきか
どうかを制御します。この関数は問題の記事が先-取得されるべきであれば
@code{nil} でない値をかえすべきです。ディフォルトは
@code{gnus-async-read-p} で、それは既読記事には @code{nil} をかえします。
この関数は記事のデータ構造を唯一の引数として呼ばれます。

例えば、もし 100 行よりも短い未読記事のみを先に取得したいのであれば、次の
ようにできます：

@lisp
(defun my-async-short-unread-p (data)
  "Return non-nil for short, unread articles."
  (and (gnus-data-unread-p data)
       (< (mail-header-lines (gnus-data-header data))
          100)))

(setq gnus-async-prefetch-article-p 'my-async-short-unread-p)
@end lisp

これらの関数は何度も何度も呼ばれますので、gnus を遅くしすぎないように、
短く甘美であるのが好ましいです。おそらく、このようなものをバイトコンパイ
ル (byte-compile) するのは良い着想でしょう。

@vindex gnus-prefetched-article-deletion-strategy
記事は非同期バッファから遅かれ早かれ削除されなければなりません。
@code{gnus-prefetched-article-deletion-strategy} はいつ記事を削除するか
を指定しています。これは以下の要素を含むようなリストです：

@table @code
@item read
記事が読まれたときに削除します。

@item exit
グループを抜けたときに記事を削除します。
@end table

ディフォルトの値は @code{(read exit)} です。

@c @vindex gnus-use-header-prefetch
@c @code{gnus-use-header-prefetch} が @code{nil} でないと、次のグループから
@c 記事を先に取得します。


@node Article Caching
@section 記事のキャッシュ
@cindex article caching
@cindex caching

もし@emph{非常に}遅い @sc{nntp} 接続であるならば、記事キャッシュをすること
を考えるかもしれません。そうすると、それぞれの記事はあなたのホームディレク
トリの下にローカルに溜めらます。既に推測されているかも知れませんが、これは 
@emph{巨大な}ディスクスペースを食い、iノードも非常に速く食いつぶす可能性が
あるため、それはあなたの頭を泳がせる事になるかもしれません。ウォッカの中で。

でも注意深く使われれば、それは記事を保存する簡単な方法になり得ます。

@vindex gnus-use-long-file-name
@vindex gnus-cache-directory
@vindex gnus-use-cache
キャッシュを実行するためには、@code{gnus-use-cache} を @code{t} に設定し
ます。ディフォルトでは、すべての可視または保留として印の付いている記事は
ローカルのキャッシュに複写されます。このキャッシュが平らな構造か階層的で
あるかは、いつもどおり、変数 @code{gnus-use-long-file-name} で制御されま
す。

可視か保留記事を再選択した場合は、サーバーの代わりにキャッシュから取得さ
れます。キャッシュにある記事は期限切れ削除されませんので、記事が属してい
るところに残したままで記事を保存する方法として使う事ができるかもしれませ
ん。保存したい記事をすべて保留の印を付けて、後は心配は要りません。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょうか。

@vindex gnus-cache-remove-articles
@vindex gnus-cache-enter-articles
キャッシュ へ入る/から削除される は変数 @code{gnus-cache-enter-articles}と 
@code{gnus-cache-remove-articles} によって制御されます。これらは両方ともシ
ンボルのリストです。前者はディフォルトでは @code{(ticked dormant)} で、可
視と保留記事はキャッシュに入れられるという事です。後者はディフォルトでは 
@code{(read)} で、既読の印が付いた記事はキャッシュから削除されるという事で
す。おそらくこれらの2つのリストは @code{ticked}, @code{dormant},
@code{unread} および @code{read} からなるでしょう。

@findex gnus-jog-cache
それで、どうやって大量の記事取得と貯蓄実現されるのでしょうか。命令
@code{gnus-jog-cache} は全ての購読グループに対して、すべての未読記事を要求
し、スコアを付け、キャッシュに保存します。この命令を実際に、実際に実際に実
際に、使うのは、 1) @sc{nntp} サーバーとの接続が本当に、本当に、本当に遅く 
2) 本当に、本当に、本当に巨大なディスクを持っているときだけにするべきです。
これは真面目にいっています。ダウンロードされる記事の数を少なくする一つの方
法は、欲しくない記事のスコアを低くし、既読の印を付ける事です。そうした場合、
それらはこの命令ではダウンロードされません。

@vindex gnus-uncacheable-groups
@vindex gnus-cacheable-groups
いくつかのグループではキャッシュをしたくないというのは良くある事です。例え
ば、@code{nnml} メールディレクトリーがホームディレクトリーの下にあれば、そ
れをあなたのホームディレクトリーの下の別の場所にキャッシュするのは意味の無
い事です。あなたが2倍の容量を使う事が良いと感じない限りは。

キャッシュを制限するために、@code{gnus-cacheable-groups} を をキャッシュ
するグループの連想リスト、例えば @samp{^nntp}、とするか、正規表現 
@code{gnus-uncacheable-groups} を例えば、@samp{^nnml} に設定して下さい。
両方の変数の初期値は @code{nil} です。もしグループが両方の正規表現に合致
すると、そのグループはキャッシュされません。

@findex gnus-cache-generate-nov-databases
@findex gnus-cache-generate-active
@vindex gnus-cache-active-file
キャッシュはどの記事が含まれているかの情報をアクティブファイル 
(@code{gnus-cache-active-file}) に溜めます。このファイル（もしくはキャッ
シュの他の部分）が何らかの理由でぐちゃぐちゃになってしまった場合、gnus 
は物事を正しくするために2つの関数をお勧めします。@kbd{M-x
gnus-cache-generate-nov-databases} はすべての @sc{nov} ファイルを（再）
作成し、@kbd{gnus-cache-generate-active} はアクティブファイルを（再）作
成します。


@node Persistent Articles
@section 永続記事
@cindex persistent articles
記事のキャッシュと近い関係にあるもに、@dfn{永続記事}があります。実際、それ
はキャッシュの別の見方で、私の意見ではその方がもっと役に立ちます。

例えば、ニュースグループを読んでいて、そのまま永遠に保存して秘蔵したい、い
くつかの価値ある宝石に出会ったとしましょう。普通はそれをファイルに保存しま
す（多くの保存命令の一つを使って）。それの問題は、単にあの、嫌なだけです。
理想的には、記事はグループであなたが見つけた場所に永遠に残っているべきでしょ
う。ニュースサーバーにおける期限削除には影響されないで。

これが@dfn{永続記事}です――記事は削除されません。それは普通のキャッシュ命
令を使って実装されていますが、永続記事の管理をするために2つの明示的な命令
を使います：

@table @kbd

@item *
@kindex * （概略）
@findex gnus-cache-enter-article
現在の記事を永続にします (@code{gnus-cache-enter-article})。

@item M-*
@kindex M-* （概略）
@findex gnus-cache-remove-article
現在の記事を永続記事から取り除きます (@code{gnus-cache-remove-articles})。
これは普通は記事を削除します。
@end table

この命令は両方ともプロセス/接頭引数の習慣を理解します。

もし永続記事にだけ興味があるのでしたら、可視記事（やその他のもの）がキャッ
シュに入るのを避けるために、@code{gnus-use-cache} を @code{passive} に設定
するのが良いでしょう：

@lisp
(setq gnus-use-cache 'passive)
@end lisp


@node Article Backlog
@section 記事のバックログ
@cindex backlog
@cindex article backlog
もし遅い接続しかない場合で、キャッシュを使うという発想はあまり魅力的ではな
いとき（実際そうなのですが）、@dfn{バックログ}に切り替える事によって状況を
何とかすることができます。これは既に読んだ記事を再取得しなくて良いように、
gnus が既に読んだ記事を一時保存しておくところです。これはもちろん、あなた
に最近読んだ記事を再び選択する癖があるときだけに役立ちます。もし絶対にそれ
をしないのであれば、バックログをすることは gnus を少し遅くし、メモリーの使
用量をいくらか増やします。

@vindex gnus-keep-backlog
もし @code{gnus-keep-backlog} を数字 @var{n} に設定すると、gnus は最大で 
@var{n} の古い記事を後の再取得のためにバッファに溜めておきます。この変数が 
@code{nil} ではなく、数字でもない場合、gnus は@emph{全て}の既読記事をたく
わえます。これはあなたの Emacs が、暴発してあなたのマシンが落ちるまで制限
なく膨れ上がるということです。私はあなた方全てが元気でいられるようにここに
書き加えました。

この変数はディフォルトでは @code{nil} です。


@node Saving Articles
@section 記事の保存
@cindex saving articles

Gnus はたくさんの方法で記事を保存する事ができます。以下のものは非常に率直
な方法（例えば、記事が保存する前にほとんど何もなされない）で記事を保存する
ための説明です。違った手段（uudecodeする、shar ファイルを展開する）につい
ては@code{gnus-uu} を使うのが良いでしょう (@pxref{Decoding Articles})。

@vindex gnus-save-all-headers
@code{gnus-save-all-headers} が @code{nil} でないと、gnus は記事を保存す
る前に望ましくないヘッダーを消去しません。

@vindex gnus-saved-headers
もし上の変数が @code{nil} であると、正規表現 @code{gnus-saved-headers}
に合致するすべてのヘッダーは残され、残りのものは保存する前に削除されます。

@table @kbd

@item O o
@itemx o
@kindex O o （概略）
@kindex o （概略）
@findex gnus-summary-save-article
@c @icon{gnus-summary-save-article}
ディフォルトの記事保存を用いて現在の記事を保存します
(@code{gnus-summary-save-article})。

@item O m
@kindex O m （概略）
@findex gnus-summary-save-article-mail
現在の記事をメールの様式で保存します
(@code{gnus-summary-save-article-mail})。

@item O r
@kindex O r （概略）
@findex gnus-summary-save-article-rmail
現在の記事を rmail の様式で保存します
(@code{gnus-summary-save-article-rmail})。

@item O f
@kindex O f （概略）
@findex gnus-summary-save-article-file
@c @icon{gnus-summary-save-article-file}
現在の記事を普通のファイル (plain file) 様式で保存します
(@code{gnus-summary-save-article-file})。

@item O F
@kindex O F （概略）
@findex gnus-summary-write-article-file
現在の記事を普通のファイル様式で保存し、以前のファイルの内容を上書きしま
す (@code{gnus-summary-write-article-file})。

@item O b
@kindex O b （概略）
@findex gnus-summary-save-article-body-file
現在の記事の本文 (body) を普通のファイル様式で保存します
(@code{gnus-summary-save-article-body-file})。

@item O h
@kindex O h （概略）
@findex gnus-summary-save-article-folder
現在の記事を mh のフォルダーの様式で保存します
(@code{gnus-summary-save-article-folder})。

@item O v
@kindex O v （概略）
@findex gnus-summary-save-article-vm
現在の記事を VM フォルダーに保存します
(@code{gnus-summary-save-article-vm})。

@item O p
@kindex O p （概略）
@findex gnus-summary-pipe-output
現在の記事をパイプに保存します。うーんと、あのぉ、私が言おうとしている事は――
現在の記事をプロセスにパイプするということです
(@code{gnus-summary-pipe-output})。
@end table

@vindex gnus-prompt-before-saving
すべてのこれらの命令はプロセス/接頭引数の習慣を使います
(@pxref{Process/Prefix})。もしこれらの関数を使ってたくさんの記事を保存し
た場合、それぞれのすべての記事に対してファイル名の入力を要求される事に飽
き飽きするでしょう。入力促進動作は変数 @code{gnus-prompt-before-saving} 
によって制御されます。これはディフォルトでは @code{always} で、あなたが
知っていて嫌がっている、過剰な促進動作をします。代わりにこの変数を
@code{t} に設定すると、あなたが保存するそれぞれの一連の記事に対して一回
だけ促されます。本当に gnus にすべての思考をさせたいのであれば、この変数
を@code{nil} にすることさえできます。そして、記事を保存するためのファイ
ルを促される事はありません。Gnus は単純にすべての記事をディフォルトのファ
イルに保存します。


@vindex gnus-default-article-saver
Gnus があなたの望むとおりになるように、変数 
@code{gnus-default-article-saver} をカスタマイズする事ができます。下の４つ
の既製関数を使う事ができますし、自分自身の関数を作る事もできます。

@table @code

@item gnus-summary-save-in-rmail
@findex gnus-summary-save-in-rmail
@vindex gnus-rmail-save-name
@findex gnus-plain-save-name
これはディフォルトの様式、@dfn{babyl} です。変数
@code{gnus-ramil-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルトは 
@code{gnus-plain-save-name} です。


@item gnus-summary-save-in-mail
@findex gnus-summary-save-in-mail
@vindex gnus-mail-save-name
Unix メール (mbox) ファイルに保存します。変数 @code{gnus-mail-save-name}
に入っている関数を、記事を保存するためのファイル名を取得するために使用し
ます。ディフォルトは @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-file
@findex gnus-summary-save-in-file
@vindex gnus-file-save-name
@findex gnus-numeric-save-name
記事を通常のファイルの後に追加します。変数 @code{gnus-file-save-name} に
入っている関数を、記事を保存するためのファイル名を取得するために使用しま
す。ディフォルトは @code{gnus-numeric-save-name} です。

@item gnus-summary-save-body-in-file
@findex gnus-summary-save-body-in-file
記事の本体を通常のファイルの後に追加します。変数
@code{gnus-file-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルトは 
@code{gnus-numeric-save-name} です。


@item gnus-summary-save-in-folder
@findex gnus-summary-save-in-folder
@findex gnus-folder-save-name
@findex gnus-Folder-save-name
@vindex gnus-folder-save-name
@cindex rcvstore
@cindex MH folders
MH ライブラリーの @code{rcvstore} を用いる事によって記事を MH フォルダー
に保存します。変数 @code{gnus-folder-save-name} に入っている関数を、記事
を保存するファイル名を取得するために使用します。ディフォルトは
@code{gnus-folder-save-name} ですが、@code{gnus-Folder-save-name} も使う
事ができて、こちらは先頭が大文字、残りが小文字になった名前をつくります。

@item gnus-summary-save-in-vm
@findex gnus-summary-save-in-vm
記事を VM フォルダーに保存します。この設定を使うためには VM メールリーダー
が必要です。
@end table

@vindex gnus-article-save-directory
これらの全ての関数は最後の一つを除いて、環境変数 @code{SAVEDIR} によって
初期化される @code{gnus-article-save-directory} に記事を保存します。これ
はディフォルトでは @file{~/News/} です。

上にあるように、記事を保存するためのファイルの適切な名前を見つけるために、
関数は違った関数を用います。以下は名前を生成するために使用可能な関数のリス
トです：

@table @code

@item gnus-Numeric-save-name
@findex gnus-Numeric-save-name
@file{~/News/Alt.andera-dworkin/45} のようなファイル名。

@item gnus-numeric-save-name
@findex gnus-numeric-save-name
@file{~/News/alt.andera-dworkin/45} のようなファイル名。

@item gnus-Plain-save-name
@findex gnus-Plain-save-name
@file{~/News/Alt.andera-dworkin} のようなファイル名。

@item gnus-plain-save-name
@findex gnus-plain-save-name
@file{~/News/alt.andera-dworkin} のようなファイル名。
@end table

@vindex gnus-split-methods
連想リスト @code{gnus-split-methods} に正規表現を放り込む事によって、
gnus に記事を保存する場所を提案する事ができます。例えば、gnus に関連した記
事をファイル @file{gnus-stuff} に、VM に関連した記事を @code{vm-stuff} 保
存したければ、この変数を以下のようにする事ができます：

@lisp
(("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
 ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
 (my-choosing-function "../other-dir/my-stuff")
 ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))
@end lisp

これはそれぞれの要素が、2つの要素――@dfn{合致} と @dfn{ファイル} を持つ
リストであるリストであるという事がわかります。合致は文字列（この場合は記事
のヘッダーに合致する正規表現として使われます）および、シンボル（グループ名
を引数として、関数として呼ばれます）および、リスト（これは評価 
(@code{eval}) されます）であることができます。もしこれらの動作の一つでも 
@code{nil} でない結果を返すと、@dfn{ファイル}がディフォルトの促進として使
われます。加えて、呼ばれた関数か式が文字列か文字列のリストを返したときは、
演算の結果自体が使われます。

基本的には、現在の記事を保存するのに使われる可能性のあるファイル名のリスト
を手に入れる事になります。（すべての『合致』が使われます。）それから本当に
名前として使いたいものを促され、この変数を適用する事により得られた結果から
ファイル名補完をして入力します。

この変数はディフォルトでは @code{((gnus-article-archive-name))} で、gnus
保存する記事の @code{Archive-name} 行を調べて、それをファイル名の提案と
して使うという事です。

これはファイル名を少しきれいにする関数の例です。
@samp{nnml:mail.whatever} のようなメールグループがたくさんあるのであれば、
保存するためのファイル名を作る前にこれらのグループ名の最初を切り落とした
いかもしれません。次の物はちょうどそれをします：

@lisp
(defun my-save-name (group)
  (when (string-match "^nnml:mail." group)
    (substring group (match-end 0))))

(setq gnus-split-methods
      '((gnus-article-archive-name)
        (my-save-name)))
@end lisp


@vindex gnus-use-long-file-name
最後に @code{gnus-use-long-file-name} という変数があります。これが
@code{nil} であると、すべての上記の関数はグループ名のすべてのピリオド
(@samp{.}) をスラッシュ (@samp{/}) で置き換えます――これは関数はすべての
ファイルを一番上のディレクトリーに置くのではなく、階層的なディレクトリーを
作るという事です（@file{~/News/alt.andrea-dworkin} の代わりに
@file{~/News/alt/andrea-dworkin}。）この変数はたいていのシステムにおいてディ
フォルトで @code{t} です。しかし、歴史的な理由から Xenix と usg-unix-v マ
シンではディフォルトで @code{nil} です。

この関数は削除とスコアのファイル名に影響します。この変数がリストで、リス
トに要素 @code{not-score} があると、長いファイル名はスコアファイルには使
われず、リストに要素 @code{not-save} があると、長いファイル名は保存には
使われず、要素 @code{not-kill} があると、長いファイル名は削除ファイルに
は使われません。

もし記事をスプールのような階層に保存したいのであれば、次のようにできます

@lisp
(setq gnus-use-long-file-name '(not-save)) ; to get a hierarchy
(setq gnus-default-article-saver 'gnus-summary-save-in-file) ; no encoding
@end lisp

それから @kbd{o} によって記事を保存するだけです。それからこの階層を短命な 
@code{nneething} グループによって読む事ができます――グループバッファで 
@kbd{G D} とし、一番上のディレクトリーを引数 (@file{~/News/}) として渡しま
す。


@node Decoding Articles
@section 記事の復号化
@cindex decoding articles

ときどき利用者は何らかの方法で符号化された記事（もしくは記事群）を投稿し
ます。Gnus はあなたのためにそれらを復号化する事ができます。

@menu
* Uuencoded Articles::    記事を uuencode する。
* Shell Archives::        shar 記事を解凍する。
* PostScript Files::      ポストスクリプトを分割する。
* Other Files::           普通の保存と binhex.
* Decoding Variables::    幸せな復号化のための変数。
* Viewing Files::         復号化の結果を見たい？
@end menu

@cindex series
@cindex article series
これらすべての関数はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) を、 
『一つの記事』を『一つの群』と解釈する拡張をして、どの記事に操作をするかを
見つけるために使います。Gnus は自分自身でどの記事がその群に属しているかを
判断し、すべての記事を復号化して、その結果のファイルを 展開/閲覧/保存 する
ことができます。

Gnus は以下の簡単な規則に則ってどの記事が群に属するのかを推測します： 表題
は行の最後の2つの数字を除いて（ほとんど）同じである必要があります。（空白
は大体無視されますが。）

例えば： @samp{cat.gif (2/3)} というような表題を選ぶと、gnus は正規表現
@samp{^cat.gif ([0-9]+/[0-9]+).*$} に合致するすべての記事を見つけようとし
ます。

@samp{cat.gif (2/3) Part 6 of a series} のような標準でない表題はどの自動
閲覧命令によっても適切に認識されないため、手で記事に @kbd{#} の印を付け
なければなりません。


@node Uuencoded Articles
@subsection uuencode された記事
@cindex uudecode
@cindex uuencoded articles

@table @kbd

@item X u
@kindex X u （概略）
@findex gnus-uu-decode-uu
@c @icon{gnus-uu-decode-uu}
現在の群を uudecode します (@code{gnus-uu-decode-uu})。

@item X U
@kindex X U （概略）
@findex gnus-uu-decode-uu-and-save
現在の群を uudecode して保存します (@code{gnus-uu-decode-uu-and-save})。

@item X v u
@kindex X v u （概略）
@findex gnus-uu-decode-uu-view
現在の群を uudecode して、表示します (@code{gnus-uu-decode-uu-view})。

@item X v U
@kindex X v U （概略）
@findex gnus-uu-decode-uu-and-save-view
現在の記事を uudecode して、表示して保存します
(@code{gnus-uu-decode-uu-and-save-view})。

@end table

これらすべてはプロセス印によって印付けられた記事の存在に対して反応すると
いうことを覚えておいてください。例えば、もしニュースグループ全体を復号化
して保存したいのであれば、普通は @kbd{M P a} (@code{gnus-uu-mark-all})
とし、それから @kbd{X U} (@code{gnus-uu-decode-uu-and-save}) とします。

この全ては、白日の下に明白にキーを打っていた @sc{GNUS 4.1} のときとは
@code{gnus-uu} の動作が全く違っています。この版の @code{gnus-uu} は普通
は何かの方法 (@pxref{Setting Process Marks}) で記事に印を付けて、それか
ら @kbd{X u} を押す事を前提としています。

@vindex gnus-uu-notify-files
注意： @code{gnus-uu-notify-files} に合致する名前、
@samp{[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)} にハードコードされる、を
持つ記事を復号化しようとしたときは、@code{gnus-uu} は問題の記事をちょうど
閲覧した事を知らせるために、自動的に @samp{comp.unix.wizards} に記事を投稿
します。この機能を使わないようにする事はできません。


@node Shell Archives
@subsection シェルアーカイブ
@cindex unshar
@cindex shell archives
@cindex shared articles

シェルアーカイブ（『shar ファイル』）はソースを配布するための人気のある方
法でしたが、今日ではそんなに使われていません。とにかくこれらを扱うための命
令があります：

@table @kbd

@item X s
@kindex X s （概略）
@findex gnus-uu-decode-unshar
現在の群を解凍します (@code{gnus-uu-decode-unshar})。

@item X S
@kindex X S （概略）
@findex gnus-uu-decode-unshar-and-save
現在の群を解凍し保存します (@code{gnus-uu-decode-unshar-and-save})。

@item X v s
@kindex X v s （概略）
@findex gnus-uu-decode-unshar-view
現在の群を解凍し表示します (@code{gnus-uu-decode-unshar-view})。

@item X v S
@kindex X v S （概略）
@findex gnus-uu-decode-unshar-and-save-view
現在の群を解凍し、表示して保存します
(@code{gnus-uu-decode-unshar-and-save-view})。
@end table


@node PostScript Files
@subsection ポストスクリプトファイル
@cindex PostScript

@table @kbd

@item X p
@kindex X p （概略）
@findex gnus-uu-decode-postscript
現在のポストスクリプト群を展開します (@code{gnus-uu-decode-postscript})。

@item X P
@kindex X P （概略）
@findex gnus-uu-decode-postscript-and-save
現在のポストスクリプト群を展開して保存します
(@code{gnus-uu-decode-postscript-and-save})。

@item X v p
@kindex X v p （概略）
@findex gnus-uu-decode-postscript-view
現在のポストスクリプト群を表示します
(@code{gnus-uu-decode-postscript-view})。

@item X v P
@kindex X v P （概略）
@findex gnus-uu-decode-ostscript-and-save-view
現在のポストスクリプト群を表示し保存します
(@code{gnus-uu-decode-postscript-and-save-view})。
@end table


@node Other Files
@subsection 他のファイル

@table @kbd
@item X o
@kindex X o （概略）
@findex gnus-uu-decode-save
現在の群を保存します (@code{gnus-uu-decode-save})。

@item X b
@kindex X b （概略）
@findex gnus-uu-decode-binhex
現在の記事を binhex 解凍します (@code{gnus-uu-decode-binhex})。これは本
当は動作しません。
@end table


@node Decoding Variables
@subsection 復号化のための変数

形容詞です。動詞ではありません。

@menu
* Rule Variables::          ファイルがどのように表示されるかを決める変数。
* Other Decode Variables::  他の復号化の変数。
* Uuencoding and Posting::  uuencode するのをカスタマイズする変数。
@end menu


@node Rule Variables
@subsubsection 規則変数
@cindex rule variables

Gnus はファイルを閲覧するのを決定するのに@dfn{規則変数}を用います。これら
の変数はすべて以下のような様式です

@lisp
      (list '(regexp1 command2)
            '(regexp2 command2)
            ...)
@end lisp

@table @code

@item gnus-uu-user-view-rules
@vindex gnus-uu-user-view-rules
@cindex sox
この変数はファイルを閲覧するときに最初に調べられます。例えば、もし
@samp{.au} 音ファイルを変換するために @code{sox} を使いたいときは、次の
ようにできます：
@lisp
(setq gnus-uu-user-view-rules
      (list '(\"\\\\.au$\" \"sox %s -t .aiff > /dev/audio\")))
@end lisp

@item gnus-uu-user-view-rules-end
@vindex gnus-uu-user-view-rules-end
この変数は gnus が利用者とディフォルトの閲覧規則から合致するものを見つけ
られなかったときに調べられます。

@item gnus-uu-user-archive-rules
@vindex gnus-uu-user-archive-rules
この変数はアーカイブを展開するときにどの命令が使われるべきかを決めるため
に使う事ができます。
@end table


@node Other Decode Variables
@subsubsection 他の復号化の変数

@table @code
@vindex gnus-uu-grabbed-file-functions

@item gnus-uu-grabbed-file-functions
このリストのすべての関数はそれぞれのファイルが上手く復号化された直後に呼ば
れます――ですから、すぐにファイルを移動や閲覧したりすることができ、何かを
する前にすべてのファイルが復号化されるのを待つ必要はありません。このリスト
に入れる事のできる既製関数は：

@table @code

@item gnus-uu-grab-view
@findex gnus-uu-grab-view
ファイルを閲覧します。

@item gnus-uu-grab-move
@findex gnus-uu-grab-move
ファイルを移動します（もし保存関数を使っているのであれば）。
@end table

@item gnus-uu-be-dangerous
@vindex gnus-uu-be-dangerous
復号化の最中に変な状況が起こったときに何をするかを指定します。もし
@code{nil} であると、できるだけ保守的になります。もし @code{t} であると、
動作しないものは無視して、現存するファイルを上書きします。その他の場合は、
それぞれのときに尋ねます。

@item gnus-uu-ignore-files-by-name
@vindex gnus-uu-ignore-files-by-name
この正規表現に合致する名前のファイルは閲覧されません。

@item gnus-uu-ignore-files-by-type
@vindex gnus-uu-ignore-files-by-type
この変数に合致する @sc{mime} の型を持つファイルは閲覧されません。Gnus はファ
イル名に基づいて型を推測している事に注意してください。@code{gnus-uu} は
（まだ）@sc{mime} パッケージではありませんので、これは少し変です。

@item gnus-uu-tmp-dir
@vindex gnus-uu-tmp-dir
@code{gnus-uu} がその仕事をする場所です。

@item gnus-uu-do-not-unpack-archives
@vindex gnus-uu-do-not-unpack-archives
@code{nil} でないのは、@code{gnus-uu} は表示するためのファイルを探すため
にアーカイブの中までは入っていかないという事です。

@item gnus-uu-view-and-save
@vindex gnus-uu-view-and-save
@code{nil} でないのは、利用者はファイルを閲覧した後に常に保存するかどう
かを尋ねられるという事です。

@item gnus-uu-ignore-default-view-rules
@vindex gnus-uu-ignore-default-view-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトの閲覧規則を無視する
という事です。

@item gnus-uu-ignore-default-archive-rules
@vindex gnus-uu-ignore-default-archive-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトのアーカイブ展開命令
を無視するという事です。

@item gnus-uu-kill-carriage-return
@vindex gnus-uu-kill-carriage-return
@code{nil} でないのは、@code{gnus-uu} は記事からすべてのキャリッジリター
ン (carriage return) を取り去るという事です。

@item gnus-uu-unmark-articles-not-decoded
@vindex gnus-uu-unmark-articles-not-decoded
@code{nil} でないのは、@code{gnus-uu} は復号化に失敗した記事に未読の印を
付けるという事です。

@item gnus-uu-correct-stripped-uucode
@vindex gnus-uu-correct-stripped-uucode
@code{nil} でないというのは、@code{gnus-uu} は続く空白が削除されてしまって
いる uuencode されたファイルを修復しようと@emph{試す}という事です。

@item gnus-uu-pre-uudecode-hook
@vindex gnus-uu-pre-uudecode-hook
@code{uudecode} にメッセージを送る前に実行されるフックです。

@item gnus-uu-view-with-metamail
@vindex gnus-uu-view-with-metamail
@cindex metamail
@code{nil} でないのは、@code{gnus-uu} は規則変数で定義された閲覧命令を無
視して、ファイル名に基づいた @sc{mime} 内容の型に取り替えるという事です。
その結果は閲覧のために @code{metamail} にかけられます。

@item gnus-uu-save-in-digest
@vindex gnus-uu-save-in-digest
@code{nil} でないのは、@code{gnus-uu} が復号化をしないで保存をするように
言われたときに、要約を保存するという事です。この変数が @code{nil} である
と、@code{gnus-uu} は 何も飾りをしないで全てをファイルに保存します。要約
は RFC1153 準じています――意味のある量を指定して、番号を発行する簡単な方
法が見つからなかったので、単純にそれらは切り落としています。

@end table


@node Uuencoding and Posting
@subsubsection uuencode と投稿

@table @code

@item gnus-uu-post-include-before-composing
@vindex gnus-uu-post-include-before-composing
@code{nil} でないのは、@code{gnus-uu} が記事を作成する前に符号化するファ
イルを尋ねるという事です。この変数が @code{t} であると、@kbd{C-c C-i} に
よって符号化されたファイルを取り込むか、記事を投稿するときに取り込むか、
どちらかをする事ができます。

@item gnus-uu-post-length
@vindex gnus-uu-post-length
記事の最大の長さです。符号化されたファイルは全体のファイルを投稿するのに
必要な量のファイルに分割されます。

@item gnus-uu-post-threaded
@vindex gnus-uu-post-threaded
@code{nil} でないのは、@code{gnus-uu} が符号化されたファイルをスレッドで投
稿するという事です。これはあまり賢い方法ではないかも知れません。というのは、
今まで私が見た中で uuencode された記事を集めるのに、スレッドを追っていく事
のできる他の復号装置が存在しないからです。（えーと、私はそれをする一つのパッ
ケージを見た事があります――@code{gnus-uu} です。しかしなぜか、それが数の
うちに入るとは思えないのです...）ディフォルトは @code{nil} です。

@item gnus-uu-post-separate-description
@vindex gnus-uu-post-separate-description
@code{nil} でないのは、記述は別の記事で投稿されるという事です。最初の記
事は普通は (0/x) のように番号が付けられます。もしこの変数が @code{nil}
であると、利用者の書いた記述は最初のファイルの始めに取り込まれ、(1/x) の
番号が付けられます。ディフォルトは @code{t} です。

@end table


@node Viewing Files
@subsection ファイルの閲覧
@cindex viewing files
@cindex pseudo-articles

復号化した後でファイルが何らかのアーカイブである場合、gnus はアーカイブを
展開しようと試み、アーカイブの中に閲覧できるファイルがあるかを調べます。例
えば、gzip された tar ファイル @file{pics.tar.gz} があって、ファイル 
@file{pic1.jpg} と @file{pic2.gif} を含んでいる場合、gnus は主ファイルを解
凍して tar を展開し、それから2つの絵を閲覧します。この展開の過程は再帰的
なので、アーカイブにアーカイブのアーカイブがあると、それはすべて展開されま
す。

最後に、gnus は普通はそれぞれの抽出された記事ごとに@dfn{疑似記事}を概略バッ
ファに挿入します。これらの『記事』に移動した場合は、実行する命令（普通は 
gnus が提案をします）を入力するように促され、それから命令が実行されます。

@vindex gnus-view-pseudo-asynchronously
@code{gnus-view-pseudo-asynchronously} が @code{nil} であると、Emacs は
先へ進む前に閲覧が終わるまで待ちます。

@vindex gnus-view-pseudos
@code{gnus-view-pseudos} が @code{automatic} であると、gnus は概略バッファ
に疑似記事を挿入しませんが、それらをすぐに閲覧します。この変数が
@code{not-confirm} であると、利用者は閲覧が済む前に確認さえも求められま
せん。

@vindex gnus-view-pseudos-separately
@code{gnus-view-pseudos-separately} が @code{nil} でないと、一つの疑似記
事が閲覧されるそれぞれのファイルに対して作成されます。@code{nil} である
と、同じ閲覧命令を使うすべての命令がその命令の引数のリストとして渡されま
す。

@vindex gnus-insert-pseudo-articles
@code{gnus-insert-pseudo-articles} が @code{nil} でないと、復号化のとき
に疑似記事を挿入します。ディフォルトでは @code{t}です。

それで、そのような感じです。@emph{実質サーバー}からの@emph{実質グループ}の
@emph{疑似記事} 読んでいます。そして考えます： どうして全てが現実ではなく
なってしまったのだろうか？どうしてここに来てしまったのだろうか？


@node Article Treatment
@section 記事の扱い

この巨大な説明文書を読んできて、人々が書いた事を読む、といったようなニュー
ズリーダーの本当の目的を完全に忘れてしまったかも知れません。記事を読む事
です。残念な事に、人々は書く事は非常に苦手としていますので、記事を読みや
すくするための関数と変数が山のようにあります。

@menu
* Article Highlighting::    記事を果物サラダのように見えるようにしたい。
* Article Fontisizing::     強調された文を素敵にする。
* Article Hiding::          特定の情報は消し去りたいとも思う。
* Article Washing::         人生をもっとよくするたくさんの気の利いた関数。
* Article Buttons::         URL や Message-ID や アドレスなどをクリックする。
* Article Date::            ぐずぐず言うな、世界時だ！
* Article Signature::       署名って何？
@end menu


@node Article Highlighting
@subsection 記事のハイライト
@cindex highlighting

記事バッファを果物サラダのようにしたいだけでなく、華やかな果物サラダのよ
うに見えるようにしたいでしょう。

@table @kbd

@item W H a
@kindex W H a （概略）
@findex gnus-article-highlight
@findex gnus-article-maybe-highlight
現在の記事をもっとハイライト (highlight) します。この関数は、ヘッダー、
引用文、署名をハイライトし、本体 (body) と頭 (head) にボタンを加えます。

たいていの利用者は代わりに @code{gnus-article-highlight} を 
@code{gnus-article-display-hook} (@pxref{Customizing Articles}) で使うほ
うを好むでしょう。これは少しだけ積極性が減少します---それはヘッダーと署
名だけをハイライトし、ボタンを加えます。

@item W H h
@kindex W H h （概略）
@findex gnus-article-highlight-headers
@vindex gnus-header-face-alist
ヘッダーをハイライトします (@code{gnus-article-highlight-headers})。ハイ
ライトは変数 @code{gnus-header-face-alist} にしたがってなされ、それはそ
れぞれの要素が @var{(正規表現 名前 内容)} という様式のリストです。 
@var{正規表現}はヘッダーに合致する正規表現、@var{名前}はヘッダーの名前を
ハイライトするのに使われるフェイス (face) (@pxref{Faces and Fonts})、
@var{内容}はヘッダーの値をハイライトするフェイスです。最初に合致したもの
が使われます。@var{正規表現}は @samp{^} が付けられるべきではない事に注意
してください――gnus がそれを付け加えます。

@item W H c
@kindex W H c （概略）
@findex gnus-article-highlight-citation
引用された文をハイライトします (@code{gnus-article-highlight-citation})。

引用ハイライトをカスタマイズするいくつかの変数は：

@table @code
@vindex gnus-cite-parse-max-size

@item gnus-cite-parse-max-size
記事の大きさがこの変数（ディフォルトでは 25000）より大きい記事は、引用ハイ
ライトは行われません。

@item gnus-cite-prefix-regexp
@vindex gnus-cite-prefix-regexp
ある行が取り得る最大の引用接頭語に合致する正規表現です。

@item gnus-cite-max-prefix
@vindex gnus-cite-max-prefix
引用接頭語の最大の長さです（ディフォルトでは 20 です）。

@item gnus-cite-face-list
@vindex gnus-cite-face-list
引用をハイライトするために使われるフェイスのリストです (@pxref{Faces and
Fonts})。同じメッセージの中に複数の記事からの引用があると、gnus はそれぞ
れの記事からの引用をそれ用のフェイスで表示しようとします。これにより、誰
が何を書いたかが分かりやすくなるでしょう。

@item gnus-supercite-regexp
@vindex gnus-supercite-regexp
普通の Supercite 属性行に合致する正規表現です。

@item gnus-supercite-secondary-regexp
@vindex gnus-supercite-secondary-regexp
引き裂かれた Supercite 属性行に合致する正規表現です。

@item gnus-cite-minimum-match-count
@vindex gnus-cite-minimum-match-count
それが引用であると決定する前に調べなければならない最小の同一接頭語です。

@item gnus-cite-attribution-prefix
@vindex gnus-cite-attribution-prefix
属性行の始まりに合致する正規表現です。

@item gnus-cite-attribution-suffix
@vindex gnus-cite-attribution-suffix
属性行の最後に合致する正規表現です。

@item gnus-cite-attribution-face
@vindex gnus-cite-attribution-face
属性行に使われるフェイスです。その属性に属する文のためのフェイスと融合さ
れます。

@end table


@item W H s
@kindex W H s （概略）
@vindex gnus-signature-separator
@vindex gnus-signature-face
@findex gnus-article-highlight-signature
署名 (signature) をハイライトします
(@code{gnus-article-highlight-signature})。
@code{gnus-signature-separator} (@pxref{Article Signature}) の後の全ての
ものは署名と考えられ、@code{gnus-signature-face} でハイライトされます。
それはディフォルトでは @code{italic} です。記事を自動的にハイライトする
方法については @xref{Customizing Articles} を参照して下さい。
@end table


@node Article Fontisizing
@subsection 記事のフォント変更
@cindex emphasis
@cindex article emphasis

@cindex gnus-article-emphasize
@kindex W e （概略）
人々はよくニュースの記事で @samp{_これ_} や @samp{*これ*} のようなものを
使って単語を強調します。Gnus は 記事を命令 @kbd{W e}
(@code{gnus-article-emphasize}) にかける事によって素敵に見えるようにでき
ます。

@vindex gnus-emphasis-alist
強調がどのように演算されるかは変数 @code{gnus-emphasis-alist} によって制
御されます。これは最初の要素が合致するべき正規表現である連想リストです。
2番目の要素はどの正規表現のグループが強調語全体を見つけるために使われる
かを示す数字です。３番目はどの正規表現のグループが表示されハイライトされ
るかを決める数字です。（この2つのグループの間の記事は隠されます。）４番
目はハイライトのフェイスです。

@lisp
(setq gnus-emphasis-alist
      '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
        ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))
@end lisp

@vindex gnus-emphasis-underline
@vindex gnus-emphasis-bold
@vindex gnus-emphasis-italic
@vindex gnus-emphasis-underline-bold
@vindex gnus-emphasis-underline-italic
@vindex gnus-emphasis-bold-italic
@vindex gnus-emphasis-underline-bold-italic
初期設定では７つの規則があり、それらは以下のフェイスを用います：
@code{gnus-emphasis-bold}, @code{gnus-emphasis-italic},
@code{gnus-emphasis-underline}, @code{gnus-emphasis-bold-italic},
@code{gnus-emphasis-underline-italic},
@code{gnus-emphasis-underline-bold},
@code{gnus-emphasis-underline-bold-italic}.

これらのフェイスを変更したいのであれば、@kbd{M-x customize} か
@code{copy-face} を使う事ができます。例えば、@code{gnus-emphasis-italic}
に代わりに赤のフェイスを使うようにしたいときは、次のようにできます：

@lisp
(copy-face 'red 'gnus-emphasis-italic)
@end lisp
記事を自動的にフォンと変更させるためには @xref{Customizing Articles} を
参照して下さい。


@node Article Hiding
@subsection 記事を隠す
@cindex article hiding

もしくは、それぞれの記事の特定のものを隠したいかもしれません。たいていの
記事には普通はありすぎるくらい作りかえるものがあります。

@table @kbd

@item W W a
@kindex W W a （概略）
@findex gnus-article-hide
記事バッファでたくさんの隠匿をします (@kbd{gnus-article-hide})。特に、こ
の関数はヘッダー、PGP、引用文と署名を隠します。

@item W W h
@kindex W W h （概略）
@findex gnus-article-hide-headers
ヘッダーを隠します (@code{gnus-article-hide-headers})。 @xref{Hiding
Headers}.

@item W W b
@kindex W W b （概略）
@findex gnus-article-hide-boring-headers
あまり興味のもてないヘッダーを隠します
(@code{gnus-article-hide-boring-headers})。 @xref{Hiding Headers}.

@item W W s
@kindex W W s （概略）
@findex gnus-article-hide-signature
署名を隠します (@code{gnus-article-hide-signature})。 @xref{Article
Signature}.

@item W W p
@kindex W W p （概略）
@findex gnus-article-hide-pgp
@vindex gnus-article-hide-pgp-hook
@sc{pgp} 署名を隠します (@code{gnus-article-hide-pgp})。 @sc{pgp} 署名が
隠された後にフック @code{gnus-article-hide-pgp-hook} が実行されます。

@item W W P
@kindex W W P （概略）
@findex gnus-article-hide-pem
@sc{pem} (privacy enhanced messages（プライバシー拡張メッセージ）) 部分を
隠します (@code{gnus-article-hide-pem})。

@item W W c
@kindex W W c （概略）
@findex gnus-article-hide-citation
引用を隠します (@code{gnus-article-hide-citation})。隠蔽をカスタマイズする
いくつかの変数は：

@table @code
@item gnus-cited-opend-text-button-line-format
@itemx gnus-cited-closed-text-button-line-format
@vindex gnus-cited-closed-text-button-line-format
@vindex gnus-cited-opend-text-button-line-format

Gnus はどこの引用文が隠されているかを示すためにボタンを付け加え、文章の
隠蔽を切り替えられるようにします。この変数の様式はこれらのフォーマットの
ような変数によって指定されます (@pxref{Formatting Variables})。次の指定
は有効です：

@table @samp
@item b
隠された文の最初のポイントです。
@item e
隠された文の最後のポイントです。
@item l
隠されたリージョンの文字の数です。
@item n
隠された文の行の数です。
@end table

@item gnus-cited-lines-visible
@vindex gnus-cited-lines-visible
引用文の最初からの表示される行数です。

@end table

@item W W C
@kindex W W C （概略）
@findex gnus-article-hide-citation-in-followups
根本でない記事の引用文を隠します
(@code{gnus-article-hide-citation-in-followups})。これは対話的命令として
はあまり役に立たないかもしれませんが、@code{gnus-article-display-hook}
に入れる事のできる手軽な関数であるでしょう (@pxref{Customizing
Articles})。

@item W W C-c
@kindex W W C-c (概略)
@findex gnus-article-hide-citation-maybe

以下の2つの変数に基づいて引用を隠します 
(@code{gnus-article-hide-citation-maybe}):

@table @code
@item gnus-cite-hide-percentage
@vindex gnus-cite-hide-percentage
もし引用文がこの変数 (初期値は 50) より大きい割合であれば、引用文を隠し
ます。

@item gnus-cite-hide-absolute
@vindex gnus-cite-hide-absolute
隠される引用文は少なくともこの長さ (初期値 10) でなければなりません。
@end table

@end table

これらの全ての『隠蔽』命令は切り替え命令ですが、これらの命令に負の接頭引数
を与えると、それらは前に隠されていたものを表示します。正の接頭引数を与えれ
ば、それらは常に隠します。

引用カスタマイズのための他の変数の情報のために @pxref{Article
Highlighting} も参照してください。

自動的に記事の要素を隠すための方法は @xref{Customizing Articles} を参照
して下さい。


@node Article Washing
@subsection 記事洗濯
@cindex washing
@cindex article washing

私たちはこれをもっともな理由の下で『記事洗濯』(article washing) と呼んでい
ます。すなわち、キー @kbd{A} は使われているので、代わりにキー @kbd{W} を使
う必要があるのです。

私たちは@dfn{洗濯}を『何かの何かを何か別のものに変換する』と定義しています
が、普通はもっと良く見える何かに落ち着きます。それにもっときれいです、たぶ
ん。

@table @kbd

@item W l
@kindex W l （概略）
@findex gnus-summary-stop-page-breaking
ページの区切りを現在の記事から取り除きます
(@code{gnus-summary-stop-page-breaking})。ページの区切りに付いては 
@xref{Misc Article} を参照して下さい。

@item W r
@kindex W r （概略）
@findex gnus-summary-caesar-message
@c @icon{gnus-summary-caesar-message}
記事バッファでカエサル変換 (Caesar rotate) (rot13) をします
(@code{gnus-summary-caesar-message})。カエサル変換か rot13 を用いて読む事
のできる、判読不可能な記事です（典型的には、攻撃的な冗談などです。）

普通は ``rot13'' と呼ばれています。それはアルファベットの位置が 13 個回転
するからです。例えば、@samp{B}（2番目の文字） → @samp{O}（15番目の文字）。
これは時々『カエサル変換』と呼ばれる事もあります。というのは、カエサルがこ
の形式の、えーと、ちょっと簡単な暗号化を採用したという噂があるからです。

@item W t
@kindex W t （概略）
@findex gnus-summary-toggle-header
記事バッファにすべてのヘッダーを表示するかどうかを切り替えます
(@code{gnus-summary-toggle-header})。

@item W v
@kindex W v （概略）
@findex gnus-summary-verbose-header
記事バッファにすべてのヘッダーを永遠に表示するかどうかを切り替えます
(@code{gnus-summary-verbose-header})。

@item W m
@kindex W m （概略）
@findex gnus-summary-toggle-mime
記事を @sc{mime} 記事として表示するかどうかを切り替えます
(@code{gnus-summary-toggle-mime})。

@item W o
@kindex W o （概略）
@findex gnus-article-treat-overstrike
オーバーストライクを処理します (@code{gnus-article-treat-overstrike})。

@item W d
@kindex W d （概略）
@findex gnus-article-treat-dumbquotes
M******** sm*rtq**t*s を処理します
(@code{gnus-article-treat-dumbquotes})。

@item W w
@kindex W w （概略）
@findex gnus-article-fill-cited-article
語の折り返しをします (@code{gnus-article-fill-cited-articles})。もしこの
関数を @code{gnus-article-display-hook} の中で使った場合、それはかなり後
の方で実行されるべきで、当然すべてのハイライトの後になります。

折り返しをするときに、幅を指定するために命令に数値接頭引数を与える事がで
きます。

@item W c
@kindex W c （概略）
@findex gnus-article-remove-cr
キャリッジリターン (CR) (すなわち、行の最後の @samp{^M}) を取り除きます
(@code{gnus-article-remove-cr})。

@item W f
@kindex W f （概略）
@cindex x-face
@findex gnus-article-display-x-face
@findex gnus-article-x-face-command
@vindex gnus-article-x-face-command
@vindex gnus-article-x-face-too-ugly
すべての X-Face 欄を探して表示します(@code{gnus-article-display-x-face})。
この命令は変数 @code{gnus-article-x-face-command} によって与えられた関数に
よって実行されます。この変数が文字列ならば、この文字列がサブシェルで実行さ
れます。関数ならば、この関数が顔を引数として呼ばれます。もし
@code{gnus-article-x-face-too-ugly}（これは正規表現です）が @code{From} 欄
に合致すれば、顔は表示されません。Emacs でのディフォルトの動作は
@code{xv} をフォークして見ようとします。XEmacs でのディフォルトの動作は
@code{From} 欄の前に顔を表示します。（XEmacs が X-Face 機能付きでコンパイ
ルされていると良いでしょう――それは表示を少し早くします。もし根本的 
X-Face 機能がないのであれば、gnus は @code{pbmplus} やその仲間の外部プログ
ラムを使って @code{X-Face} 欄を変換しようと試みます。）この関数を表示フッ
クに入れたいのであれば、おそらくそれあ最後になるべきでしょう。

@item W b
@kindex W b （概略）
@findex gnus-article-add-buttons
クリックできるボタンを記事に加えます (@code{gnus-article-add-buttons})。
@xref{Article Buttons}.

@item W B
@kindex W B （概略）
@findex gnus-article-add-buttons-to-head
クリックできるボタンを記事のヘッダーに加えます
(@code{gnus-article-add-buttons-to-head})。

@item W E l
@kindex W E l （概略）
@findex gnus-article-strip-leading-blank-lines
記事の始めからのすべての空白行を取り除きます
(@code{gnus-article-strip-leading-blank-lines})。

@item W E m
@kindex W E m （概略）
@findex gnus-article-strip-multiple-blank-lines
すべての空白行を空行で置き換え、すべての複数の空行を一つの空行で置き換え
ます (@code{gnus-article-strip-multiple-blank-lines})。

@item W E t
@kindex W E t （概略）
@findex gnus-article-remove-trailing-blank-lines
記事の最後のすべての空白行を取り除きます
(@code{gnus-article-remove-trailing-blank-lines})。

@item W E a
@kindex W E a （概略）
@findex gnus-article-strip-blank-lines
上の３つの命令をすべて行います (@code{gnus-article-strip-blank-lines})。

@item W E A
@kindex W E A （概略）
@findex gnus-article-strip-all-blank-lines
すべての空白行を取り除きます (@code{gnus-article-strip-all-blank-lines})。

@item W E s
@kindex W E s （概略）
@findex gnus-article-strip-leading-space
記事の本体のすべての行の始めからのすべての空白を取り除きます
(@code{gnus-article-strip-leading-space})。

@end table

記事の洗濯を自動的にするための方法は @xref{Customizing Articles} を参照
して下さい。


@node Article Buttons
@subsection 記事のボタン
@cindex buttons

よく記事の中に他のものへの参照が入れられる事があります。そして、gnus が
それに関する事を、それらの参照の上で @kbd{RET} を打つか、マウスの真中の
ボタンを使う事によって、最小限の努力で取得する事ができれば素敵でしょう。

Gnus はディフォルトで特定の標準の参照に@dfn{ボタン}を付けます： ちゃんとし
た URL、メールアドレス、Message-ID です。これは2つの変数によって制御され
ていて、その一つは記事の本体を扱い、もう一つは記事のヘッダーを扱います。

@table @code

@item gnus-button-alist
@vindex gnus-button-alist
それぞれの入力要素が次のような様式の連想リストです：

@lisp
(REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@table @var

@item regexp
この正規表現 (regexp) に合致するすべての文は外部参照であるとみなされます。
これは埋め込まれた URL に合致する典型的な正規表現です
@samp{<URL:\\([^\n\r>]*\\)>}。

@item button-par
Gnus は合致したもののどの部分がハイライトされるのかを知らなければなりま
せん。これは正規表現のどの副表現がハイライトされるかを指定する番号です。
全てをハイライトしたいのなら、ここで 0 を使ってください。

@item use-p
この式は @code{評価} され、結果が @code{nil} でなければ、これは合致であ
るとみなされます。これは間違った合致を避けるために特別な選別をしたいとき
に役に立ちます。

@item function
この関数 (function) はこのボタンをクリックしたときに呼ばれます。

@item data-par
@var{button-par} のように、これは部分表現の番号ですが、これは合致のどの部
分が @var{function} にデータとして送られるかを指定します。

@end table

ですから、URL をボタンにする完全な入力要素は

@lisp
("<URL:\\([^\n\r>]*\\)>" 0 t gnus-button-url 1)
@end lisp

@item gnus-header-button-alist
@vindex gnus-header-button-alist
それが記事のヘッダーだけに適用され、それぞれの入力要素がどのヘッダーにボ
タン化を適用するかを示す追加の要素がある事を除き、これは他の連想リストと
同じようなものです：

@lisp
(HEADER REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@var{HEADER} は正規表現です。

@item gnus-button-url-regexp
@vindex gnus-button-url-regexp
埋め込まれた URL に合致する正規表現です。それは上の変数のディフォルトの
値で使われます。

@item gnus-article-button-face
@vindex gnus-article-button-face
ボタンに使われるフェイスです。

@item gnus-article-mouse-face
@vindex gnus-article-mouse-face
マウスのカーソルがボタンの上にあるときに使われるフェイスです。

@end table

記事を自動的にボタン化する方法は @xref{Customizing Articles} を参照して
下さい。


@node Article Date
@subsection 記事の日付

日付は聞いた事の無い何か辺鄙な時間帯 (timezone) で作成されている事が良くあ
るので、記事が送られたときに何時であったかを知る事ができるのは非常に良い事
でしょう。

@table @kbd

@item W T u
@kindex W T u （概略）
@findex gnus-article-date-ut
UT (別名 GMT, ZULU) で日付を表示します (@code{gnus-article-date-ut})。

@item W T i
@kindex W T i （概略）
@findex gnus-article-date-iso-8601
@cindex ISO 8601
日付を国際的な形式、ISO 8601 で表示します
(@code{gnus-article-date-iso8601})。

@item W T l
@kindex W T l （概略）
@findex gnus-article-date-local
日付をその地域の時間帯で表示します (@code{gnus-article-date-local})。

@item W T s
@kindex W T s （概略）
@vindex gnus-article-time-format
@findex gnus-article-date-user
@findex format-time-string
日付を利用者定義の様式を使って表示します (@code{gnus-article-date-user})。
その様式は変数 @code{gnus-article-time-format} で指定され、
@code{format-time-string} に渡される文字列です。様式指定をする事ができる
一覧は変数の説明文を見てください。

@item W T e
@kindex W T e （概略）
@findex gnus-article-date-lapsed
@findex gnus-start-date-timer
@findex gnus-stop-date-timer
記事が投稿されてから今までどれくらいの時間が経過したかを表示します
(@code{gnus-article-date-lapsed})。この行が連続して更新されるようにした
いのであれば、

@lisp
(gnus-start-date-timer)
@end lisp

をあなたの @file{.gnus.el} ファイルに入れるか、何かのフックで実行するよ
うにする事ができます。タイマーを止めたいのであれば、命令
@code{gnus-stop-date-timer} を使う事ができます。

@item W T o
@kindex W T o （概略）
@findex gnus-article-date-original
本来の日付を表示します (@code{gnus-article-date-original})。これはあなたが
普通は他の変換関数を使っていて、それが完全に間違った事をしているのではない
かと心配しているときに役に立ちます。例えば、記事が 1854 年に投稿されたとなっ
ているとしましょう。しかし、そのような事は@emph{完全に}不可能です。私が
信用できませんか？ *くすくす(笑)*

@end table

自動的に好む書式で日付を表示する方法は @xref{Customizing Articles} を参
照して下さい。


@node Article Signature
@subsection 記事の署名
@cindex signatures
@cindex article signature

@vindex gnus-signature-separator
それぞれの記事は2つの部分に分けられます――見出し (header) と本体 
(body) です。本体は署名部分と文章部分に分けられます。どれが署名とみなされ
るかを決める変数は @code{gnus-signature-separator} です。これは普通は 
son-of-RFC 1036 で指示されている標準の @samp{^-- $} です。しかし、多くの人
が標準でない署名分離を用いますので、この変数は一つ一つ試される、正規表現の
リストであることもできます。（探索は本体の最後から始めへとなされます。）よ
くありそうな値は：

@lisp
(setq gnus-signature-separator
      '("^-- $"         ; 標準
        "^-- *$"        ; 普通の壊し方
        "^-------*$"    ; 多くの人は長ーーい横棒の
                        ; 行を使います。あぁ！
        "^ *--------*$" ; 2倍のあぁぁ！
        "^________*$"   ; 下線も人気があります
        "^========*$")) ; 邪道！
@end lisp

あなたが寛容であればあるほど、間違った結果を得る事になるでしょう。

@vindex gnus-signature-limit
@code{gnus-signature-limit} はどれが署名とみなされるかへの制限を提供しま
す。

@enumerate
@item
これが整数であれば、署名はこの整数より（文字で）長くなっていてはいけません。
@item
これが浮動小数点数であれば、署名はその数字より（行で）長くなっていてはいけ
ません。
@item
これが関数であれば、その関数は引数なしで呼ばれ、それが @code{nil} を返せ
ば、バッファには署名がありません。
@item
これが文字列であれば、それは正規表現として使われます。もしそれが合致すれ
ば、その当の文字列は署名ではありません。
@end enumerate

この変数は要素が上に挙げられた型のリストである事もできます。これは例です：

@lisp
(setq gnus-signature-limit
      '(200.0 "^---*Forwarded article"))
@end lisp

これは署名分離物の後に 200 を超える行か、署名分離物の後の文章が正規表現
@samp{^---*Forwarded article} に合致すれば、結局それは署名ではないという事
です。


@node Article Commands
@section 記事命令

@table @kbd

@item A P
@cindex PostScript
@cindex printing
@kindex A P （概略）
@vindex gnus-ps-print-article
@findex gnus-summary-print-article
記事バッファのポストスクリプト (PostScript) イメージを作成して印刷します 
(@code{gnus-summary-print-article})。@code{gnus-ps-print-hook} がバッファ
を印刷する直前に実行されるでしょう。

@end table


@node Summary Sorting
@section 概略の並び替え
@cindex summary sorting

私はどうしてあなたがそうしたいのかはわからないのですが、それでもあなたは
たくさんの方法で概略バッファを並び替える事ができます。

@table @kbd

@item C-c C-s C-n
@kindex C-c C-s C-n （概略）
@findex gnus-summary-sort-by-number
記事番号によって並び替えます (@code{gnus-summary-sort-by-number})。

@item C-c C-s C-a
@kindex C-c C-s C-a （概略）
@findex gnus-summary-sort-by-author
著者によって並び替えます (@code{gnus-summary-sort-by-author})。

@item C-c C-s C-s
@kindex C-c C-s C-s （概略）
@findex gnus-summary-sort-by-subject
表題によって並び替えます (@code{gnus-summary-sort-by-subject})。

@item C-c C-s C-d
@kindex C-c C-s C-d （概略）
@findex gnus-summary-sort-by-date
日付によって並び替えます (@code{gnus-summary-sort-by-date})。

@item C-c C-s C-l
@kindex C-c C-s C-l （概略）
@findex gnus-summary-sort-by-lines
行によって並び替えます (@code{gnus-summary-sort-by-lines})。

@item C-c C-s C-i
@kindex C-c C-s C-i （概略）
@findex gnus-summary-sort-by-score
スコアによって並び替えます (@code{gnus-summary-sort-by-score})。
@end table

これらの関数はスレッドを使っているときと使っていないときの両方で動作しま
す。後者の場合は、すべての概略行が一行一行並び替えられます。前者の場合は、
根本と根本を基本として並び替えられ、それはあなたが求めている事とは異
なっているかもしれません。スレッドを使う事を切り替えるには @kbd{T T} を
打ってください (@pxref{Thread Commands})。


@node Finding the Parent
@section 親記事を探す
@cindex parent articles
@cindex referring articles

@table @kbd
@item ^
@kindex ^ （概略）
@findex gnus-summary-refer-parent-article
現在の記事の親記事を読みたくて、それが概略バッファに表示されていないくて
も、おそらくそれは可能でしょう。というのは、現在のグループが @sc{nntp}
で取得されていて、親がまだ期限消去されていない上、現在の記事の
@code{References} がぶち壊されていなければ、ただ、@kbd{^} か @kbd{A r}
を押せば良いだけです (@code{gnus-summary-refer-parent-article})。もし全
てが上手く行けば、親記事を取得できるでしょう。もし親記事が既に概略バッファ
に表示されているのであれば、ポイントがその記事に移動するでしょう。

正の数値接頭引数を与えられれば、祖先まで多くの記事を戻って取得します。負
の数字接頭引数が与えられれば、その祖先の記事だけを取得します。ですから、
@kbd{3 ^} とすれば、gnus は現在の記事の親と、祖父母と、曾祖父母を取得し
ます。 @kbd{-3 ^} とすれば、gnus は現在の記事の曾祖父母だけを取得します。

@item A R （概略）
@findex gnus-summary-refer-references
@kindex A R （概略）
記事の @code{References} 欄にある全ての記事を取得します
(@code{gnus-summary-refer-references})。

@item A T （概略）
@findex gnus-summary-refer-thread
@kindex A T （概略）
現在の記事が出てきているスレッドの、完全なスレッドを表示します
(@code{gnus-summary-refer-thread})。この命令は動作するために現在のグルー
プのすべてのヘッダーを取得しなければなりませんので、普通は少し時間がかか
ります。もし、これをしばしば行うのであれば、
@code{gnus-fetch-old-headers} を @code{invisible} に設定することを考えた
ほうが良いでしょう (@pxref{Filling In Threads})。これは普通は視覚的な効
果はありませんが、この命令の動作をかなり速くするでしょう。もちろん、グルー
プに入るのは少し遅くなります。

@vindex gnus-refer-thread-limit
変数 @code{gnus-refer-thread-limit} はこの命令を実行するときにどのくらい古
い（すなわち、現在の記事で最初に表示されたよりも前の記事）ヘッダーを取得す
るかを指定します。ディフォルトは 200 です。もし @code{t} であれば、取得可
能なすべてのヘッダーを取得します。この変数は命令 @code{A T} に数値接頭引数
を与える事により上書きする事ができます。

@item M-^ （概略）
@findex gnus-summary-refer-article
@kindex M-^ （概略）
@cindex Message-ID
@cindex fetching by Message-ID
どのグループに属しているかに関わらず、任意の記事を @sc{nntp} サーバーに
尋ねる事ができます。@kbd{M-^} (@code{gnus-summary-refer-article}) は
@code{Message-ID}、それはあの長く、なかなか読む事のできない
@samp{<38o6up$6f2@@hymir.ifi.uio.no>} のような参照をあなたに尋ねます。
あなたはすべてを正確に打ち込まなければなりません。残念ながら、あいまいな
検索はできないのです。
@end table

ニュースでない選択方法から @code{Message-ID} で取得するときには現在の選択
方法が使われますが、この命令に接頭引数を与える事でこれを上書きする事ができ
ます。

@vindex gnus-refer-article-method
もしあなたの読んでいるグループが @code{Message-ID} での取得があまり良くで
きないようなグループ（@code{nnspool} など）である場合、
@code{gnus-refer-article-method} を @sc{nntp} に設定する事ができます。おそ
らく、あなたが会話している @sc{nntp} サーバーがあなたの読んでいるスプール
を更新していると非常に良いでしょう。しかし、それはどうしても必要なわけでは
ありません。

ほとんどのメールバックエンドは @code{Message-ID} での取得が可能ですが、
あまり優雅な方法でやっているわけではありません。@code{nnmbox} と
@code{nnbabyl} はどのグループからの記事も位置を得ることができますが、
@code{nnml} と @code{nnfolder} は現在のグループに投稿した記事の位置しか
得る事ができません。（その他のものは時間がかかりすぎます。）@code{nnmh}
では全く不可能です。

@node Alternative Approaches
@section 代替手段

違った人は違った方法を使ってニュースを読もうとします。これは gnus でもそ
うであるので、我々は概略バッファーのためのマイナーモード (minor mode) に
少しの選択肢を与えてあります。

@menu
* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動-復号化する
@end menu


@node Pick and Read
@subsection 選んで読む
@cindex pick and read

いくつかのニュースリーダー（@code{nn} や、あのぉ、VM/CMS での
@code{Netnews} など）は2相の読むための界面を使います。利用者はまず概略バッ
ファで読みたい記事に印を付けます。それから、記事バッファだけを表示して記事
を読みます。

@vindex gnus-pick-mode
@kindex M-x gnus-pick-mode
Gnus はこれをするための概略バッファマイナーモードを提供します――
@code{gnus-pick-mode} です。これは基本的には簡単に印を付けられるように少し
のプロセス印命令が１打鍵命令になり、概略バッファへ切り替えるための追加命令
を1つ提供します。

これが pick mode を使ったときに使用可能なキーです：

@table @kbd
@item .
@kindex . （選択）
@findex gnus-pick-article-or-thread
現在の行の記事かスレッドを選択します 
(@code{gnus-pickd-article-or-thread})。もし変数 
@code{gnus-thread-hide-subtree} が true であれば、このキーはスレッドの最
初の記事で使われたときはスレッド全体を選択します。そうでなければ、それは
その記事だけを選択します。もし数値接頭引数を与えられればそのスレッドか記
事へと生んでいき、それを選択します。 (行数は普通は概略選択行の最初に表示
されています。)

@item SPACE
@kindex SPACE（選択）
@findex gnus-pick-next-page
概略バッファを一ページ次にスクロールします (@code{gnus-pick-next-page})。
もしバッファの最後であれば、選択記事を読み始めます。

@item u
@kindex u （選択）
@findex gnus-pick-unmark-article-or-thread
スレッドか記事を未選択にします (@code{gnus-pick-unmark-article-or-thread})。変数 @code{gnus-thread-hide-subtree} が true であれば、このキーはスレッドの最初で使われればスレッドを未選択にします。そうでない場合はそれは記事だけを未選択にします。その行にあるスレッドか記事を未選択にするためにこのキーに数値接頭引数を与える事ができます。

@item RET
@kindex RET （選択）
@findex gnus-pick-start-reading
@vindex gnus-pick-display-summary
選択された記事を読み始めます (@code{gnus-pick-start-reading})。接頭引数
を与えられれば、まずすべての未選択記事に既読の印を付けます。
@code{gnus-pick-display-summary} が @code{nil} でないと、概略バッファは
読んでいる間も表示されます。

@end table

全ての普通の概略モード命令は選択モード (pick-mode)でも使用可能ですが、
@kbd{u} は例外です。しかし、同じ関数 
@code{gnus-summary-tick-article-forward} に割り当てられている @kbd{!} を
使う事ができます。

これが良い考えだと思うのであれば、次のようにする事ができます：

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@vindex gnus-pick-mode-hook
@code{gnus-pick-minor-mode-hook} は pick マイナーモードバッファで実行さ
れます。

@vindex gnus-summary-pick-line-format
pick モードでの概略行の様式は標準の様式とは少し違います。それぞれの行の
最初に行数が表示されます。 Pick モードの行の様式は変数
@code{gnus-summary-pick-line-format} で制御されます (@pxref{Formatting
Variables})。これは @code{gnus-summary-line-format} と同じ様式指定を受け
付けます (@pxref{Summary Buffer Lines})。


@node Binary Groups
@subsection バイナリーグループ
@cindex binary groups

@findex gnus-binary-mode
@kindex M-x gnus-binary-mode
もし多くの時間をバイナリーグループ (binary group) で過ごしているのなら、い
つも @kbd{X u}, @kbd{n}, @kbd{RET} を叩くのが嫌になっているでしょう。
@kbd{M-x gnus-binary-mode} は記事を普通の方法で表示する代わりに、普通の
gnus の記事選択関数を記事群を uudecode しその結果を表示するように変更する、
概略バッファのためのマイナーモードです。

@kindex g (バイナリー)
@findex gnus-binary-show-article
実際は、このモードにしたときに、現実の記事を見るための唯一の命令が 
@kbd{g} です (@code{gnus-binary-show-article})。

@vindex gnus-binary-mode-hook
@code{gnus-binary-mode-hook} がバイナリーマイナーモードバッファで呼ばれ
ます。


@node Tree Display
@section 木表示
@cindex trees

@vindex gnus-use-trees
もし普通の gnus の概略表示を好きでないならば、@code{gnus-use-trees} を
@code{t} に設定してみると良いかもしれません。これは（ディフォルトで）追加
の @dfn{木バッファ} (tree buffer) を作成します。木バッファではすべての概略
モード命令を実行する事ができます。

もちろん、木表示をカスタマイズする変数が少しあります：

@table @code
@item gnus-tree-mode-hook
@vindex gnus-tree-mode-hook
すべての木モードバッファで実行されるフックです。

@item gnus-tree-mode-line-format
@vindex gnus-tree-mode-line-format
木モードバッファでのモード行のためのフォーマット文字列です (@pxref{Mode
Line Formatting})。ディフォルトは @samp{Gnus: %%b %S %Z} です。使用可能
な指定は @pxref{Summary Buffer Mode Line} を参照してください。

@item gnus-selected-tree-face
@vindex gnus-selected-tree-face
木バッファで選択された記事をハイライトするために使われるフェイスです。ディ
フォルトでは @code{modeline} です。

@item gnus-tree-line-format
@vindex gnus-tree-line-format
木の節のためのフォーマット文字列です。でもこの名前は少し誤った名称です――
それは行ではなく、ただ節を定義するだけです。ディフォルトの値は
@samp{%(%[%3,3n%]%)} で、それは投稿者の名前の最初の３文字を表示します。す
べての節が同じ長さであるのは重要ですので、@samp{%4,4n} のような指定を 
@emph{使わなければならない} のです。

有効な指定は：

@table @samp
@item n
投稿者の名前。
@item f
@code{From} 欄。
@item N
記事の番号。
@item [
開き括弧。
@item ]
閉じ括弧。
@item s
表題。
@end table

@xref{Formatting Variables}。

表示に関連した変数は：

@table @code
@item gnus-tree-brackets
@vindex gnus-tree-brackets
これは『本当の』記事と『まばら記事』に違いを付けるために使われます。
様式は 
@var{((本当の開 . 本当の閉) (まばら開 . まばら閉) (偽の開 . 偽の閉))}
となっていて、ディフォルトは 
@code{((?[ . ?]) (?( . ?)) (?@{ . ?@}) (?< . ?>))} です。

@item gnus-tree-parent-child-edges
@vindex gnus-tree-parent-child-edges
これは親の節を子に接続するために使われる文字を含んだリストです。ディフォ
ルトは @code{(?- ?\\ ?|)} です。

@end table

@item gnus-tree-minimize-window
@vindex gnus-tree-minimize-winodw
もしこの変数が @code{nil} でないと、他の gnus ウィンドウがもっと場所を取
れるように gnus は木バッファをできるだけ小さくします。もしこの変数が数字
であると、木バッファはその数字より大きくなる事はありません。ディフォルト
は @code{t} です。フレームでいくつかのウィンドウが横に並んで表示されてい
て、木バッファがそのうちの一つである場合、木ウィンドウを最小化することは
その隣に表示されているすべてのウィンドウの大きさを変更する事に注意してく
ださい。

@item gnus-generate-tree-function
@vindex gnus-generate-tree-function
@findex gnus-generate-horizontal-tree
@findex gnus-generate-vertical-tree
実際にスレッドの木を作成する関数です。2つの既定義の使用可能な関数は：
@code{gnus-generate-horizontal-tree} と
@code{gnus-generate-vertical-tree}（これがディフォルトです）です。

@end table

水平木バッファ (horizontal tree buffer) の例です：

@example
@{***@}-(***)-[odd]-[Gun]
     |      \[Jan]
     |      \[odd]-[Eri]
     |      \(***)-[Eri]
     |            \[odd]-[Paa]
     \[Bjo]
     \[Gun]
     \[Gun]-[Jor]
@end example

同じスレッドが垂直木バッファ (vertical tree buffer) で表示されたものです：

@example
@{***@}
  |--------------------------\-----\-----\
(***)                         [Bjo] [Gun] [Gun]
  |--\-----\-----\                          |
[odd] [Jan] [odd] (***)                   [Jor]
  |           |     |--\
[Gun]       [Eri] [Eri] [odd]
                          |
                        [Paa]
@end example

もし水平木を使っているのなら、概略バッファで木を隣り合わせで表示できれば
嬉しいでしょう。次のようなものをファイル @file{.gnus.el} に加える事がで
きます：

@lisp
(setq gnus-use-trees t
      gnus-generate-tree-function 'gnus-generate-horizontal-tree
      gnus-tree-minimize-window nil)
(gnus-add-configuration
 '(article
   (vertical 1.0
             (horizontal 0.25
                         (summary 0.75 point)
                         (tree 1.0))
             (article 1.0))))
@end lisp

@xref{Windows Configuration}。


@node Mail Group Commands
@section メールグループ命令
@cindex mail group commands

いくつかの命令はメールグループのみで意味を持ちます。これらの命令が現在の
グループで有効でないなら、それらは大騒ぎをしてあなたに知らせるでしょう。

すべてのこれらの命令は（期限削除と編集命令は除く）プロセス/接頭引数の習慣
を使います (@pxref{Process/Prefix})。

@table @kbd

@item B e
@kindex B e （概略）
@findex gnus-summary-expire-articles
グループのすべての期限削除可能な記事を期限切れ削除します
(@code{gnus-summary-expire-articles})。

@item B M-C-e
@kindex B M-C-e （概略）
@findex gnus-summary-expire-articles-now
グループのすべての期限削除可能な記事削除します
(@code{gnus-summay-expire-articles-now})。これは現在のグループの該当する
@strong{全て}の期限削除記事は永遠に空の大きな @file{/dev/null} へ消え去る
という事です。

@item B DEL
@kindex B DEL （概略）
@findex gnus-summary-delete-article
@c @icon{gnus-summary-mail-delete}
メール記事を削除します。これは『あなたのディスクから今から永遠に削除して、
二度と戻らない』の『削除』です。注意して使ってください 
(@code{gnus-summary-delete-article})。

@item B m
@kindex B m （概略）
@cindex move mail
@findex gnus-summary-move-article
あるメールグループから別のところへ記事を移動します
(@code{gnus-summary-move-article})。

@item B c
@kindex B c （概略）
@cindex copy mail
@findex gnus-summary-copy-article
@c @icon{gnus-summary-mail-copy}
あるグループ（メールグループや他のもの）からメールグループに記事を複製しま
す (@code{gnus-summary-copy-article})。

@item B B
@kindex B B （概略）
@cindex crosspost mail
@findex gnus-summary-crosspost-article
現在の記事を他のグループにクロスポストします
(@code{gnus-summary-crosspost-article})。これは他のグループ記事の新しい複
製を作成し、記事の Xref 欄も適切に更新されます。

@item B i
@kindex B i （概略）
@findex gnus-summary-import-article
任意のファイルを現在のメールグループに取り込みます
(@code{gnus-summary-import-article})。あなたはファイル名と、@code{From} 欄
と @code{Subject} 欄の入力を促されます。

@item B r
@kindex B r （概略）
@findex gnus-summary-respool-article
メール記事をスプールし直します (@code{gnus-summary-move-article})。
@code{gnus-summary-respool-default-method} が再スプールするときのディフォ
ルトの選択方法として使用されます。この変数はディフォルトで @code{nil} で、
これは現在のグループの選択方法が代わりに使われるという事です。

@item B w
@itemx e
@kindex B w （概略）
@kindex e （概略）
@findex gnus-summary-edit-article
@kindex C-c C-c （記事）
現在の記事を編集します (@code{gnus-summary-edit-article})。編集を終了し
て変更を永遠にするために、@kbd{C-c C-c} を打ちます。もし命令 
@kbd{C-c C-c} に数値接頭引数を与えると、gnus は記事を再ハイライトしませ
ん。

@item B q
@kindex B q （概略）
@findex gnus-summary-respool-query
もし記事を再スプールしたいときは、再スプールをする前にどのグループに記事
が移るかに興味があるでしょう。この命令でそれがわかります
(@code{gnus-summary-respool-query})。

@item B t
@kindex B t (概略)
@findex gnus-summary-respool-trace
同様に、この命令は再溜め込みをするときに使われた全ての特級分割方式を、も
しそれがあれば表示します (@code{gnus-summary-respool-trace})。

@item B p
@kindex B p （概略）
@findex gnus-summary-article-posted-p
一部の人はあなたの投稿へのフォローアップをするときに、『親切な』複製を送る
傾向があります。これらは普通はそこに @code{Newsgroups} 欄が付いているので
すが、いつもそうであるとは限りません。この命令
(@code{gnus-summary-article-posted-p}) は現在の記事をあなたのニュースサー
バーから（というよりは、むしろ @code{gnus-refer-article-method} や
@code{gnus-select-method} から）取得しようとし、記事を発見できたかどうかを
報告します。それが記事を発見しなかったとしても、それはとにかく投稿されてい
るかもしれません――メールの伝達はニュースの伝達よりもずっと速く、ニュース
の複製がまだ到着していないだけかもしれないのです。

@end table

@vindex gnus-move-split-methods
@cindex moving articles
もし、規則的に記事を移動（もしくは複製）するのであれば、gnus に記事をどこ
に入れれば良いか提案させたいと思うでしょう。
@code{gnus-move-split-methods} は @code{gnus-split-methods} と同じ構文を使
う変数です (@pxref{Saving Articles})。あなたが妥当だと思うような提案をする
ようにその変数をカスタマイズする事ができます。

@lisp
(setq gnus-move-split-methods
      '(("^From:.*Lars Magne" "nnml:junk")
        ("^Subject:.*gnus" "nnfolder:important")
        (".*" "nnml:misc")))
@end lisp


@node Various Summary Stuff
@section いろいろな概略の物件

@menu
* Summary Group Information::         情報指向の命令。
* Searching for Articles::            複数記事命令。
* Summary Generation Commands::       概略バッファの（再）作成。
* Really Various Summary Commands::   あのやっかいな他に適合しない命令。
@end menu

@table @code
@vindex gnus-summary-mode-hook
@item gnus-summary-mode-hook
概略モードバッファを作成するときにこのフックが呼ばれます。

@vindex gnus-summary-generate-hook
@item gnus-summary-generate-hook
これはスレッド作成と概略バッファ作成の前に実行する最後のものとして呼ばれ
ます。これはニュースグループの持っているデータに基づいてスレッドの変数を
カスタマイズするために非常に便利です。このフックはほとんどの概略バッファ
変数が設定された後に呼ばれます。

@vindex gnus-summary-prepare-hook
@item gnus-summary-prepare-hook
それは概略バッファが作成された後に呼ばれます。例えば、それは何か他の邪悪
な方法で行をハイライトしたり、バッファの見え方を修正したりするのに使った
りするかも知れません。

@vindex gnus-summary-ignore-duplicates
@item gnus-summary-ignore-duplicates
Gnus が同じ @code{Message-ID} を持つ2つの記事を発見したときは、何か思い切っ
た事をしなければなりません。別の記事が同じ @code{Message-ID} を持つ事は許
されていませんが、それは何らかの出所からメールを読んでいるときに起こるかも
しれません。Gnus はこの変数によって何が起こるかをカスタマイズできるように
なっています。もしそれが @code{nil}（これがディフォルトです）であれば、
gnus は @code{Message-ID} を付け替えて（表示のためだけに）記事を他の記事と
同じように表示します。この変数が @code{t} であると、それは記事を表示しませ
ん---最初から存在しなかったかのように。

@end table


@node Summary Group Information
@subsection 概略グループ情報

@table @kbd

@item H f
@kindex H f （概略）
@findex gnus-summary-fetch-faq
@vindex gnus-grou-faq-directory
現在のグループの FAQ（frequently asked questions（頻繁にされる質問）のリス
ト）を取得しようとします (@code{gnus-summary-fetch-faq})。Gnus は普通は遠
隔マシンのディレクトリである @code{gnus-group-faq-directory} から FAQ を取
得しようとします。この変数はディレクトリーのリストである事もできます。その
場合は、この命令に接頭引数を与える事でいろいろなサイト (site) から選ぶ事が
できます。おそらく @code{ange-ftp} もしくは @code{efs} がファイルの取得に
使われるでしょう。

@item H d
@kindex H d （概略）
@findex gnus-summary-describe-group
現在のグループに関する短い記述を与えます
(@code{gnus-summary-describe-group})。接頭引数が与えられると、サーバーから
強制的に記述の再読み込みをします。

@item H h
@kindex H h （概略）
@findex gnus-summary-describe-briefly
最重要概略打鍵の非常に短い記述を与えます
(@code{gnus-summary-describe-briefly})。

@item H i
@kindex H i （概略）
@findex gnus-info-find-node
Gnus の info の節 (node) に移動します (@code{gnus-info-find-node})。
@end table


@node Searching for Articles
@subsection 記事を探す

@table @kbd

@item M-s
@kindex M-s （概略）
@findex gnus-summary-search-article-forward
直後にある全ての記事を正規表現で検索します
(@code{gnus-summary-search-article-forward})。

@item M-r
@kindex M-r （概略）
@findex gnus-summary-search-article-backward
前にある全ての記事を正規表現で検索します
(@code{gnus-summary-search-article-backward})。

@item &
@kindex & （概略）
@findex gnus-summary-execute-command
この命令はあなたにヘッダー部分とその部分に合致する正規表現、合致した場合
に実行される命令の入力を促進します (@code{gnus-summary-execute-command})。
もし接頭引数を与えられれば、代わりに後ろ向きに探します。

@item M-&
@kindex M-& （概略）
@findex gnus-summary-universal-argument
プロセス印によって印付けられた全ての記事の操作を実行します
(@code{gnus-summary-universal-argument})。
@end table

@node Summary Generation Commands
@subsection 概略生成命令

@table @kbd

@item Y g
@kindex Y g （概略）
@findex gnus-summary-prepare
現在の概略バッファを再作成します (@code{gnus-summary-prepare})。

@item Y c
@kindex Y c （概略）
@findex gnus-summary-insert-cached-articles
全ての（現在のグループに）キャッシュされた記事 を概略バッファに挿入します 
(@code{gnus-summary-insert-cached-articles})。

@end table


@node Really Various Summary Commands
@subsection 本当にいろいろな概略命令

@table @kbd

@item C-d
@kindex C-d （概略）
@findex gnus-summary-enter-digest-group
もし現在のグループが他の記事の集まりであるならば（例えば、摘要 (digest)）、
そのような記事でできているグループに入るためにこの命令を使うかもしれません 
(@code{gnus-summary-enter-digest-group})。Gnus はこの命令に接頭引数を与え
ない限り、どのような型の記事が現在表示されているかを推測しようとし、それは
強制的に『摘要』という解釈になります。基本的に、他の様式からなる他のメッセー
ジの集合であったときは、@kbd{C-d} とすることによりもっと便利な方法でそれら
のメッセージを読む事ができるようになります。

@item M-C-d
@kindex M-C-d （概略）
@findex gnus-summary-read-document
この命令は上のものに非常に似ていますが、いくつかの文書を一つの大ーきいグ
ループに集めます (@code{gnus-summary-read-read-document})。それはいくつ
かの @code{nndoc} グループをそれぞれの文書のために 開き、それからこれら
の @code{nndoc} グループの上に @code{nnvirtual} グループを開く事によって
この事を可能にしています。この命令はプロセス/接頭引数の習慣を理解します
(@pxref{Process/Prefix})。

@item C-t
@kindex C-t （概略）
@findex gnus-summary-togle-truncation
概略行の切断を切り替えます (@code{gnus-summary-toggle-truncation})。これ
はおそらく概略バッファの行中央表示関数を混乱させますので、記事を読んでい
る間に切断を切っているのは良い考えではないでしょう。

@item =
@kindex = （概略）
@findex gnus-summary-expand-window
概略バッファのウィンドウを拡大します
(@code{gnus-summary-expand-window})。接頭引数を与えられれば、@code{記事} 
ウィンドウを拡大します。

@item M-C-e
@kindex M-C-e （概略）
@findex gnus-summary-edit-parameters
現在のグループのグループの媒介変数 (parameter) (@pxref{Group
Parameters}) を編集します (@code{gnus-summary-edit-parameters})。

@end table


@node Exiting the Summary Buffer
@section 概略バッファを抜ける
@cindex summary exit
@cindex exiting groups

普通は概略バッファから抜けると、グループの全ての情報を更新してグループバッ
ファに戻ります。

@table @kbd

@item Z Z
@itemx q
@kindex Z Z (Summary)
@findex q （概略）
@findex gnus-summary-exit
@vindex gnus-summary-exit-hook
@vindex gnus-summary-prepare-exit-hook
@c @icon{gnus-summary-exit}
現在のグループを出て、グループの全ての情報を更新します
(@code{gnus-summary-exit})。抜け出るためのたいていの事をする前に 
@code{gnus-summary-prepare-exit-hook} が呼ばれ、それはディフォルトで 
@code{gnus-summary-expire-articles} を呼びます。抜け出る過程を追えた後に 
@code{gnus-summary-exit-hook} が呼ばれます。(未読の) グループが残ってい
ないときにグループモードに戻るときに 
@code{gnus-group-no-more-groups-hook} が実行されます。

@item Z E
@itemx Q 
@kindex Z E （概略）
@findex Q （概略）
@findex gnus-summary-exit-no-update
グループのどの情報も更新せずに現在のグループを抜け出ます
(@code{gnus-summary-exit-no-update})。

@item Z c
@itemx c
@kindex Z c （概略）
@kindex c （概略）
@findex gnus-summary-catchup-and-exit
@c @icon{gnus-summary-catchup-and-exit}
グループの全ての保留でない記事 (unticked article) に既読の印を付けて、そ
れから抜けます (@code{gnus-summary-catchup-and-exit})。

@item Z C
@kindex Z C （概略）
@findex gnus-summary-catchup-all-and-exit
保留記事も含めて、全ての記事に既読の印を付けて、それから抜けます 
(@code{gnus-summary-catchup-all-and-exit})。

@item Z n
@kindex Z n （概略）
@findex gnus-summary-catchup-and-goto-next-group
全ての記事に既読の印を付けて次のグループへ移動します 
(@code{gnus-summary-catchup-and-goto-next-group})。

@item Z R
@kindex Z R （概略）
@findex gnus-summary-reselect-current-group
現在のグループを出て、それから入り直します 
(@code{gnus-summary-reselect-current-group})。もし接頭引数を与えられれば、
既読と未読の両方の全ての記事を選択します。

@item Z G
@itemx M-g
@kindex Z G （概略）
@kindex M-g （概略）
@findex gnus-summary-rescan-group
@c @icon{gnus-summary-mail-get}
グループを抜け、グループの新しい記事を調べ、グループを選択します 
(@code{gnus-summary-rescan-group})。もし接頭引数を与えられれば、既読と未
読の両方の全ての記事を選択します。

@item Z N
@kindex Z N （概略）
@findex gnus-summary-next-group
グループを抜けて、次のグループへ移動します 
(@code{gnus-summary-next-group})。

@item Z P
@kindex Z P （概略）
@findex gnus-summary-prev-group
グループを抜けて、前のグループへ移動します 
(@code{gnus-summary-prev-group})。

@item Z s
@kindex Z s （概略）
@findex gnus-summary-save-newsrc
現在の既読/印付き記事の数をドリブルバッファ (dribble buffer) に保存し、
それからドリブルバッファを保存します (@code{gnus-summary-save-newsrc})。
もし接頭引数を与えられれば、ファイル @file{.newsrc} も保存します。この命
令を使うと、更新なしで抜け出る事 (@kbd{Q} 命令) は意味が無くなります。
@end table

@vindex gnus-exit-group-hook
現在のグループを抜けるときに @code{gnus-exit-group-hook} が呼ばれます。

@findex gnus-summary-wake-up-the-dead
@findex gnus-dead-summary-mode
@vindex gnus-kill-summary-on-exit
あなたにグループを抜けて、それから考えを変える癖があるのであれば、 
@code{gnus-kill-summary-on-exit} を @code{nil} に設定するのが良いかもしれ
ません。もしそうすれば、gnus はそれから抜け出るときに概略バッファを削除し
ません。（何という驚き！）その代わりに、それはバッファの名前を 
@samp{*Dead Summary ... *} のようなものに変更し、
@code{gnus-dead-summary-mode} と呼ばれるマイナーモードを導入します。今や、
そのバッファに切り替えれば、全てのキーが関数 
@code{gnus-summary-wake-up-the-dead} に割り当てられていることに気付くでしょ
う。死んだ概略バッファ (dead summary buffer) でどれかのキーを叩く事と、生
きた普通の概略バッファになるでしょう。

死んだ概略バッファは同時に一つしか存在する事はできません。

@vindex gnus-use-cross-reference
概略バッファを抜け出ると、現在のグループのデータは更新されます（どの記事を
読んで、どの記事に返答したか、などなど。）もし変数 
@code{gnus-use-cross-reference} が @code{t} であると（それがディフォルトで
す）、そのグループに相互参照された (cross referenced) 記事は既読の印が付き、
それが相互投稿 (cross post) された他の購読しているグループでも既読の印が付
きます。この変数が @code{nil} でも @code{t} でなければ、記事は購読と未購読
の両方のグループで既読の印が付きます (@pxref{Crosspost Handling})。


@node Crosspost Handling
@section 相互投稿の扱い

@cindex velveeta
@cindex spamming
相互投稿 (cross post) された記事に既読の印を付ける事は、同じ記事を2回以上
読まないですむという事を保証します。もちろん、だれかがそれをいくつかのグルー
プに別々に投稿しない限りは。同じ記事をいくつかのグループに投稿する事（相互
投稿でなくて）は @dfn{spamming} と呼ばれ、あなたはそのような憎むべき犯罪を
行うものにに対して、法律によって不快な記事を送ることが義務づけられています。
spam を選別するために、NoCeM 取扱を試したいと思うかもしれません 
(@pxref{NoCeM})。

覚えてください： 相互投稿は構いませんが、同じ記事を別々にいくつかのグルー
プに投稿するのは許されません。大量の相互投稿 (@dfn{velveeta}) はどうしても
避けられるべきで、過剰相互投稿に対して不満を言うために命令 
@code{gnus-summary-mail-crosspost-complaint} を使うことさえできます。

@cindex cross-posting
@cindex Xref
@cindex @sc{nov}
相互投稿を gnus が正しく扱えないようになる原因の一つは、@sc{nov} 行に 
@code{Xref} 欄を含まない、@sc{xover}（これは非常に良いです、というのはそれ
は速度をとても速くするからです）の使用可能な @sc{nntp} サーバーを使ってい
ることです。これは害悪なのですが、あぁ、悲しいかな、非常に良くある事です。
Gnus はあなたが読んだ全ての記事に @code{Xref} 行を登録する事で、正しい事を
しよう としますが、記事を削除するか、読まないで既読の印を付けると、gnus は
これらの記事に @code{Xref} の行をのぞきまわる機会を得る事が無く、相互参照
機構を用いる事ができません。

@cindex LIST overview.fmt
@cindex overview.fmt
あなたの @sc{nntp} サーバーがその概観ファイル (overview file) に
@code{Xref} 欄を含んでいるかを調べるには、@samp{telnet your.nntp.server
nntp} として、@code{inn} サーバーで @samp{More READER} とし、それから 
@samp{LIST overview.fmt} とする事を試してください。これは動作しないでしょ
うが、もし動作して、取得した最後の行が @samp{Xref:full} でないならば、ニュー
スの管理者が概観ファイルに @code{Xref} 欄を含むようにするまで、ニュース管
理者に叫び、泣き付く事を続けるべきでしょう。

@vindex gnus-nov-is-evil
Gnus にいつでも正しい @code{Xref} を取得するようにさせたいのであれば、
@code{gnus-nov-is-evil} を @code{t} にする必要があり、それは非常に速度を
遅くします。

ま、人生はそのようなものです。

代替手段に付いては @pxref{Duplicate Suppression} を参照してください。


@node Duplicate Suppression
@section 重複の抑制

ディフォルトでは gnus は相互投稿機構を利用する事によって、同じ記事を2回以
上読まないようにしようとします (@pxref{Crosspost Handling})。しかし、その
単純で効果的な方法は、いろいろな理由により、満足する結果をもたらさないかも
知れません。

@enumerate
@item
@sc{nntp} サーバーは @code{Xref} 欄の生成に失敗するかも知れません。これは
悪い事で、あまり起こりません。

@item
@sc{nntp} サーバーは @file{.overview} データベースに @code{Xref} 欄を含め
るのに失敗するかも知れません。これは悪い事で、非常に良くある事です、あぁ悲
しい。

@item
同じグループ（もしくはいくつかの関連したグループ）を違った @sc{nntp} サー
バーから読んでいるかもしれません。

@item
グループに投稿された記事と重複するメールを受け取ったかもしれません。
@end enumerate

@code{Xref} の扱いに失敗する状況は他にもありますが、これら４つがとても良く
ある状況です。

もし、本当にもしも @code{Xref} の扱いに失敗したら、@dfn{重複抑制}に切り替
える事を考えるかもしれません。そうすれば、gnus はあなたが読んだ全ての記事
かそうでなければ、既読の印が付いた全ての記事の @code{Message-ID} を記憶し、
それから、魔法のように、その後のそれらと出会った全ての場合に、既読の印を付
けます――@emph{全て}のグループで。この機構を使うのは非常に非効率的ですが、
過度に非効率なわけではありません。もちろん同じ記事を一回以上読むほうが好ま
しいです。

重複抑制はあまり繊細なものではありません。どちらかというと、大槌のようなも
のです。それは非常に単純な方法で動作しています――もし記事に既読の印を付け
れば、それはこの Message-ID を キャッシュに加えます。次にこのMessage-ID に
であったときは、@samp{M} 印によって記事に既読の印を付けます。それはその記
事がどのグループにあるかは気にしません。

@table @code
@item gnus-suppress-duplicates
@vindex gnus-suppress-duplicates
@code{nil} でなければ、重複抑制をします。

@item gnus-save-duplicate-list
@vindex gnus-save-duplicate-list
@code{nil} でなければ、重複のリストをファイルに保存します。これは起動と終
了の時間を長くしますので、初期状態では @code{nil} です。しかし、これは単一
の gnus の実行期で読まれた重複記事だけが抑制されるという事です。

@item gnus-duplicate-list-length
@vindex gnus-duplicate-list-length
この変数はどのくらい多くの @code{Message-ID} を重複抑制リストに保ってお
くかも決定します。ディフォルトは 10000 です。

@item gnus-duplicate-file
@vindex gnus-duplicate-file
重複抑制のリストを蓄積しておくファイルの名前です。ディフォルトは 
@file{~/News/suppression} です。
@end table

何度も gnus を終了して起動する傾向があるのであれば、おそらく 
@code{gnus-save-duplicate-list} を @code{t} にするのは良い考えでしょう。
もし gnus を続けて何週間も走らせておくのであれば、それを @code{nil} にす
るかもしれません。一方で、リストを保存する事は起動と終了をずっと遅くしま
すので、よく gnus を終了して起動するのであれば、
@code{gnus-save-duplicate-list} を @code{nil} に設定するべきであるという
事になります。うーむ。私はあなたがどうするかに任せたい、と思います。


@node The Article Buffer
@chapter 記事バッファ
@cindex article buffer

記事は一つしかない記事バッファに表示されます。全ての概略バッファは（gnus 
に共有しないように指示しない限り）同じ記事バッファを共有します。

@menu
* Hiding Headers::        どのヘッダーを表示するかを決める。
* Using MIME::            @sc{mime} 記事として見せる。
* Customizing Articles::  記事の見栄えを仕立てる。
* Article Keymap::        記事バッファで使えるキー操作。
* Misc Article::          その他。
@end menu


@node Hiding Headers
@section 余分なヘッダーを隠す
@cindex hiding headers
@cindex deleting headers

各記事の頭の部分はヘッダー(@dfn{head})と呼ばれます（残りの部分はボディ
(@dfn{body})です。すでにお気づきでしょうが）。

@vindex gnus-show-all-headers
ヘッダーにはたくさんの便利な情報が含まれています。記事を書いた人の名前、そ
れが書かれた日付、記事の表題などです。これはとても良いんですが、ヘッダーに
は大部分の人には見たくもない情報――記事があなたのところに着くまでどんなシ
ステムを経由してきたか、@code{Message-ID}, @code{References} などなど…も
うやんなっちゃうくらい――もたくさん含まれています。たぶんあなたはこれらの
行はいくつか取り除いてしまいたいと思うでしょう。もしこれらの行を全て記事バッ
ファ内に残しておきたければ、@code{gnus-show-all-headers} を @code{t} に設
定してください。

Gnus はヘッダーを選り分けるために2つの変数を用意しています。

@table @code

@item gnus-visible-headers
@vindex gnus-visible-headers
この変数が @code{nil} 以外であれば、どのヘッダーを記事バッファに
残したいかを指定する正規表現であるとみなされます。この変数にマッ
チしないヘッダーは全て隠されます。

例えば、記事を書いた人の名前と表題のみを見たければ、こう指定します。

@lisp
(setq gnus-visible-headers "^From:\\|^Subject:")
@end lisp

この変数は、表示させたいヘッダーにマッチする正規表現をリストで指
定することもできます。

@item gnus-ignored-headers
@vindex gnus-ignored-headers
この変数は @code{gnus-visible-headers} の反対です。この変数が設定されてい
れば（かつ @code{gnus-visible-headers} が @code{nil} であれば）、これは隠
したいヘッダー行全てにマッチする正規表現であるとみなされます。この変数にマッ
チしない全てのヘッダー行は表示されます。

例えば、単に @code{References} 欄と @code{Xref} 欄のみを消し去りたければ、
以下のようにします：

@lisp
(setq gnus-ignored-headers "^References:\\|^Xref:")
@end lisp

この変数は消したいヘッダーにマッチする正規表現のリストでも構いま
せん。

なお、@code{gnus-visible-headers} が @code{nil} 以外の場合は、こ
の変数には効果が無いことに注意してください。

@end table

@vindex gnus-sorted-header-list
Gnus はヘッダーの並べ替え(sort)も行います（これはディフォルトで行われます）。
この並べ替えは @code{gnus-sorted-header-list} 変数を設定することで制御する
ことができます。これはヘッダーをどういう順序で表示するかを指定する正規表現
のリストです。

例えば、記事の著者名を最初に、次に表題を表示したければ、こんな風
になるでしょう。

@lisp
(setq gnus-sorted-header-list '("^From:" "^Subject:"))
@end lisp

表示するようになっているヘッダーでこの変数に指定されていないもの
は、この変数に指定されている全てのヘッダーの後に、適当な順序で表
示されるでしょう。

@findex gnus-article-hide-boring-headers
@vindex gnus-article-display-hook
@vindex gnus-boring-article-headers
@code{gnus-article-hide-boring-headers} を
@code{gnus-article-display-hook} に入れることによって、もっとつ
まらないヘッダーを隠すことができます。この関数が何をするかは
@code{gnus-boring-article-headers} 変数に依存します。この変数は
リストですが、このリストには実際のヘッダーの名前が入るのではあり
ません。代わりに gnus がチェックして視界から消し去るためのさまざ
まな「つまらない条件」@dfn{boring conditions} のリストを指定しま
す。

この条件には以下のようなものがあります。
@table @code
@item empty
空のヘッダーを全て消去します。
@item newsgroups
@code{Newsgroups} 欄が現在のグループ名しか含んでいない場合には消去します。
@item followup-to
@code{Followup-To} 欄が @code{Newsgroups} 欄と同一である場合には消去します。
@item reply-to
@code{Reply-To} 欄が @code{From} 欄と同じアドレスを示している場合には消去
します。
@item date
その記事が過去３日以内のものであれば、@code{Date} 欄を消去します。
@item long-to
@code{To} 欄があまりにも長い場合には消去します。
@item many-to
@code{To} 欄が一つよりも多ければ、それらを全て消去します。
@end table

上記の最初の４つの要素を入れたければ、こんな風になります。

@lisp
(setq gnus-boring-article-headers
      '(empty followup-to reply-to))
@end lisp

これはこの変数のディフォルト値でもあります。


@node Using MIME
@section @sc{mime} を使う
@cindex @sc{mime}

パントマイム (mime) とは、意味も無く空中で手を振るものとして広く
知られており、その間観客はあくびをしながらぼんやりとしてます。

一方、@sc{mime} とは、意味も無く記事を符号化する標準であり、その
ために全てのニュースリーダが恐怖で死んでしまうものです。

@sc{mime} はその記事がどんな文字集合を使用しているか、その文字をどう符号化
しているかを指定することができ、さらには絵やその他のみだらなものを無邪気な
格好の記事で埋め込むことさえ可能にします。

@vindex gnus-show-mime
@vindex gnus-article-display-method-for-mime
@vindex gnus-strict-mime
@findex gnus-article-display-mime-message
Gnus は @code{gnus-article-display-method-for-mime} に記事を押し付けるこ
とで @sc{mime} を扱います。この初期値は
@code{gnus-article-display-mime-message} です。この関数は SEMI MIME-View 
プログラムを呼び出して実際の処理を行います。SEMI MIME-View に関する詳し
い情報は、マニュアルを参照してください（まだないけど(;_;)）。

@sc{mime} を常に使用したければ、@code{gnus-show-mime} を 
@code{t} に設定してください。しかし、@code{gnus-strict-mime} が 
@code{nil} 以外であれば、@sc{mime} 処理は記事中に @sc{mime} ヘッ
ダーがあるときのみ使用されます。@code{gnus-show-mime} を設定して
いると、運が悪いと記事バッファには故障したような画面が見えること
もあるでしょう。これは避けようがありません。

GNUS や Gnus では、このたちの悪い問題で驚かされないようにするには、概略バッ
ファにおいて切り替え機能を使うというのが最善かも知れません（例えば、
@samp{alt.sing-a-long} グループに入ると、あなたの気づかないうちに
@sc{mime} は記事中のサウンドファイルを復号して、何やら怪しげな長い長い歌が
あなたのスピーカーから大音響で流れ出し、あなたはボリュームボタンを見つけら
れず、というのはそんなものはもともとついてないからで、みんなはあなたの方を
睨みはじめ、あなたはプログラムを止めようとするけどできなくて、ボリュームを
制御するプログラムも見つけられなくて、そして部屋中の全員は突然あなたのこと
を軽蔑の眼差しで見るようになってしまい、あなたはちょっと面白くない思いをす
る、とか）。

現実の出来事と実在の人物に類似しているかもしれませんが、これは全
てホントのことです。げほげほ。


@node Customizing Articles
@section 記事のカスタマイズ
@cindex article customization

@vindex gnus-article-display-hook
@code{gnus-article-display-hook} は記事が記事バッファに書き込ま
れた直後に呼び出されます。これは記事が表示される前の処理を全て扱
う、ということです。

@findex gnus-article-maybe-highlight
@findex gnus-article-maybe-hide-headers
初期設定ではではこのフックには @code{gnus-article-maybe-hide-headers},
@code{gnus-hide-boring-headers}, @code{gnus-article-treat-overstrike},
@code{gnus-article-maybe-highlight} (XEmacs では、
@code{gnus-article-display-x-face} も) だけが含まれていますが、このフッ
クに入れることができる関数は何千も、いや何百万もあります。各関数の概観は
@pxref{Article Highlighting}, @pxref{Article Hiding}, @pxref{Article
Washing}, @pxref{Article Buttons}, @pxref{Article Date} を参照してくださ
い。注意点として、このフックでは関数の順序が影響することがあるので、お望
みの結果を得るにはちょっと手間取ってしまうかもしれません。

もちろん、あなた独自の関数を書くこともできます。この関数は記事バッファ内か
ら呼び出され、あなたのやりたいことをほとんど何でもできます。バッファに残し
ておかなければならない情報は何もありません――何でも変更することができます。
ですが、ヘッダーは消去しない方が良いです。その代わり、ヘッダーをどこかにやっ
てしまいたければ、それらを見えないようにしてください。

@node Article Keymap
@section 記事のキー操作

概略バッファにおけるキー操作のほとんどは記事バッファでも使用でき
ます。これらは概略バッファでそのキーを押したかのように動作します。
つまり、実は記事を読んでいる間、概略バッファを表示させておく必要
もないということです。全ての操作は記事バッファから行うことができ
るのです。

それらに加えていくつかのキー操作が利用できます。

@table @kbd

@item SPACE
@kindex SPACE (Article)
@findex gnus-article-next-page
一頁前にめくります (@code{gnus-article-next-page})。

@item DEL
@kindex DEL (Article)
@findex gnus-article-prev-page
一頁後ろに戻します (@code{gnus-article-prev-page})。

@item C-c ^
@kindex C-c ^ (Article)
@findex gnus-article-refer-article
カーソル位置が @code{Message-ID} の近辺にあるときに @kbd{C-c ^} を押
すと、gnus はサーバーからその記事を取ってこようとします
(@code{gnus-article-refer-article})。

@item C-c C-m
@kindex C-c C-m (Article)
@findex gnus-article-mail
カーソル位置の近くにあるアドレスに返信を送ります
(@code{gnus-article-mail})。接頭引数を与えると、そのメールに引用
します。

@item s
@kindex s (Article)
@findex gnus-article-show-summary
バッファを再構成して、概略バッファを見えるようにします
(@code{gnus-article-show-summary})。

@item ?
@kindex ? (Article)
@findex gnus-article-describe-briefly
利用できるキー操作のごく簡単な説明を出します
(@code{gnus-article-describe-briefly})。

@item TAB
@kindex TAB (Article)
@findex gnus-article-next-button
次のボタンがあればそこに移動します 
(@code{gnus-article-next-button})。これはボタン機能をオンにして
いるときのみ意味を持ちます。

@item M-TAB
@kindex M-TAB (Article)
@findex gnus-article-prev-button
一つ前のボタンがあればそこに移動します 
(@code{gnus-article-prev-button})。

@end table


@node Misc Article
@section 記事のその他

@table @code

@item gnus-single-article-buffer
@vindex gnus-single-article-buffer
@code{nil} 以外であれば、全てのグループに対して同じ記事バッファを使用しま
す（これはディフォルトです）。@code{nil} であれば、各グループ毎の固有の記
事バッファを持つようになります。

@vindex gnus-article-prepare-hook
@item gnus-article-prepare-hook
このフックは記事が記事バッファに書き込まれた直後に呼び出されます。
これは主に、何か記事の内容に依存する処理をする関数のために用意さ
れています。つまり記事バッファの内容を変更するような目的で使うべ
きではないでしょう。

@vindex gnus-article-display-hook
@item gnus-article-display-hook
このフックは記事を表示するときの最後に呼び出されるようになってい
て、記事バッファの内容の修正、ハイライト処理、ヘッダーを隠す、な
どといったことを行うために用意されています。

@item gnus-article-mode-hook
@vindex gnus-article-mode-hook
記事モードバッファで呼び出されるフックです。

@item gnus-article-mode-syntax-table
@vindex gnus-article-mode-syntax-table
記事バッファで用いられるシンタックステーブルです。これは
@code{text-mode-syntax-table} をもとに初期化されます。

@vindex gnus-article-mode-line-format
@item gnus-article-mode-line-format
この変数は @code{gnus-summary-mode-line-format} と同じ行に従った様式文字
列です (@pxref{Mode Line Formatting})。これは以下の一つの拡張を除いて、
その変数と同じ様式指定を受付けます。

@table @samp
@item w
記事の「洗濯状態」@dfn{wash status}。これは記事に対して行われた
であろう洗濯操作を示す一文字からなる短い文字列になります。
@end table

@vindex gnus-break-pages

@item gnus-break-pages
改頁 @dfn{page breaking} を行うかどうかを制御します。この変数が
@code{nil} 以外であれば、記事中に頁区切り文字が現れた場所ごとに
頁分割します。この変数が @code{nil} であれば頁分けは行われません。

@item gnus-page-delimiter
@vindex gnus-page-delimiter
これが上で触れた区切り文字です。ディフォルトでは @samp{^L} (フォー
ムフィード、改頁) です。
@end table


@node Composing Messages
@chapter メッセージの作成
@cindex composing messages
@cindex messages
@cindex mail
@cindex sending mail
@cindex reply
@cindex followup
@cindex post

@kindex C-c C-c (投稿)
全ての投稿とメールの命令は、@kbd{C-c C-c} を押す事によって、記事を送信する
前に記事を好きなように編集する事のできる、メッセージバッファに移動します。
@xref{Top, , Top, message, The Message Manual}。もし外部ニュースグループに
いて、記事を外部サーバーを使って投稿したいのであれば、@kbd{C-c C-c} に接頭
引数を与えて、gnus に外部サーバーを使って投稿しようと試させる事ができます。

@menu
* Mail::                 メールと返答。
* Post::                 投稿とフォローアップ。
* Posting Server::       どのサーバーを通して投稿するべきか？
* Mail and Post::        同時にメールを出し返答する。
* Archived Messages::    送ったメッセージを gnus が貯めておくところ。
* Posting Styles::       あなたが誰であるかを指定するより簡単な方法。   
* Drafts::               メッセージの延期と拒否されたメッセージ。
* Rejected Articles::    サーバーがあなたの記事を好きでないときに何が起こる？
@end menu

投稿するべきでなかった記事を削除するための情報は @pxref{Canceling and
Superseding} を参照してください。


@node Mail
@section メール

出て行くメールをカスタマイズする変数です：

@table @code
@item gnus-uu-digest-headers
@vindex gnus-uu-digest-headers
要約メッセージ (digested message) に含まれるヘッダーに合致する正規表現の
リストです。ヘッダーは合致した順に取り込まれます。

@item gnus-add-to-list
@vindex gnus-add-to-list
@code{nil} でなければ、@kbd{a} をしたときに、@code{to-list} グループパラ
メータをそれのないメールグループに付け加えます。

@end table


@node Post
@section 投稿

ニュース記事作成のための変数：

@table @code
@item gnus-sent-message-ids-file
@vindex gnus-sent-message-ids-file
Gnus は送信した全てのメールの @code{Message-ID} 履歴ファイル (history
file) を保存します。もしメールを既に送った事が発見されたなら、利用者にメー
ルを再送するかどうかを尋ねます。（これは主に同じパケットを複数回送る傾向の
ある @sc{soup} パケットや、それに似たようなものを扱っているときに役に立ち
ます。）この変数はこの履歴ファイルがどこにあるかを指定します。ディフォルト
では @file{~/News/Sent-Message-IDs} です。Gnus が履歴ファイルを保持する事
を望まないのであれば、この変数を @code{nil} に設定する事ができます。

@item gnus-sent-message-ids-length
@vindex gnus-sent-messages-ids-length
この変数はどれくらい多くの @code{Message-ID} を履歴ファイルに保持するか
を指定します。ディフォルトでは 1000 です。

@end table


@node Posting Server
@section 投稿するサーバー

最新の（もちろん、非常に知的な）記事を送り出すために、あの魔法のような
@kbd{C-c C-c} キーを押した時、それはどこにいくのでしょう？

尋ねてくれてありがとう。あなたを恨みます。

@vindex gnus-post-method

それは非常に複雑になり得ます。普通は、gnus は同じ基本サーバーを使用します。
しかし。あなたの基本サーバーが投稿を許可せず、読むことのみを許可しているの
ならば、おそらくあなたの（非常に知的でとんでもなく興味深い）記事を投稿する
ために、他のサーバーを使いたいと思うでしょう。@code{gnus-post-method} を他
の方法に設定する事ができます。

@lisp
(setq gnus-post-method '(nnspool ""))
@end lisp

さて、この設定をした後でサーバーがあなたの記事を拒否したり、サーバーが落ち
ていたりしたら、どうしたらよいのでしょう？この変数を上書きするために、命令 
@kbd{C-c C-c} に零でない接頭引数を与える事で、投稿に『現在の』サーバーを使
わせる事ができます。

もし、零接頭引数をその命令に与えたなら（すなわち、@kbd{C-u 0 C-c C-c}）、
gnus は投稿にどの方法を使うかをあなたに尋ねます。

@code{gnus-post-method} を選択方法のリストにする事もできます。その場合は、
gnus は常に投稿にどの方法を使うかをあなたに尋ねます。


@node Mail and Post
@section メールと投稿

これはメールを出す事と投稿する事の両方に関連する変数のリストです：

@table @code
@item gnus-mailing-list-groups
@findex gnus-mailing-list-groups
@cindex mailing lists

もしあなたのニュースサーバーが本当にメーリングリストから @sc{nntp} サー
バーへのゲートウェイを提供しているのであれば、それらのグループは問題なく
読めるでしょう。しかし簡単にはそれらに投稿/フォローアップすることはでき
ません。一つの解決法は グループパラメータ (@pxref{Group Parameters}) に 
@code{to-address} を加える事です。簡単にできるのは、
@code{gnus-mailing-list-groups} を、本当にメーリングリストであるようなグ
ループに合致する正規表現に設定することです。その後は、すくなくとも、メー
リングリストへのフォローアップはたいていのときに動作します。これらのグルー
プに投稿する事は (@kbd{a}) それでも苦痛を引き起こすでしょうけど。

@end table

あなたは自分が送るメッセージの綴りを調べたいと思うかも知れません。もしく
は、もし手で綴り調べをしたくないのであれば、自動綴り調べを @code{ispell}
パッケージを使う事によって付け加える事ができます：

@cindex ispell
@findex ispell-message
@lisp
(add-hook 'message-send-hook 'ispell-message)
@end lisp


@node Archived Messages
@section メッセージの保管
@cindex archived messages
@cindex sent messages

Gnus はあなたが送ったメールとニュースを貯めておくためのいくつかの違った方
法を提供します。ディフォルトの方法はメッセージを保存するために@dfn{事実上
の書庫サーバー}(archive virtual server)を使います。これを完全に禁止したい
のであれば、変数 @code{gnus-message-archive-group} は @code{nil} になるべ
きで、これがディフォルトです。

@vindex gnus-message-archive-method
@code{gnus-message-archive-method} は送ったメッセージを蓄積するためにどの
事実上のサーバーを gnus が使うべきかを指定します。ディフォルトは：

@lisp
(nnfolder "archive"
          (nnfolder-directory   "~/Mail/archive")
          (nnfolder-active-file "~/Mail/archive/active")
          (nnfolder-get-new-mail nil)
          (nnfolder-inhibit-expiry t))
@end lisp

しかし、どのメール選択方法でも使う事ができます（@code{nnml},
@code{nnmbox} などなど）。しかし @code{nnfolder} はこのような事をするのに
とても好ましい選択方法です。ディフォルトのディレクトリー選択を好きでないな
らば、次のようにできます：

@lisp
(setq gnus-message-archive-method
      '(nnfolder "archive"
                 (nnfolder-inhibit-expiry t)
                 (nnfolder-active-file "~/News/sent-mail/active")
                 (nnfolder-directory "~/News/sent-mail/")))
@end lisp

@vindex gnus-message-archive-group
@cindex Gcc
Gnus は外へ出て行く全てのメッセージに、一つかそれ以上のそのサーバーのグルー
プへ向かう @code{Gcc} 欄を挿入します。どのグループを使うかは変数 
@code{gnus-message-archive-group} によって決まります。

この変数は次のような事をするために使われます：

@itemize @bullet
@item 文字列
メッセージはそのグループに保存されます。
@item 文字列のリスト
メッセージはそれらの全てのグループに保存されます。
@item 正規表現、関数、様式の連想リスト
キーが『合致』すると、結果が使われます。
@item @code{nil}
メッセージの保存は行われません。これがディフォルトです。
@end itemize

試してみましょう：

@samp{MisK} と呼ばれる一つのグループに保存するならば：
@lisp
(setq gnus-message-archive-group "MisK")
@end lisp

2つのグループ、@samp{MisK} と @samp{safe} に保存するならば：
@lisp
(setq gnus-message-archive-group '("MisK" "safe"))
@end lisp

どのグループにいるかによって違ったグループに保存するなら：
@lisp
(setq gnus-message-archive-group
      '(("^alt" "sent-to-alt")
        ("mail" "sent-to-mail")
        (".*" "sent-to-misc")))
@end lisp

もっと複雑なもの：
@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          "misc-mail")))
@end lisp

全てのニュースメッセージを一つのファイルに保存して、メールメッセージを一月
につき一つのファイルに保存するには：

@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          (concat "mail." (format-time-string
                           "%Y-%m" (current-time))))))
@end lisp

（XEmacs 19.13 には @code{format-time-string} はありませんので、その 
@code{gnus-message-archive-group} のために違った値を使わなければなりません。）

今や、メッセージを送ると、それは適切なグループに保存されます。（もし特定の
メッセージに対して保存をしたくないのであれば、挿入された @code{Gcc} 欄を取
り除いてください。）保管グループは次に gnus を起動したときか、次にグループ
バッファで @kbd{F} を押したときにグループバッファに現れます。他のグループ
と同じようにそのグループに入って、記事を読む事ができます。そのグループが本
当に大きくなって嫌になったら、なにか良いものにその名前を変更する事ができま
す（グループバッファで @kbd{G r} を使う事によって）――
@samp{misc-mail-september-1995} や他のもに。新しいメッセージは古い（今は空
になった）グループに溜められます。

以上が送ったメッセージを保管するディフォルトの方法です。Gnus はディフォ
ルトの方法を好きではない人には違ったやり方を勧めています。そのような場合
は、@code{gnus-message-archive-group} を @code{nil} に設定するべきです。
これは保管をしないようにします。

@table @code
@item gnus-outgoing-message-group
@vindex gnus-outgoing-message-group
全ての外にいくメッセージはこのグループに入れられます。もし全ての外に行く
メールと記事をグループ @samp{nnml:archive} に保管したいのであれば、この
変数をその値に設定する事ができます。この変数はグループ名のリストである事
もできます。

もしそれぞれのメッセージをどのグループに入れるかをもっと制御したいのであれ
ば、この変数を現在のニュースグループ名を調べて、適切なグループ名（もしくは
名前のリスト）を返す関数に設定する事ができます。

この変数は @code{gnus-message-archive-group} の代わりに使う事ができます
が、後者の方が好ましい方法です。
@end table


@node Posting Styles
@section 投稿様式
@cindex posting styles
@cindex styles

それらはすべて変数で、それは私の頭を泳がせます。

それで、なぜどのグループに投稿するかによって違った @code{Organization} 
と署名を望むのでしょうか？そして、あなたは家庭のマシンと職場のマシンの両
方から投稿して、違った @code{From} 行やその他のものを望むのですか？

@vindex gnus-posting-styles
そのような事をする方法の一つは変更される必要のある変数を変更する賢いフッ
クを書く事です。それは少し退屈なので、利用者にこれらの事を手軽な連想リス
トで指定するというすばらしい着想にたどり着いた人がいました。これは変数 
@code{gnus-posting-styles} の例です:

@lisp
((".*"
   (signature "Peacs and happiness")
   (organization "What me?"))
 ("^comp"
  (signature "Death to everybody"))
 ("comp.emacs.i-love-it"
  (organization "Emacs is it")))
@end lisp

この例から推測されるように、この連想リストはいくつかの @dfn{様式}
(style) からなっています。それぞれの様式は最初の要素が何らかの形で ``合
致'' したときに適用されます。連想リスト全体は最初から最後まで反復して実
行され、それぞれの合致が適用されます。これは、後の様式の属性が前に合致し
た様式の属性を上書きすると言う事です。ですから、
@samp{comp.programming.literate} は、署名 @samp{Death to everybody} と 
@code{Organization} ヘッダー @samp{What me?} を持ちます。

それぞれの様式の最初の要素は @code{合致} (match) と呼ばれます。もしそれ
が文字列であれば、gnus はそれをグループ名に正規表現として合致操作を行い
ます。もしそれが関数のシンボルであれば、その関数が引数無しで呼ばれます。
それが変数のシンボルであれば、その変数が参照されます。それがリストであれ
ば、そのリストが @code{評価} されます。どの場合でも、これが @code{nil} 
でない値を帰せば、様式は @code{合致した} と言います。

それぞれの様式は任意の量の @dfn{属性} を持つ事ができます。それぞれの属性
は @var{(name . value)} の対により成り立っています。属性名は、
@code{signature}, @code{signature-file}, @code{organization},
@code{address}, @code{name}, @code{body} のどれかである事ができます。属
性名は文字列である事もできます。その場合は、これはヘッダー名として使われ、
その値が記事のヘッダーに挿入されます。

属性値は文字列 (そのまま使われます)、関数 (返り値が使われます)、変数 (そ
の値が使われます)、リスト (それは @code{評価} されて、返り値が使われます) 
である事ができます。

もし、作成しようとしているメッセージがニュース記事かメールメッセージであ
るかを調べたいときは、2つの動的に束縛される変数 
@code{message-this-is-news} と @code{message-thiss-is-mail} を調べる事が
できます。

@vindex message-this-is-mail
@vindex message-this-is-news

そして、これは例です:

@lisp
(setq gnus-posting-styles
      '((".*"
         (signature-file "~/.signature")
         (name "User Name")
         ("X-Home-Page" (getenv "WWW_HOME"))
         (organization "People's Front Against MWM"))
        ("^rec.humor"
         (signature my-funny-signature-randomizer))
        ((equal (system-name) "gnarly")
         (signature my-quote-randomizer))
        (message-this-is-news
         (signature my-news-signature))
        (posting-from-work-p
         (signature-file "~/.work-signature")
         (address "user@@bar.foo")
         (body "You are fired.\n\nSincerely, your boss.")
         (organization "Important Work, Inc"))
        ("^nn.+:"
         (signature-file "~/.mail-signature"))))
@end lisp


@node Drafts
@section 下書き
@cindex drafts

もしメッセージ（メールもしくはニュース）を書いているときに、突然オーブン
にステーキが入っている事を思い出したなら（もしくは、あなたがとーってもす
ごい菜食主義者で、茎をフードプロセッサーをいれているなら）、書いているメッ
セージを保存する方法があれば良いと思うでしょう。そうすれば、いつか別の日
に編集を続ける事ができ、それが完成したと思ったときに送る事ができます。

えぇ、心配しないでください。Gnus のメールと投稿命令を使う何らかのメッセー
ジを書き始めたときに、手に入れるバッファは自動的に特別な @dfn{draft} グルー
プに関連付けられます。普通の方法でバッファを保存すれば（たとえば、
@kbd{C-x C-s}）、その記事はそこに保存されます。（自動保存ファイルも下書き
グループ (draft group) に行きます。）

@cindex nndraft
@vindex nndraft-directory
下書きグループは @samp{nndraft:draftx} と呼ばれる特別なグループ です（もし
あなたが全てを知らなければならないのであれば、それは @code{nndraft} グルー
プとして実装されています）。変数 @code{nndraft-directory} はそのファイルを 
@code{nndraft} がどこに保管するべきかを指定します。このグループが特別であ
るというのは、その中の記事を永可視にしたり既読の印を付けたりできないからで
す――グループの全ての記事は永久に未読です。

もしグループが存在しないなら、それは作成され、購読されます。グループバッ
ファからそれを消し去る唯一の方法は、それを未購読にすることです。

@c @findex gnus-dissociate-buffer-from-draft
@c @kindex C-c M-d (Mail)
@c @kindex C-c M-d (Post)
@c @findex gnus-associate-buffer-with-draft
@c @kindex C-c C-d (Mail)
@c @kindex C-c C-d (Post)
@c If you're writing some super-secret message that you later want to
@c encode with PGP before sending, you may wish to turn the auto-saving
@c (and association with the draft group) off.  You never know who might be
@c interested in reading all your extremely valuable and terribly horrible
@c and interesting secrets.  The @kbd{C-c M-d}
@c (@code{gnus-dissociate-buffer-from-draft}) command does that for you.
@c If you change your mind and want to turn the auto-saving back on again,
@c @kbd{C-c C-d} (@code{gnus-associate-buffer-with-draft} does that.
@c
@c @vindex gnus-use-draft
@c To leave association with the draft group off by default, set
@c @code{gnus-use-draft} to @code{nil}.  It is @code{t} by default.

@findex gnus-draft-edit-message
@kindex D e（下書き）
記事の編集を続けたいときは、下書きグループに入って @kbd{D e}
(@code{gnus-draft-edit-message}) を押すだけです。あなたが残した状態のバッ
ファに移動します。

拒否された記事もこの下書きグループに入れられます (@pxref{Rejected
Articles})。

@findex gnus-draft-send-all-messages
@findex gnus-draft-send-message
それ以上編集しないで投稿（もしくはメール）したい拒否されたメッセージがたく
さんあるのであれば、命令 @kbd{D s} を使う事ができます。この命令はプロセス
/接頭引数の習慣を理解します (@pxref{Process/Prefix})。命令 @kbd{D S}
(@code{gnus-draft-send-all-messages}) はバッファの全てのメッセージを送り出
します。

送りたくないメッセージがいくつかあるのであれば、命令 @kbd{D t}
(@code{gnus-draft-toggle-sending}) を使ってメッセージを配送不可の印を付
ける事ができます。これは切り替え命令です。


@node Rejected Articles
@section 拒否された記事
@cindex rejected articles

時々ニュースサーバーは記事を拒否します。おそらくサーバーはあなたの顔を好き
ではないのでしょう。おそらくそれは惨めに感じたからでしょう。おそらく 
@emph{悪魔 (demon) がいるのでしょう}。 おそらく引用文を入れすぎたのでしょ
う。おそらくディスクが一杯だったのでしょう。おそらくサーバーが落ちていたの
でしょう。

これらの状況は、もちろん、完全に gnus の扱える範囲外です。（Gnus は、もち
ろん、あなたの外見を愛しており、いつも機嫌が良く、中を飛び回る天使がいて、
どれくらい引用文が含まれていようと気にせず、一杯になったり、落っこちたり
しません。）ですから、gnus はこれらの記事を後でサーバーの気分がよくなる
まで保存します。

拒否された記事は自動的に特別な下書きグループ (@pxref{Drafts}) に入れられ
ます。サーバーが戻ってきたなら、普通はそのグループに入って全ての記事を送
ります。


@node Select Methods
@chapter 選択方法
@cindex foreign groups
@cindex select methods

@dfn{外部グループ} (foreign group) とは、普通 (もしくはディフォルト) の
方法で読まれないグループの事です。例えば、それは違った @sc{nntp} サーバー
のグループであったり、事実上のグループであったり、個人的なメールグループ
であったりするでしょう。

外部グループ (もしくは、本当に全てグループ) は @dfn{名前} と 
 @dfn{選択方法} で指定されます。後者を先に例に出すと、選択方法は最初の要
素がどのバックエンドを使うか (たとえば、@code{nntp}、@code{nnspool}、
@code{nnml}) で、2つめの要素が @dfn{サーバー名} である連想リストです。選
択方法には、その当のバックエンドにとって特別の意味を持つ値である追加の要
素があるかも知れません。

選択方法は @dfn{事実上のサーバー} を定義すると言うことができるかもしれま
せん---ですから私たちはちょうどそれをしました (@pxref{The Server
Buffer})。

グループの @dfn{名前} はバックエンドがグループを認識する名前です。

たとえば、@sc{nntp} サーバーのグループ @samp{soc.motss} は名前 
@samp{soc.motss} と選択方法 @code{(nntp "some.where.edu")} を持ちます。
@code{nntp} バックエンドはこのグループを @samp{soc.motss} として知ってい
るだけですが、gnus はこのグループを @samp{nntp+some.where.edu:soc.motss} 
と呼びます。

もちろん、違った方法は全てそれ特有のものがあります。

@menu
* The Server Buffer::     事実上のサーバーを作って編集する。
* Getting News::          USENET ニュースを gnus で読む。
* Getting Mail::          個人的なメールを gnus で読む。
* Other Sources::         ディレクトリー、ファイル、SOUP パケットを読む。
* Combined Groups::       複数のグループを一つのグループに結合する。
* Gnus Unplugged::        ニュースとメールをオフラインで読む。
@end menu

@node The Server Buffer
@section サーバーバッファ

伝統的に、@dfn{サーバー} はそれに接続して、それから情報を要求するマシン
かソフトウェアです。

@menu
* Server Buffer Format::      このバッファの外見をカスタマイズできる。
* Server Commands::           サーバーを操る命令。
* Example Methods::           サーバー指定の例。
* Creating a Virtual Server:: セッションの例。
* Server Variables::          どの変数を設定するか。
* Servers and Methods::       サーバー名を選択方法として使う事ができる。
* Unavailable Servers::       接続しようと試みたサーバーのいくつかが落ちているかもしれない。
@end menu

@vindex gnus-server-mode-hook
サーバーバッファを作成するときに @code{gnus-server-mode-hook} が実行されます。

@node Server Buffer Format
@subsection サーバーバッファの表示様式
@cindex server buffer format

@vindex gnus-server-line-format
サーバーバッファの行の外見を、変数 @code{gnus-server-line-format} 変数を
変更する事によって変える事ができます。これは @code{format} のような変数
で、すこし単純な拡張がなされています:

@table @samp

@item h
どのようにニュースが取得されるか---バックエンドの名前。

@item n
サーバーの名前。

@item w
どこからニュースが取得されるべきか---アドレス。

@item s
サーバーの接続の 開いた/閉じた/拒否された 状態。
@end table

@vindex gnus-server-mode-line-format
モード行も変数 @code{gnus-server-mode-line-format} を使う事によってカス
タマイズする事ができます (@pxref{Mode Line Formatting})。以下の指定は理
解されます:

@table @samp
@item S
サーバー名。

@item M
サーバー方法。
@end table

@pxref{Formatting Variables} も参照してください。


@node Server Commands
@subsection サーバー命令
@cindex server commands

@table @kbd

@item a
@kindex a (サーバー)
@findex gnus-server-add-server
新しいサーバーを追加します (@code{gnus-server-add-server})。

@item e
@kindex e (サーバー)
@findex gnus-server-edit-server
サーバーを編集します (@code{gnus-server-edit-server})。

@item SPACE
@kindex SPACE (サーバー)
@findex gnus-server-read-server
現在のサーバーをざっと眺めます (@code{gnus-server-read-server})。

@item q
@kindex q (サーバー)
@findex gnus-server-exit
グループバッファに戻ります (@code{gnus-server-exit})。

@item k
@kindex k (サーバー)
@findex gnus-server-kill-server
現在のサーバーを切ります (kill) (@code{gnus-server-kill-server})。

@item y
@kindex y (サーバー)
@findex gnus-server-yank-server
先ほど切られた (killed) サーバーを貼り付けます (yank)
(@code{gnus-server-yank-server})。

@item c
@kindex c (サーバー)
@findex gnus-server-copy-server
現在のサーバーを複写します (@code{gnus-server-copy-server})。

@item l
@kindex l (サーバー)
@findex gnus-server-list-servers
全てのサーバーの一覧を挙げます (@code{gnus-server-list-servers})。

@item s
@kindex s (サーバー)
@findex gnus-server-scan-server
サーバーにその資源から新しい記事を調べるように要求します
(@code{gnus-server-scan-server})。これは主にメールサーバーに対して意味を
持ちます。

@item g
@kindex g (サーバー)
@findex gnus-server-regenerate-server
サーバーが全てのデータ構造を再作成するように求めます
(@code{gnus-server-regenerate-server})。これは同期からはずれてしまったメー
ルバックエンドがあるときに役に立ちます。

@end table


@node Example Methods
@subsection 方法の例

ほとんどの選択方法は非常に簡単で、自分自身をよく説明しています:

@lisp
(nntp "news.funet.fi")
@end lisp

直接スプールから読むのはもっと簡単です:

@lisp
(nnspool "")
@end lisp

見たとおり、選択方法の最初の要素はバックエンドの名前で、2番目は 
@dfn{アドレス} (address) 、もしくはそう呼びたいのであれば、@dfn{名前} で
す。

これらの2つの要素の後には、任意の数の @var{(変数 様式)} の対を入れる事が
できます。

最初の例に戻りましょう---そのマシンのポート15から読みたかったと思ってく
ださい。これがその時に、なるべき選択方法です:

@lisp
(nntp "news.funet.fi" (nntp-port-number 15))
@end lisp

どの変数が関連するかを見つけるために、それぞれのバックエンドの説明文書を
読むべきでしょうが、これは @code{nnmh} の例です。

@code{nnml} はスプールのような構造で読むメールバックエンドです。例えば、
接触を図りたい2つの構造があるとしましょう: 一つはあなたの私的なメールス
プールで、他方は公的なものです。これは私的なメールのために使用可能な指定
です:

@lisp
(nnmh "private" (nnmh-directory "~/private/mail/"))
@end lisp

(そうするとこのサーバーは @samp{private} と呼ばれますが、あなたは既に推
測していたかもしれません。)

これは公的スプールのための方法です:

@lisp
(nnmh "public"
      (nnmh-directory "/usr/information/spool/")
      (nnmh-get-new-mail nil))
@end lisp

防壁 (firewall) の中にいて、防壁マシンからの @sc{nntp} サーバーへの接続
しかないのであれば、gnus に防壁マシンに @code{rlogin} して、そこから 
@sc{nntp} サーバーに telnet をするように指示する事ができます。
これをする事は少しばからしいですが、事実上のサーバーの定義はおそらくこの
ようなものになるべきです:

@lisp
(nntp "firewall"
      (nntp-address "the.firewall.machine")
      (nntp-open-connection-function nntp-open-rlogin)
      (nntp-end-of-line "\n")
      (nntp-rlogin-parameters
       ("telnet" "the.real.nntp.host" "nntp")))
@end lisp

もし、すばらしい @code{ssh} プログラムを、モデム線からの圧縮された接続を
提供するために使いたいのであれば、このような感じの事実上のサーバーを作る
事ができます:

@lisp
(nntp "news"
      (nntp-address "copper.uio.no")
      (nntp-rlogin-program "ssh")
      (nntp-open-connection-function nntp-open-rlogin)
      (nntp-end-of-line "\n")
      (nntp-rlogin-parameters
       ("telnet" "news.uio.no" "nntp")))
@end lisp

これはもちろん、自動認証を提供するために @code{ssh-agent} を適切に設定し
なければなりません。圧縮された接続を得るためには、@code{ssh}のファイル 
@file{config} で @samp{Compression} オプションがある必要があります。


@node Creating a Virtual Server
@subsection 事実上のサーバーを作成する

もしあなたは永続記事を使ってたくさんの記事をキャッシュに保存しているので
あれば、キャッシュを読むための事実上のサーバーを作りたいと思うかもしれま
せん。

最初に、新しいサーバーを付け加える必要があります。命令 @kbd{a} がそれを
します。おそらくキャッシュを読むためには @code{nnspool} を使うのが一番良
いでしょう。@code{nnml} や @code{nnmh} も使う事ができますけど。

@kbd{a nnspool RET cache RET} と打ってください。

今や全く新しい @samp{cache} と呼ばれる @code{nnspool} の事実上のサーバー
あるはずです。次はそれを編集して、正しい定義を与えるだけです。サーバーを
編集するために @kbd{e} を打ってください。以下のものを含むバッファに入る
でしょう。

@lisp
(nnspool "cache")
@end lisp

それを次のものに変更してください:

@lisp
(nnspool "cache"
         (nnspool-spool-directory "~/News/cache/")
         (nnspool-nov-directory "~/News/cache/")
         (nnspool-active-file "~/News/cache/active"))
@end lisp

サーバーバッファに戻るために @kbd{C-c C-c} と打ってください。今やこの事
実上のサーバーで @kbd{RET} を押すと、閲覧バッファに入るべきで、表示され
ているどのグループにでも入る事ができるはずです。


@node Server Variables
@subsection サーバー変数

変数を定義する一つのやっかいな点は (バックエンドと Emacs 一般の両方で)、
変数の定義がロードされるている間に、いくつかの変数は他の変数から初期化さ
れるという事です。もし "基となる" 変数がロードされた後に変更しても、"導
き出された" 変数は変更されません。

これは普通はディレクトリーやファイルの変数に影響します。例えば、
@code{nnml-directory} はディフォルトで @file{~/Mail} ですが、全ての 
@code{nnml} ディレクトリー変数はその変数によって初期化されるので、
@code{nnml-active-file} は @file{~/Mail/active} になります。もし新しい事
実上の @code{nnml} サーバーを定義した場合、@code{nnml-directory} を設定
するだけでは充分では@emph{ありません}---あなたは望んだ状態になるように、
全てのファイル変数を明示的に設定しなければなりません。それぞれのバックエ
ンドに対する完全な変数のリストを見るためには、このマニュアルの後に続くそ
れぞれのバックエンドの部分を読んでください。でも、@code{nnml} の定義の例
はここにあります:

@lisp
(nnml "public"
      (nnml-directory "~/my-mail/")
      (nnml-active-file "~/my-mail/active")
      (nnml-newsgroups-file "~/my-mail/newsgroups"))
@end lisp


@node Servers and Methods
@subsection サーバーと方法

普通は選択方法を使うところ (例えば、外部サーバーを概観しているときのグルー
プ選択方法での @code{gnus-secondary-select-method}) はどこでも、事実上の
サーバー名をそれの代わりに使う事ができます。このことによりたくさんキーボー
ドを叩かなくてすむ可能性があります。そして、全てにわたって、その方が良い
です。


@node Unavailable Servers
@subsection 使用不可能なサーバー

もしサーバーに接続不可能であるならば、gnus はサーバーを @code{拒否} とし
て印を付けます。これはその後のそのサーバーとの接続をはかるどのような試み
も無視されるという事です。Gnus は接続が開けないことが本当であるかどうか
を少しも確かめず、``It can't be opend,'' (接続を開く事ができません) と告
げます。

それは行儀が悪いと思う事があるかもしれませんが、それはたいていのときには
良い方法です。例えば、サーバー @samp{nephelococcdyia.com} に10個購読して
いるグループがあるとしましょう。サーバーはどこか非常に遠くにあり、マシン
はとても遅いので、それが今日はあなたとの接続を拒否するかどうかを調べるだ
けで1分かかります。もし gnus がそれを10回試すようになっていたなら、あな
たは非常にうるさく思うでしょう。ですから、gnus はそれを試そうとはしませ
ん。1度 ``connection refused'' (接続は拒否されました) を受け取ると、それ
はサーバーが ``down'' (落ちている) であるとみなします。

それで、一時的にそのマシンの機嫌が悪いだけだと何が起こるのでしょう? どう
やってマシンが戻ってきているかどうかっを再び調べる事ができるでのしょう?

サーバーバッファに飛び移って (@pxref{The Server Buffer}) 、以下の命令で
つつくだけでできます:

@table @kbd

@item O
@kindex O (サーバー)
@findex gnus-server-open-server
現在の行のサーバーとの接続を確立しようとします
(@code{gnus-server-open-server})。

@item C
@kindex C (サーバー)
@findex gnus-server-close-server
サーバーの接続 (もしあれば) を閉じます (@code{gnus-server-close-server})。

@item D
@kindex D (サーバー)
@findex gnus-server-deny-server
現在のサーバーに接続不可能の印を付けます
(@code{gnus-server-open-all-server})。

@item M-c
@kindex M-c (サーバー)
@findex gnus-server-close-to-all-servers
バッファにある全てのサーバーとの接続を閉じます
(@code{gnus-server-close-all-servers})。

@item R
@kindex R (サーバー)
@findex gnus-server-remove-denials
Gnus がどれかのサーバーから接続拒否を受けたかどうかの全ての印を消去しま
す (@code{gnus-server-remove-denials})。
@end table


@node Getting News
@section ニュースの取得
@cindex reading news
@cindex newsbackends

ニュースリーダーは普通はニュースを読む事に使われます。Gnus は現在はニュー
ズを取得するために2つだけの方法を提供しています---@sc{nntp} サーバーか、
ローカルスプールから読む事ができます。

@menu
* NNTP::               @sc{nntp} サーバーからニュースを読む。
* News Spool::         ローカルスプールからニュースを読む。
@end menu


@node NNTP
@subsection @sc{nntp}
@cindex nntp

@sc{nntp} サーバーの外部グループを購読するのは比較的簡単です。単に 
@code{nntp} を方法として指定し、@sc{nntp} サーバーのアドレス (address)
を、うーん、アドレスとして指定するだけです。

もし @sc{nntp} サーバーが標準でないポート (port) に位置しているときは、
選択方法の3番目の要素をこのポートの数字に設定する事で正しいポートに接続
する事ができるでしょう。そのためにグループ情報を編集しなければなりません 
(@pxref{Foreign Groups})。

外部グループの名前は基本グループと同じである事ができます。実際、あなたの
思うままに同じグループを可能な限りの違ったサーバーから購読する事ができま
す。名前の衝突は起こりません。

以下の変数は事実上の @code{nntp} サーバーを作るために使われます:

@table @code

@item nntp-server-opened-hook
@vindex gnus-server-opend-hook
@cindex @sc{mode reader}
@cindex authinfo
@cindex authentification
@cindex nntp authentification
@findex nntp-send-authinfo
@findex nntp-send-mode-reader
は接続ができた後に実行されます。それは @sc{nntp} サーバーに接触した後に
それに命令を送るために使われる事ができます。ディフォルトでは関数 
@code{nntp-send-mode-reader} により命令 @code{MODE READER} がサーバー
に送られます。その関数は常にこのフックにあるべきです。

@item nntp-authinfo-function
@vindex nntp-authinfo-function
@findex nntp-send-authoinfo
@vindex nntp-authinfo-file
この関数は @sc{nntp} サーバーに @samp{AUTHINFO} を送るために使われます。
ディフォルトの関数は @code{nntp-send-authinfo} で、@file{~/.authinfo}
(もしくは変数 @code{nntp-authinfo-file} に設定したどのようなものでも) を
使用可能な記載を調べるために探します。もし一つも見つからなかったら、あな
たにログイン名とパスワードの入力を促進します。ファイル 
@file{~/.authinfo} の様式は (ほとんど) @code{ftp} のファイル 
@file{~/.netrc} と同じで、それは @code{ftp} のマニュアルページに定義され
ていますが、ここのものは顕著な事実です:

@enumerate
@item
ファイルは一つ以上の行を含み、それぞれは一つのサーバーを定義します。

@item
それぞれの行は任意の数の 区切り印/値 の対を含む事ができます。有効な区切
り印は @samp{machine}、@samp{login}、@samp{password}、@samp{default}、
@samp{force} です。(最後のものは有効な @code{.netrc}/@code{ftp} の区切り
印ではありません。これがファイル @file{.authinfo} が @file{.netrc} ファ
イル様式から逸れる唯一の方法です。)

@end enumerate

これがそのファイルの例です:

@example
machine news.uio.no login larsi password geheimnis
machine nntp.ifi.uio.no login larsi force yes
@end example

区切り印/値 の対はどのような順番ででも現れる事ができます。例えば、
@samp{machine} は最初に現れる必要はありません。

この例では、ログイン名とパスワードの両方が前者のサーバーには与えられてい
るのに対して、後者はログイン名だけを挙げていて、利用者はパスワードの入力
を促進されます。後者は @samp{force} タグも持っていて、それは接続時に 
@var{nntp} サーバーに認証情報 (authinfo) が送られるという事です。ディフォ
ルト (すばわち、@samp{force} タグが無いとき) では @var{nntp} サーバーが
認証情報を尋ねない限りそれを @var{nntp} サーバーに送りません。

@samp{machine} 行に合致しない全てのサーバーに適用される @samp{default} 
行を追加する事もできます。

@example
default force yes
@end example

これは以前に書かれていない全てのサーバーに命令 @samp{AUTHINFO} を強制的
に送ります。

ファイル @file{~/.authinfo} を世界中が読めるような設定に放置しないように
注意してください。

@item nntp-server-action-alist
@vindex nntp-server-action-alist
これはサーバーの型に合致する正規表現と、合致が起こったときに取られる動作
の連想リストです。例えば、gnus に innd に接続したときに毎回ビープ音を鳴
らさせたい (beep) のであれば、次のようにする事ができます:

@lisp
(setq nntp-server-action-list
      '(("innd" (ding))))
@end lisp

まぁ、そのような事はしたくないでしょうけど。

ディフォルトの値は

@lisp
'(("nntpd 1\\.5\\.11t"
   (remove-hook 'nntp-server-opened-hook 'nntp-send-mode-reader)))
@end lisp

で、これは nntpd 1.5.11t には命令 @code{MODE READER} を送らない事を確実
にします。なぜなら、その命令はそのサーバーを固まらせると私は聞いているか
らです。

@item nntp-maximum-request
@vindex nntp-maximum-request
もし @sc{nntp} サーバーが @sc{nov} ヘッダーの機能を提供していないのであ
れば、このバックエンドは命令 @code{head} をいくつも送って、ヘッダーを集
めます。この動作を速くするために、バックエンドは返答を待たずにこの命令を
たくさん送り、それから全ての返答を読みます。これは変数 
@code{nntp-maximum-request} によって制御され、ディフォルトで400です。も
しネットワークが故障がちであるなら、この変数を1に設定するべきでしょう。

@item nntp-connection-timeout
@vindex nntp-connection-timeout
定期的に接続する外部 @code{nntp} グループがたくさんあるなら、適切に応答
しない @code{nntp} サーバーがあったり、あるサーバーは常識的な時間内では
返答できないくらい負荷がかかっている、などの問題があるでしょう。これは困っ
た問題になることがありますが、@code{nntp-connection-timeout} を設定する
事によりある程度解消する事ができます。これは接続をあきらめるまえに、
@code{nntp} バックエンドが何秒待つかを示す整数です。もしこれが 
@code{nil} であると、これが初期設定ですが、時間切れ切断はなされませ
ん。

@c @item nntp-command-timeout
@c @vindex nntp-command-timeout
@c @cindex PPP connections
@c @cindex dynamic IP addresses
@c If you're running Gnus on a machine that has a dynamically assigned
@c address, Gnus may become confused.  If the address of your machine
@c changes after connecting to the @sc{nntp} server, Gnus will simply sit
@c waiting forever for replies from the server.  To help with this
@c unfortunate problem, you can set this command to a number.  Gnus will
@c then, if it sits waiting for a reply from the server longer than that
@c number of seconds, shut down the connection, start a new one, and resend
@c the command.  This should hopefully be transparent to the user.  A
@c likely number is 30 seconds.
@c
@c @item nntp-retry-on-break
@c @vindex nntp-retry-on-break
@c If this variable is non-@code{nil}, you can also @kbd{C-g} if Gnus
@c hangs.  This will have much the same effect as the command timeout
@c described above.

@item nntp-server-hook
@vindex nntp-server-hook
このフックは @sc{nntp} サーバーに接続する最後の一歩として実行されます。

@findex nntp-open-rlogin
@findex nntp-open-telnet
@findex nntp-open-network-stream
@item nntp-open-connetcion-function
@vindex nntp-open-connection-function
この関数は遠隔システムに接続するために使われます。4つの既製関数が提供さ
れています: 

@table @code
@item nntp-open-network-stream
これは初期設定で、単純に遠隔システムの何らかのポートか他のもに接続します。

@item nntp-open-rlogin
@samp{rlogin} を遠隔システムに行って、そこから仕様可能な @sc{nntp} サー
バーに @samp{telnet} をします。

@code{nntp-open-rlogin} に関連した変数です:

@table @code

@item nntp-rlogin-program
@vindex nntp-rlogin-program
遠隔マシンにログインをするために使われるプログラムです。ディフォルトは 
@samp{rsh} ですが、@samp{ssh} が人気のある代替手段です。

@item nntp-rlogin-parameters
@vindex nntp-rlogin-parameters
このリストは @code{rsh} に与えられるパラメータのリストとして使われます。

@item nntp-rlogin-user-name
@vindex nntp-rlogin-user-name
遠隔システムでの利用者名です。

@end table

@item nntp-open-telnet
遠隔システムに @samp{telnet} をして、@sc{nntp} サーバーにたどり着くため
にもう一度 @code{telnet} をします。

@code{nntp-open-telnet} に関連した変数です:

@table @code
@item nntp-telnet-command
@vindex nntp-telnet-command
@code{telnet} を始めるのに使われる命令です。

@item nntp-telnet-switches
@vindex nntp-telnet-switches

命令 @code{telnet} のスイッチ (switch) として使われる文字列のリストです。

@item nntp-telnet-user-name
@vindex nntp-telnet-user-name
遠隔システムにログインするための利用者名です。

@item nntp-telnet-passwd
@vindex nntp-telnet-passwd
ログインするときに使われるパスワードです。

@item nntp-telnet-parameters
@vindex nntp-telnet-parameters
@code{telnet} でログインをした後に命令として実行される文字列のリストです。

@item nntp-telnet-shell-prompt
@vindex nntp-telnet-shell-prompt
遠隔マシンでのシェルのプロンプトに合致する正規表現です。ディフォルトは 
@samp{bash\\|\$ *\r?$\\|> *\r?} です。

@item nntp-open-telnet-envuser
@vindex nntp-open-telnet-envuser
@code{nil} でないなら、@code{telnet} セッションは (クライアントとサーバー
の両方で) @code{ENVIRON} オプションを使用する事ができ、ログイン名入力を
促進しません。これはたとえば Solaris の @code{telnet} に対して動作します。

@end table

@findex nntp-open-ssl-stream
@item nntp-open-ssl-stream
サーバーに @dfn{安全な} チャンネルを使ってサーバーに接続します。これを使
うためには、SSLay がインストールされていなければなりません 
(@file{ftp://ftp.psy.uq.oz.au/pub/Crypto/SSL} と、@file{ssl.el} (例えば、
W3 の配布から) が必要になります)。それからサーバーを次のように定義します:

@lisp
;; Type `C-c C-c after you'ver finished editing.
;;
;; "snews" is port 563 and is predefined in our /etc/services
;; 
(nntp "snews.bar.com"
      (nntp-open-connection-function nntp-open ssl-stream)
      (nntp-port-number "snews")
      (nntp-address "snews.bar.com"))
@end lisp

@end table

@item nntp-end-of-line
@sc{nntp} サーバーとお話をしているときに行の終わり (end-of-line) として
使われる印です。これはディフォルトで @samp{\r\n} ですが、サーバーとお喋
りをするために @code{rlogin} を使っているときは @samp{\n} であるべきです。

@item nntp-rlogin-user-name
@vindex nntp-rlogin-user-name
@code{rlogin} 接続関数を使っているときの遠隔システムでの利用者名です。

@item nntp-address
@vindex nntp-address
@sc{nntp} サーバーが動いている遠隔システムのアドレスです。

@item nntp-port-number
@vindex nntp-port-number
@code{nntp-open-network-stream} 接続関数を使っているときの接続するポート
番号です。

@item nntp-buggy-select
@vindex nntp-buggy-select
あなたの選択の一連の作業が故障がちであるときにこれを @code{nil} でない値
に設定してください。

@item nntp-nov-is-evil
@vindex nntp-nov-is-evil
@sc{nntp} サーバーが @sc{nov} 機能を提供していなければこの変数を 
@code{t} に設定する事ができますが、@code{nntp} は普通は @sc{nov} が使わ
れるかどうかを自動的に調べます。

@item nntp-xover-commands
@vindex nntp-xover-commands
@cindex nov
@cindex XOVER
サーバーから @sc{nov} 行を取得するための命令として使われる文字列のリスト
です。この変数のディフォルトの値は @code{("XOVER" "XOVERVIEW")} です。

@item nntp-nov-gap
@vindex nntp-nov-gap
@code{nntp} は普通はサーバーに @sc{nov} 行のための一つの大きな要求を送り
ます。サーバーは一つの巨大な、行のリストで応答します。しかし、もしグルー
プの2-5000の記事を読んで、1と5001を読みたいだけなら、@code{nntp} は必要
無い4999の @sc{nov} 行を取得する事になります。この変数は @code{XOVER}
要求がどれくらい大きな2つの連続した記事群の間のへだたり (gap) まで分割さ
れないで送られるかを決定します。ネットワークが速い場合は、この変数を本当
に小さな数字に設定するとおそらく取得が遅くなるという事に注意してください。
この変数が @code{nil} であると、@code{nntp} は要求を分割しません。ディフォ
ルトは5です。

@item nntp-prepare-server-hook
@vindex nntp-prepare-server-hook
@sc{nntp} サーバーに接続を試みる前に実行されるフックです。

@item nntp-warn-about-losing-connection
@vindex nntp-warn-about-losing-connection
この変数が @code{nil} でないと、サーバーが接続を閉じたときに少し雑音がた
てられます。

@item nntp-record-commands
@vindex nntp-record-commands
もし @code{nil} でないと、@code{nntp} は @sc{nntp} サーバーに送った全て
の命令を (時間と共に) @samp{*nntp-log*} バッファに記録します。これは動作
していないと思われる gnus/@sc{nntp} 接続をディバッグしているときに役に立
ちます。

@end table


@node News Spool
@subsection ニューススプール
@cindex nnsppl
@cindex new spool

ローカルスプールから外部グループを購読する事は非常に簡単で、役に立ちます。
たとえば、非常に大きな記事があるグループ---例えば
@samp{alt.binaries.pictures.furniture} を読む速度が速くなります。

とにかく、@code{nnspool} を方法として、 @code{""} (もしくは何でも) をア
ドレスとして指定するだけです。

もしローカルスプールにつなぐ事が可能なら、おそらくそれを基本選択方法とし
て使うべきでしょう (@pxref{Finding the News})。それは普通は @code{nntp} 
選択方法より速いですが、そうでないかもしれません。それは状況に依存します。
何があなたのサイトで一番良いかを見つけるために、いろいろと試してみなけれ
ばなりません。

@table @code

@item nnspool-inews-program
@vindex nnspool-inews-program
記事を投稿するために使われるプログラムです。

@item nnspool-inews-switches
@vindex nnspool-inews-switches
記事を投稿するときに inews プログラムに与えられるパラメータです。

@item nnspool-spool-directory
@code{nnspool} が記事を探すところです。これは普通は 
@file{/usr/spool/news/} です。

@item nnspool-nov-directory
@vindex nnspool-nov-directory
@code{nnspool} が @sc{nov} ファイルを探すところです。これは普通は 
@file{/usr/spool/news/over.view/} です。

@item nnspool-lib-dir
@vindex nnspool-lib-dir
ニュースのライブラリーディレクトリーの場所です (ディフォルトで 
@file{/usr/lib/news/} です)。

@item nnspool-active-file
@vindex nnspool-active-file
アクティブファイルへのパスです。

@item nnspool-newsgroups-file
@vindex nnspool-newsgroups-file
グループ記述ファイルへのパスです。

@item nnspool-history-file
@vindex nnspool-history-file
ニュース履歴ファイルへのパスです。

@item nnspool-active-times-file
@vindex nnspool-active-times-file
現状日付ファイルへのパスです。

@item nnspool-nov-is-evil
@vindex nnspool-nov-is-evil
@code{nil} でないと、@code{nnspool} はそれが見つけたどんな @sc{nov} ファ
イルも使おうとはしません。

@item nnspool-sift-nov-with-sed
@vindex nnspool-sift-nov-with-sed
@cindex sed
@code{nil} でないと、これがディフォルトですが、概観ファイル (overview)
から関連する部分を得るために @code{sed} を使います。もし nil だと、
@code{nnspool} はファイル全体をバッファに読み込んで、そこで実行します。

@end table


@node Getting Mail
@section メール取得
@cindex reading mail
@cindex mail

ニュースリーダーでメールを読む---それは明白に超自然的な事ではないのです
か？ いや、もちろんできます。

@menu
* Getting Started Reading Mail:: 簡単な料理本のような例。
* Splitting Mail::               どのようにメールグループを作成するか。
* Mail Backend Variables::       メールの扱いをカスタマイズするための変数。
* Fancy Mail Splitting::         Gnus は入って来たメールの毛のような分離をすることができる。
* Mail and Procmail::            procmail が作成したメールグループを読む。
* Incorporating Old Mail::       あなたが持っている古いメールをどうするか?
* Expiring Mail::                欲しくないメールを取り除く。
* Washing Mail::                 取得したメールから嫌なものを取り除く。
* Duplicates::                   重複したメールを扱う。
* Not Reading Mail::             他のファイルを読むためにメールバックエンドを使う。
* Choosing a Mail Backend::      Gnus は色々なメール様式を読む事ができる。
@end menu


@node Getting Started Reading Mail
@subsection メールを読む事を始める

Gnus を使って新しいメールを読む事は非常に簡単です。あなたのメールバック
エンドのあなたの選択を @code{gnus-secondary-select-methods} に放り込むだ
けで、あとのことは自動的に起こります。

例えば、@code{nnml} (これは "一メール一ファイル" バックエンドです) を使
いたいなら、次のものをあなたの @file{.gnus} ファイルに入れる事ができます。

@lisp
(setq gnus-secondary-select-methods
      '((nnml "private")))
@end lisp

今や、次に gnus を起動したときには、このバックエンドは新しい記事を求め、
それはあなたのスプールファイルから全てのメッセージをディレクトリー、ディ
フォルトでは @code{~/Mail/} 、に移動します。作成された新しいグループ 
(@samp{mail.misc}) が購読され、他のグループと同じように読む事ができます。

あなたはおそらくメールをいくつかのグループに分割したいでしょうけど:

@lisp
(setq nnmail-split-methods
      '(("junk" "^From:.*Lars Ingebrigtsen")
        ("crazy" "^Subject:.*die\\^Organization:.*flabby")
        ("other" "")))
@end lisp

これは結果として3つの新しい @code{nnml} メールグループを作ります:
@samp{nnml:junk}、@samp{nnml:crazy}、@samp{nnml:other} です。最初の2つの
グループに合わないメールは全て最後のグループに入れられます。

これは gnus でメールを読むために充分であるはずです。マニュアルのこの部分
の他の項を熟読したいと思うかもしれませんが。特に @pxref{Choosing a Mail
Backend} と @pxref{Expiring Mail} を。


@node Splitting Mail
@subsection メールの分割
@cindex splitting mail
@cindex mail splitting

@vindex nnmail-split-methods
変数 @code{nnmail-split-methods} は入ってくるメールをどのようにグループ
分けするかを指定します。

@lisp
(setq nnmail-split-methods
  '(("mail.junk" "^From:.*Lars Ingebrigtsen")
    ("mail.crazy" "^Subject:.*die\\|^Organization:.*flabby")
    ("mail.other" "")))
@end lisp

この変数はリストのリストで、これらのリストの最初のそれぞれの要素がメール
グループの名前で (ところで、それらは @samp{mail} で始まる必要はありませ
ん)、2つめの要素がそれぞれのメールのヘッダーからそれがどのグループに属す
るかを決定する正規表現です。最初の文字列は、@code{replace-match} によっ
て、合致した文章からの副表現を挿入するために使われるような、 
@code{samp\\1} の様式を含むかもしれません。たとえば:

@lisp
("list.\\1" "From:.*\\(.*\\)-list@@majordomo.com")
@end lisp

2番目の要素は関数である事もできます。その場合は、それは法則の最初の要素
を引数として、ヘッダーに範囲を狭めて (narrowed to headers) 呼ばれます。
それは、メールがそのグループに属すると考えるのであれば、@code{nil} でな
い値を帰す必要があります。

これらの最後は常に総合的なものであるべきで、他の正規表現に合致しないメー
ルに合致するために、この正規表現は @emph{いつも} @samp{}であるべきです。
(これらの法則は連想リストの初めから終わりまで順番に実行されます。相互投
稿 (crosspost) を使用可能にしていない限り、最初の合致した法則が "勝ちま
す"。相互投稿を使用可能にしている場合、全ての合致した法則が "勝ちます"。)

もしあなた自身でこれをいじくりまわしたいときは、あなたの選んだ関数をこの
変数に設定する事ができます。この関数は入って来たメールメッセージのヘッダー
に範囲を狭められたバッファで引数なしで呼ばれます。この関数は、それがこの
メールメッセージを運ぶべきである、と考えるグループ名のリストを返すべきで
す。

全てのメールバックエンドは、入って来た貧乏で純粋なヘッダーを乱暴に扱って
も良い事に注意してください。それらはすべて @code{Lines} ヘッダーを追加し
ます。いくつかは @code{X-Gnus-Group} ヘッダーを加えます。たいていのもの
は Unix の mbox の @code{From<SPACE>} 行を何か別の名前に変えます。

@vindex nnmail-crosspost
メールバックエンドはすべて相互投稿の機能を提供しています。いくつかの正規
表現が合致すると、メールは全てのグループに ``相互投稿'' されます。
@code{nnmail-crosspost} はこの機能を使うかどうかを指定します。どの記事も
総合の (@samp{}) グループに相互投稿されない事に注意してください。

@vindex nnmail-crosspost-link-function
@cindex crosspost
@cindex links
@code{nnmh} と @code{nnml} は相互投稿された記事にハードリンク (hardlink) 
を作る事によって相互投稿を行います。しかし、全てのファイルシステムがハー
ドリンクの機能を提供しているわけではありません。もしあなたがその場合に当
てはまるのであれば、@code{nnmail-crosspost-link-function} を 
@code{copy-file} に設定してください。 (この変数はディフォルトで 
@code{add-name-to-file} です。)

@kindex M-x nnmail-split-history
@kindex nnmail-split-history
前のメール分割がメッセージをどこに入れたかを見たい場合は、命令 @kbd{M-x
nnmail-split-history} を使う事ができます。

Gnus はあなたに自分自身に跳ね返ってくるような可能性のある全ての機会を提
供します。例えば、あなたの上司からくる全てのメールを含んだグループを作っ
たとしましょう。それから、偶発的にそのグループの購読取り止めが起こったと
します。Gnus はそれでも上司からの全てのメールを未購読のグループに入れま
すので、上司が ''月曜日までにその報告書を準備しないと首だ！'' というメー
ルをあなたに送っても、あなたはそれを見る事はなく、火曜日になって本当は翌
月の家賃を払うために空のボトルを集めるべきであっても、まだ有給で雇われて
いると信じているかもしれません。


@node Mail Backend Variables
@subsection メールバックエンド変数

これらの変数は (たいていの場合) 全ての違ったメールバックエンドに関連しま
す。

@table @code
@vindex nnmail-read-incoming-hook
@item nnmail-read-incoming-hook
メールバックエンドは新しいメールを読み込んだ後にこのフックを呼びます。も
しそうしたいと思うなら、このフックをメール監視プログラムに知らせるために
使う事ができます。

@vindex nnmail-spool-file
@item nnmail-spool-file
@cindex POP mail
@cindex MAILHOST
@cindex movemail
@vindex nnmail-pop-password
@vindex nnmail-pop-password-required
バックエンドはこのファイルで新しいメールを探します。この変数が 
@code{nil} であると、メールバックエンドは決して自分自身ではメールを取得
しようとしません。もし POP メールサーバーを使っていて、あなたの名前が 
@samp{larsi} であるならば、この変数を @samp{po:larsi} に設定するべきです。
もしあなたの名前が @samp{larsi} でないならば、おそらくこれを少し修正しな
ければなりませんが、既にあなたはそれを推測しているでしょう。この賢く顔立
ちの良い悪魔さん！ この変数を @code{pop} に設定する事もでき、その時は 
gnus が自分自身で POP メール文字列を発見しようとします。どのような場合で
も、gnus は 環境変数 @code{MAILHOST} で指定されている POP サーバーに接触
を図ろうとする @code{movemail} を呼びます。POP サーバーがパスワードを必
要とするなら、@code{nnmail-pop-password-required} を @code{t} に設定して
パスワード入力を促進されるか、@code{nnmail-pop-password} をパスワードそ
のものに設定する事ができます。

@code{nnmail-spool-file} はメールボックスのリストである事もできます。

あなたの Emacs が コンパイル (compilation) の前に @samp{--with-pop} と共
に環境設定 (configure) されなければなりません。これはディフォルトですが、
いくつかのインストールはその設定を切ってしまいます。

メールバックエンドを使うときは、gnus は全てのメールを inbox から吸い上げ
て、ホームディレクトリーに放り投げます。あなたがメールバックエンドを使っ
ていない場合は、gnus は1通もメールを移動しません---最初に魔法の呼び出し
をたくさんしなければなりません。まず5角形を描き、蝋燭に火を付け、山羊を
生け贄として捧げ終えた後で、gnus があなたのメールを移動しても本当にあま
り驚いてはいけません。

@vindex nnmail-use-procmail
@vindex nnmail-procmail-suffix
@item nnmail-use-procmail
もし @code{nil} でなければ、メールバックエンドは入ってくるメールを 
@code{nnmail-procmail-directory} で探します。そのディレクトリーで 
@code{nnmail-procmail-suffix} で終わっている名前を持つ全てのファイルは入っ
て来たメールボックスとみなされ、そこで新しいメールが探されます。

@vindex nnmail-crash-box
@item nnmail-crash-box
メールバックエンドがスプールファイルを読んだときに、メールは最初にこのファ
イルに移動されます。これはディフォルトで @file{~/.gnus-crash-box} です。
このファイルが既に存在する場合は、それは常に他のスプールファイルより先に
読み込まれ (そして取り込まれ) ます。

@vindex nnmail-prepare-incoming-hook
@item nnmail-prepare-incoming-hook
これは入って来た新しいメールを持っているバッファで実行され、えーと、本当
に、全てのことについて使われます。

@vindex nnmail-split-hook
@item nnmail-split-hook
@findex article-decode-rfc1522
@findex RFC1522 decoding
それぞれのメッセージがそのヘッダーに基づいて分割がなされる直前にそれが保
存されているバッファで実行されるフックです。このフックはそれが適合すると
考えるように自由にバッファの内容を編集する事ができます---バッファは分割
が終わった後で消去され、バッファで行われた変更はどのファイルにも現れませ
ん。@code{gnus-article-decode-rfc1522} がこのフックに加える事が適切な関
数の一つです。

@vindex nnmail-pre-get-new-mail-hook
@vindex nnmail-post-get-new-mail-hook
@item nnmail-pre-get-new-mail-hook
@itemx nnmail-post-get-new-mail-hook
これらは入ってくるメールを扱うときに実行される役に立つ2つのフックです---
@code{nnmail-pre-get-new-mail-hook} (これは新しいメールを扱う直前に呼ば
れます) と @code{nnmail-post-get-new-mail-hook} (これはメールの扱いが終
わったときに呼ばれます) です。次のものは、この2つのフックを使って新しい
メールファイルに与えられるディフォルトのファイルモードを変更する例です:

@lisp
(add-hook 'gnus-pre-get-new-mail-hook
          (lambda () (set-default-file-modes 511)))

(add-hook 'gnus-post-get-new-mail-hook
          (lambda () (set-default-file-modes 551)))
@end lisp

@item nnmail-tmp-directory
@vindex nnmail-tmp-directory
この変数は入って来たメールをどこに移動するかを指定します -- それを実行し
ている間に。これは普通はメールバックエンドが住んでいるものと同じディレク
トリー (例、 @file{~/Mail/}) で行われますが、この変数が @code{nil} でな
いと、それが代わりに使われます。

@item nnmail-movemail-program
@vindex nnmail-movemail-program
このプログラムは利用者のインボックスからホームディレクトリーに移動するた
めに実行されます。ディフォルトは @code{movemail} です。

これは関数である事もできます。その場合は、その関数は2つのパラメータ -- 
インボックスの名前と移動するファイル名前 と共に呼ばれます。

@item nnmail-delete-incoming
@vindex nnmail-delete-incoming
@cindex incoming mail files
@cindex deleting incoming files
@code{nil} でないなら、メールバックエンドはメールを適切なグループへ分割した後で一時新入ファイルを消去します。これはディフォルトで @code{t} です。

@c This is @code{nil} by
@c default for reasons of security.

@c Since Red Gnus is an alpha release, it is to be expected to lose mail.
((ding) Gnus 0.10 (もしくはそのようなもの) からの Gnus のリリースは私が
思うにメールを失った事はないのですが、でもそのことはここでは重要ではあり
ません。 (特別なバージョンの Red Gnus を除きます。)) Incoming* ファイル
を消去しない事で、メールを失わない事を確実にできます -- もし gnus が完全
に強制的に吹っ飛んでも、いつも失われたものを取り戻す事ができます。

いつでもあなたの意志で @file{Incoming*} ファイルを消去する事ができます。

@item nnmail-use-long-file-names
@vindex nnmail-use-long-file-names
@code{nil} でないなら、メールバックエンドは長いファイル名とディレクトリー
名を使います。@samp{mail.misc} のようなグループ名は @file{mail.misc} と
いうディレクトリー (@code{nnml} バックエンドが使われているとみなすと) か
ファイル (@code{nnfolder} バックエンドが使われているとみなすと) という結
果になります。もしそれが @code{nil} であるなら、同じグループは 
@file{mail/misc} という結果になります。

@item nnmail-delete-file-function
@vindex nnmail-delete-file-function
@findex delete-file
ファイルを消去するために呼ばれる関数です。ディフォルトで 
@code{delete-file} です。

@item nnmail-cache-accepted-message-ids
@vindex nnmail-cache-accepted-message-ids
@code{nil} でないと、バックエンドに入って来た記事 (例えば、@code{Gcc} に
よって) の @code{Message-ID} をメール重複発見ファイルに入れます。ディフォ
ルトは @code{nil} です。

@end table

@node Fancy Mail Splitting
@subsection 特級メール分割
@cindex mail splitting
@cindex fancy mail splitting

@vindex nnmail-split-fancy
@findex nnmail-split-fancy
比較的単純な標準のメール分割指定の方法ではあなたの望む事ができない場合、
@code{nnmail-split-methods} を @code{nnmail-split-fancy} に設定する事が
できます。それから変数 @code{nnmail-split-fancy} で遊ぶ事ができます。

まずこの変数の値の例を見てみましょう:

@lisp
;; メールデーモン (mailer deamon) は普通のグループには相互投稿されませ
;; ん。警告は本当のエラーとは違ったグループに入れられます。
(| ("from" mail (| ("subject" "warn.*" "mail.warning") 
                   "mail.misc")) 
   ;; エラーでないメッセージは全ての関連したグループに相互投稿されます
   ;; が、(ding) リストと他の (ding) 関連のメールのためのグループには
   ;; 相互投稿しません。
   (& (| (any "ding@@ifi\\.uio\\.no" "ding.list" "ding.list")
         ("subject "ding" "ding.misc"))
      ;; 他のメーリングリスト...
      (any "procmail@@informatik\\.rwth-aachen\\.de" "procmail.list")
      (any "SmartList@@informatik\\.rwth-aachen\\.de" "SmartList.list")
      ;; 人々...
      (any "larsi@@ifi\\.uio\\.no" "people.Lars_Magne_Ingebrigtsen"))
   ;; 合致しなかったメールは全てを捕まえるグループへ行きます。
   "misc.misc")
@end lisp

この変数は @dfn{分割} の様式になっています。分割は (あるいは) それぞれの
分割が他の分割を含む再帰的構造です。これは使用可能な5つの分割構文です:

@enumerate

@item
@samp{group}: もし分割が文字列であると、それはグループ名としてみなされま
す。普通の正規表現の合致がなされます。例は下の方を見て下さい。

@item
@var{(FIELD VALUE SPLIT)}: もし分割がリストで、最初の要素が文字列であり、
ヘッダー FIELD (正規表現) が VALUE (これも正規表現) を含んでいる場合、メッ
セージを SPLIT で指定されたところに蓄積します。

@item
@var{(| SPLIT...)}: 分割がリストで、最初の要素が @code{|} (垂直棒) であ
ると、それぞれの SPLIT をそのうちの一つが合致するまで実行します。 SPLIT 
はメールメッセージが一つ以上のグループに蓄積されたときに ``合致した'' と
します。

@item
@var{(& SPLIT...)}: 分割がリストで、最初の要素が @code{t} であると、リス
トの全ての SPLIT を実行します。

@item
@code{junk}: もし分割がシンボル @code{junk} であると、そのメッセージを保
存しません。非常に注意して使って下さい。

@item
@var{(: function arg1 arg2 ...)}: もし分割がリストで、最初の関数が 
@code{:} であると、2番目の要素が @var{args} を引数として関数として呼ばれ
ます。関数は SPLIT を返すべきです。

@item
@code{nil}: もし分割が @code{nil} であれば、それは無視されます。

@end enumerate

これらの分割で、@var{FIELD} は完全なフィールド名に合致しなければなりませ
ん。@var{VALUE} は基礎モード (fundamental mode) 構文テーブル (syntax
table) に従って完全に合致しなければなりません。正規表現でフィールド名か
語の部分に合致させるために @code{.*} を使う事ができます。言い換えれば、
全ての @var{VALUE} は @samp{\<} と @samp{\>} の対で囲まれます。

@vindex nnmail-split-abbrev-alist
@var{FIELD} と @var{VALUE} は lisp シンボル (symbol) である事もでき、そ
の場合はそれらは @code{nnmail-split-abbrev-alist} で指定されているように
展開されます。これはセルの @code{car} がキーを含んでいて、@code{cdr} が
関連付けられた値を持っているコンスセル (cons cell) の連想リストです。

@vindex nnmail-split-fancy-syntax-table
@code{nnmail-split-fancy-syntax-table} がこれらの全ての分割が実行されて
いるときに有効な構文テーブルです。

ヘッダーのいくつかの情報に基づいて、gnus に動的にグループを作らせたいのであれば (例えば、グループ名で @code{replace-match} のような代用をする)、次のような事ができます。

@example
(any "debian-\\b\\(\\w+\\)@@lists.debian.org" "mail.debian.\\1")
@end example

もし文字列が要素 @samp{\&} を含んでいると、代わりに前で合致した文字列が
使われます。同様に、要素 @samp{\\1} から @samp{\\9} まではグループ付け 1 
から 9 までで合致した文字文で代替されます。

@node Mail and Procmail
@subsection メールと Procmail
@cindex procmail 

@cindex slocal
@cindex elm
多くの人は @code{procmail} (もしくは他のメール選別プログラムか外部配送代
理---@code{slocal}、@code{elm} など) を入って来たメールをグループに分割
するために使います。もしそうしているのであれば、メールバックエンドが自分
自身でメールを取得しない事を確実にするために、@code{nnmail-spool-file} 
を @code{procmail} に設定するべきです。

もし複合 @code{procmail}/POP/mailbox 設定を使っているのであれば、以下の
ような事をする事ができます:

@vindex nnmail-use-procmail
@lisp
(setq nnmail-use-procmail t)
(setq nnmail-spool-file
     '("/usr/spool/mail/my-name" "po:my-name"))
@end lisp

これはいくつかの、おそらく、期待しない副効果をもたらすであろう 
@code{nnmail-split-methods} も設定したいとは思わないという事も意味します。

メールバックエンドがどのグループに運ぶかを尋ねられたときは、それは他の方
法で運ぶ事を発見した他の全てのグループと共に、その変数の内容から値を帰し
ます。@code{nnmh} 以外のバックエンドは実際にディスクへ行ってどのグループ
が実際に存在しているかを調べることはしません。 (利用者がどのグループを
ニュースグループのためで、どのグループが普通の古いファイルやディレクトリー
のためであると考えているかを区別する事はささいな事ではありません。)

これは、あなたが gnus (とバックエンド) に手でどのグループが存在している
かを教えなければならないという事です。

@code{nnmh} バックエンドを例に取ってみましょう:

フォルダーは @code{nnmh-directory} に位置づけられています。そうですねぇ、
@file{~/Mail} としましょう。そこには @file{foo}、@file{bar}、
@file{mail.baz} という3つのフォルダーがあります。

グループバッファへ行って、@kbd{G m} と打ってください。入力を促進されたと
きは、名前 (name) として @samp{foo} を、方法 (method) として @samp{nnmh} 
を答えてください。2つの他のグループ、@samp{bar} と @samp{mail.baz} のた
めに同様の事を2回繰り返してください。全てのあなたのメールグループを含め
るようにしてください。

これで全部です。もう、メールを読む事ができるように設定されています。この
方法のアクティブファイルは自動的に作成されます。

@vindex nnmail-procmail-suffix
@vindex nnmail-procmail-directory
もし @code{nnfolder} や他の2通以上のメールを一つのファイルに溜めるバック
エンドを使っているのなら、gnus が見るファイルに procmail がメールを加え
ないようにしなければなりません。代わりに、procmail は全ての入ってくるメー
ルを @code{nnmail-procmail-directory} に入れるべきです。入って来たメール
を入れるファイル名に到着するために、グループ名に 
@code{nnmail-procmail-suffix} を付加してください。メールバックエンドはこ
れらのファイルからメールを読み込みます。

@vindex nnmail-reslpit-incoming
Gnus が @file{mail.misc.spool} と呼ばれているファイルを読み込んだときは、
このメールは期待通り、 @code{mail.misc} に入れられます。しかし、gnus に
普通の方法でメールを分割させたい場合、@code{nnmail-resplit-incoming} を 
@code{t} に設定する事ができます。

@vindex nnmail-keep-last-article
もし @code{procmail} に入って来た物を分割して直接 @code{nnmh} のディレク
トリーに入れるようにしている場合 (これはするべきではないことですが)、
gnus が最後の記事 (すなわち、もっとも大きい記事番号を持つ記事) を期限切
れ削除するのを防ぐために、@code{nnmail-keep-last-article} を @code{nil} 
でない値に設定するべきです。

これは設定の例です: 入ってくるスプールは @file{~/incoming/} に置かれてい
て、@samp{""} を接尾語として持っています (すなわち、入ってくるスプールファ
イルはそれと等価なグループと同じ名前になっています)。 @code{nnfolder} バッ
クエンドはメールインターフェースとして使われ、@code{nnfolder} ディレクト
リーは @file{~/fMail/} です。

@lisp
(setq nnfolder-directory "~/fMail/*)
(setq nnmail-spool-file 'procmail)
(setq nnmail-procmail-directory "~/incoming/")
(setq gnus-secondary-select-methods '((nnfolder "")))
(setq nnmail-procmail-suffix "")
@end lisp


@node Incorporating Old Mail
@subsection 古いメールを取り込む

たいていの人は色々なファイルフォーマットで蓄積されたたくさんの古いメール
があるでしょう。もし gnus に粋な gnus メールバックエンドの一つを使うよう
に設定したのであれば、おそらく古いメールをメールグループに取り込みたいと
思うでしょう。

それをする事はとても簡単です。

例を挙げましょう: @code{nnml} (@pxref{Mail Spool}) を使ってメールを読ん
でいて、@code{nnmail-split-methods} を満足できる値に設定しています。古い 
Unix mbox ファイルが重要だけれど古いメールで満たされています。あなたはそ
れを @code{nnml} グループに移動したいと思っています。

方法です:

@enumerate
@item
グループバッファに行きます。

@item
`G f' と打って、mbox ファイルから @code{nndoc} グループを作成するように
促進されたときに mbox ファイルへのパスを与えます (@pxref{Foreign
Groups})。

@item
`SPACE' を打って、新しく作られたグループに入ります。

@item
`M P b' を打って、グループバッファの全ての記事に実行印を付けます 
(@pxref{Setting Process Marks})。

@item
`B r' を打って全てのプロセス印の付いた再スプールし、促進されたときに 
@samp{nnml} と答えます (@pxref{Mail Group Commands})。
@end enumerate

mbox ファイルの全てのメールメッセージも今やあなたの @code{nnml} グループ
に広がっています。それらに入って、変な故障もなく物事が上手く行っているか
どうかを調べてください。もし大丈夫なようであれば、mbox ファイルを消す事
を考えるかもしれませんが、私は全てのメールがあるべきところに納まっている
のを完全に確認するまでは、そうはしません。


@node Expiring Mail
@subsection メールの期限切れ消去
@cindex article expiry

伝統的なメールリーダーは、何か、既読の印を付けると記事を削除する傾向があ
ります。 Gnus はメールを読む事に対して、基本的に全く違った方法を取ります。

Gnus は基本的にメールを比較的特別な方法で受け取られたニュースであるとみ
なします。それは実際にメールを変更しあり、メールメッセージを消す権力があ
るとは考えません。メールグループに入って、記事に ``既読'' の印を付けたり、
他の流儀で切ったりしても、メール記事はまだシステムに存在しています。繰り
返します: gnus はあなたの古い、既読メールを消去しません。もちろん、あな
たがそうしろと尋ねない限りの話ですが。

Gnus に望ましくないメールを削除させるためには、記事を @dfn{期限切れ消去
可能} (expirable) として印を付けなければなりません。しかしながら、これは
記事が即座に消え去るという事ではありません。一般的に、メール記事は次のよ
うな場合にシステムによって削除されます 1) 期限切れ消去可能の印を付けられ
る 2) 1週間以上経った記事である。 もし記事を期限切れ消去可能にしなければ、
それは地獄が凍りつくまでシステムに残りつづけます。これはもう一度強調付き
で繰り返されるに足るものです: ``もし'' あなたが記事を ``期限切れ消去可能'' 
であると ``しない'' なら、gnus は ``決して'' それらの ``記事'' を消去し
ません。

@vindex gnus-auto-expirable-newsgroups
手で記事に期限切れ消去可能の印を付けなければならないわでではありません。
正規表現 @code{gnus-auto-expirable-newsgroups} に合致するグループは全て
の既読記事に自動的に期限切れ消去可能の印が付けられます。全ての期限切れ消
去可能の印の付いた記事は概略バッファの最初の桁に @samp{E} が表示されます。

ディフォルトでは自動期限切れ消去可能を使用すると、gnus はあなたが読んだ
全ての記事を、それが既読であったか未読であったかに関わらず、期限切れ消去
可能として印を付けます。既読の印の付いた記事が自動的に期限切れ消去可能と
して印付けられるのを避けるために、以下のようなものを @file{.gnus} ファイ
ルに書く事ができます:

@vindex gnus-mark-article-hook
@lisp
(remove-hook 'gnus-mark-article-hook
             'gnus-summary-mark-read-and-unread-as-read)
(add-hook 'gnus-mark-article-hook 'gnus-summary-mark-unread-as-read)
@end lisp

自動期限切れ消去可能グループを作る事は、全ての既読記事が期限切れ消去され
る事ではない事に気を付けてください---期限切れ消去可能として印の付いた記
事だけが期限切れ消去されます。命令 @kbd{d}が自動的にグループを期限切れ消
去可能にするのでは無いという事にも気を付けてください---半自動の、自動期
限切れ消去可能グループで記事を既読に印付けることだけが記事を期限切れ消去
可能にします。

@lisp
(setq gnus-auto-expirable-newsgroups
      "mail.nosense-list\\|mail.nice-list")
@end lisp

自動期限切れ消去を実行する他の方法は、グループのグループパラメータとして、
要素 @code{auto-expirable} を持つ事です。

もし適応スコア付け (@pxref{Adaptive Scoring}) と自動期限切れ消去を使用し
ているなら、問題が起こるでしょう。自動期限切れ消去と適応スコア付けはあま
り良く相互作用しません。

@vindex nnmail-expiry-wait
変数 @code{nnmail-expiry-wait} は期限切れ消去可能記事がどれくらいの期間
生存しているかのディフォルトの時間設定を提供します。Gnus はメッセージが
送られたときではなく、それが @emph{到着} してからの日を計算します。ディ
フォルトは7日間です。

Gnus は記事がどのグループに属しているかに基づいて、それがどのくらい生存
するかを成功に設定する関数も提供しています。グループ @samp{mail.private} 
は期限を1ヶ月に、グループ @samp{mail.junk} では期限を1日に、その他のもの
には期限を6日間にするには:

@vindex nnmail-expiry-wait-function
@lisp
(setq nnmail-expiry-wait-function
      (lambda (group)
       (cond ((string= group "mail.private")
               31)
             ((string= group "mail.junk")
               1)
             ((string= group "important")
              'never)
             (t
               6))))
@end lisp

この関数に与えられるグループ名は ``装飾無し'' のグループ名です---
@samp{nnml:} やその他の似たようなものは付きません。

変数 @code{nnmail-expiry-wait} と関数 @code{nnmail-expiry-wait-function} 
は数字 (整数である必要はありません) かシンボル @code{immediate} か 
@code{never} のどちらかである事ができます。

期限切れ期間を選択的に変更するためにグループパラメータ 
@code{expiry-wait} を使う事もできます (@pxref{Group Parameters})。

@vindex nnmail-keep-last-article
@code{nnmail-keep-last-article} が @code{nil} でないと、gnus はメールニュー
スグループの最後の記事を決して期限切れ消去しません。これは procmail の利
用者の人生を楽にするためです。

@vindex gnus-total-expirable-newsgroups
ところで: そこにある、gnus が決して期限切れ消去可能でない記事を期限切れ
消去する事はない、というのは嘘です。@code{total-expire} をグループパラメー
タに入れると、記事は期限切れ消去の印が付きませんが、全ての記事は期限切れ
消去過程に入れられます。非常に注意して使ってください。さらにもっと危険な
ものは変数 @code{gnus-total-expirable-newsgroups} です。この正規表現に合
致する全てのグループは全ての既読記事が期限切れ消去可能の過程に突っ込まれ
ます。これは、当のグループの @emph{全て} の古いメール記事は少し後で削除
されるという事です。非常に注意して使って、あなたが使用した正規表現が間違っ
たグループに合致して、あなたの全ての重要なメールが消えてしまったと言って、
私のところに泣き付いて来ないでください。@emph{男}になりなさい！ もしくは、
@emph{女} になりなさい！ あなたが気持ちよいと感じる全てのものと！ ですか
らそこに！

たいていの人はほとんどのメールグループを total-expirable (全体期限切れ消
去可能) にしますが。


@node Washing Mail
@subsection メール洗濯
@cindex mail washing
@cindex list server brain damage
@cindex incoming mail treatment

メイラー (mailer) やリストサーバー (list server) は本当に本当に馬鹿げた
事をすることで悪名高いです。 ``わぁ、RFC822 は我々のサーバーを通っていく
メッセージの全ての行の最後に @code{wE aRe ElIte!!!!!1!!} を加える事を明
示的に禁止はしていないぞ。さぁ、やってみよう!!!!1'' えぇ、そのとおりです
が、RFC822 は能力の低い人によって読まれるようには書かれていません。明白
な事はそこでは議論されていません。ですから。そういうことです。

問題点: ドイツ版 Microsoft Exchange は返答の表題に @samp{Re: } の代わり
に @samp{AW: } を付け加えます。私はこれに動揺して狼狽しているふりをする
こともできましたが、そうする気力がありませんでした。それは笑うべき事です。

Gnus は記事を表示するときにそれを洗濯するために過度の関数を提供していま
すが、メールをディスクに保存する前に選別をすることができた方が良いでしょ
う。その目的のために、3つのフックとそのフックに入れる事のできる色々な関
数があります。

@table @code
@item nnmail-prepare-incoming-hook
@vindex nnmail-prepare-incoming-hook
このフックはメールに何かをする前に呼ばれ、基本的な、メールを掃いてきれい
にする所作のためにあります。使う事のできる関数は:

@table @code
@item nnheader-ms-strip-cr
@findex nnheader-ms-strip-cr
それぞれの行から、最後にあるキャリッジリターン (carriage return) を取り
除きます。これは MS のマシン上で動作している Emacs のディフォルトです。

@end table

@item nnmail-prepare-incoming-header-hook
@vindex nnmail-prepare-incoming-header-hook
このフックはそれぞれのヘッダーに範囲を狭められて (narrowed) 呼ばれます。
ヘッダーをきれいにするときに使う事ができます。使う事のできる関数は:

@table @code
@item nnmail-remove-leading-whitespace
@findex nnmail-remove-leading-whitespace
ヘッダーにそれが良く見えるように ``有用な'' リストサーバーが前の方に付け
加えた空白を無くします。あぁぁ。

@item nnmail-remove-list-identifiers
@findex nnmail-remove-list-identifiers
いくつかのリストサーバーは同一識別子を付け加えます---例えば、
@samp{(idm)}---を全ての @code{Subject} ヘッダーの最初に付けます。それは、
石器時代のメールヘッダーを使っている人には良い事だと思います。この関数は
正規表現 @code{nnmail-list-identifiers} に合致する文字列を取り除きます。
それは正規表現のリストである事もできます。

例えば、@samp{(idm)} と @samp{nagnagnag} 同一識別子を取り除きたいのなら:

@lisp
(setq nnmail-list-identifiers
      '("(idm)" "nagnagnag"))
@end lisp

@item nnmail-remove-tabs
@findex nnmail-remove-tabs
全ての @samp{TAB} 文字を @samp{SPACE} 文字に変換します。

@end table

@item nnmail-prepare-incoming-message-hook
@vindex nnmail-prepare-incoming-message-hook
このフックはそれぞれのメッセージに範囲を狭められて呼ばれます。使う事ので
きる関数は:

@table @code
@item article-de-quoted-unreadable
@findex article-de-quoted-unreadable
Quoted Readable 符号化を復号化します。

@end table
@end table


@node Duplicates
@subsection 重複

@vindex nnmail-treat-duplicates
@vindex nnmail-message-id-cache-length
@vindex nnmail-message-id-cache-file
@cindex duplicate mails
いくつかのメーリングリストのメンバーなら、時々同じメールを2つ受け取る事
があります。これはとてもうるさく感じることもありますので、@code{nnmail} 
はそれが発見するかもしれない重複を調べて扱います。これをするために、古い 
@code{Message-ID} を保存します---@code{nnmail-messagge-id-cache-file} に。
これはディフォルトでは @file{~/.nnmail-cache} です。それに保存される最大
数の @code{Message-ID} は変数 @code{nnmail-message-id-cache-length} に制
御され、それはディフォルトで1000です。 (ですから、1000 @code{Message-ID} 
が溜められます。) これが恐ろしいと思ったなら、
@code{nnmail-treat-duplicates} を @code{warn} (ディフォルトではそのよう
になっていますが) に設定する事ができ、そうすれば、@code{nnmail} は重複メー
ルを消去しません。その代わりに、メールの先頭にこれは違ったメッセージの重
複であるという警告を挿入します。

この変数は関数である事もできます。その場合は、関数は @code{Message-ID} 
を引数として、当のメッセージに範囲を狭められたバッファから呼ばれます。こ
の関数は @code{nil}、@code{warn}、@code{delete} のどれかを返さなければな
りません。

変数を @code{nil} に設定する事によって、この機能を完全に使わないようにす
る事ができます。

もし全ての重複メールを特別な @dfn{duplicate} グループに入れたいのであれ
ば、普通のメール分割方法を使ってそれをすることができます:

@lisp
(setq nnmail-split-fancy
      '(| ;; 重複メッセージは分離されたグループへ行きます。
        ("gnus-warning" "duplication of message" "duplicate")
        ;; デーモンやポストマスターや似たようなものからの
        ;; メッセージは他のところへ。
        (any mail "mail.misc")
        ;; 他の法則。
        [ ... ] ))
@end lisp

もしくは次のようなもの:
@lisp
(setq nnmail-split-methods
      '(("duplicates" "^Gnus-Warning:")
        ;; 他の法則。
        [...]))
@end lisp

すばらしい機能があります: もし受け手がメールを gnus で読んでいる事を知っ
ていて、@code{nnmail-treat-duplicates} が @code{delete} に設定してあると、
あなたの知っている、その人が既に受け取ったメールの @code{Message-ID} を
使って、考える限りたくさんの侮辱を送る事ができます。その楽しさを考えてみ
てください！ その人はそれらを決してみる事はありません！ わぉ！


@node Not Reading Mail
@subsection メールを読むのではない

メールバックエンドを使い始めると、それらにはあなたがそれらでメールを読み
たいと思っていると仮定するといううるさい癖があります。これはもっともでな
い事ではないかもしれませんが、あなたの望む事ではないかもしれません。

もし @code{nnmail-spool-file} を @code{nil} に設定すると、どのバックエン
ドも入ってくるメールを読もうと試みる事はなく、望む事の手助けになるでしょ
う。

@vindex nnbabyl-get-new-mail
@vindex nnmbox-get-new-mail
@vindex nnml-get-new-mail
@vindex nnmh-get-new-mail
@vindex nnfolder-get-new-mail
例えば、@code{nnml} でメールを読む事に非常に満足していて、古い 
@sc{rmail} ファイルが @code{nnbabyl} で隠されているのをさっと見たいだけ
なら、これは余分でしょう。すべてのバックエンドは バックエンド-
@code{get-new-mail} という変数を持っています。もし @code{nnbabyl} のメー
ル読み込みを使用不可にしたいのであれば、グループの事実上のサーバーを 
@code{nnbabyl-get-new-mail} を @code{nil} に設定するように編集します。

全てのメールバックエンドは入ってくるメールを読み込むときに、保存されるべ
き記事に範囲を狭めて @code{nn}*@code{-prepare-save-mail-hook} を呼びます。


@node Choosing a Mail Backend
@subsection メールバックエンドを選ぶ

Gnus はメールグループを動作するようにするとメールスプールを読み込みます。
メールファイルはまずあなたのホームディレクトリーに複写されます。その後に
何が起こるかはメールをどの様式で溜めたいかによって変わります。

@menu
* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う。
* Rmail Babyl::                 Emacs のプログラムは rmail の babyl format を使う。
* Mail Spool::                  あなたのメールを私的なスプールに溜める？
* MH Spool::                    mhspool のようなバックエンド。
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ。
@end menu


@node Unix Mail Box
@subsubsection Unix メールボックス
@cindex nnmbox
@cindex unix mail box

@vindex nnmbox-active-file
@vindex nnmbox-mbox-file
@dfn{nnmbox} バックエンドはメールを蓄蔵するために標準の Un*x mbox ファイ
ルを用います。@code{nnmbox} はそれぞれのメール記事にそれがどのグループに
属しているかを示す追加のヘッダーを加えます。

事実上のサーバーの設定:

@table @code
@item nnmbox-mbox-file
@vindex nnmbox-mbox-file
利用者のホームディレクトリーのメールボックスの名前。

@item nnmbox-activate-file
@vindex nnmbox-active-file
メールボックスのアクティブファイルの名前。

@item nnmbox-get-new-mail
@vindex nnmbox-get-new-mail
@code{nil} でなければ、@code{nnmbox} は入って来たメールを読み込んでグルー
プに分割します。
@end table


@node Rmail Babyl
@subsubsection Rmail Babyl
@cindex nnbabyl
@cindex rmail mbox

@vindex nnbabyl-active-file
@vindex nnbabyl-mbox-file
@dfn{nnbabyl} バックエンドはメールを蓄蔵するために babyl メールボックス 
(別名 @dfn{rmail mbox}) を使います。@code{nnbabyl} はそれぞれの記事にそ
れがどのグループに属しているかを示す追加のヘッダーを加えます。

事実上のサーバーの設定:

@table @code
@item nnbabyl-mbox-file
@vindex nnbabyl-mbox-file
rmail mbox ファイルの名前

@item nnbabyl-active-file
@vindex nnbabyl-active-file
rmail box のためのアクティブファイルの名前。

@item nnbabyl-get-new-mail
@vindex nnbabyl-get-new-mail
@code{nil} でなければ、@code{nnbabyl} は入ってくるメールを読み込みます。
@end table


@node Mail Spool
@subsubsection メールスプール
@cindex nnml
@cindex mail @sc{nov} spool

@dfn{nnml} スプールメール様式は他の知られた様式とは互換性がありません。
それは少し注意して使われるべきです。

@vindex nnml-directory
もしこのバックエンドを使うと、gnus は入ってくるメールを、それぞれのメー
ルを1ファイルとしてファイルに分割し、記事を変数 @code{nnml-directory} で
指定されたディレクトリーの下の対応するディレクトリーに入れます。ディフォ
ルトの値は @file{~/Mail/} です。

前もってディレクトリーを作っておく必要はありません。それの面倒は gnus が
見てくれます。

もしあなたのアカウントに蓄積できるファイルの数に厳密な制限があるなら、こ
のバックエンドを使うべきではありません。それぞれのメールはそれ自身のファ
イルを得ますので、数週間でたくさんの iノードを占有する可能性は十分にあり
ます。別にこれが問題でなく、親切なシステム管理者が、気が狂ったように 
``誰が私の iノードを食いつぶしているんだ？ 誰だ？ 誰！？ と叫びながら歩
き回る事が問題でないなら、これがおそらく使う事のできる一番速い様式である
ということは知っておくべきでしょう。新しいメールを読むためだけに大きな 
mbox ファイルを重い足取りで探す必要はありません。

@code{nnml} は記事分割に関してはおそらく一番遅いバックエンドでしょう。そ
れは多くのファイルを作らなければならず、それは入ってくるメールのための 
@sc{nov} データベースも作成しなければなりません。これのために、メールを
読む事に関しては最速のバックエンドになります。

事実上のサーバーの設定:

@table @code
@item nnml-directory
@vindex nnml-directory
全ての @code{nnml} ディレクトリーはこのディレクトリーの下に置かれます。

@item nnml-active-file
@vindex nnml-active-file
@code{nnml} サーバーのためのアクティブファイル。

@item nnml-newsgroups-file
@vindex nnml-newgroups-file
@code{nnml} グループ記述ファイル。 @xref{Newsgroups File Format}。

@item nnml-get-new-mail
@vindex nnml-get-new-mail
@code{nil} でなければ、@code{nnml} は入って来たメール読み込みます。

@item nnml-nov-is-evil
@vindex nnml-nov-is-evil
@code{nil} でなければ、このバックエンドはどの @sc{nov} ファイルも無視し
ます。

@item nnml-nov-file-name
@vindex nnml-nov-file-name
@sc{nov} ファイルの名前。ディフォルトは @file{.overview} です。

@item nnml-prepare-save-mail-hook
@vindex nnml-prepare-save-mail-hook
保存する前に記事に範囲を狭めて実行するフックです。

@end table

@findex nnml-generate-nov-databases
@code{nnml} グループと @sc{nov} ファイルが完全に良い状態でなくなってしまっ
たなら、@kbd{M-x nnml-generate-nov-databases} と打つ事によって、完全に更
新する事ができます。この命令は、それぞれ全てのファイルを見る事によって 
@code{nnml} 階層全体をトロール魚網でさらいますので、それが終わるまでには
時間がかかるかもしれません。この機能へのより良いインターフェースはサーバー
バッファで見つかるでしょう (@pxref{Server Commands})。


@node MH Spool
@subsubsection MH スプール
@cindex nnmh
@cindex mh-e mail spool

@code{nnmh} は、@sc{nov} データベースを作らないこととアクティブファイル
を保持しない事を除いて、 @code{nnml} と似ています。そのことは 
@code{nnmh} を @code{nnml} より @emph{かなり} 遅いバックエンドにしていま
すが、それは procmail のスクリプトを書くためにずっとやりやすくなってもい
ます。

事実上のサーバーの設定:

@table @code
@item nnmh-directory
@vindex nnmh-directory
全ての @code{nnmh} ディレクトリーはこのディレクトリーの下に置かれます。

@item nnmh-get-new-mail
@vindex nnmh-get-new-mail
@code{nil} でなければ、@code{nnmh} は入ってくるメールを読み込みます。

@item nnmh-be-safe
@vindex nnmh-be-safe
@code{nil} でなければ、@code{nnmh} はフォルダーにある記事が実際に gnus 
が考えているものと同じであるかを調べるという馬鹿げた事をやります。それは
日付と目に入る全ての情報を調べますので、これを @code{t} に設定する事は深
刻な速度低下が起こるという事です。もし @code{nnmh} 記事を読むのに gnus 
以外のものを使っていないのであれば、この変数を @code{t} に設定する必要は
ありません。
@end table

@node Mail Folders
@subsubsection メールフォルダー
@cindex nnfolder
@cindex mbox folders
@cindex mail folders

@code{nnfolder} はそれぞれのメールグループを違ったファイルに蓄蔵するバッ
クエンドです。それぞれのファイルは標準の Un*x mbox 様式です。
@code{nnfolder} は記事番号と到着日を記録しておくための追加のヘッダーを加
えます。

事実上のサーバーの設定:

@table @code
@item nnfolder-directory
@vindex nnfolder-directory
全ての @code{nnfolder} メールボックスはこのディレクトリーの下に置かれま
す。

@item nnfolder-active-file
@vindex nnfolder-active-file
アクティブファイルの名前。

@item nnfolder-newgroups-file
@vindex nnfolder-newsgroups-file
グループ記述ファイルの名前。 @xref{Newsgroups File Format}。

@item nnfolder-get-new-mail
@vindex nnfolder-get-new-mail
@code{nil} でなければ、@code{nnfolder} は入ってくるメールを読み込みます。

@item nnfolder-save-buffer-hook
@vindex nnfolder-save-buffer-hook
@cindex backup files
フォルダーを保存する前に実行されるフックです。@code{nnfolder} バッファに
対してさえも Emacs は通常のバックアップの変名をする事に注意して下さい。
この機能を無効にしたいのであれば、ファイル @file{.emacs} で次のような事
をする事ができます:

@lisp
(defun turn off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'nnfolder-save-buffer-hook 'turn-off-backup)
@end lisp

@end table


@findex nnfolder-generate-active-file
@kindex M-x nnfolder-generate-active-file
@code{nnfolder} で読みたいと思う、たくさんの @code{nnfolder} のようなファ
イルを持っているのであれば、@code{nnfolder} に @code{nnfolder-directory} 
にある全てのそのようなファイルに気付かせるために、命令 @kbd{M-x
nnfolder-generate-active-file} を使う事ができます。


@node Other Sources
@section その他のグループ源

Gnus はただ単にニュースやメールを読む以上のことができます。以下
に示す方法によって、gnus でディレクトリーやファイルを、あたかも
ニュースグループであるかのように閲覧することができるようになりま
す。

@menu
* Directory Groups::      ディレクトリーをニュースグループのように読む。
* Anything Groups::       Dired?  誰が dired なんて使うの?
* Document Groups::       個別のファイル群はグループの素。
* SOUP::                  @sc{SOUP} パケットを ``オフライン''で読む。
* Web Searches::          文字列にマッチする記事からグループを作る。
* Mail-To-News Gateways:: メールからニュースへのゲートウェイを通して記事を投稿する。
@end menu


@node Directory Groups
@subsection ディレクトリーグループ
@cindex nndir
@cindex directory groups

もし、たくさんの記事が個別のファイルとして入っているディレクトリー
があれば、それをニュースグループとして扱うことができます。もちろ
ん、ファイルは数字のファイル名をもっていなければなりません。

ここで Emacs の素晴らしいパッケージの中でも最も素晴らしい 
@code{ange-ftp} (とその後継の @code{efs}) について触れる良い機会
でしょう。私が @code{nndir} を書いたときは、これ --- ディレクト
リーを読むバックエンドについてはあまり考えていませんでした。とん
でもないことだね。

@code{ange-ftp} はこの情況を劇的に変化させました。例えば、
@code{ange-ftp} ファイル名
@file{/ftp.hpc.uh.edu:/pub/emacs/ding-list/} をディレクトリー名
として入力したとすると、@code{ange-ftp} あるいは @code{efs} は実
に、@samp{シナ} の向こうのディレクトリーをニュースグループとして
読むことを可能にするのです。おーい、分散ニュースよ!

@code{nndir} は @sc{nov} ファイルが存在すればそれを利用します。

@code{nndir} は ``読み出し専用'' のバックエンドです --- この選択
方法では、記事の削除や期限切れ消去を行なうことはできません。
@code{nndir} が使えるものなら何でも @code{nnmh} あるいは
@code{nnml} を使うことができるので、もし読み出し専用ではない
@code{nndir} が必要だと思ったら、これらのどちらかの方法に切り替
えることもできます。


@node Anything Groups
@subsection なんでもグループ
@cindex nneething

(一つのスプール風ディレクトリーと解釈できる) @code{nndir} バック
エンドから@code{nneething} までは、ほんのすぐそこです。それはい
かなるディレクトリーでもニュースグループに見せかけてしまう、とい
うものです。不思議です、でも真実です。

@code{nneething} にディレクトリーを与えると、そのディレクトリー
を走査し、各ファイルに記事番号を割り当てます。このようなグループ
に入ったときは、@code{nneething} は gnus が使う ``ヘッダー'' を
作らなくてはなりません。つまるところ、gnus はニュースリーダなん
です。忘れてるかもしれないので念のため。@code{nneething} はこれを
2 段階で処理します。最初に、問題となるファイルをそれぞれ詮索して
まわります。もしそのファイルが記事のように見えたなら (すなわち、
最初の数行がヘッダーのように見えたら) それをヘッダとして使います。
もしそれがヘッダーのないただの適当なファイル (例えば C のソース
ファイル) であったなら、@code{nneething} はヘッダーを虚空から作
り出します。これはファイルの所有者、名前、日付を使い、これらの要
素に対してできることを何でもやります。

これはあなたにとっては全て自動的に起こることで、あなたはニュース
グループにとても良く似た何かを見せられることになるでしょう。ほん
とうに寸分違わない、ニュースグループのようなものを。記事を選択す
ると、それはいつものように、記事バッファに表示されるでしょう。

ディレクトリーを表わしている行を選択すると、gnus はあなたをこの
@code{nneething} グループのための新しい概略バッファに連れて行く
でしょう。以下同様で、もしあなたがそうしたければ、この方法で全ディ
スクを駆け巡ることができます。ですが、gnus は本当は dired ではな
く、そのように意図されたものでもない、ということは覚えておいてく
ださい。 

ここでの動作には全体的に 2 つのモードがあります --- 一時モードと
固定モードです。一時的な操作を行なっているときは(すなわち、グルー
プバッファで @kbd{G D} とする)、gnus はどのファイルを読んだか、
どのファイルが新しいか、などの情報を憶えておきません。もし@kbd{G
m} で普通に固定 @code{nneething} グループを作ると、gnusは記事番
号とファイル名の対応表を憶えておき、このグループを他のグループと
同様に扱うことができるようになります。固定@code{nneething} グルー
プを作動させると、未読記事がいくつ含まれているかを知らされたり、
などなど。

いくつかの変数があります。

@table @code
@item nneething-map-file-directory
@vindex nneething-map-file-directory
全ての固定 @code{nneething} グループの対応表はこのディレクトリー
に格納されます。この初期設定値は @file{~/.nneething/} です。

@item nneething-exclude-files
@vindex nneething-exclude-files
この正規表現にマッチするファイルはすべて無視されます。自動保存ファ
イルなどを除くのに便利に使えます。そしてそれがまさに初期設定で行
なわれる動作です。

@item nneething-map-file
@vindex nneething-map-file
対応表ファイルの名前。
@end table


@node Document Groups
@subsection 文書グループ
@cindex nndoc
@cindex documentation group
@cindex help group

@code{nndoc} は一つのファイルをニュースグループとして読むことを
できるようにする、ちょっと気の利いたやつです。いくつかのファイル
種別がサポートされています。

@table @code
@cindex babyl
@cindex rmail mbox

@item babyl
babyl (rmail) 形式のメールボックス。
@cindex mbox
@cindex Unix mbox

@item mbox
標準 Unix mbox ファイル。

@cindex MMDF mail box
@item mmdf
MMDF 形式のメールボックス。

@item news
いくつかのニュース記事が連結された一つのファイル。

@item rnews
@cindex rnews batch files
rnews のバッチ転送形式。
@cindex forwarded messages

@item forward
転送された記事。

@item mime-parts
集配配送 (digest) の他の MIME 多部分メッセージ (multipart message) です。

@item mime-digest
@cindex digest
@cindex MIME digest
@cindex 1153 digest
@cindex RFC 1153 digest
@cindex RFC 341 digest
MIME (RFC 1341) まとめ送り形式。

@item standard-digest
標準 (RFC 1153) まとめ送り形式。

@item slack-digest
非標準まとめ送り形式 --- だいたいはうまくマッチするが、でも扱いは下手。
@end table

また、特別な ``ファイル種別'' @code{guess} を使うこともできます。
これは @code{nndoc} は注目しているファイルの種別を推測しようとす
る、という意味です。@code{digest} は @code{nndoc} にそのファイル
がどのまとめ送り形式かを推測させるという意味です。

@code{nndoc} はファイルを書き換えようとしたり、余分なヘッダーを
挿入しようとしたりはしません --- 単純に、ファイルをそのグループ
の主成分として使えるようにする、というようなものです。それだけの
ことです。

もしあなたが古い保存記事を持っていて、それを新しくてかっこいい
gnus のメールバックエンドに追加したいというときは、おそらく
@code{nndoc} が助けになります。例えばあなたがメールを古い
@file{RMAIL} で持っていて、それをあなたの新しい @code{nnml} グルー
プに分配したいとします。あなたはそのファイルを @code{nndoc} を使っ
て開いて (グループバッファで @kbd{G f} 命令を使う 
(@pxref{Foreign Groups}))、バッファ内の全記事にプロセスマークを
付け (例えば @kbd{M P b})、そして @code{nnml} を使って再スプール
(@kbd{B r}) します。全てがうまく行けば、@file{RMAIL} ファイル内
の全てのメールはたくさんの  @code{nnml} ディレクトリーの中にも保
存されます。そしてあなたはあの厄介な @file{RMAIL} を削除すること
もできます。あなたにガッツがあれば!

仮想サーバー変数。

@table @code
@item nndoc-article-type
@vindex nndoc-article-type
これは @code{mbox}、 @code{babyl}、 @code{digest}、@code{news}、 
@code{rnews}、 @code{mmdf}、 @code{forward}、 @code{rfc934}、
@code{rfc822-forward}、 @code{mime-digest}、 
@code{standard-digest}、@code{slack-digest}、 
@code{clari-briefs}、@code{guess} のいずれかでなくてはなりません。

@item nndoc-post-type
@vindex nndoc-post-type
この変数は gnus にそのグループがニュースグループかメールグループ
かを教えます。正当な値は 2 つあります。 @code{mail} (初期設定)か
 @code{news}です。
@end table

@menu
* Document Server Internals::   あなた独自の文書種別を追加する方法。
@end menu


@node Document Server Internals
@subsubsection 文書サーバーの内部

@code{nndoc} で認識される新しい文書種別を追加することは難しくあ
りません。その文書がどのように見えるのかを寄せ集めて、その文書種
別を認識する述語関数を書き、そして @code{nndoc} に繋げるだけです。

まず、これが文書種別定義の例です。

@example
(mmdf
 (article-begin .  "^\^A\^A\^A\^A\n")
 (body-end .  "^\^A\^A\^A\^A\n"))
@end example

この定義は単に、唯一の名前 (@dfn{name}) とそれに続く正規表現と仮
想変数設定の列からなります。以下がこれに使える変数です --- 変数
の数に圧倒されないでください。ほとんどの文書種別はごくわずかの設
定で定義できます。

@table @code
@item first-article
これがあれば、@code{nndoc} はこの正規表現にマッチする何かが見つ
かるまで、全てのテキストを読み飛ばします。 マッチする前の全ての
テキストは完全に無視されます。

@item article-begin
この設定は全ての文書種別定義において必ずなくてはなりません。これ
は各記事の始まりがどのように見えるかを指定します。

@item head-begin-function
これがある場合、これは記事の先頭にポイントを移動させる関数でなく
てはなりません。

@item nndoc-head-begin
これがある場合、これは記事のヘッダーにマッチする正規表現でなくて
はなりません。

@item nndoc-head-end
これは記事のヘッダーの最後にマッチしなくてはなりません。この初期
設定値は @samp{^$} --- 空行です。

@item body-begin-function
これがある場合、この関数は記事のボディの開始位置にポイントを移動
させる関数でなくてはなりません。

@item body-begin
これは記事のボディの開始位置にマッチしなくてはなりません。この初
期設定値は @samp{^\n} です。

@item body-end-function
これがある場合、この関数は記事のボディの最後の位置にポイントを移
動させる関数でなくてはなりません。

@item body-end
これがあれば、記事のボディの最後にマッチしなくてはなりません。

@item file-end
これがある場合、これはファイルの最後にマッチしなくてはなりません。
この正規表現の後ろのテキストは全て、完全に無視されます。

@end table

このように、これらの変数を使って @code{nndoc} は文書ファイルを、
それぞれヘッダーとボディを持った記事の連なりとして解剖することが
できます。しかし、全ての文書種別が全てこのようなニュース風になっ
てるわけではないので、さらにいくつかの変数 --- ヘッダーやボディ
を gnus の趣味に合うように変形させる変数が必要になります。

@table @code
@item prepare-body-function
これがあれば、この関数は記事が要求されたときに呼び出されます。こ
れはボディの開始位置のポイントとともに呼び出され、文書の内容の一
部が符号化されている場合に有用です。

@item article-transform-function
これがあれば、この関数は記事が要求されたときに呼び出されます。こ
れは、記事のヘッダーとボディの両方により広範囲な変形を行なうため
に使われるものです。

@item generate-head-function
これがあれば、この関数は gnus が理解できるヘッダーを生成するため
に呼び出されます。これは記事番号をパラメータとして呼び出され、問
題の記事のきれいなヘッダーを生成することを求められます。これは全
ての記事のヘッダーが要求されるときに呼び出されます。

@end table

私が作った中で最も複雑な例 --- 標準まとめ送り形式を見てみましょう。

@example
(standard-digest
 (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
 (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
 (prepare-body-function . nndoc-unquote-dashes)
 (body-end-function . nndoc-digest-body-end)
 (head-end . "^ ?$")
 (body-begin . "^ ?\n")
 (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
 (subtype digest guess))
@end example

70 文字のダッシュ(`-')の行より前は全て無視されるというのが分かりま
す。また @samp{^End of} で始まる行より後ろも全て無視されます。各
記事は30 文字のダッシュの行で始まり、ヘッダーとボディの区切りの
行は一個のスペースを含むことがあり、そしてボディはそれが渡される
前に @code{nndoc-unquote-dashes} を通されます。

あなた独自の文書定義を @code{nndoc} に接続するには、
@code{nndoc-add-type} 関数を使用します。これは二つのパラメータを
とります --- 一つ目はその定義自身で、二つ目の (省略可能な) パラ
メータはこの定義を、文書種別定義連想リストのどこに置くかを指定し
ます。この連想リストは順番に走査され、与えられた種別 @code{TYPE} 
に対して @code{nndoc-TYPE-type-p} が呼び出されます。このように文
書が @code{mmdf} 種別であるかどうかを調べるために
@code{nndoc-mmdf-type-p} が呼び出され、そして以下同様に続きます。
これらの種別述語関数は、その文書がその種別でない場合は
@code{nil} を返し、その種別である場合は @code{t} を返し、その種
別かもしれないときは数字を返さなくてはなりません。高い数字は高い
可能性を意味し、低い数字は低い可能性を意味します。@samp{0} は正
しい値の中でもっとも低い数字です。


@node SOUP
@subsection SOUP
@cindex SOUP
@cindex offline

PC の世界の人々はよく、``オフライン'' ニュースリーダについて話を
しています。これはリーダとニュース配送を合体させた、実在するモン
スターです。内蔵モデムプログラム付きでね。きゃはは!

もちろん、我らが Unix キチガイの人間供は @code{uucp} だとか
@code{nntpd} のようなものを使い、神の領域たるメール、ニュースの
配送を正しく設定するのです。そして僕たちはただ普通のニュースリー
ダを使います。

しかし、あなたがとても遅いモデムを持っていてこれらを正しく設定す
ることに興味が無ければ、脳みそに楽をさせる方をするのも時には便利
です。

@sc{soup} と呼ばれるファイル形式はニュースとメールをサーバーから
家のマシンへと転送し、それをまた戻すために開発されました。ちょっ
と面倒くさいかもしれないけどね。

はじめにいくつか用語を。

@table @dfn

@item server
これは外の世界に繋がっていて、あなたがニュースとメールを送受信す
るマシンです。

@item home machine
これはあなたが実際に読んだり返事を書いたりしたいマシンです。これ
は普通、他の世界といかなる形でも接続されていません。

@item packet
メッセージと命令を含んだもの。パケットには二種類あります。

@table @dfn
@item message packets
これはサーバーで作られるパケットで、普通はあなたが読むためのた
くさんのメッセージが含まれています。これらは初期設定では
@file{SoupoutX.tgz} という名前です。ここで @var{X} は数字です。

@item response packets
(返信パケット)
このパケットは自宅マシンで作られるパケットで、普通はあなたの書い
た返事が含まれています。これらは初期設定では
@file{SoupinX.tgz} という名前です。ここで @var{X} は数字です。

@end table

@end table


@enumerate

@item
まず @sc{soup} パケットを作るためにサーバーにログインします。
@sc{soup} のための専用のブツ (@code{awk} プログラムのような) を
使っても良いし、 gnus の @sc{soup} 命令を使ってパケットを作って
も良いです (@kbd{O s} あるいは @kbd{G s b} そして @kbd{G s p})
(@pxref{SOUP Commands})。

@item
パケットを自宅に転送します。電車で、船で、自動車で、あるいはモデ
ムで、何でもいいです。

@item
パケットをあなたのホームディレクトリーに置きます。

@item
Gnus をあなたの自宅マシンでかっ飛ばして、 @code{nnsoup} バックエ
ンドを基本サーバーあるいは二次サーバーとして使用します。

@item
記事やメールを読んで必要なやつに返事を書いてフォローアップ記事を
書きます (@pxref{SOUP Replies})。

@item
@kbd{G s r} 命令を実行して、これらの返事を @sc{soup} パケットに
梱包します。

@item
このパケットをサーバーに転送します。

@item
Gnus から @kbd{G s s} 命令を使ってこのパケットからメールを出します。

@item
あとはこれを死ぬまで続けます。

@end enumerate

つまり基本的に二者分割システムができたことになります ---
@code{nnsoup} を読むために、gnus を @sc{soup} パケットの梱包と送
出に使います。 

@menu
* SOUP Commands::     @sc{soup} パケットを作成、送出する命令。
* SOUP Groups::       @sc{soup} パケットを読むバックエンド。
* SOUP Replies::      @code{nnsoup} にメールとニュースを引き継がせる方法。
@end menu


@node SOUP Commands
@subsubsection SOUP 命令

これらの命令は @sc{soup} パケットの作成と操作を行なうものです。

@table @kbd
@item G s b
@kindex G s b (Group)
@findex gnus-group-brew-soup
現在のグループの全ての未読記事を梱包する
(@code{gnus-group-brew-soup})。このコマンドはプロセス/接頭引数の
習慣に従います。

@item G s w
@kindex G s w (Group)
@findex gnus-soup-save-areas
全ての @sc{soup} データファイルを保存します
(@code{gnus-soup-save-areas})。

@item G s s
@kindex G s s (Group)
@findex gnus-soup-send-replies
返信パケットから全ての返信を送出する
(@code{gnus-soup-send-replies})。

@item G s p
@kindex G s p (Group)
@findex gnus-soup-pack-packet
全てのファイルを  @sc{soup} パケットに梱包する
(@code{gnus-soup-pack-packet})。

@item G s r
@kindex G s r (Group)
@findex nnsoup-pack-replies
全ての返信を返信パケットに梱包する (@code{nnsoup-pack-replies})。

@item O s
@kindex O s (Summary)
@findex gnus-soup-add-article
この概略モード命令は、現在の記事を @sc{soup} パケットに追加しま
す (@code{gnus-soup-add-article})。これはプロセス/接頭引数の習慣
に従います (@pxref{Process/Prefix})。

@end table


gnus がこれらの実体をどこに置くかをカスタマイズするいくつかの変
数があります。

@table @code

@item gnus-soup-directory
@vindex gnus-soup-directory
@sc{soup} パケットを作成中に gnus が中間ファイルを保存するディレ
クトリー。初期設定値は @file{~/SoupBrew/}。

@item gnus-soup-replies-directory
@vindex gnus-soup-replies-directory
返信パケット送信中に gnus が使用する一時ディレクトリー。
@file{~/SoupBrew/SoupReplies/} が初期設定値。

@item gnus-soup-prefix-file
@vindex gnus-soup-prefix-file
gnus が最後に使った接頭引数を保存するファイル名。初期設定値は
@samp{gnus-prefix}。

@item gnus-soup-packer
@vindex gnus-soup-packer
@sc{soup} パケットを梱包する命令文字列の形式。初期設定値は
@samp{tar cf - %s | gzip > $HOME/Soupout%d.tgz}。

@item gnus-soup-unpacker
@vindex gnus-soup-unpacker
@sc{soup} パケットを取り出す命令文字列の形式。初期設定値は
@samp{gunzip -c %s | tar xvf -}。

@item gnus-soup-packet-directory
@vindex gnus-soup-packet-directory
gnus が返信パケットを探しに行く場所。初期設定値は @file{~/}。

@item gnus-soup-packet-regexp
@vindex gnus-soup-packet-regexp
@code{gnus-soup-packet-directory} 内の @sc{soup} パケットにマッ
チする正規表現。

@end table


@node SOUP Groups
@subsubsection @sc{soup} グループ
@cindex nnsoup

@code{nnsoup} は @sc{soup} パケットを読むためのバックエンドです。
これは入ってきたパケットを読み、それを取り出して、あなたが暇なと
きに読むディレクトリーに展開します。

これらはこの振る舞いをカスタマイズできる変数です。

@table @code

@item nnsoup-tmp-directory
@vindex nnsoup-tmp-directory
@code{nnsoup} が @sc{soup} パケットを取り出すとき、このディレク
トリ内で行なう (初期設定は @file{/tmp/})。

@item nnsoup-directory
@vindex nnsoup-directory
そして @code{nnsoup} がそれぞれのメッセージと索引ファイルをこの
ディレクトリーに移動させる。初期設定は @file{~/SOUP/}。

@item nnsoup-replies-directory
@vindex nnsoup-replies-directory
全ての返信は、返信パケットに梱包される前にこのディレクトリーに格
納される。初期設定は @file{~/SOUP/replies/"}。

@item nnsoup-replies-format-type
@vindex nnsoup-replies-format-type
返信パケットの @sc{soup} 形式。初期設定値は @samp{?n} (rnews)
で、この変数には触るべきではないと私は思います。たぶん文書に明記
すべきでさえなかったね。ちぇっ! もう手遅れか。

@item nnsoup-replies-index-type
@vindex nnsoup-replies-index-type
返信パケットの索引の種類。初期設定値は @samp{?n} で、意味は
``なし''。これもいじるんじゃないよ!

@item nnsoup-active-file
@vindex nnsoup-active-file
@code{nnsoup} がたくさんの情報を格納する場所。これは @code{nntp}
の意味での ``アクティブファイル'' ではなく、Emacs Lisp のファイ
ルです。このファイルを無くしてしまったり、何か壊してしまったら、
あなたは死にます。初期設定値は @file{~/SOUP/active} です。

@item nnsoup-packer
@vindex nnsoup-packer
返信 @sc{soup} パケットを梱包する命令文字列の形式。初期設定値
は @samp{tar cf - %s | gzip > $HOME/Soupin%d.tgz}。

@item nnsoup-unpacker
@vindex nnsoup-unpacker
入ってくる @sc{soup} パケットを取り出すための命令文字列の形式。
初期設定値は @samp{gunzip -c %s | tar xvf -}。

@item nnsoup-packet-directory
@vindex nnsoup-packet-directory
入ってきたパケットを @code{nnsoup} が探す場所。初期設定値は
@file{~/}。

@item nnsoup-packet-regexp
@vindex nnsoup-packet-regexp
入ってきた @sc{soup} パケットにマッチする正規表現。初期設定値
は @samp{Soupout}。

@item nnsoup-always-save
@vindex nnsoup-always-save
@code{nil} 以外であれば、メッセージを投稿した後に返信バッファを
保存する。

@end table


@node SOUP Replies
@subsubsection SOUP 返信

単に @code{nnsoup} を使うだけでは、@sc{soup} 返信パケット中のあ
なたの投稿とメールの送信が、魔法のように自動的に終了するわけでは
ありません。それを起こすにはもうちょっと働かなくてはいけません。

@findex nnsoup-set-variables
@code{nnsoup-set-variables} 命令は、あなたの全てのフォローアップ
記事と返信を @sc{soup} システムに確実に終了させるように、適切な
変数を設定します。

特別に、これが実際に行われることです。

@lisp
(setq message-send-news-function 'nnsoup-request-post)
(setq message-send-mail-function 'nnsoup-request-mail)
@end lisp

それだけです、ほんとに。もし @sc{soup} システムにニュースだけを
入れたかったら、最初の行だけを使ってください。もしメールだけを
@sc{soup} させたかったら、二番目を使ってください。


@node Web Searches
@subsection ウェブ検索
@cindex nnweb
@cindex DejaNews
@cindex Alta Vista
@cindex InReference
@cindex Usenet searches
@cindex searching the Usenet

それは、なんというか、Usenet から文字列にマッチする記事を検索す
るのはとても素晴らしいんだけど、その、あのウェブブラウザーってや
つを使って、そんでもって、宣伝を読ませられるっていうのは、その、
なんというか、ほんとうに @emph{「不様ね」} というか、それで、
gnus ではブラウザーを使わずに、その、@emph{超かっこよく}それがで
きる、ってことです。

@code{nnweb} バックエンドは、強力な検索エンジンに対して簡単なイ
ンターフェースを提供します。@code{nnweb} グループを作成し、検索
パターンを入力し、そしてそのグループに入って他の普通のグループの
ように記事を読みます。グループバッファ (@pxref{Foreign
Groups}) の @kbd{G w} 命令によってお手軽にこれができます。

@code{nnweb} グループは、固定グループになろうとはしません --- こ
のグループでは記事番号はごく一時的なものとして扱います。つまり、
@code{nnweb} グループに入るたびに(たとえ検索パターンを変更してい
なくとも)、記事の順序が違っているかもしれません。また、重複抑制 
(@pxref{Duplicate Suppression}) を使ってもうまく働かないでしょう。
というのは、@code{nnweb} は検索エンジン(例えば DejaNews) を使っ
て記事を読み込むまでは、@code{Message-ID} を知ることはできないか
らです。あなたが読んだ記事を憶えておくための唯一の方法は、
@code{Date} ヘッダーをもとにスコアを付けることだけです --- つま
りあなたがそのグループを最後に読んだ日付より、前に投稿された記事
を全て既読にする、ということです。

もし検索エンジンの出力形式が変更されると、@code{nnweb} はそれを
うまく解釈できず、処理は失敗するでしょう。もしウェブ提供者達がそ
んなことをしたら、彼らを激しく責めるべきでしょう --- それは広告
で金を稼ぐのが彼らの @emph{存在理由} であり、社会にサービスを提
供することではないからです。@code{nnweb} は全ての記事から広告を
洗い流してしまうので、提供者たちがムカついていると思われるかも知
れません。まあ見ててください。

@code{nnweb} を使うには、@code{url} と @code{w3} パッケージをイ
ンストールしておかなくてななりません。

以下は仮想サーバー変数です。

@table @code
@item nnweb-type
@vindex nnweb-type
どの検索エンジンを使っているか。現在サポートされている種類は、
@code{dejanews}、 @code{dejanewsold}、 @code{altavista}、
@code{reference} です。

@item nnweb-search
@vindex nnweb-search
検索エンジンに与える検索文字列。

@item nnweb-max-hits
@vindex nnweb-max-hits
表示する検索結果の最大数。初期値は 100 です。

@item nnweb-type-definition
@vindex nnweb-type-definition
型・定義連想リスト。この連想リストは、さまざまな検索エンジンの種
類に対して、 @code{nnweb} がどうすべきかを与えます。以下に示す要
素を与えなくてはなりません。

@table @code
@item article
記事を復号化し、gnus が理解できる形で提供する関数。

@item map
記事番号からメッセージヘッダーと URL を得る連想リストを作成する関数。

@item search
検索エンジンに検索文字列を送る関数。

@item address
前述の関数が検索文字列を送るべきアドレス。

@item id
@code{Message-ID} をもとに記事を取得するための URL 形式文字列。
@end table

@end table



@node Mail-To-News Gateways
@subsection メールからニュースへのゲートウェイ
@cindex mail-to-news gateways
@cindex gateways

もしあなたのローカルの @code{nntp} サーバーが、何らかの理由で投
稿を許可していなければ、数あるメールからニュースへのゲートウェイ
を使って投稿することができます。@code{nngateway} バックエンドは
このインターフェースを提供します。

このバックエンドからは何も読み出せないことに注意してください ---
これは投稿するためだけに使われます。

以下はサーバー変数です。

@table @code
@item nngateway-address
@vindex nngateway-address
これがメール・ニュースゲートウェイのアドレスです。

@item nngateway-header-transformation
@vindex nngateway-header-transformation
ニュースヘッダーは、メール・ニュースゲートウェイが受け付けられる
ように、奇妙な形に変形しておかなくてはならない時があります。この
変数はどんな変形処理が呼び出されるべきかを示しており、初期設定値
は @code{nngateway-simple-header-transformation} になっています。
この関数は変形するヘッダーに領域制限(narrow)されて呼び出され、一
個の引数 --- ゲートウェイのアドレスを与えられます。

初期設定値の関数は単に新しい @code{To} ヘッダーを、
@code{Newsgroups} ヘッダーとゲートウェイアドレスをもとに挿入しま
す。例えば、以下のような @code{Newsgroups} ヘッダー

@example
Newsgroups: alt.religion.emacs
@end example

を持つ記事には、次のような @code{To} ヘッダーが挿入されます。

@example
To: alt-religion-emacs@@GATEWAY
@end example

以下の既製関数が存在します:

@findex nngateway-simple-header-transformation
@table @code

@item nngateway-simple-header-transformaton
@var{newsgroup}@@@code{nngateway-address} のような @code{To} ヘッダーを
つくります。

@findex nngateway-mail2news-header-transformation

@item nngateway-mail2news-header-transformation
@code{nngateway-address} のような @code{To} ヘッダーをつくります。

ここに例があります。

@lisp
(setq gnus-post-method
      '(nngateway "mail2news@@replay.com"
                  (nngateway-header-transformation
                   nngateway-mail2news-header-transformation)))
@end lisp

@end table


@end table

つまり、これを使うには、こんな風にするだけです。

@lisp
(setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))
@end lisp


@node Combined Groups
@section 結合グループ

Gnus は、全てのグループの種類を混合して、大きなグループに結合す
ることができます。

@menu
* Virtual Groups::     たくさんのグループの記事を結合する。
* Kibozed Groups::     ニューススプールの中からの記事を検索する。
@end menu


@node Virtual Groups
@subsection 仮想グループ
@cindex nnvirtual
@cindex virtual groups

nnvirtual グループ (@dfn{nnvirtual group}) は実は他のグループの
集合以上の何物でもありません。

例えば、もし小さなグループをたくさん読むのが嫌になってきたら、そ
れらを一つの大きなグループに入れて、嫌になるくらい巨大で手に負え
ないグループを読むことができます。これがコンピューターの楽しみだ
ね!

選択方法として @code{nnvirtual} を指定してください。アドレスは、
それを構成するグループにマッチする正規表現です。

仮想グループ内で付けられた全ての印は、その構成グループの記事にくっ
つけられます。つまり、もし仮想グループ内で記事に可視記事の印をつ
けると、その記事はもともとの構成グループの中でも可視記事になりま
す。 (そして逆も成り立ちます --- 構成グループ内で付けた印は仮想
グループ内でも表示されます。)

これが、Andrea Dworkin に関する全てのニュースグループを、一つの
巨大でシアワセなニュースグループにまとめる @code{nnvirtual} 方法
の例です。

@lisp
(nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")
@end lisp

構成グループは基本グループでも外部グループでも構いません。全て問
題無く動くはずですが、もしあなたのコンピューターが爆発でもしてし
まったら、それはたぶん私が悪いんでしょうね。

いくつかのサーバーから同じグループを集めることは、利用者が
Distribution ヘッダーを使って配布範囲を制限している場合は、非常
に良いかも知れません。もしあなたが @samp{soc.motss} を、日本のサー
バーとノルウェーのサーバーの両方から読みたければ、グループの正規
表現として以下の値が使えます。

@example
"^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"
@end example

(でもちょっと注意。@kbd{G m} でグループを作成するときは、バック
スラッシュを二重に付けてはいけません。そして文字列の最初と最後の
引用記号も取り払ってください。)

これはちょっとうまく動作するはずです --- 両方のグループの記事は
全部完全に一つのグループになり、重複も無いはずです。スレッド表示
(とその他)も通常通りうまく動作するでしょうけど、記事の並ぶ順序に
は問題があるかもしれません。日付による並べ替えはここでは仕様外と
なるかもしれません (@pxref{Selecting a Group})。

なお、ここで一つだけ制限があります --- 仮想グループに含まれるグ
ループは全て生きている(すなわち、購読または非購読の)状態でなくて
はなりません。削除あるいはゾンビグループは @code{nnvirtual} グルー
プの構成グループになることはできません。

@vindex nnvirtual-always-rescan
@code{nnvirtual-always-rescan} が @code{nil} 以外であれば、
@code{nnvirtual} は仮想グループに入ったとき常に、未読記事を走査
します。この変数が @code{nil} (これが初期設定)であって、仮想グルー
プを作成した後に構成グループ内の記事を読んだ場合は、その構成グルー
プで読まれた記事は、仮想グループに入ったときに表示され るでしょ
う。もし共通の構成グループを持つ二つの仮想グループがある場合にも
この影響があります。その場合はこの変数を @code{t} にした方が良い
です。あるいは仮想グループに入る時に、毎回そのグループの上で 
@code{M-g} を叩いても良いです --- これはほぼ同様の効果があります。

@code{nnvirtual} はメールとニュースの両方のグループを構成グループとする
事ができます。@code{nnvirtual} グループの記事に返答するときは、
@code{nnvirtual} は記事の出所の構成グループのバックエンドにそれがニュー
スのバックエンドであるかメールのバックエンドであるかを尋ねなければなりま
せん。しかし、@kbd{^} をしたときには、普通は構成バックエンドがこれを知る
確かな方法はなく、その場合は、@code{nnvirtual} は gnus に記事はニュース
でないバックエンドから来たと告げる事になります。 (安全のために。)

このような場合は、メッセージバッファでの @kbd{C-c C-t} が応答しようとし
ている記事から @code{Newsgroups} 行を抜き出して挿入します。



@node Kibozed Groups
@subsection Kiboze グループ
@cindex nnkiboze
@cindex kibozing

@dfn{Kiboze} する、とは、``ニューススプール全部(あるいはその一部)
から grep すること'' とオックスフォード大辞典によって定義されてい
ます。@code{nnkiboze} はこれをあなたのために行ってくれるバックエ
ンドです。嬉しいね! これでどんな @sc{nntp} サーバーでも、役に立
たない要求で止まってしまうまで酷使することができるね。ああ、なん
て幸せなんだ!

@kindex G k (Group)
kiboze グループを作成するには、グループバッファで @kbd{G k} 命令
を使います。

@code{nnkiboze} 方法におけるアドレス欄は、@code{nnvirtual} と同
様に、@code{nnkiboze} に ``含めたい'' グループにマッチする正規表
現です。ここが @code{nnkiboze} と @code{nnvirtual} バックエンド
の最も類似している点です。

この構成グループを列挙する正規表現に加えて、@code{nnkiboze} グルー
プには、グループ内のどの記事を含めるかを決めるスコアファイルがな
くてはなりません (@pxref{Scoring})。

@kindex M-x nnkiboze-generate-groups
@findex nnkiboze-generate-groups
あなたの欲しい @code{nnkiboze} グループを作成した後には、
@kbd{M-x nnkiboze-generate-groups} を実行しなければなりません。
この命令は時間がかかります。とってもかかります。すごく、すごーく
かかります。Gnus はその @code{nnkiboze} グループの一部となるべき
記事があるかどうかを調べるために、全部の構成グループの全部の記事
に対してヘッダーを取得し、それら全てに対してスコア処理を実行しな
くてはならないのです。

構成グループの数を抑えるように、限定した正規表現を使ってください。
さもないと、あなたのところのシステム管理者を怒らせてしまって、
@sc{nntp} サーバーからあなたを追い出して二度と入れないようにして
しまうかも知れません。不慣れな人がよくやることです。

@code{nnkiboze} の構成グループは生きている必要はありません ---
死んでても良いし、外部グループでも構いません。無制限です。

@vindex nnkiboze-directory
@code{nnkiboze} グループの生成によって、二つのファイルが
@code{nnkiboze-directory} 内に作成されます。この初期設定値は
@file{~/News/} です。一方のファイルはそのグループの全記事の
@sc{nov} ヘッダー行を含んでいて、もう一方は構成記事を見つけるた
めにどのグループが検索されたかの情報を格納する、@file{.newsrc} 
の補助ファイルです。

@code{nnkiboze} グループ内の既読となった記事は、その記事の 
@sc{nov} 行が @sc{nov} ファイルから削除されます。


@node Gnus Unplugged
@section Gnus の切り離し
@cindex offline
@cindex unplugged
@cindex Agent
@cindex Gnus Agent
@cindex Gnus Unplugged

いにしえの時代(およそ 1988 年 2 月頃)、人々はニュースリーダーを、
大きなマシンの上でネットワークに永続的に接続して走らせていました。
ニュースの配送はニュースサーバーによって取り扱われ、全てのニュー
スリーダーがすべきことは、ニュースを読むことであったのです。信じ
られないかもしれませんが。

今日では、多くの人々は自宅でニュースやメールを読み、ネットワーク
に接続するためにモデムの類を使います。電話代の請求書が莫大なもの
に上らないように、全てのニュースとメールを吸い上げ、電話を切り、
数時間掛けて読み、そして送りたい返信を全て送信する、という手段を
持つことは良いことでありましょう。あとはこの手順を繰り返すのです。

もちろん、これを行うためにニュースサーバーを使うこともできます。
私は @code{inn} を @code{slurp}、@code{pop}、 @code{sendmail} と
一緒にここ数年使ってきましたが、しかしこれは退屈な仕事です。もし
あるマシン上でニュースを読む人があなたしかいなければ、ニュースサー
バーの機能をニュースリーダーに任せるようにすることは理にかなって
います。

Gnus を ``オフライン'' のニュースリーダーとして使うのは極めて簡
単です。

@itemize @bullet
@item
まず、ネットワークに完全に繋がっているマシン上で動作させるのと同
じように、gnus を設定します。まずやっておいで。僕はここで待って
るから。

@item
そしたら、以下の魔法の呪文をあなたの @file{.gnus.el} ファイルの
最後に書いてください。

@lisp
(gnus-agentize)
@end lisp
@end itemize

こんだけです。これで gnus は ``オフライン'' ニュースリーダーになっ
てしまいました。

もちろん、これをオフラインニュースリーダーとして使うには、いくつ
か新しい命令を覚えなくてはなりません。

@menu
* Agent Basics::           これらはどう動くのか。
* Agent Categories::       何をダウンロードするかを gnus エージェントに教える方法。
* Agent Commands::         各バッファーでの新しい命令。
* Agent Expiry::           古い記事を消す方法。
* Outgoing Messages::      投稿、メールを出すときになにが起こるのか? 
* Agent Variables::        カスタマイズは楽し。
* Example Setup::          オフライン人間のための @file{.gnus.el} の例。
* Batching Agents::        @code{cron} ジョブによるニュース取得方法。
@end menu


@node Agent Basics
@subsection エージェントの基礎

まず、いくつかの用語を片付けておきましょう。

あなたがネットワークとの通信が切れているとき(でエージェントがそ
れを知らされているとき)は、gnus エージェントは切り離されている
(@dfn{unplugged})、と言います。ネットワークの通信が復活し (そし
て gnus がそれを知れば)、エージェントは差し込まれている
(@dfn{plugged})、と言います。

ローカル (@dfn{local}) マシンとは、あなたが触っているマシンで、
ネットワークに継続的に接続されているものではありません。

ダウンロード (@dfn{download}) とはネットワークから何かをあなたの
ローカルマシンに取ってくることを意味します。アップロード 
(@dfn{upload}) はその逆をすることです。

エージェントを使った典型的な gnus の対話操作を見てみましょう。

@itemize @bullet

@item
Gnus を @code{gnus-unplugged} で起動します。これは gnus エージェ
ントを切り離されている状態で起動します。この状態では、すでに取得
しているニュース記事は全て読むことができます。

@item
そして、新しいニュースが到着しているかどうかを調べることにします。
あなたは (PPP か何かを使って) あなたのマシンをネットワークに接続
し、そして gnus を差し込むために @kbd{J j} を叩きます。

@item
そして、その場ですぐに新しいニュースを読むこともできますし、ニュー
スをローカルマシンにダウンロードすることもできます。後者を実行し
たければ、@kbd{J s} を押して、全グループから適切な記事を全て取得
します。(Gnus にどの記事をダウンロードしたいかを指定するには
@pxref{Agent Categories} を参照してください。)

@item
記事を取得した後は @kbd{J j} を押して、gnus を再び切り離し状態に
させ、PPP 関係(など)を閉じます。そうしてニュースをオフラインで読
むことができます。

@item
そして第 2 ステップに戻ります。
@end itemize

以下にエージェントを初めて(かそこらに)使うときに必要ないくつかの
作業を示します。

@itemize @bullet

@item
どのサーバーをエージェントで面倒を見るかを決めます。もしメールバッ
クエンドがあれば、それをエージェントに面倒を見させるのはおそらく
無意味でしょう。サーバーバッファーに移動し (グループバッファーで
@kbd{^})、エージェントに扱って欲しいサーバー(複数可)で @kbd{J a}
を押します (@pxref{Server Agent Commands})。これは大抵の場合、バッ
ファーの下に一覧表示されている基本選択方法だけでしょう。

@item
ダウンロード方針を決定します。@xref{Agent Categories}.

@item
ええと…、以上です。
@end itemize


@node Agent Categories
@subsection エージェント分類

ニュース配送機構とニュースリーダーを統合する一つの大きな理由は、
どの記事をダウンロードするかについて、より良い制御を可能とするこ
とです。莫大な量の記事をダウンロードしてもあまり意味はなく、それ
らを読んでもあまり面白くないことが分かるだけです。何をダウンロー
ドするかの選択はもっと慎重であるべきであり、その記事が面白いと分
かった時点で、ダウンロードするための印を手動で付けるべきなのです。

何をダウンロードするかを制御する主な方法は、分類 
(@dfn{category}) を作成して、そしてその分類にいくつか (あるいは
全部) のグループを割り当てます。gnus は分類の作成と管理のための
独自のバッファーを持っています。

@menu
* Category Syntax::       分類とはどんなものか。
* The Category Buffer::   分類を管理するバッファー。
* Category Variables::    カスタマイザ"ら"ス
@end menu


@node Category Syntax
@subsubsection 分類の文法

分類は二つのものからなります。

@enumerate
@item
(通常) どの記事をダウンロードするのが適当かという大まかな輪郭を
与える述語。そして

@item
(通常) どの記事をダウンロードするかを決めるときのよりきめの細か
いスコア規則。(このダウンロードスコア (@dfn{download score}) は
通常のスコアとは全く関係が無いことに注意してください。)
@end enumerate

述語は論理演算子が間に散りばめられた述語の組み合わせからなります。

おそらくいくつかの例がそのまま使えます。

以下は簡単な述語です。(これは初期設定の述語です。つまり、他のど
の分類にも含まれない全てのグループに対して使用されます。)

@lisp
short
@end lisp

とっても簡単でしょ? この述語は、記事が短い(``短い'' 価値がある)
場合に限り真になります。

これはもっと複雑な述語です。

@lisp
(or high
    (and
     (not low)
     (not long)))
@end lisp

この意味は、高いスコアを持っているか、あるいはスコアが低くなくて
かつ長くない、という記事をダウンロードする、ということです。わか
るだろ。

使ってもよい論理演算子は、@code{or}、 @code{and}、@code{not} で
す。(もし使いたければ、より ``C'' 風の演算子 @samp{|}、@code{&}、 
@code{!} を代りに使うことができます。)

以下の述語はあらかじめ定義されていますが、これらのどれもあなたの
やりたいことに一致しなければ、自分で独自のものを書くこともできます。

@table @code
@item short
記事が @code{gnus-agent-short-article} 行より短かければ真。
初期設定値は 100。

@item long
記事が @code{gnus-agent-long-article} 行より長ければ真。初期設定
値は 200。

@item low
記事のダウンロードスコアが @code{gnus-agent-low-score} 以下であ
れば真。初期設定値は 0。

@item high
記事のダウンロードスコアが @code{gnus-agent-high-score} 以上であ
れば真。初期設定値は 0。

@item spam
gnus エージェントがその記事を SPAM だと見做したら真。この発見的
手法は、今後変更されるかもしれませんが、現時点では、これはチェッ
クサムを計算し記事が一致するかどうかを調べています。

@item true
常に真。

@item false
常に偽。
@end table

あなたが自分の独自の述語関数を作成したければ、これを知っておいて
ください: 関数は引数無しで呼び出されますが、@code{gnus-headers}
と @code{gnus-score} 動的変数には便利な値が束縛されます。

さて、ダウンロードスコアの文法は通常のスコアファイルの文法と同じ
ですが、例外として、実際に記事自身を調べる必要がある要素は禁止さ
れています。つまり、以下のヘッダーのみがスコア付けできます:
@code{From}、@code{Subject}、@code{Date}、@code{Xref}、 
@code{Lines}、 @code{Chars}、 @code{Message-ID}、 
@code{References}。

@node The Category Buffer
@subsubsection 分類バッファー

通常は全ての分類は分類バッファーから管理します。(グループバッファー
から @kbd{J c} 命令によって) 初めてこれに入ったとき、初期設定の
分類だけが表示されます。


以下の命令がこのバッファーで使用できます。

@table @kbd
@item q
@kindex q (Category)
@findex gnus-category-exit
グループバッファーに戻る (@code{gnus-category-exit})。

@item k
@kindex k (Category)
@findex gnus-category-kill
現在の分類を消去する (@code{gnus-category-kill})。

@item c
@kindex c (Category)
@findex gnus-category-copy
現在の分類を複製する (@code{gnus-category-copy})。

@item a
@kindex a (Category)
@findex gnus-category-add
新しい分類を追加する (@code{gnus-category-add})。

@item p
@kindex p (Category)
@findex gnus-category-edit-predicate
現在の分類の述語を編集する (@code{gnus-category-edit-predicate})。

@item g
@kindex g (Category)
@findex gnus-category-edit-groups
現在の分類に属するグループの一覧を編集する
(@code{gnus-category-edit-groups})。

@item s
@kindex s (Category)
@findex gnus-category-edit-score
現在の分類のダウンロードスコア規則を編集する
(@code{gnus-category-edit-score})。

@item l
@kindex l (Category)
@findex gnus-category-list
全ての分類を表示する (@code{gnus-category-list})。
@end table


@node Category Variables
@subsubsection 分類変数

@table @code
@item gnus-category-mode-hook
@vindex gnus-category-mode-hook
分類バッファーで実行するフック。

@item gnus-category-line-format
@vindex gnus-category-line-format
分類バッファーの行様式 (@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item c
分類の名前。

@item g
分類に属するグループの数。
@end table

@item gnus-category-mode-line-format
@vindex gnus-category-mode-line-format
分類モード行の様式 (@pxref{Mode Line Formatting})。

@item gnus-agent-short-article
@vindex gnus-agent-short-article
この変数より少ない行数の記事は短い。初期設定値は 100。

@item gnus-agent-long-article
@vindex gnus-agent-long-article
この変数より多い行数の記事は長い。初期設定値は 200。

@item gnus-agent-low-score
@vindex gnus-agent-low-score
この値より小さいスコアを持つ記事は低スコアである。初期設定値は 0。

@item gnus-agent-high-score
@vindex gnus-agent-high-score
この値より大きいスコアを持つ記事は高スコアである。初期設定値は 0。

@end table


@node Agent Commands
@subsection エージェント命令

全ての gnus エージェント命令は @kbd{J} サブマップにあります。
@kbd{J j} (@code{gnus-agent-toggle-plugged}) 命令は全てのモード
で動作し、gnus エージェントの切り離し/差し込み状態を切り替えます。


@menu
* Group Agent Commands::
* Summary Agent Commands::
* Server Agent Commands::
@end menu

完全な一括取得を行うには、コマンド行から以下のおまじないを
実行すればできます。

@cindex gnus-agent-batch-fetch
@example
$ emacs -batch -l ~/.gnus.el -f gnus-agent-batch-fetch
@end example



@node Group Agent Commands
@subsubsection グループエージェント命令

@table @kbd
@item J u
@kindex J u (Agent Group)
@findex gnus-agent-fetch-groups
現在のグループの適格な記事を全て取得する
(@code{gnus-agent-fetch-groups})。

@item J c
@kindex J c (Agent Group)
@findex gnus-enter-category-buffer
エージェント分類バッファーに入る
(@code{gnus-enter-category-buffer})。 

@item J s
@kindex J s (Agent Group)
@findex gnus-agent-fetch-session
全グループの適格な記事を全て取得する
(@code{gnus-agent-fetch-session})。

@item J S
@kindex J S (Agent Group)
@findex gnus-group-send-drafts
下書きグループにある送信可能なメッセージを全て送信する
(@code{gnus-group-send-session})。 @xref{Drafts}.

@item J a
@kindex J a (Agent Group)
@findex gnus-agent-add-group
現在のグループをエージェント分類に追加する
(@code{gnus-agent-add-group})。

@end table


@node Summary Agent Commands
@subsubsection 概略エージェント命令

@table @kbd
@item J #
@kindex J # (Agent Summary)
@findex gnus-agent-mark-article
記事にダウンロードするように印を付ける
(@code{gnus-agent-mark-article})。

@item J M-#
@kindex J M-# (Agent Summary)
@findex gnus-agent-unmark-article
記事からダウンロードする印を消去する
(@code{gnus-agent-unmark-article})。

@item @@
@kindex @@ (Agent Summary)
@findex gnus-agent-toggle-mark
記事をダウンロードするかどうかを切り替える
(@code{gnus-agent-toggle-mark})。

@item J c
@kindex J c (Agent Summary)
@findex gnus-agent-catchup
ダウンロード印の無い記事を全て既読にする
(@code{gnus-agent-catchup})。

@end table


@node Server Agent Commands
@subsubsection サーバーエージェント命令

@table @kbd
@item J a
@kindex J a (Agent Server)
@findex gnus-agent-add-server
現在のサーバーを、gnus エージェントで扱われるサーバーの一覧に追
加する (@code{gnus-agent-add-server})。

@item J r
@kindex J r (Agent Server)
@findex gnus-agent-remove-server
現在のサーバーを、gnus エージェントで扱われるサーバーの一覧から
削除する (@code{gnus-agent-remove-server})。

@end table


@node Agent Expiry
@subsection エージェント期限切れ消去

@vindex gnus-agent-expire-days
@findex gnus-agent-expire
@kindex M-x gnus-agent-expire
@cindex Agent expire
@cindex Gnus Agent expire
@cindex expiry

@code{nnagent} は期限切れ消去を扱いません。その代わりに、特別な
@code{gnus-agent-expire} 命令が @code{gnus-agent-expire-days} 日
よりも古い既読記事を全て消去します。これはあなたがディスク容量を
使い切りそうだと思ったときにいつでも実行することができます。これ
は特に速くもなく効率的でもなく、一旦始めてしまったら (@kbd{C-g}
やその他で) 中断することもあまり良いことではありません。

@vindex gnus-agent-expire-all
@code{gnus-agent-expire-all} が @code{nil} でなければ、この命令
は全ての記事 --- 未読、既読、可視、保留記事を消去します。もし
@code{nil} (これが初期設定値) であれば、既読記事のみが消去の対象
となり、未読、可視、保留記事はさらに無期限に保持します。


@node Outgoing Messages
@subsection 差出用メッセージ

Gnus が切り離されているとき、全ての差出用メッセージ (メールとニュー
スの両方) は下書きグループ (@pxref{Drafts}) に格納されます。投稿
した後でも、ここでそのメッセージを見たり、編集したりするのは意の
ままです。

Gnus が再び差し込まれたとき、メッセージを送信するために、特別な
命令を使って下書きグループから送ることも、グループバッファ内で 
@kbd{J S} を使って、下書きグループ内の全ての送信可能メッセージ送
信することもできます。

@node Agent Variables
@subsection エージェント変数

@table @code
@item gnus-agent-directory
@vindex gnus-agent-directory
Gnus エージェントがファイルを格納する場所。初期設定値は
@file{~/News/agent/}。

@item gnus-agent-handle-level
@vindex gnus-agent-handle-level
この変数の値より高いレベル (@pxref{Group Levels}) のグループは、
エージェントからは無視されます。初期設定値は
@code{gnus-level-subscribed} で、これは初期設定では、購読してい
るグループのみがエージェントの処理の対象となるということです。

@item gnus-agent-plugged-hook
@vindex gnus-agent-plugged-hook
ネットワークに接続されたときに実行されるフック。

@item gnus-agent-unplugged-hook
@vindex gnus-agent-unplugged-hook
ネットワークから切断されたときに実行されるフック。

@end table


@node Example Setup
@subsection 設定例

もしあなたがこのマニュアルを読みたくなくて、ごく標準的な設定がさ
れているとするなら、あなたの @file{.gnus.el} ファイルに以下のよ
うな設定をするところから始められるでしょう。

@lisp
;;; Gnus がどのようにニュースを取得するかを定義する。ここでは
;;; ISP のサーバーから NNTP で取ってくることにする。
(setq gnus-select-method '(nntp "nntp.your-isp.com"))

;;; Gnus がどのようにメールを読むかを定義する。ISP の POP サーバー 
;;; からメールを読むことにする。
(setenv "MAILHOST" "pop.your-isp.com")
(setq nnmail-spool-file "po:username")

;;; Gnus がメールをどのように格納するかを指定する。nnml グループ
;;; を使う。
(setq gnus-secondary-select-methods '((nnml "")))

;;; Gnus をオフラインニュースリーダーにする。
(gnus-agentize)
@end lisp

基本的にはこれだけで良いはずです。これをあなたの
@file{~/.gnus.el} ファイルに入れて、あなたの要望に合わせて編集し、
PPP (や何か) を起動して、@kbd{M-x gnus} と打鍵してください。

あなたが初めて gnus を実行するしたときは、いくつかのニュースグルー
プが初期設定として自動的に購読されます。おそらくもっとたくさんの
グループを購読したくなるでしょうけど、そのためには、@kbd{A A} 命
令で @sc{nntp} サーバーに全グループの一覧を問い合わせなければな
りません。これは通常とても時間がかかりますが、一度だけしか実行す
る必要はありません。

しばらくの読み込みと解析の後に、グループの一覧を提示させられるで
しょう。@kbd{u} 命令で読みたいグループを購読します。読みたいグルー
プを全部購読したら、@kbd{l} で削除グループを全て画面から消去しま
す。(@kbd{A k} で削除グループは全て戻ってきます。)

さて、ここでその場でグループを読むこともできますし、あるいは
@kbd{J s} 命令で記事をダウンロードすることもできます。あとはこの
マニュアルの残りを読んで、その他の何百億の項目からカスタマイズし
たいことを見つけ出してください。

@node Batching Agents
@subsection 一括エージェント処理

Gnus エージェントに記事を取得させるのは (そしてあなたの書いた何
かのメッセージを投稿するのは)、一旦物事を正しく設定してしまえば
非常に簡単です。以下のシェルスクリプトは必要なことを全てやってく
れるでしょう。

@example
#!/bin/sh
emacs -batch -l ~/.emacs -f gnus-agent-batch >/dev/null
@end example


@node Scoring
@chapter スコア
@cindex scoring

他の人々は @dfn{削除ファイル} を使いますが、ここ gnus タワーは削除よりも
スコアの方を好みますので、他と格闘するよりは切り替える事にしました。それ
らは完全に違う事をしますので、真っ直ぐに座って注意を払ってください！

@vindex gnus-summary-below
全ての記事はスコアの初期値を持っており 
(@code{gnus-summary-default-score})、これはディフォルトで 0 です。このス
コアは対話的や、スコアファイル (score file) の方法により、上げられたり下
げられたりします。@code{gnus-summary-bark-below} よりも低いスコアの記事
には既読の印が付きます。

Gnus は概略バッファを作成する前に、現在のグループに適用されるどんな 
@dfn{スコアファイル} も読み込みます。

現在の記事に基づいてスコアの登録を挿入するいくつかの命令が概略バッファに
あります。例えば、gnus に特定の表題の記事のスコアを下げたり上げたりする
ように求める事ができます。

2種類のスコア登録があります: 永続と一時的です。一時的スコア登録は自分自
身で期限がくると削除する登録です。例えば、1週間以上使われていないどんな
登録も、スコアファイルの大きさを小さくするために、静かに削除されます。

@menu
* Summary Score Commands::   現在のグループのためのスコア登録を追加する。
* Group Score Commands::     一般的なスコア命令。
* Score Variables::          あなたのスコアをカスタマイズする。 
                             (まぁ、なんて用語でしょう)。
* Score File Format::        スコアファイルに何を入れるか。
* Score File Editing::       手でスコアファイルを編集する事もできる。
* Adaptive Scoring::         大姉 gnus はあなたが何を読んだか知っている。
* Home Score File::          新しいスコア登録がどこへ行くかをどのように指定するか。
* Followups To Yourself::    人があなたに返答したときに gnus に気付かせる。
* Scoring Tips::             どうやって効果的にスコアを付けるか。
* Reverse Scoring::          古いものの子であるという問題は問題ではない。
* Global Score Files::       地をつかみ、耳を切り裂くスコアファイル。
* Kill Files::               それらはまだここにありますが、無視する事ができる。
* Converting Kill Files::    削除ファイルをスコアファイルに変換する。
* GroupLens::                どれを読むのが好きかの予言を得る。
* Advanced Scoring::         スコアの法則を作るために論理表現を使う。
* Score Decays::             スコアを枯れていかせるのは役に立つ事もある。
@end menu


@node Summary Score Commands
@section 概略スコア命令
@cindex score commands

スコア登録を変更するスコア命令は実際に本当のスコアファイルを修正するわけ
ではありません。それはあまりに非効率です。Gnus は以前にロードされたスコ
アファイルのキャッシュを保持しており、その一つは @dfn{現在のスコアファイ
ル連想リスト} (current score file alist) と考えられています。スコア命令
は単純にこのリストに登録を挿入して、グループから出ると、このリストは保存
されます。

現在 (current) のスコアファイルは、実際にそのようなスコアファイルが存在
していない場合でも、初期設定でグループのローカルスコアファイルになってい
ます。スコア命令を何か他のスコアファイル (例、@file{all.SCORE}) に挿入し
たいなら、まずこのスコアファイルを現在のものにしなければなりません。

一般的なスコア命令は実際にはスコアファイルを変更しません:

@table @kbd

@item V s
@kindex V s (概略)
@findex gnus-summary-set-score
現在の記事のスコアを設定します (@code{gnus-summary-set-score})。

@item V S
@kindex V S (概略)
@findex gnus-summary-current-score
現在の記事のスコアを表示します (@code{gnus-summary-current-score})。

@item V t
@kindex V t (概略)
@findex gnus-score-find-trace
現在の記事に使われている全てのスコア法則 (score rule) を表示します 
(@code{gnus-score-find-trace})。

@item V R
@kindex V R (概略)
@findex gnus-summary-rescore
現在の概略でスコア過程を実行します (@code{gnus-summay-rescore})。これは 
gnus の後ろでいろいろとスコアファイルで遊んで、それの効果を見たいときに
役立つかもしれません。

@item V c
@kindex V c (概略)
@findex gnus-score-change-score-file
違ったスコアファイルを現在のものにします 
(@code{gnus-score-change-score-file})。

@item V e
@kindex V e (概略)
@findex gnus-score-edit-current-scores
現在のスコアファイルを編集します (@code{gnus-score-edit-current-scores})。
@code{gnus-score-mode} バッファに移動する事になるでしょう (@pxref{Score
File Editing})。

@item V f
@kindex V f (概略)
@findex gnus-score-edit-file
スコアファイルを編集して、このスコアファイルを現在のものにします 
(@code{gnus-score-edit-file})。

@item V F
@kindex V F (概略)
@findex gnus-score-flush-cache
現在のスコアキャッシュを書き込みます (@code{gnus-score-flush-cache})。こ
れはスコアファイルを編集した後に役に立ちます。

@item V C
@kindex V C (概略)
@findex gnus-score-customize
視覚的で嬉しい方法でスコアファイルをカスタマイズします 
(@code{gnus-score-customize})。

@end table

これらの命令の残りはローカルスコアファイルを修正します。

@table @kbd

@item V m
@kindex V m (概略)
@findex gnus-score-set-mark-below
スコアの入力を促進し、それよりも低いスコアの全ての記事に既読の印を付けま
す (@code{gnus-score-set-mark-below})。

@item V x
@kindex V x (概略)
@findex gnus-score-set-expunge-below
スコアの入力を促進し、そのスコアより低い全ての記事を削除するためのスコア
法則を現在のスコアファイルに付け加えます 
(@code{gnus-score-set-expunge-below})。
@end table

実際にスコア登録をするためのキー打ち込みは非常に規則正しい法則に従います
ので、それらの命令全てを表に上げる必要はありません。(たーくさんあります。)

@findex gnus-summary-increase-score
@findex gnus-summary-lower-score

@enumerate
@item
最初のキーはスコアを増やすための @kbd{I} (i の大文字) か、スコアを下げる
ための @kbd{L} です。
@item
2番目のキーはどのヘッダーにスコアをしたいかを表します。以下のキーが使用
可能です:
@table @kbd

@item a
著者 (author) の名前にスコアを付けます。

@item s
表題 (subject) の行にスコアを付けます。

@item x
Xref 行にスコアを付けます---すなわち、相互投稿行です。

@item r
References 行にスコアをつけます。

@item d
日付 (date) にスコアを付けます。

@item l
行数 (number of lines) にスコアを付けます。

@item i
Messsage-ID にスコアを付けます。

@item f
フォローアップ (followup) にスコアを付けます。

@item b
本体 (body) にスコアを付けます。

@item h
ヘッダー (head) にスコアを付けます。

@item t
スレッドにスコアを付けます。

@end table

@item
3番目のキーは合致する型です。どの合致の型が有効かはどのヘッダーにスコア
を付けようとしているかに依ります。

@table @code

@item 文字列 (strings)

@table @kbd

@item e
正確な (exact) 合致です。

@item s
文字列の一部の (substring) 合致です。

@item f
あいまいな (fuzzy) 合致です (@pxref{Fuzzy Matching})。

@item r
正規表現 (regexp) の合致です。
@end table

@item 日付 (date)
@table @kbd

@item b
日付の前 (before) です。

@item a
日付の後 (after) です。

@item n
その日付です。
@end table

@item 数字 (number)
@table @kbd

@item <
数字より小さいものです。

@item =
数字と等しいものです。

@item >
数字より大きいものです。
@end table
@end table

@item
4つめで、最後のキーはこれが一時的 (すなわち、期限切れ消去) のスコア登録
か、永続的な (すなわち、期限切れ消去でない) スコア登録であるかということ、
もしくはすぐになされるべきか、スコアファイルに追加する事はしないかという
事を指定します。
@table @kbd

@item t
一時的な (temporary) スコア登録です。

@item p
永続的な (permanent) スコア登録です。

@item i
即座の (immediate) スコア付けです。
@end table

@end enumerate

ですから、現在の著者に正確な合致で永続的にスコアを増やしたいとしましょう:
@kbd{I a e p}。表題に基づいてスコアを下げたくて、文字列の部分の合致を使
い、一時的なスコア登録をしたいのであれば: @kbd{L s s t}。非常に簡単です。

物事を複雑にするのは、短縮打鍵が存在するからです。2番目か3番目の文字に大
文字を使うと、gnus は残る1つか2つの打鍵に初期値を使います。初期値は ``文
字列の一部'' と ``一時的'' です。ですから、@kbd{I A} は @kbd{I a s t} と
同じで、@kbd{I a R} は @kbd{I a r t} と同じです。

これらの関数は数字接頭引数と、シンボル接頭引数を受け付けます 
(@pxref{Symbolic Prefixes})。数字接頭引数はどのくらい記事のスコアを下げ
る (もしくは上げる) かを指定します。シンボル接頭引数 @code{a} は命令が現
在のスコアファイルではなくファイル @file{all.SCORE} を使う事を指定します。

@vindex gnus-score-mimic-keymap
@code{gnus-score-mimic-keymap} はこれらの命令がキーマップであるかのよう
に振る舞うかどうかを指定します。


@node Group Score Commands
@section グループスコア命令
@cindex group score commands

残念ながら、まだたくさんはありません。

@table @kbd

@item W f
@kindex W f (グループ)
@findex gnus-score-flush-cache
Gnus は何度もスコア連想リストを読み込むのを避けるために、それのキャッシュ
を保持しています。この命令はキャッシュを書き出します 
(@code{gnus-score-flush-cache})。

@end table

以下のような事をする事によって、コマンド行からスコア付けをする事がで
きます。

@findex gnus-batch-score
@cindex batch scoring
@example
& emacs -batch -l ~/.emacs -l gnus -f gnus-batch-score
@end example


@node Score Variables
@section スコア変数
@cindex score variables

@table @code

@item gnus-use-scoring
@vindex gnus-use-scoring
@code{nil} であれば、gnus はスコアファイルを調べず、一般的に、スコア関連
の仕事を全くしません。これは初期設定で @code{t} です。

@item gnus-kill-killed
@vindex gnus-kill-killed
この変数が @code{nil} であれば、gnus は既に削除過程を実行された記事に決
してスコアファイルを適用しません。これはたくさんの時間を節約するでしょう
が、もし削除ファイルをグループに適用しているときに、削除ファイルを変更し、
もっと多くの記事を削除するためにそれを再実行しても、それは動作しないとい
う事になります。それをするためにはこの変数を @code{t} に実行しなければな
りません。 (これは初期設定で @code{t} です。)

@item gnus-kill-files-directory
@vindex gnus-kill-files-directory
全ての削除とスコアのファイルはこのディレクトリーに蓄積され、それは初期設
定で環境変数 @code{SAVEDIR} によって初期化されます。これは初期設定で 
@file{~/News/} です。

@item gnus-score-file-suffix
@vindex gnus-score-file-suffix
スコアファイルにたどり着くためにグループ名に加える接尾語です (初期値で 
@samp{SCORE} です。)

@item gnus-score-uncacheable-files
@vindex gnus-score-uncacheable-files
@cindex score cache
全てのスコアファイルは普通はスコアファイルの過剰読み込みを避けるために
キャッシュされます。しかし、これによりあなたの Emacs が大きく肥大化する
のであれば、再び必要とされないようなスコアファイルを除去するためにこの正
規表現を使う事ができます。@file{all.SCORE} のキャッシュを止めるのは悪い
考えですが、@file{comp.infosystems.www.authoring.misc.ADAPT} をキャッシュ
しないのは良い考えでしょう。実際のところ、この変数は初期設定で 
@samp{ADAPT$} で、適応スコアファイルはキャッシュされません。

@item gnus-save-score
@vindex gnus-save-score
もし本当に複雑なスコアファイルを持っていて、たくさんの一括スコアをするの
であれば、この変数を @code{t} に設定すると良いかもしれません。これは 
gnus にスコアを @file{.newsrc.eld} ファイルに保存するようにさせます。

@item gnus-score-interactive-default-score
@vindex gnus-score-interactive-default-score
全ての対話的スコア上げ/下げ命令によって使われる上げ/下げするスコアです。
ディフォルトは1000で、過剰だと思うかもしれませんが、これは適応スコア付け
をする余地の存在する事を確実にするためです。手で登録されたデータを適応ス
コアでの小さな変更で上書きされたくはありません。

@item gnus-summary-default-score
@vindex gnus-summary-default-score
記事のスコアの初期値で、初期設定では0になっています。

@item gnus-summary-expunge-below
@vindex gnus-summary-expunge-below
この変数より低いスコアを持つ記事は概略の行に表示されません。これは初期設
定で @code{nil} で、これはどの記事も隠されないという事です。この変数は各
概略バッファに固有で、@code{gnus-summary-mode-hook} によって設定されるべ
きです。

@item gnus-score-over-mark
@vindex gnus-score-over-mark
初期設定のスコアより大きなスコアを持つ記事に対して (3桁目に) 使われる印
です。初期設定は @samp{+} です。

@item gnus-score-below-mark
@vindex gnus-score-below-mark
初期設定のスコアより小さなスコアを持つ記事に対して (3桁目に) 使われる印
です。初期設定は @samp{-} です。

@item gnus-score-find-score-files-function
@vindex gnus-score-find-score-files-function
現在のグループのスコアファイルを見つけるために使われる関数です。この関数
はグループ名を引数として呼ばれます。

使用可能な既定関数は:
@table @code

@item gnus-score-find-single
@findex gnus-score-find-single
グループ自身のスコアファイルだけを適用します。

@item gnus-score-find-bnews
@findex gnus-score-find-bnews
bnews 構文を使って、全ての合致するスコアファイルを適用します。これが初期
設定です。例えば、現在のグループが @samp{gnu.emacs.gnus} ならば、
@file{gnu.all.SCORE}、@file{not.alt.SCORE} と @file{gnu.all.SCORE} がす
べて適用されます。要するに、スコアファイル名の @samp{all} が @samp{.*} 
に変換され、それから正規表現の合致がなされます。

これは、全てのグループに適用したいスコア登録がいくつかある場合は、それら
の登録を @file{all.SCORE} ファイルに入れるということです。

Gnus は一般的なスコアファイルを特定のスコアファイル向けのものより前に適
用しようと試みますが、スコアファイルはほとんど無作為の順番で適用されます。
これはスコアファイル名の要素の数を調べる事によってなされます---
@samp{all} 要素を取り除いて。

@item gnus-score-find-hierarchical
@findex gnus-score-find-hierarchical
全ての親グループからの全てのスコアファイルを適用します。これは 
@file{all.SCORE} のようなスコアファイルを持つ事はできないけれど、
@file{SCORE}、@file{comp.SCORE} と @file{comp.emacs.SCORE} を持つ事がで
きるという事です。

@end table
この変数は関数のリストである事もできます。その場合は、これらの全ての関数
が呼ばれ、スコアファイルの返された全てのリストが適用されます。これらの関
数は直接スコア連想リストのリストを返す事もできます。その場合は、それらの
ファイルでないスコア連想リストを返す関数は、返される最後のスコアファイル
がローカルスコアファイルである事を確実にするために、おそらく ``本当の'' 
スコアファイル関数よりも前に置かれるべきでしょう。ふぅ。

@item gnus-score-expiry-days
@vindex gnus-score-expiry-days
この変数は使われていないスコアファイル登録が期限切れ削除されるまでどのく
らいの日が経つべきかを指定します。この変数が @code{nil} であると、スコア
ファイル登録は削除されません。初期値は7です。

@item gnus-update-score-entry-dates
@vindex gnus-update-score-entry-dates
この変数が @code{nil} でないと、合致するスコア登録は日付が更新されます。
(これは gnus が期限切れ消去を操作している方法です---全ての合致しない登録
は古くなりすぎ、合致する登録を新鮮で若いままです。) しかし、この変数を 
@code{nil} に設定すると、合致する登録でさえも古くなり、あの嫌な死神と直
面する事になるでしょう。

@item gnus-score-after-write-file-function
@vindex gnus-score-after-write-file-function
そこでちょうど書かれたスコアファイルの名前と共に呼ばれる関数です。

@item gnus-score-thread-simplify
@vindex gnus-score-thread-simplify
この変数が @code{nil} でないと、記事表題はスレッドと同じ方法で表題スコア
のために単純化されます---現在の gnus-simplify-subject-functions の値によっ
て。スコア登録が @code{文字列部分} か @code{正確な} 合致を使っていると、
合致もこの方法で単純化されます。

@end table


@node Score File Format
@section スコアファイル様式
@cindex score file format

スコアファイルは普通は単純な様式のものだけを含む @code{emacs-lisp} ファ
イルです。無頓着な利用者はこれを編集しないでください。全ては概略バッファ
から変更されるでしょう。

とにかく、それを自分でいじってみたくなったのなら、例があります:

@lisp
(("from"
  ("Lars Ingebrigtsen" -10000)
  ("Per Abrahamsen")
  ("larsi\\|lmi" -50000 nil R))
 ("subject"
  ("Ding is Badd" nil 728373))
 ("xref"
  ("alt.politics" -1000 728372 s))
 ("lines"
  (2 -100 nil <))
 (mark 0)
 (expunge -1000)
 (mark-and-expunge -10)
 (read-only nil)
 (orphan -10)
 (adapt t)
 (files "/hom/larsi/News/gnu.SCORE")
 (exclude-files "all.SCORE")
 (local (gnus-newsgroup-auto-expire t)
        (gnus-summary-make-false-root empty))
 (eval (ding)))
@end lisp

この例はたいていのスコアファイルの要素を説明しています。違った方法につい
ては、@pxref{Advanced Scoring} を見てください。

これは lisp コードのように見えますが、実際はここにあるものは何も 
@code{評価} (eval) されません。しかし、lisp リーダーがこの様式を読み込む
のに使われますので、意味的に有効でないとしても、文法的には有効です。

この連想リストでは6つのキーを使う事ができます。

@table @code

@item 文字列 (STRING)
もしキーが文字列であると、それは合致が実行されるヘッダーの名前です。スコ
アはこれらの8つのヘッダーだけに実行されます: @code{From}、@code{Subject}、
@code{References}、@code{Message-ID}、@code{Xref}、@code{Lines}、
@code{Chars}、@code{Date} です。これらのヘッダーに加えて、gnus に記事全
体を取得して,記事のより大きな部分で合致を行うようにする3つの文字列があり
ます: @code{Body} は記事の本体 (Body) で合致を実行し、@code{Head} は記事
のヘッダー (Head) で合致を実行し、@code{All} は記事全体で合致を実行しま
す。最後のこれらの3つのキーを使う事はグループに入るときに速度を @emph{か
なり} 遅くする事に気を付けてください。スコアを付ける事のできる最後の 
``ヘッダー'' は @code{Followup} です。これらのスコア登録はそれに合致する
記事への全てのフォローアップのための新しいスコア登録が付け加えられる事に
なります。

このキーに続くのは任意の数のスコア登録で、それぞれのスコア登録は1つから4
つまでの要素を持ちます。
@enumerate

@item
最初の要素は @dfn{合致要素} です。たいていのヘッダーではこれは文字列です
が、Lines と Chars ヘッダーではこれは整数でなければなりません。

@item
もし2番目の要素が存在するなら、それは数字であるべきです---@dfn{スコア要
素}。この数字は負の無限大から正の無限大までの間の整数であるべきです。も
し合致が成功すれば、この数字が記事のスコアに加えられます。もしこの要素が
存在していなければ、数字 @code{gnus-score-interactive-default-score} が
代わりに使われます。これは初期設定で1000です。

@item
もし3番目の要素が存在していると、それは数字であるべきです---@dfn{日付要
素} です。この日付は最後にこのスコア登録が合致した時刻を示し、これはスコ
ア登録の期限切れ消去機構の機能のために使われます。この要素が存在していな
ければ、スコア登録は永続します。日付は紀元前1年12月31日から経過した日に
ちの数で表されます。

@item
もし4番目の要素が存在していると、それはシンボルであるべきです---@dfn{型
要素} です。この要素はこのスコア登録が記事に合致するかどうかを調べるのに
どの関数が使われるべきであるかを指定します。

@table @dfn

@item From, Subject, References, Xref, Message-ID
たいていのヘッダーの型に対して、@code{r} と @code{R} (正規表現) (regexp) 
や、@code{s} と @code{S} (文字列の一部) (substring) 型、@code{e} と 
@code{E} (正確な合致) (exact match)、@code{w} (語の合致) (word match) 型
が存在します。もしこの要素が存在しないと、gnus は文字列の一部の合致が用
いられるべきであるとみなします。@code{R}、@code{S}、@code{E} は合致が大文
字と小文字を区別する方法で行われるという点で他のものと異なります。全ての
これらの一文字型は本当は @code{regexp}、@code{exact}、@code{word} 型の短
縮形で、もしそうしたいと思えばこちらを代わりに使う事ができます。

@item Lines, Chars
これらの2つのヘッダーは違った合致の型を使います: @code{<}、@code{>}、
@code{=}、@code{>=}、@code{<=} です。

これらの述語はもし

@example
(PREDICATE HEADER MATCH)
@end example

の評価が @code{nil} でないと、真となります。例えば、上級合致 
@code{("lines" 4 <)} (@pxref{Advanced Scoring}) は結果として以下の式にな
ります。

@lisp
(< header-value 4)
@end lisp

もしくは他の方法にしましょう: @code{<} を @code{Lines} で 4 を合致として
使っているときは、記事が4行よりも少ないときにスコアが追加されます。(混乱
して、反対ではないかと考え易いです。でも、そうではないのです。私が思うに。)

合致が @code{Lines} でなされていると、いくつかのバックエンド 
(@code{nndir}のようなもの) は @code{Lines} ヘッダーを作成しないために全
ての記事が 0 行であるとして扱われる事に気を付けてください。これはもし少
しの行しかない記事のスコアを下げているのなら、変な結果が起こり得る事にな
ります。

@item Date
Date (日付) ヘッダーには3つのなんとなくばかげている合致の型があります:
@code{before}、@code{at}、@code{after} です。私は本当にこれが役立つよう
な機会を想像できないのですが、この関数を提供しないのもなんとなくばかげて
います。そうした場合のためにあるのです。いつ必要になるかは誰にもわかりま
せん。転ばぬ先の杖です。一度焼けると2度恥ずかしい、です。本をカバーで判
断しては行けません。最初の日に性行為を行っていは行けません。 (しかし、私
は少なくとも一人、引用しますが、``この関数は欠かせないものである事がわかっ
た'' と言った人が入ると聞いています。)

@cindex ISO8601
@cindex date
もっと役立つ合致の型は @code{正規表現} です。それによって日付文字列に正
規表現を用いて合致させる事ができます。日付はまず ISO8601 短縮様式 
(compact format) に標準化されます---@var{YYYYMMDD}@code{T}@var{HHMMSS} 
です。例えば、もし全ての年の4月1日に投稿された全ての記事にが治させたいの
であれば、@samp{....0401.........} を合致文字列として使う事ができます。
(日付は元々の標準時で保存されていますので、その記事が投稿されたところで4
月1日に投稿された記事に合致する事に注意してください。標準時は一家にとっ
て非常に有益な楽しみでしょう？)

@item Head, Body All
これらの3つの合致のキーは @code{From} ヘッダー (など) と同じ合致の型を使
います。

@item Followup
この合致のキーは少し特別で、それは @code{From} ヘッダーに合致し、合致し
た記事だけでなくその記事への全てのフォローアップのスコアにも影響します。
これはたとえば、あなた自身の記事へのフォローアップのスコアを増やしたり、
良く知られた問題児へのフォローアップ記事のスコアを下げたりするのに使われ
ます。@code{From} ヘッダーが使うのと同じ型の合致を使います。 (この合致キー
を使うと、ファイル @file{ADAPT} を作る事になります。)

@item Thread
この合致キーは @code{Followup} 合致キーと同じ行に動作します。
@code{Message-ID} @var{X} で始まっている (副)スレッドにスコアを付けたい
のであれば、@samp{thread} 合致を付け加えます。これは @code{Reference} ヘッ
ダーに @var{X} を持つそれぞれの記事に新しい @samp{thread} 合致を追加しま
す。 (これらの新しい @samp{thread} 合致はこれらの合致する記事の 
@code{Message-ID} を使います。) これはスレッドのいくつかの記事が完全な 
@code{References} ヘッダーを持っていなかったとしても、スレッド全体のスコ
アを上げ/下げできる事を保証します。これを使うと、スレッドの記事に決定的
でないスコアが付くかもしれないということに注意してください。 (この合致キー
を使うと、ファイル @file{ADAPT} を作る事になります。)
@end table
@end enumerate

@cindex Score File Atoms
@item mark
この登録の値は数字であるべきです。この数字より低いスコアの記事には既読の
印が付きます。

@item expunge
この登録の値は数字であるべきです。この数字より低いスコアの記事は概略バッ
ファから削除されます。

@item mark-and-expunge
この登録の値は数字であるべきです。この数字より低いスコアの記事には既読の
印が付き、概略バッファから削除されます。

@item thread-mark-and-expunge
この登録の値は数字であるべきです。スコアの総計がこの数字より低いスレッド
には既読の印が付き、概略バッファから削除されます。
@code{gnus-thread-score-function} はスレッドのスコアの総計をどのように計
算するかを指定します。

@item files
この登録の値は任意の数のファイル名であるべきです。これらのファイルもスコ
アファイルであるとみなされ、これがされたのと同じような方法で読み込まれま
す。

@item exclude-files
この登録の手がかりは任意の数のファイル名であるべきです。これらのファイルは何
らかの理由で普通は読み込まれるようになっていたとしても、読み込まれません。

@item eval
この登録の値は @code{評価} されます。この要素は全体的スコアファイルを扱っ
ているときは無視されます。

@item read-only
読み込み専用スコアファイルは更新されたり保存されたりしません。全体的スコ
アファイルはこのアトムを使用するべきです (@pxref{Global Score Files})。 
(注意: @dfn{全体的} はここでは本当に @dfn{全体的} という意味です。個人的
な全てのグループに適用するスコアファイルの事ではありません。)

@item orphan
この登録の値は数字であるべきです。親記事を持たない記事はスコアにこの数字
が加えられます。@samp{comp.lang.c} のような量の多いニュースグループを追
いかけているとしてください。おそらく2,3のスレッドと新しいスレッドだけを
追いたいでしょう。

以下の2つのスコアファイル登録によってそれをする事ができます:

@example
        (orphan -500)
        (mark-and-expunge -100)
@end example

最初にこのグループに入ったときは、新しいスレッドだけを見ます。それからお
もしろいと思ったスレッドのスコアを上げ (@kbd{I T} もしくは @kbd{I S} に
よって)、残りを無視 (@kbd{C y}) します。次にグループに入ったときは、おも
しろいスレッドの新しい記事と全く新しいスレッドを見る事になります。

すなわち---orphan (孤児) スコアアトムは普通のスコア法則では発見できない興味深いスレッドが少し存在しする量の多いグループのためにあります。

@item adapt
この登録は適応スコアを制御します。もしこれが @code{t} であると、初期設定
の適応スコア法則が使われます。もしこれが @code{ignore} であると、このグ
ループには適応スコアは実行されません。もしリストであると、そのリストは適
応スコア法則として用いられます。もしそれが存在しないか、@code{t} や 
@code{ignore} でない他のものであれば、初期設定の適応スコア法則が使われま
す。たいていのグループに適応スコアを使いたいのであれば、
@code{gnus-use-adaptive-scorint} を @code{t} に設定し、@code{(adapt
ignore)} を適応スコアをしたくないグループに挿入するでしょう。少しのグルー
プでだけ適応スコアを行いたいのであれば、@code{gnus-use-adaptive-scoring} 
を @code{nil} に設定し、@code{(adaptive t)} をそれを行いたいグループのス
コアファイルに挿入するでしょう。

@item adaptive-file
全ての適応スコア登録はこの登録によって名づけられたファイルに入ります。そ
れはグループに入るときにも適用されます。このアトムは多くのグループに同じ
適応スコアファイルを用いる事によって、複数のグループに一度に適応スコアを
付けたいときに便利でしょう。

@item local
@cindex local variables
この登録の値は @code{(VAR VALUE)} 対のリストであるべきです。それぞれの 
@var{var} は現在の概略バッファのバッファ固有になり、指定された値 (value) 
に設定されます。これは便利な、もし少し変だとしても、フックをあまり好まな
いいくつかのグループで変数を設定する方法です。@var{value} は評価されない
事に注意してください。
@end table


@node Score File Editing
@section スコアファイル編集

普通は全てのスコア命令を概略バッファから発行しますが、手でそれらを編集し
たい気に駆られるかもしれませんので、それのためのモードを提供しています。

それは単純に少しカスタマイズされた @code{emacs-lisp} モードで、以下の追
加の命令が存在します:

@table @kbd

@item C-c C-c
@kindex C-c C-c (スコア)
@findex gnus-score-edit-done
あなたが行った変更を保存して概略バッファに戻ります 
(@code{gnus-score-edit-done})。

@item C-c C-d
@kindex C-c C-d (スコア)
@findex gnus-score-edit-insert-date
現在の日付を数字様式で挿入します (@code{gnus-score-edit-insert-date})。
もしこれがどのようなものであろうと考えているのであれば、これは本当に日の
数字です。

@item C-c C-p
@kindex C-c C-p (スコア)
@findex gnus-score-pretty-print
適応スコアファイルは整えられていない流儀で保存されます。もしこれらのファ
イルの内の一つを読みたいと思っているのであれば、まず @dfn{素敵な表示} を
したいでしょう。この命令 (@code{gnus-score-pretty-print}) があなたのため
にそれをします。

@end table

このモードを使うためには @kbd{M-x gnus-score-mode} と打ってください。

@vindex gnus-score-mode-hook
@code{gnus-score-menu-hook} がスコアモードバッファで実行されます。

概略バッファでは、@kbd{V f} や @kbd{V e} のような命令でスコアファイルの
編集を始める事ができます。


@node Adaptive Scoring
@section 適応性スコア
@cindex adaptive scoring

これらのスコア付けはあなたを憂鬱にさせてしまうかもしれないので、
gnus にはこれらを全て自動的に --- まるで魔法でも使ったように作成
する方法があります。いやむしろ、人工無能によって、という方が正確
かな。

@vindex gnus-use-adaptive-scoring
記事を読んだとき、あるいは記事に既読の印をつけたとき、記事を削除
したときに、その印を残しておいてください。グループから出るときに
gnus は、それらの印の辺りを嗅ぎ回り、何の印を見つけたかに依存し
てスコア要素を追加します。この機能は
@code{gnus-use-adaptive-scoring} を @code{t} か @code{(line)} に
設定することで有効になります。もしスコアを、表題に現れる個別の単
語をもとに適応させたければ、この変数を @code{(word)} に設定して
ください。両方の適応方法を使いたければ、この変数を@code{(word
line)} に設定してください。

@vindex gnus-default-adaptive-score-alist
@code{gnus-default-adaptive-score-alist} 変数をカスタマイズする
ことで、スコア付けの処理を完全に制御できます。例えば、このような
感じになります。

@lisp
(defvar gnus-default-adaptive-score-alist
  '((gnus-unread-mark)
    (gnus-ticked-mark (from 4))
    (gnus-dormant-mark (from 5))
    (gnus-del-mark (from -4) (subject -1))
    (gnus-read-mark (from 4) (subject 2))
    (gnus-expirable-mark (from -1) (subject -1))
    (gnus-killed-mark (from -1) (subject -3))
    (gnus-kill-file-mark)
    (gnus-ancient-mark)
    (gnus-low-score-mark)
    (gnus-catchup-mark (from -1) (subject -1))))
@end lisp

見てお分かりのように、この連想リストの各要素は、キーとして印 (変
数名かもしくは ``本当の'' 印 --- つまり文字)を持ちます。このキー
の後には任意の数のヘッダー/スコアの組が続きます。もしそのキーの
後にヘッダー/スコアの組が一つもなければ、そのキーが記事の印とし
てついている記事に対しては適応性スコアは実行されません。例えば上
記の例では、@code{gnus-unread-mark} がついている記事は適応性スコ
アの登録項目にはなりません。

各記事はただ一つの印しか持ち得ないので、それぞれの記事にはこれら
の規則のうちただ一つしか適用されません。

@code{gnus-del-mark} を例に取りましょう --- この連想リストでの意
味は、この印 (すなわち @samp{D} の印)がついている記事は全て、
@code{From} ヘッダーをもとに -4 下げられ @code{Subject} で -1 下
げられるスコア登録が追加されます。これをあなたの偏見に合わせて変
更してください。

もし 10 個の記事に同じ subject で @code{gnus-del-mark} の印がつ
いていたとすると、この印に対する規則は十回適用されます。それはつ
まり、その subject は -1 の十倍のスコアを得ます。その値は、私が
大きく誤解していないかぎり、-10 のはずです。

もし自動期限切れ消去 (メール) グループ (@pxref{Expiring Mail})
があれば、既読記事には全て @samp{E} 印がつけられます。これはおそ
らく、適応性スコア付けをちょっとばかり不可能にするので、自動期限
切れ消去と適応性スコアは一緒にはうまくやっていけません。

スコアをつけられるヘッダーには @code{from}、 @code{subject}、
@code{message-id}、 @code{references}、 @code{xref}、 
@code{lines}、@code{chars}、@code{date} があります。さらに
@code{followup} にもスコア付けできます。これは現在の記事の
@code{Message-ID} を使用して @code{References} ヘッダーにマッチ、
すなわちこれに続いたスレッドにマッチする適応性スコア登録を作成し
ます。

また @code{thread} にもスコア付けすることができます。これはスレッ
ド中の全ての記事にスコア付けしようとします。@code{thread} のマッ
チは、@code{Message-ID} を使って記事の @code{References} ヘッダー
にマッチさせます。マッチが起こったらその記事の @code{Message-ID}
が @code{thread} 規則に追加されます。(ちょっと考えてみてください。
後で頭痛薬を二粒お勧めしときますが)

この機構を使うならば、ときどき記事を既読にしてしまう小さな変更を
避けるために、スコアファイルの @code{mark} アトムを何か小さい値 
--- ことによれば -300 くらいに設定しておいた方が良いです。

適応性スコアを一週間かそこら使ってくると、gnus はそれ相応に調教
され、あなたが何も言わなくても、あなたの好きな投稿者を強調し、あ
まり好きではない投稿者を消去するようになるはずです。

どのグループにおいて適応性スコアを作動させるかは、スコアファイル
(@pxref{Score File Format}) を使うことによって制御できます。また
これを使って、違ったグループに対して違った規則を使うようにもでき
ます。

@vindex gnus-adaptive-file-suffix
適応性スコア登録項目は、グループ名に
@code{gnus-adaptive-file-suffix} を付加した名前のファイルに入れ
られます。初期設定値は @samp{ADAPT} です。

@vindex gnus-score-exact-adapt-limit
適応性スコアを行うときは、部分文字列一致やファジーな一致を行った
方が、おそらくほとんどの場合において良い結果が得られるでしょう。
しかし、ヘッダーの一致した部分が短い場合、意図に反するような動作
をする可能性が大きくなるので、
@code{gnus-score-exact-adapt-limit} より短い長さしか一致しない場
合は完全一致が行われます。この変数が @code{nil} であれば、この問
題が起こらないように常に完全一致が行われます。

@vindex gnus-default-adaptive-word-score-alist
上で述べたように、個別の単語に対してもヘッダー全体に対しても適応
を行うことができます。単語に対して適応を行った場合、
@code{gnus-default-adaptive-word-score-alist} 変数によって、各単
語に対してある印へどんなスコアを与えるかを指定します。

@lisp
(setq gnus-default-adaptive-word-score-alist
      `((,gnus-read-mark . 30)
        (,gnus-catchup-mark . -10)
        (,gnus-killed-mark . -20)
        (,gnus-del-mark . -15)))
@end lisp

これが初期設定値です。単語に対する適応を有効にすると、
@code{gnus-read-mark} の印のついた記事の表題に現れる全ての単語が、
スコアに 30 点追加するというスコア規則を生み出します。

@vindex gnus-default-ignored-adaptive-words
@vindex gnus-ignored-adaptive-words
@code{gnus-default-ignored-adaptive-words} のリストに現れる単語
は無視されます。無視したい単語を追加したいときは、この変数ではな
く @code{gnus-ignored-adaptive-words} リストの方を使ってください。

@vindex gnus-adaptive-word-syntax-table
スコア付けが終了したとき、@code{gnus-adaptive-word-syntax-table}
の文法表がその影響を受けます。これは標準の文法表と似ていますが、
単語の構成要素とならない文字の数も考慮します。

@vindex gnus-adaptive-word-minimum
もし @code{gnus-adaptive-word-minimum} に数字が設定されていると、
単語適応性スコア付け処理において、記事のスコアがこの数字よりも小
さくなることはありません。初期設定値は @code{nil} です。

この機構をしばらく使ってみた後には、あなたがどんな単語が好きで
どんな単語が嫌いかを、この規則を通して診断する利用者精神分析命令
@code{gnus-psychoanalyze-user} を書いてみると良いかもしれません。
いや、良くないかな。

単語適応性スコア付けは非常に実験的なものであって、今後変更される
であろうということは心に留めておいてください。第一印象では、これ
は現状では全く使い物にならないように思えます。これをもっと使える
ようにするためには、(より厳密な統計的手法を巻き添えにして) さら
なる作業が必要となるでしょう。


@node Home Score File
@section ホームスコアファイル

新しいスコアファイル登録項目が入れられるスコアファイルは、ホーム
スコアファイル @dfn{home score file} と呼ばれます。これは通常
(初期設定で) そのグループ用のスコアファイルになります。例えば、
@samp{gnu.emacs.gnus} 用のホームスコアファイルは
@file{gnu.emacs.gnus.SCORE} となるわけです。

しかしながら、これはあなたのお望みではないかもしれません。たくさ
んのグループ間で共通のホームスコアファイルを共有すると便利なとき
が多いでしょう --- 例えば全ての @samp{emacs} グループで同じホー
ムスコアファイルを使うこともできます。

@vindex gnus-home-score-file
これを制御する変数が @code{gnus-home-score-file} です。これは以
下の値を取り得ます。

@enumerate
@item
文字列。この場合このファイルが全てのグループでホームスコアファイ
ルとして使用されます。

@item
関数。この関数の結果がホームスコアファイルとして使用されます。こ
の関数はグループの名前を引数として呼び出されます。

@item
リスト。このリストの要素は以下の値を取り得ます。

@enumerate
@item
@var{(regexp file-name)}。@var{regexp} がグループ名にマッチすれ
ば、@var{file-name} がホームスコアファイルとして使用されます。

@item
関数。この関数が @code{nil} 以外を返せば、その返却値がホームスコ
アファイルとして使用されます。

@item
文字列。 この文字列をホームスコアファイルとして使用します。
@end enumerate

このリストの中からマッチするものを、最初から後ろの方に向かって探
していきます。

@end enumerate

というわけで、単に一個のスコアファイルを使いたい場合は、以下のよ
うにすればできます。

@lisp
(setq gnus-home-score-file
      "my-total-score-file.SCORE")
@end lisp

もし全 @samp{gnu} グループに対して @file{gnu.SCORE} を、
全 @samp{rec} グループに対して @file{rec.SCORE} (等々) を使いた
ければ、このようにできます。

@findex gnus-hierarchial-home-score-file
@lisp
(setq gnus-home-score-file
      'gnus-hierarchial-home-score-file)
@end lisp

これは便利なようにあらかじめ提供されている関数です。
多の関数は以下の以下のものを含みます

@table @code
@item gnus-current-home-scre-file
@findex gnus-current-home-score-file
``現在の'' 標準スコアファイルを返します。これはスコア命令にスコアファイ
ルの ``最内部'' 合致への登録を加えるようにします。

@end table

もし @samp{emacs} グループ用のスコアファイルと、それとは別の
@samp{comp} グループ用のスコアファイルを使い、他の全部のグループ
ではそれぞれ独自のスコアファイルを使いたいのであれば、

@lisp
(setq gnus-home-score-file
      ;; All groups that match the regexp "\\.emacs"
      '(("\\.emacs" "emacs.SCORE")
        ;; All the comp groups in one score file
        ("^comp" "comp.SCORE")))
@end lisp

@vindex gnus-home-adapt-file
@code{gnus-home-adapt-file} は @code{gnus-home-score-file} と全
く同じように動作しますが、これは代わりに何をホーム適用スコアファ
イルにするかを指定します。新しい適用ファイル登録項目は全て、この
変数で指定されるファイルに入れられます。値には同じ文法が許されま
す。

@code{gnus-home-score-file} と @code{gnus-home-adapt-file} の使
用に加えて、グループパラメータ (@pxref{Group Parameters}) とトピッ
クパラメータ (@pxref{Topic Parameters}) を使ってほぼ同様のことが
できます。グループ、トピックパラメータはこの変数よりも優先されます。


@node Followups To Yourself
@section 自分自身へのフォローアップ

Gnus は現在のバッファーから @code{Message-ID} ヘッダーを見つけ出
すために二つの命令を提供しています。 そして gnus は、他の記事に
おける@code{References} ヘッダー中にこの @code{Message-ID} を使っ
ている得点を、スコア規則として追加します。これは実質的に、その記
事へ返答した記事で、現在のバッファーにあるもの全てに対してスコア
を増加させます。これはあなたの言ったことに対してみんなが答えてく
れたとき、すぐにそれに目を向けたいときにとても便利ですね。

@table @code

@item gnus-score-followup-article
@findex gnus-score-followup-article
これはあなた自身の記事に直接フォローアップした記事にスコアを加算
します。

@item gnus-score-followup-thread
@findex gnus-score-followup-thread
これはあなたの記事より ``下'' のスレッドに現れる記事全てに対して
スコアを加算します。
@end table

@vindex message-sent-hook
これら二つの関数は、基本的にはどちらも @code{message-sent-hook} 
のようなフックの中で使うためのものです。

あなたの自分の @code{Message-ID} をじっくりと眺めてみると、はじ
めの二、三文字は常に同じであることに気がつくでしょう。以下の二つ
は私のものです。

@example
<x6u3u47icf.fsf@@eyesore.no>
<x6sp9o7ibw.fsf@@eyesore.no>
@end example

つまりこのマシン上での ``私の'' の識別は @samp{x6} であるという
ことです。これは使えます --- 以下の規則は私自身へのフォローアッ
プ全てに対してスコアを増加させるでしょう。

@lisp
("references"
 ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@@.*eyesore.no>"
  1000 nil r))
@end lisp

``あなたの'' が最初の二文字になるか最初の三文字になるかはシステ
ムに依存します。


@node Scoring Tips
@section スコア付けの奥義
@cindex scoring tips

@table @dfn

@item クロスポスト
@cindex crossposts
@cindex scoring crossposts
クロスポストのスコアを低くしたければ、マッチさせるべき行は
@code{Xref} ヘッダーです。
@lisp
("xref" (" talk.politics.misc:" -1000))
@end lisp

@item 複数のクロスポスト
ある数、例えば 3 つ以上のグループにクロスポストされている記事の
スコアを低くしたければ、
@lisp
("xref" ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+" -1000 nil r))
@end lisp

@item 本文へのマッチ
これは一般的にはあまり良い考えではありません --- それはとても長
時間かかってしまうからです。実際 gnus は、それぞれの記事を個別に
サーバーから取得してこなければならないのです。でも、あなたはそれ
でもやりたいかも知れませんね。マッチさせるキーは三つ 
(@code{Head}、@code{Body}、 @code{All}) あるのですが、スコアファ
イル毎に一つ選んでそれに固定した方が良いです。もし二つを使うと、
それぞれの記事は @emph{二回} 取得されてしまいます。もし 
@code{Head} からちょっとだけ、@code{Body} からちょっとだけマッチ
させたい、というのであれば、素直に @code{All} を使って全部マッチ
させてください。

@item 既読の印付け
ある一定数字以下のスコアを持つ記事には、おそらく既読の印をつけて
しまいたくなるでしょう。これは @file{all.SCORE} ファイルに以下の
ものを入れておくことによって最も簡単に実現できます。
@lisp
((mark -100))
@end lisp
@code{expunge} を使って同様のことを考えることもできます。

@item 否定文字クラス
もし @code{[^abcd]*} みたいなものを指定すると、たぶん期待通りの
結果は得られないでしょう。これは改行文字にもマッチしてしまい、えー
と、未知の世界まで続くかもしれません。代わりに@code{[^abcd\n]*} 
を使ってください。
@end table


@node Reverse Scoring
@section 逆スコア
@cindex reverse scoring

もし、表題ヘッダーに @samp{Sex with Emacs} という文字がある記事
だけを残して、その他の記事全てを消去してしまいたければ、スコアファ
イルに以下のようなものを入れることもできます。

@lisp
(("subject"
  ("Sex with Emacs" 2))
 (mark 1)
 (expunge 1))
@end lisp

そして @samp{Sex with Emacs} にマッチする全ての記事を集めて、残
りを蹴飛ばすために既読の印をつけ、消去します。


@node Global Score Files
@section グローバルスコアファイル
@cindex global score files

間違いなく、他のニュースリーダーは ``グローバル削除ファイル 
(global kill file)'' を持っています。これは普通、全てのグループ
に適用される、ユーザーのホームディレクトリーに格納されている一つ
の削除ファイル以上の何物でもありません。はん! ちっぽけなニュース
リーダーだね。弱すぎ。

僕がここで話しているのはグローバルスコアファイルです。全世界中か
らの、至る所からのユーザーによるスコアファイル、世界の国々を全て、
巨大な一つの幸せなスコアファイル同盟に団結させるスコアファイル!
Ange-score! 新しくてテストしていない!

@vindex gnus-global-score-files
他の人のスコアファイルを使うためにしなければならないことは、
@code{gnus-global-score-files} 変数を設定することだけです。それ
ぞれのスコアファイル毎に、あるいはそれぞれのスコアファイルディレ
クトリ毎に対して一つの項目になります。Gnus はどのスコアファイル
をどのグループに使うのが適切であるかを自分で決定します。

例えば
@file{/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE}
のスコアファイルと @file{/ftp@@ftp.some-where:/pub/score} ディレ
クトリにある全てのスコアファイルを使いたければ、

@lisp
(setq gnus-global-score-files
      '("/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
        "/ftp@@ftp.some-where:/pub/score/"))
@end lisp

@findex gnus-score-search-global-directories
どうだい、簡単だろう? ディレクトリ名は @samp{/} で終わらなくては
なりません。これらのディレクトリは普通は、一回の gnus 使用期間中
に一回だけしか読み込みません。もし遠隔ディレクトリを手動で再読み
込みする必要が出てきたら、
@code{gnus-score-search-global-directories} 命令を使うことができ
ます。

ただし現時点では、このオプションを使うとグループに入るのがいくら
か遅くなります。(つまり --- かなり、ですけど)

もしスコアファイルを、他の人たちに使ってもらうように維持したくなっ
てきたら、単にあなたのスコアファイルを匿名 FTP に置いて、世界中
に公表してください。逆司会者になれるよ! その後に続いて間違いなく
起こる逆司会者戦争、すなわち人々の共感を勝ち取るための逆司会者の
戦いに参加することで、彼らのスコアファイルに間違った前提を使わせ
るように誘導するのだ! やった! これでネットは救われる!

以下に、逆司会者なりたがりのための秘技をいくつか、即席で述べます。

@itemize @bullet

@item
非常に多くの場所にクロスポストされている記事は間違いなく屑である。
@item
一個の不適切な記事を減点するには、@code{Message-ID} で減点する。
@item
特に素晴らしい投稿者たちは永続的な主役達として加算する。
@item
そのグループの憲章無視の投稿を頻繁に繰り返す投稿者は、絶滅させて
しまって差し支えない。
@item
@code{mark} と @code{expunge} アトムを設定し、汚らわしい記事を完
全に葬り去る。

@item
消去のスコア項目を使ってファイルの大きさを小さく抑える。でもおそ
らくは、サイトによって古い記事を長期間保存するように、期限切れ消
去の期間は長く取るでしょうけれども。
@end itemize

... 果たして他のニュースリーダーは将来、グローバルスコアファイル
をサポートするでしょうか? @emph{うふふ}。そう、どう考えてみたっ
て、Blue Wave や xrn や 1stReader とかいったニュースリーダーはス
コアをサポートするべきだね。今は固唾を飲んで見守ることにしましょ
うか?


@node Kill Files
@section 消去ファイル
@cindex kill files

Gnus はまだ、あのうざったい古い消去ファイルをサポートしています。
実際消去ファイルの項目はもう消してもよいのですが、それは Daniel
Quinlan がスコアファイルを考え出す前に私が書いたものなので、その
コードはまだ残っています。

要するに、消去処理はスコア処理よりもかなり遅いので (私の言いたい
のは @emph{ものすごく})、あなたの消去ファイルはスコアファイルに
書き換えた方が良いかもしれません。

いずれにせよ、消去ファイルは普通の @code{emacs-lisp} ファイルです。
このファイルの中にはどんな形式でも入れることができます。つまり消
去ファイルをグループに入ったときに実行する一種の原始的なフック関
数のように使うことができます。まあそれがあまりいい方法ではないと
してもね。

通常の消去ファイルは以下のようになります。

@lisp
(gnus-kill "From" "Lars Ingebrigtsen")
(gnus-kill "Subject" "ding")
(gnus-expunge "X")
@end lisp

これは私が書いた全ての記事に既読の印をつけ、概略バッファから印の
ついた記事を削除します。とっても便利です。あなたもそう思うでしょ。

他のプログラムでは全く違う消去ファイルの構文を使っています。もし
gnus が @code{rn} の消去ファイルらしきものに出会ったら、何とかそ
れを解釈しようとします。

GNUS 消去ファイルを編集するための二つの概略バッファ関数がありま
す。

@table @kbd

@item M-k
@kindex M-k (Summary)
@findex gnus-summary-edit-local-kill
そのグループの消去ファイルを編集する
(@code{gnus-summary-edit-local-kill})。

@item M-K
@kindex M-K (Summary)
@findex gnus-summary-edit-global-kill
一般消去ファイルを編集する
(@code{gnus-summary-edit-global-kill})。
@end table

消去ファイルを編集する二つのグループモード関数があります。

@table @kbd

@item M-k
@kindex M-k (Group)
@findex gnus-group-edit-local-kill
そのグループの消去ファイルを編集する
(@code{gnus-group-edit-local-kill})。

@item M-K
@kindex M-K (Group)
@findex gnus-group-edit-global-kill
一般消去ファイルを編集する (@code{gnus-group-edit-global-kill})。
@end table

消去ファイル変数。

@table @code
@item gnus-kill-file-name
@vindex gnus-kill-file-name
@samp{soc.motss} グループ用の消去ファイルは通常
@file{soc.motss.KILL} という名前です。このファイル名を得るために
グループ名に付加される接尾辞は、@code{gnus-kill-file-name} 変数
で与えられます。``グローバル'' 消去ファイルは (スコアファイルの
意味での ``グローバル'' じゃないよ、もちろん) 単に @file{KILL}と
いう名前です。

@vindex gnus-kill-save-kill-file
@item gnus-kill-save-kill-file
この変数が @code{nil} 以外であれば、gnus は処理の後に消去ファイ
ルを保存します。これは期限切れ削除を行う消去を使っているときに必
要です。

@item gnus-apply-kill-hook
@vindex gnus-apply-kill-hook
@findex gnus-apply-kill-file-unless-scored
@findex gnus-apply-kill-file
グループに消去ファイルを適用するために呼び出されるフック。これは
初期設定では @code{(gnus-apply-kill-file)} です。もし同じグルー
プに対してスコアファイルがある場合には消去ファイルを無視したけれ
ば、このフックを @code{(gnus-apply-kill-file-unless-scored)} に
設定します。消去ファイルを処理させたくなければ、この変数を
@code{nil} に設定してください。

@item gnus-kill-file-mode-hook
@vindex gnus-kill-file-mode-hook
消去ファイルモードバッファ内で呼び出されるフック。

@end table


@node Converting Kill Files
@section 消去ファイルの変換
@cindex kill files
@cindex converting kill files

あなたが古い消去ファイルをどっさり持っているのであれば、それらを
スコアファイルに変換したくなるでしょう。もしそれらが ``普通の'' 
やつであれば、@file{gnus-kill-to-score.el} パッケージを使うこと
ができます。そうでなければ、手で変換しなければならないでしょう。

消去ファイルからスコアファイルへの変換パッケージは、標準では
gnus には含まれません。
@file{http://www.stud.ifi.uio.no/~larsi/ding-other/gnus-kill-to-score}
から入手することができます。

もしあなたの消去ファイルが非常に複雑なものであれば --- それに
@code{gnus-kill} 形式以外のものがたくさん含まれていれば、それら
を手で変換しなければなりません。あるいは単にそれらを、そのままに
しておいてください。Gnus は以前同様にそれらを使ってくれるでしょ
う。


@node GroupLens
@section GroupLens
@cindex GroupLens

GoupLens は、毎日作成される多くの量のニュース記事から質の良い記事を他の
人と共に見つけるのを助けるための共同選別機構です。

これを達成するために、GroupLens 機構はあなたが既に読んだ記事に対する意見
を、同じような事をした他の人の意見と結合して、それぞれの未読ニュース記事
に個人化された予言を与えます。GroupLens を仲人のようなものだと見なしてく
ださい。GroupLens はあなたがどのように記事の価値を付けるかを見て、同じよ
うに記事の価値を付ける人を探します。一度あなたの意見と一致する人を発見す
れば、予言の形で、それらの人が記事をどう思うかをあなたに告げます。あなた
はこの予言を記事を読みたいかどうかを決定するのに役立てる事ができます。

@menu
* Using GroupLens::          どのように gnus に GroupLens を使わせるよう
                             にするか。
* Rating Articles::          GropLens にあなたがどのように値を付けるかを
                             知らせる。
* Displaying Predictions::   GropuLens によって与えられた予言を表示する。
* GroupLens Variables::      GoupLens をカスタマイズする。
@end menu


@node Using GroupLens
@subsection GroupLens を使う

GroupLens を使うためには、ローカルの Better Bit Berau (BBB) に筆名 
(pseudonym) を登録しなければなりません。
@samp{http://www.cs.umn.edu/Research/GroupLens/bbb.html} が現在、ちまた
に存在する唯一の better bit です。

登録した後で、いくつかの変数を設定する必要があります。

@table @code

@item gnus-use-grouplens
@vindex gnus-use-grouplens
この変数を @code{nil} でない値に設定すると、Gnus が全ての GroupLens 関連
関数をフックするようになります。

@item grouplens-pseudonym
@vindex grouplens-pseudonym
この変数は Better Bit Bureau に登録したときにもらった筆名に設定されるべ
きです。

@item grouplens-newsgroups
@vindex grouplens-newsgroups
GroupLens の予言を得たいと思うグループのリストです。

@end table

これが起き上がって GroupLens を実行するために必要な最低限の設定です。一
度登録すると、GroupLens はあなたに他の人が考える平均に基づいたスコアをあ
なたに提供することを始めます。しかし、GroupLens の本当の利益を受けるため
には、自分自身で記事の値付けを始めなければなりません。そうすると、
GroupLens があなたに提供するスコアはあなたが普段納得するような意見を持っ
た人が既に値を付けた基づいて個人化されます。


@node Rating Articles
@subsection Rating Articles

GroupLens では、記事は1から5まででそれを含んだ範囲で値を付けられます。1
は帯域の無駄遣いのようなものだと考えられ、5は記事が本当に良いと考えられ
るいう事を意味します。あなたが自分自身に尋ねる基本的な質問は、``1から5の
範囲の中で、これと同じような記事をもっと読みたいだろうか？'' です。

GroupLens で、記事の値を登録するための4つの方法があります。

@table @kbd

@item r
@kindex r (GroupLens)
@findex bbb-summary-rate-article
この関数は1から5の範囲の値付けの入力を促進します。

@item k
@kindex k (GroupLens)
@findex grouplens-score-thread
この関数は値付けの入力を促進し、スレッドの全ての記事を値付けます。これは 
rec.humor にあるようなあの長い間続くスレッドに対して非常に役に立ちます。

@end table

次の2つの命令、@kbd{n} と @kbd{,} は、あなたが読んでいる記事のスコアにな
る数値接頭引数をとります。

@table @kbd

@item 1-5 n
@kindex n (GroupLens)
@findex grouplens-next-unread-article
記事の値を付けて、次の未読記事に移動します。

@item 1-5 ,
@kindex , (GroupLens)
@findex grouplens-best-unread-article
記事の値を付けて次の一番高いスコアの未読記事に移動します。

@end table

もし現在の記事にスコア4を付け、次の記事に移動したいのであれば、@kbd{4 n} 
と叩いてください。


@node Displaying Predictions
@subsection 予言表示

GroupLens はあなたがニュース記事をどれくらい気に入るかの予言をします。
GroupLens からの予言は1から5の範囲にあり、1が最悪で5が最良です。
GroupLens からの予言を変数 @code{gnus-grouplens-override-scoring} によっ
て制御される3つの内の1つによって使う事ができます。

@vindex gnus-grouplens-override-scoring
grouplens で予言を表示するために3つの方法があります。GroupLens のスコア
を普通の gnus スコア機構に貢献するか、上書きするかを選ぶ事ができます。上
書きが初期設定です。しかし、gnus のスコアを grouplens のスコアに足すのを
好む人もいます。分離スコアの振る舞いを得るためには、
@code{gnus-grouplens-override-scoring} を @code{'separate} に設定する必
要があります。GroupLens の予言と grouplens スコアを結合するためにはそれ
を @code{'override} に設定し、スコアを結合するためには 
@code{gnus-grouplens-override-scoring} を @code{'combine} に設定します。
結合付加機能を用いるときは、@code{grouplens-prediction-offset} と 
@code{grouplens-score-scale-factor} の値を設定したいと思うでしょう。

@vindex grouplens-prediction-display
どちらの場合でも、GroupLens は2,3の予言がどのよう表示されたいかの選択を
与えます。予言の表示は変数 @code{grouplens-prediction-display} によって
制御されます。

以下のものがその変数で有効な値です。

@table @code
@item prediction-spot
予言が高いほど、右の方に @samp{*} が表示されます。

@item confidence-interval
数字の確信 (confidence) 間隔です。

@item prediction-bar
予言が高いほど、棒が長くなります。

@item confidence-bar
数字確信です。

@item confidence-spot
確信が高いほど点が大きくなります。

@item prediction-num
普通の昔ながらの数値です。

@item confidence-plus-minus
予言の +/- 確信です。

@end table


@node GroupLens Variables
@subsection GroupLens 変数

@table @code

@item gnus-summary-grouplens-line-format
GropuLens 拡張の概略バッファで使われる概略行様式です。普通の概略行様式が
受け付けるものと同じ指定を受け付けます (@pxref{Summary Buffer Lines})。
初期設定は@samp{%U%R%z%l%I%(%[%4L: %-20,20n%]%) %s\n} です。

@item grouplens-bbb-host
bbbd サーバーが実行されているホストです。@samp{goruplens.cs.umn.edu} が
初期設定です。

@item grouplens-bbb-port
bbbd サーバーが実行されているホストのポートです。初期値は9000です。

@item grouplens-score-offset
予言から差し引きされる値です。つまり、意味のあるスコアにするために予言の
値からこの数字を引き算します。初期値は0です。

@item grouplens-score-scale-factor
利用者はこの変数を使って GroupLens のスコアを拡大する事ができます。掛け
算の要素は差し引きの後に適用されます。初期値は1です。

@end table


@node Advanced Scoring
@section 上級スコア付け

表題や From ヘッダーにスコアを付けるのは十分素敵ですが、ある人特定の題に
関して言っている事にだけ本当に興味がある場合はどうすれば良いのでしょう？
もしくは、Aさんが Bさんにフォローアップしているときに言っている事を読み
たくないけれど、Cさんにフォローアップしているときは何を言っているかを知
りたいという場合は？

上級スコア法則を使う事で、任意の複雑なスコアの付け方を作成する事ができま
す。

@menu
* Advanced Scoring Syntax::     定義。
* Advanced Scoring Examples::   どのように見えるか。
* Advanced Scoring Tips::       それを最大限利用する。
@end menu


@node Advanced Scoring Syntax
@subsection 上級スコア付け構文

普通のスコア法則は法則の最初の要素に文字列があります。上級スコア付け法則
は最初の要素にリストがあります。2番目のリストは最初の要素が @code{nil} 
でない値に評価されたときに適用されます。

これらのリストは3つの論理作用子からなっており、それらは1方向作用子で、色々
な合致作用子です。

論理作用子:

@table @code
@item &
@itemx and
この論理作用子はそれぞれの引数を @code{false} に評価されるものを見つける
まで評価し、それから停止します。全ての引数が @code{true} の値に評価され
た場合は、この作用子は @code{true} を返します。

@item |
@itemx or
この論理作用子はそれぞれの引数を @code{true} に評価されるものを見つける
まで評価します。もしどの引数も @code{true} でないと、この作用子は 
@code{false} を返します。

@item !
@itemx not
@itemx \254
この論理作用子は単一の引数のみをとります。それはその引数の値の論理否定を
返します。

@end table

引数をスコア付けされている現在の記事の祖先に適用する @dfn{間接作用子} が
あります。例えば、@code{1-} は現在の記事の親にもスコア法則を適用します。
@code{2-} は現在の記事の祖父母にスコア法則を適用します。代わりに、
@code{^^} を書く事もでき、この時、@code{^} (キャラット) (carat) の数はど
のくらい祖先の記事までさかのぼるかを示します。

最後に、合致作用子があります。これらが本当の仕事をするものです。合致作用
子はヘッダー名の文字列で、その後に合致と合致の型が続きます。典型的な合致
作用子は @samp{("form" "Lars Ingebrigtsen" s)} のようなものです。ヘッダー
名は単純なスコア付けをするときのものと同じで、合致の型も同じです。


@node Advanced Scoring Examples
@subsection 上級スコア付けの例

Lars が Gnus に関して話をしているときに彼によって書かれた記事のスコアを
増やしたいとしましょう:

@example
((&
  ("from" "Lars Ingebrigtsen")
  ("subject" "Gnus"))
 1000)
@end example

ね、とても単純でしょ？

長い記事を書いているときは、時々何か素敵な事を言います:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (|
   ("subject" "Gnus")
   ("lines" 100 >)))
 1000)
@end example

しかし、彼が Reig Eigil Logge によって書かれたものに反応しているときは、
彼が書いたものを読みたくありません:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (1- ("from" "Reig Eigir Logge")))
 -100000)
@end example

Redmondo が消えた靴下について書いたときにフォローアップした全ての人はス
コアが上げられますが、それは彼らが白い靴下について語っているときのみです。
しかし、Lars が靴下について話をしているときは、たいていあまりおもしろく
ありません:

@example
((&
  (1-
   (&
    ("from" "redmondo@@.*no" r)
    ("body" "disappearing.*socks" t)))
  (! ("from" "Lars Ingebrigtsen"))
  ("body" "white.*socks"))
 1000)
@end example

可能性は無限大です。


@node Advanced Scoring Tips
@subsection 上級スコアのちょっとした秘訣

@code{&} と @code{|} 論理作用子は、短縮回路論理を行います。すなわち、そ
の作用の結果が明らかになって時点で、引数を実行過程にかける事を止めます。
例えば、@code{&} の引数の評価が @code{false} になると、残りの引数を評価
する目的は存在しなくなります。これは遅い合致 (@samp{body} や 
@samp{header}) を最後に持ってきて、速い合致 (@samp{from} や 
@samp{subject}) を最初に持ってくるべきであるという事を意味します。

間接作用子 (@code{1-} など) はそれらの引数をスレッドの1世代前に作用する
ようにします。次のような事をすれば:

@example
...
(1-
 (1-
  ("from" "lars")))
...
@end example

これは ``現在の記事の祖父母の from ヘッダーにスコアを付ける'' という事を
意味します。間接はとても速いですが、次の方よりも:

@example
(1-
 (&
  ("from" "Lars")
  ("subject" "Gnus")))
@end example

次の方が良いです:

@example
(&
 (1- ("from" "Lars"))
 (1- ("subject" "Gnus")))
@end example


@node Score Decays
@section スコア腐敗
@cindex score decays
@cindex decays

スコアは再現無く膨れ上がる傾向がある事に気付くかもしれません。特に、適応
スコアを使っているときは。スコアが大きくなりすぎると、それらは意味を失い
ます---それらは単に最大を通り越してしまって、それを意味のある方法で使う
事は難しくなります。

@vindex gnus-decay-scores
@findex gnus-decay-score
@vindex gnus-decay-score-function
Gnus はこの問題の解決を助けるためにスコアを腐らせる機構を提供します。ス
コアファイルは読み込まれ、 @code{gnus-decay-scores} が @code{nil} でない
と、gnus はスコアファイルを腐敗機構を通し、全ての永続でないスコア法則の
スコアを下げます。腐敗自身は関数 @code{gnus-decay-score-function} によっ
て実行され、初期設定は @code{gnus-decay-score} です。以下はその関数の定
義です:

@lisp
(defun gnus-decay-score (score)
  "Decay SCORE.
This is done according to `gnus-score-decay-constant'
and `gnus-score-decay-scale'."
  (floor
   (- score
      (* (if (< score 0) 1 -1)
         (min (abs score)
              (max gnus-score-decay-constant
                   (* (abs score)
                      gnus-score-decay-scale)))))))
@end lisp

@vindex gnus-score-decay-scale
@vindex gnus-score-decay-constant
@code{gnus-score-decay-constant} は初期値として3を持ちで、
@code{gnus-score-decay-scale} は初期値として0.05を持ちます。これは以下の
ような事を引き起こします:

@enumerate
@item
-3から3の間のスコアはこの関数が呼ばれたときに0に設定されます。

@item
3から60までの間の大きさのスコアは3つ減らされます。

@item
60より大きいスコアはスコアの5%に減らされます。
@end enumerate

もしこの腐敗関数を好きでないなら、自分自身の関数を書いてください。それは
腐敗するべきスコアを唯一の引数として呼ばれ、整数であるべき新しいスコアを
返さなければなりません。

Gnus は1日に1回スコアを腐敗させようとします。例えば、もし gnus を4日間実
行していないと、gnus は4回スコアを腐らせます。


@node Various
@chapter いろいろ

@menu
* Process/Prefix::             多くの扱い命令で使われる習慣。
* Interactive::                Gnus に多くの質問を尋ねさせる。
* Symbolic Prefixes::          いくつかの gnus の関数に選択権を提供する方法。
* Formatting Variables::       バッファがどのように見えるべきかを指定する事ができる。
* Windows Configuration::      Gnus バッファウィンドウを設定する。
* Faces and Fonts::            フェイスがどのように見えるかを変更する。
* Compilation::                どのようにして gnus の速度を上げるか。
* Mode Lines::                 モード行に情報を表示する。
* Highlighting and Menus::     バッファを素敵で心地よく見せる。
* Buttons::                    簡単な10歩でアキレス腱を得る。
* Daemons::                    Gnus はあなたの裏で物事を実行する事ができる。
* NoCeM::                      Spam や他の太りやすい食事を避ける方法。
* Undo::                       いくつかの動作は元に戻す事ができる。
* Moderation::                 あなたがモデレーターだったらどうするか。
* XEmacs Enhancements::        XEmacs ではもっと絵やその他のものが存在する。
* Fuzzy Matching::             大きな綿毛って何？
* Thwarting Email Spam::       余計な商業的電子メールを避ける方法。
* Various Various::            本当にいろいろなもの。
@end menu


@node Process/Prefix
@section プロセス/接頭引数
@cindex process/prefix convention

多くの関数、その中でも記事の移動、復号化、保存をするための関数は、
@dfn{プロセス/接頭引数の習慣} として知られているものを使います。

これは利用者がどの記事に命令を実行したいかを見つけるための方法です。

それはこのような感じです:

もし数値接頭引数が N であると、現在の記事から始めて、次の N 記事に作業を
実行します。もし数値接頭引数が負であると、現在の記事から始めて、前の N 
記事に作業を実行します。

@vindex transient-mark-mode
@code{transient-mark-mode} が @code{nil} でなく、リージョンが操作されて
いると、リージョンにある全ての記事に作業がなされます。


もし接頭引数が無いけれど、いくつかの記事はプロセス印が付いているという場
合は、プロセス印の付いている記事に作業が実行されます。

数値接頭引数やプロセス印の付いている記事が無い場合は、現在の記事にだけ作
業を実行します。

これは本当に非常に簡単ですが、驚嘆を避けられるように詳細を明らかにしてお
く必要があるのです。

プロセス印に反応する記事は現在のプロセス印の付いている記事のリストをスタッ
クに積み、全てのプロセス印の記事のリストを消去します。前回の設定を 
@kbd{M P y} で復旧させる事ができます (@pxref{Setting Process Marks})。

@vindex gnus-summary-goto-unread
多くの人々を驚かせ、恐がらせると思われることは、例えば、@kbd{3 d} は本当
に @kbd{d} @kbd{d} @kbd{d} と同じ事をする事です。それぞれの @kbd{d} (こ
れは現在の記事に既読の印を付けます) は初期設定では印を付けた後に次の未読
記事に移動するので、@kbd{3 d} は概略バッファがどのようであっても、次の3
つの未読記事を既読にします。もっと分かりやすい動作のためには 
@code{gnus-summary-goto-unread} を @code{nil} に設定してください。


@node Interactive
@section 対話的
@cindex interaction

@table @code

@item gnus-novice-user
@vindex gnus-novice-user
もしこの変数が @code{nil} でないと、あなたは Usenet の世界に新しく入って
来た人であるか、非常に慎重な人で、これは本当に良い事です。何か危険な事を
する前に、``本当にこれをしたいのですか？'' というような質問を受けます。
これは初期設定では @code{t} です。

@item gnus-expert-user
@vindex gnus-expert-user
この変数が @code{nil} でないと、あなたは gnus からほとんど質問を受ける事
はありません。これは単純にあなたがどのような変な事をしていても、何をして
いるかをわかっていると見なします。

@item gnus-interactive-catchup
@vindex gnus-interactive-catcup
@code{nil} でないと、グループに追いつく (catchup) 前に、確認を要求します。
これは初期設定で @code{t} です。

@item gnus-interactive-exit
@vindex gnus-interactive-exit
Gnus を終了する前に確認を要求します。この変数は初期設定で @code{t} です。
@end table


@node Symbolic Prefixes
@section シンボルの接頭引数
@cindex symbolic prefixes

非常に多くの Emacs の命令は (数値) 接頭引数に反応します。例えば、
@kbd{C-u 4 C-f} はポイントを4文字先に移動し、@kbd{C-u 9 0 0 I s s p} は
永続 @code{Suject} 文字列の一部スコア法則の900を現在の記事に加えます。

これは素敵で良いのですが、命令にもう少し追加の情報を与えたいときはどうす
れば良いのでしょう？えーと、たいていの命令がしている事は、``生の'' 接頭
引数を特別な方法で解釈する事です。例えば、@kbd{C-u 0 C-x C-s} は現在の記
事を保存するときにバックアップファイルを作らないで欲しいということを意味
します。でも、バックアップファイルを作らないで保存し、同時に Emacs に光っ
て欲しく、素敵な音楽を演奏して欲しいときはどうすれば良いでしょう？それは
不可能で、おそらくそれが不可能であってもあなたは幸せでしょう。

@kindex M-i (概略)
@findex gnus-symbolic-argument
私はそうではありません。ですから、私は2つめの接頭引数---@dfn{シンボル接
頭引数} を加えました。接頭キーは @kbd{M-i}
(@code{gnus-symbolic-argument}) で、次に押される文字が値です。望むだけ多
くの @kbd{M-i} 接頭語を積み重ねる事ができます。@kbd{M-i a M-C-u} は ``命
令 @kbd{M-C-u} にシンボル接頭引数 @code{a} を与える'' ということです。
@kbd{M-i a M-i b M-C-u} は命令 @kbd{M-C-u} にシンボル接頭引数 @code{a}
@code{b} を与える'' という事です。趣旨は分かったでしょう。

シンボル接頭引数を受け付けない命令にそれを打鍵する事は何も悪い事をしませ
んが、良い事も何もしません。現在のところ、あまり多くの関数がシンボル接頭
引数を役立てているわけではありません。

もしどのように gnus がこれを実装しているかに興味があるなら、
@pxref{Extended Interactive} を見てください。


@node Formatting Variables
@section 書法仕様変数
@cindex formatting variables

このマニュアルを通して、あなたはおそらく @code{gnus-group-line-format} 
や @code{gnus-summary-mode-line-format} のように呼ばれるたくさんの変数が
ある事に気付いたでしょう。これらは gnus が色々なバッファでどのように行を
出力するかを制御します。非常にたくさんのものがあります。幸運な事に、それ
らはすべて同じ構文を使いますので、あまり嫌な目には会わないでしょう。

書法仕様 (format) 指定の例があります (グループバッファより):
@samp{%M%S%5y: %(%g%)\n}。それは実際に非常に醜く、たくさんのパーセント記
号がどこにでもあります。

@menu
* Formatting Basics::     書法仕様変数は基本的に書法指定文字列である。
* Mode Line Formatting::  モード行の書法仕様変数に関するいくつかの規則。
* Advanced Formatting::   色々な方法で出力を修正する。
* User-Defined Specs::    Gnus にあなた自身の関数を呼ばせる。
* Formatting Fonts::      仕様を多彩で素敵に見せる。
@end menu

現在のところ、gnus は以下の書法仕様変数を使います:
@code{gnus-group-line-format}、@code{gnus-summary-line-format}、
@code{gnus-server-line-format}、@code{gnus-topic-line-format}、
@code{gnus-group-mode-line-format}、@code{gnus-summary-mode-line-format}、
@code{gnus-article-mode-line-format}、
@code{gnus-server-mode-line-format}、
@code{gnus-summary-pick-line-format}。

これら全ての書法仕様変数は任意の elisp 式である事もできます。その場合は、
それらは要求される行に挿入するために @code{評価} されます。

@kindex M-x gnus-update-format
@findex gnus-update-format
Gnus はあなた自身の書法仕様指定を作る手伝いをする命令を備えています。
@kbd{M-x gnus-update-format} は現在の式を @code{評価} し、当の指定を更新
し、結果の lisp 式を実行して行を作成する事を実験できるバッファに移動しま
す。



@node Formatting Basics
@subsection 書法仕様の基本

それぞれの要素 @samp{%} は当のバッファが作成されるときに何らかの文字列や
他のもので置き換えられます。@samp{%5y} は ``@samp{y} 指定を挿入し、5文字
の場所を得るために空白を入れなさい'' という事です。

普通の C や Emacs Lisp の書法仕様 (format) 文字列と同じように、@samp{%} 
と書法仕様の型の文字の間の数値修飾子は常に少なくともその長さになるように、
出力に @dfn{詰め} れられます。@samp{%5y} はその部分を常に (少なくとも) 5
文字の長さになるように、左に空白を詰めます。もし @samp{%-5y} とすれば、
代わりに右側に詰め込みます。

特に長い値からその部分を保護するために、長さを制限したいとも思うでしょう。
そのためには、@samp{%4,6y} とする事ができて、これはその領域は決して6文字
を超える長さにはならず、4文字より少ない長さにならないという事です。


@node Mode Line Formatting
@subsection モード行書法仕様

モード行書法仕様変数 (すなわち、@code{gnus-summary-mode-line-format}) は
以下の2つの違い以外は、バッファ行に基づく書法仕様変数と 
(@pxref{Formatting Basics}) 同じような規則に従います:

@enumerate

@item
最後に改行 (@samp{\n}) があってはなりません。

@item
特別な @samp{%%b} 指定をバッファ名を表示するために使うことができます。えー
と、本当はそれは指定ではないのです---@samp{%%} は単に書法仕様が機械的に
切り裂くのを切り抜けて @samp{%} をそのまま渡すための方法で、Emacs が 
@samp{%b} を受け取ると、Emacs のモード行表示の部分がそれを ``バッファ名
を表示しなさい'' と解釈します。Emacs が理解するモード行指定の完全な一覧
を見るためには、変数 @code{mode-line-format} の説明文を見て下さい。

@end enumerate


@node Advanced Formatting
@subsection 上級書法仕様

何らかの方法で領域を後で処理するのは頻繁に役に立ちます。部分を詰め込む、
制限する、切り取ることと特定の値を抑制する事は、@dfn{チルダ修飾子} を使
う事により達成されます。よくあるチルダ指定はこのように見えるかもしれませ
ん @samp{%~(cut 3)~(ignore "0")y}。

これらは有効な修飾子です:

@table @code
@item pad
@itemx pad-left
要求された長さになるまで、領域に空白を左側から詰め込みます。

@item pad-right
要求された長さになるまで、領域に空白を右側から詰め込みます。

@item max
@itemx max-left
指定された長さになるように、文字を左側から切り取ります。

@item max-right
指定された長さになるように、文字を右側から切り取ります。

@item cut
@itemx cut-left
指定された数の文字を左側から切り落とします。

@item cut-right
指定された数の文字を右側から切り落とします。

@item ignore
領域が指定された値と等しければ (equal) 、空文字列を返します。

@item form
@samp{@@} 指定が使われたときに、指定された式を領域の値として使います。
@end table

例を出してみましょう。概略モード行での @samp{%o} 指定は小型の ISO0861 様
式の日付を返します---@samp{19960809T230410} です。これは発音しにくいので、
世紀を表す数と時間を削ぎ落として、6文字の日付を残したいと思います。それ
は @samp{%~(cut-left 2)~(max-right 6)~(pad 6)o} となるでしょう。(切り落
とし (cutting) は 最大限 (maxing) より先になされますので、桁で素敵に見え
るようにするために日付が6文字より少なく無くならない事を保証するために詰
め込み (padding) が必要になります。)

無視 (ignore) が最初になされます。それから切り落とし (cut) が行われます。
そして、それから最後の操作、詰め込み (pad) が行われます。

もしこれらの上級参照をたくさん使っているなら、gnus がとても遅くなるのが
わかるでしょう。これはあなたの行の外見に満足したときに @kbd{M-x
gnus-compile} を実行する事で格段に速度低下を減らす事ができます。
@xref{Compilation}。


@node User-Defined Specs
@subsection 利用者定義の指定

全ての指定は利用者定義---@samp{u} の指定を挿入する事ができます。書法仕様
文字列の次の文字はアルファベットである必要があります。Gnus は関数 
@code{gnus-user-format-function-}@samp{X} を呼び、ここで @samp{X} は 
@samp{%u} に続くアルファベットです。関数には単一の引数が与えられます---
引数の意味は関数がどのバッファから呼ばれているかによって変わります。関数
は文字列を返すべきで、それは他の指定からの情報と全く同じようにバッファに
挿入されます。関数は意味の無い値と共に呼ばれる事もありえますので、それの
対策をするべきです。

新しい関数を定義しないでも、チルダ修飾子 (@pxref{Advanced Formatting}) 
を使ってほとんど同じ事を達成する事ができます。例です: @samp{%~(form
(count-lines (point-min) (point)))@@}。ここで与えられた式は評価されて、
現在の行数をもたらし、それから挿入されます。


@node Formatting Fonts
@subsection 書法仕様フォント

ハイライトのための指定があり、それらは全ての書法仕様変数によって共有され
ています。@samp{%(} と @samp{%)} 指定の間の文章は特別な 
@code{mouse-face} プロパティが設定され、それはそこにマウスのポインターを
あわせたときに (@code{gnus-mouse-face} によって) ハイライトされることに
なります。


@samp{%@{} と @samp{%@}} 指定の間の文章は @code{gnus-face-0} を使って普
通のフェイスが設定され、それは初期設定で @code{bold} です。もし 
@samp{%@{1} としたなら、代わりに @code{gnus-face-1} を得、以下同様です。
欲しいだけたくさんのフェイスを作ってください。同じ事が @code{mouse-face} 
指定にも言えます---@samp{hello} が @code{gnus-mouse-face-3} でマウス−ハ
イライトされるためには、@samp{%3(hello%)} とする事ができます。

これはグループバッファの代替手法です:

@lisp
;; 3つのフェイスの型を作る。
(setq gnus-face-1 'bold)
(setq gnus-face-3 'italic)

;; 我々は記事の数をボールドで緑のフェイス
;; にしたいので、`my-green-bold' と呼ばれる
;; 新しいフェイスを作った。
(copy-face 'bold 'my-green-bold)
;; 色を設定する。
(set-face-foreground 'my-green-bold "ForestGreen")
(setq gnus-face-2 'my-green-bold)

;; 新しい上等の書法仕様を設定する。
(setq gnus-group-line-format
      "%M%S%3@{%5y%@}%2[:%] %(%1@{%g%@}%)\n")
@end lisp

あなたがこの案を使って完全に読めなくて非常に下品な表示を作る事ができると
確信しています。楽しんでください！

@samp{%(} 指定 (やその類のもの) はモード行変数では全く意味をなさない事に
注意してください。


@node Windows Configuration
@section ウィンドウの設定
@cindex windows configuration

いえ、X に関する事はありませんので、おとなしくして下さい。

@vindex gnus-use-full-window
もし @code{gnus-use-full-window} が @code{nil} でないと、gnus は全ての他
のウィンドウを消して、Emacs の画面全体を占有します。これは初期設定で 
@code{t} です。

@vindex gnus-buffer-configuration
@code{gnus-buffer-configuration} はそれぞれの gnus のバッファがどのくら
いの空間を与えられるべきかを現します。これはこの変数の抜粋です:

@lisp
((group (vertical 1.0 (group 1.0 point)
                      (if gnus-carpal (group-carpal 4))))
 (article (vertical 1.0 (summary 0.25 point)
                        (article 1.0))))
@end lisp

これは連想リストです。@dfn{キー} は何らかの動作や他のものを任命するシン
ボルです。例えば、グループバッファを表示するときは、ウィンドウ設定関数は 
@code{group} をキーとして使います。使用可能な名前の完全な一覧は下に挙げ
られています。

@dfn{値} (すなわち、@dfn{分割}) はそれぞれのバッファがどれくらいを占める
べきかを指定します。@code{article} 分割を例に取ると -

@lisp
(article (vertical 1.0 (summary 0.25 point)
                       (article 1.0)))
@end lisp

この @dfn{分割} は概略バッファ (summary buffer) が画面の上の 25% を占め
るべきで、それは記事バッファ (article buffer) の上に配置されます。お気づ
きの通り、100% + 25% は実際は 125% です (えぇ、皆さんの計算はこの様になっ
たと思います。) しかし、特別な数字 @code{1.0} は、残りのバッファが必要な
ものを取り去った後に、使用可能な残りの空間全てを吸い取る、という事を合図
するために使われます。1つの分割につき、@code{1.0} の大きさ指定のバッファ
は一つだけでなくてはなりません。

ポイントは省略可能な3つ目の要素、@code{point} を持つバッファに置かれます。
@code{frame} 分割では、タグ @code{frame-focus} が構成要素である (すなわ
ち、@code{point} タグが存在するかどうかによって、リストの3番目か4番目か
に存在する要素) 葉分割を持つ最後の副分割が焦点を得る事になります。

次はもっと複雑な例です:

@lisp
(article (vertical 1.0 (group 4)
                       (summary 0.25 point)
                       (if gnus-carpal (summary-carpal 4))
                       (article 1.0)))
@end lisp

もし大きさ指定が浮動小数点数の代わりに整数であったなら、それは割合ではな
く、どのくらい多くの行をバッファが占めるべきかを指定するために使われます。

もし @dfn{分割} が @code{評価} されるもののように見えるときは (明確にす
ると---分割の @code{car} が関数か原始関数 (subr) であるときは)、この分割
は @code{評価} されます。結果が @code{nil} でないなら、それは分割として
用いられます。これは、@code{gnus-carpal} が @code{nil} であれば3つのバッ
ファが、@code{gnus-carpal} が @code{nil} でないなら、4つのバッファが存在
するという事です。

まだ複雑ではないですって？ それでは、大きさにこれを試してみて下さい:

@lisp
(article (horizontal 1.0
             (vertical 0.5
                 (group 1.0)
                 (gnus-carpal 4))
             (vertical 1.0
                 (summary 0.25 point)
                 (summary-carpal 4)
                 (article 1.0))))
@end lisp

おぉっと。2つのバッファに不思議な 100% タグが付いています。そして、あの 
@code{horizontal} っていうものは何でしょう？

もし分割の一つの最初の要素が @code{horizontal} であったなら、gnus は ウィ
ンドウを水平に分割し、2つのウィンドウを横に並べます。これらのそれぞれの
小片の中では、全てを普通の流儀で行う事ができます。@code{horizontal} の後
の数字は、この小片に画面のどれくらいの割合が与えられるかを指定します。

それぞれの分割では、100% のタグを持つ要素が @emph{必ず} 一つある必要があ
ります。分割は決して正確には行われませんので、このバッファが分割から残さ
れた全ての行を占領します。

もう少し正式にするために、ここに有効な分割がどのようになるかの定義があり
ます:

@example
split       = frame | horizontal | vertical | buffer | form
frame       = "(frame " size *split ")"
horizontal  = "(horizontal " size *split ")"
vertical    = "(vertical " size *split ")"
buffer      = "(" buffer-name " " size *[ "point" ] *[ "frame-focus"] ")"
size        = number | frame-params
buffer-name = group | article | summary ...
@end example

制限には、@code{frame} は最上位の分割としてしか現れる事ができないという
ものがあります。@var{form} は有効な分割を返す Emacs Lisp の式 (form) で
なければなりません。それぞれの分割は完全に再帰的で、任意の数の 
@code{vertical} と @code{horizontal} 分割を含む事ができます。

@vindex gnus-window-min-width
@vindex gnus-window-min-height
@cindex window height
@cindex window width
正しい大きさを見つけるのは少し複雑です。どのウィンドウも 
@code{gnus-window-min-height} (初期値 1) の文字の高さよりも小さくてはな
らず、少なくとも @code{gnus-window-min-width} (初期値 1) の文字幅でなく
てはなりません。Gnus は分割を適用する前にこれを強制しようと試みます。も
し普通の Emacs のウィンドウの幅/高さ制限を使いたいなら、この2つの変数を 
@code{nil} にするだけで良いです。

もし Emacs の用語になじんでいないのなら、@code{horizontal} と 
@code{vertical} 分割は、期待するものと反対の動作をするでしょう。
@code{horizontal} 分割の中のウィンドウは横に並んで表示され、
@code{vertical} 分割の中のウィンドウは上下に表示されます。

@findex gnus-configure-frame
ウィンドウの設置に関して実験をしてみたいのであれば、よい方法は分割で直接 
@code{gnus-configure-frame} を呼ぶことです。これはバッファを分割するとき
に全ての本当の仕事をする関数です。下のものは5ウィンドウのとてもばかげた
設定です。2つをグループバッファに、3つを記事バッファのために充てます。 
(それはばかげていると言ったでしょ。) もし下の文を @code{評価} すると、普
通の gnus の経路を使わないで、すぐにそれがどのように見えるかの考えを得る
事ができます。満足するまでそれで遊んで、それから 
@code{gnus-add-configuration} を使って新しい想像をバッファ設定リストに加
えて下さい。

@lisp
(gnus-configure-frame
 '(horizontal 1.0
    (vertical 10
      (group 1.0)
      (article 0.3 point))
    (vertical 1.0
      (article 1.0)
      (horizontal 4
        (group 1.0)
        (article 10)))))
@end lisp

いくつかのフレームも欲しいかもしれません。簡単です---@code{frame} 分割を
使うだけです:

@lisp
(gnus-configure-frame
 '(frame 1.0
         (vertical 1.0
                   (summary 0.25 point frame-focus)
                   (article 1.0))
         (vertical ((height . 5) (width . 15)
                    (user-position . t)
                    (left . -1) (top . 1))
                   (picon 1.0))))

@end lisp

この分割の結果は、最初 (もしくは、``主な'') フレームは見慣れた概略/記事
ウィンドウ設定で、小さな追加のフレームが picon を表示するために作られる
という事になります。ご覧の通り、普通の @code{1.0} 最上位指定の代わりに、
それぞれの追加の分割がフレームパラメータ連想リストを大きさ指定として持た
なければなりません。@xref{Frame Parameters, , Frame Parameters, elisp,
The GNU Emacs Lisp Reference Manual}. XEmacs では、フレームプロパティリ
ストも使えます---例えば、@code{(height 5 width 15 left -1 top 1)} はその
ようなパラメータリストです。

これは @code{gnus-buffer-configuration} に仕様可能なキーの一覧です:

@code{group}、@code{summary}、@code{article}、@code{server}、
@code{browse}、@code{message}、@code{pick}、@code{info}、
@code{summary-faq}、@code{edit-group}、@code{edit-server}、
@code{edit-score}、@code{post}、@code{reply}、@code{forward}、
@code{reply-yank}、@code{mail-bounce}、@code{draft}、@code{pipe}、
@code{bug}、@code{compose-bounce}、@code{score-trace}。

キー @code{message} は @code{gnus-group-mail} と 
@code{gnus-summary-mail-other-window} の両方で使われる事に注意して下さい。
もし2つを区別するほうが望ましいなら、このような物を使う事ができます:

@lisp
(message (horizontal 1.0
                     (vertical 1.0 (message 1.0 point))
                     (vertical 0.24
                               (if (buffer-live-p gnus-summary-buffer)
                                   '(summary 0.5))
                               (group 1.0)))))
@end lisp

@findex gnus-add-configuration
変数 @code{gnus-buffer-configuration} はとても長く複雑なので、単一の設定
の変更を簡単にするための関数があります: @code{gnus-add-configuration} で
す。もし、例えば、@code{article} の設定を変えたいのなら、次のようにでき
ます:

@lisp
(gnus-add-configuration
 '(article (vertical 1.0
               (group 4)
               (summary .25 point)
               (article 1.0))))
@end lisp

普通はこれらの @code{gnus-add-configuration} 呼び出しをファイル 
@code{.gnus.el} に入れるか、何らかの起動時のフックに入れるでしょう---そ
れらは gnus が読み込まれた後に実行されるべきです。

@vindex gnus-always-force-window-configuration
もし設定で言及された全てのウィンドウが既に見えているのであれば、gnus は
ウィンドウの設定を変更しません。もし常に ``正しい'' ウィンドウ設定を強制
したいのであれば、@code{gnus-always-force-window-configuration} を 
@code{nil} でない値に設定する事ができます。


@node Faces and Fonts
@section フェイスとフォント
@cindex faces
@cindex fonts
@cindex colors

フォントとフェイスを弄るのは非常に難しかったのですが、今日では非常に簡単
です。単に @kbd{M-x customize-face} とやって、変えたいフェイスを選び出し
て、標準のカスタマイズインターフェースを使って変更する事ができます。


@node Compilation
@section コンパイル
@cindex compilation
@cindex byte-compilation

@findex gnus-compile

あの行書法仕様指定変数を覚えていますか？ @code{gnus-summary-line-format}、
@code{gnus-group-line-format} などなどです。さて、gnus はもちろんこれら
の変数がどのようなものでも注意しますが、不運な事に、それらを変更すると、
大変重大な速度低下を引き起こす事になります。 (これらの変数の初期値はそれ
らに関連付けられたバイトコンパイルされた関数を持っていますが、利用者作成
のものはもちろんそうではありません。)

これを改善するために、変数を弄りまわして、(なんとなく) 満足したと感じた
後で、@kbd{M-x gnus-compile} を実行する事ができます。これは新しい指定が
バイトコンパイルされ、もう一度最高速度に復帰できるという事です。Gnus は
これらのコンパイルされた指定をファイル @file{.newsrc.eld} に保存します。 
(利用者定義の関数は、この関数ではコンパイルされませんが--それらをコンパ
イルするためには、それらをファイル @code{.gnus.el} に突っ込んで、そのファ
イルをバイトコンパイルするべきです。)


@node Mode Lines
@section モード行
@cindex mode lines

@vindex gnus-update-mode-lines
@code{gnus-updated-mode-lines} はどのバッファがそのモード行を常に最新の
ものにしておくかを指定します。それはシンボルのリストです。使う事のできる
シンボルは @code{group} 、@code{article}、@code{summary}、@code{server}、
@code{browse}、@code{tree} などです。もし対応するシンボルが存在すると、
gnus は該当するであろう情報でモード行を更新します。この変数が @code{nil} 
であるなら、画面の再描画はもっと速いでしょう。

@cindex display-time

@vindex gnus-mode-non-string-length
初期設定では、gnus は概略バッファと記事バッファのモード行に現在の記事の
情報を表示します。Gnus が表示したい情報 (例えば、記事の表題) はしばしば
モード行よりも長いことがあるので、どこかで切り落とされなければなりません。
変数 @code{gnus-mode-non-string-length} はその行の他の要素 (すなわち、情
報でない部分) がどのくらいの長さであるかを指定します。もしモード行に追加
の要素を入れたなら、この変数を修正する必要があります:

@c Hook written by Francesco Potorti` <pot@cnuce.cnr.it>
@lisp
(add-hook 'display-time-hook
          (lambda () (setq gnus-mode-non-string-length
                           (+ 21
                              (if line-number-mode 5 0)
                              (if column-number-mode 4 0)
                              (length display-time-string)))))
@end lisp

もしこの変数が @code{nil} であるなら (これが初期値ですが)、モード行は切
り落とされず、詰め込みもされません。初期設定は、バッファの完全なパーセン
ト表示さえもモード行から追いやられる可能性もありますので、おそらく望まし
い設定ではないという事に注意して下さい。利用者が自分の設定に合うようにこ
の変数を適切に設定しなければなりません。


@node Highlighting and Menus
@section ハイライトとメニュー
@cindex visual
@cindex highlighting
@cindex menus

@vindex gnus-visual
変数 @code{gnus-visual} はたいていの gnus を素敵にする部分の操作をします。
@code{nil} であると、gnus はメニューを作ったり、素敵な色やフォントを使っ
たりしようとしません。これはファイル @file{gnus-vis.el} を読み込む事も禁
止します。

この変数は仕様可能な視覚的プロパティのリストである事ができます。以下の要
素は有効で、初期設定ですべて含まれています:

@table @code
@item group-highlight
グループバッファでハイライトをします。
@item summary-highlight
概略バッファでハイライトをします。
@item article-highlight
記事バッファでハイライトをします。
@item highlight
全てのバッファでハイライトをするようにします。
@item group-menu
グループバッファでメニューを作成します。
@item summary-menu
概略バッファでメニューを作成します。
@item article-menu
記事バッファでメニューを作成します。
@item browse-menu
ブラウズバッファでメニューを作成します。
@item server-menu
サーバーバッファでメニューを作成します。
@item score-menu
スコアバッファでメニューを作成します。
@item menu
全てのバッファでメニューを作成します。
@end table

ですから、記事バッファだけをハイライトしたく、全てのバッファでメニューを
作りたい場合は、このようにする事ができます:

@lisp
(setq gnus-visual '(article-highlight menu))
@end lisp

もしハイライトだけで、メニューの類は欲しくないときは、次のようにできます:

@lisp
(setq gnus-visual '(highlight))
@end lisp

@code{gnus-visual} が @code{t} であると、ハイライトとメニューは全ての 
gnus のバッファで使用されます。

他の全てのバッファの外見に影響する総合的な変数は:

@table @code
@item gnus-mouse-face
@vindex gnus-mouse-face
これは gnus でマウスのハイライトに使われるフェイス (すなわち、フォント) 
です。@code{gnus-visual} が @code{nil} であると、マウスハイライトはなさ
れません。

@end table

全く違ったメニューを作成するために関連するフックがあります:

@table @code

@item gnus-article-menu-hook
@vindex gnus-article-menu-hook
記事モード (article mode) メニューを作成した後に呼ばれるフックです。

@item gnus-group-menu-hook
@vindex gnus-group-menu-hook
グループモード (group mode) メニューを作成した後に呼ばれるフックです。

@item gnus-summary-menu-hook
@vindex gnus-summary-menu-hook
概略モード (summary mode) メニューを作成した後に呼ばれるフックです。

@item gnus-server-menu-hook
@vindex gnus-server-menu-hook
サーバーモード (server mode) メニューを作成した後に呼ばれるフックです。

@item gnus-browse-menu-hook
@vindex gnus-browse-menu-hook
概観モード (browse mode) メニューを作成した後に呼ばれるフックです。

@item gnus-score-menu-hook
@vindex gnus-score-menu-hook
スコアモード (score mode) メニューを作成した後に呼ばれるフックです。

@end table


@node Buttons
@section ボタン
@cindex buttons
@cindex mouse
@cindex click

最近では、最新流行のマウス @dfn{mouse} 装置が、ちゃんとした操作法を学び
たがらないナウなヤングの間で大人気です。それでは、私がTops 20 システム上
で Emacs を使っていた頃の '89 年の夏を思い起こしてみましょう。300 人の利
用者が、一つのマシン上で、みんなが Simula コンパイラを走らせていました。
ああ、ばかばかしい!

ほんとにそうだね。

@vindex gnus-carpal
まずですね、@code{gnus-carpal} を @code{t} に設定することによっ
て、クリックするだけで何でもできるボタンだらけのバッファを gnus
に表示させることができます。とっても簡単です、ほんとに。指圧療法
の先生に教えてあげて。(訳注: carpal とは手首の骨のこと)


@table @code

@item gnus-carpal-mode-hook
@vindex gnus-carpal-mode-hook
全ての手首モードバッファで実行するフック。

@item gnus-carpal-button-face
@vindex gnus-carpal-button-face
Face used on buttons.
ボタンに使われるフェイス。

@item gnus-carpal-header-face
@vindex gnus-carpal-header-face
手首バッファのヘッダーで使用されるフェイス。

@item gnus-carpal-group-buffer-buttons
@vindex gnus-carpal-group-buffer-buttons
グループバッファのボタン。

@item gnus-carpal-summary-buffer-buttons
@vindex gnus-carpal-summary-buffer-buttons
概略バッファのボタン。

@item gnus-carpal-server-buffer-buttons
@vindex gnus-carpal-server-buffer-buttons
サーバーバッファのボタン。

@item gnus-carpal-browse-buffer-buttons
@vindex gnus-carpal-browse-buffer-buttons
閲覧バッファのボタン。
@end table

全ての @code{buttons} 変数はリストです。このリストの要素は、
@code{car} が表示される文で @code{cdr} が関数シンボルの cons セ
ルか、もしくはただの文字列のどちらかです。


@node Daemons
@section デーモン
@cindex demons
@cindex daemons

Gnus、それは(言い伝えによれば)かつて書かれたいかなるプログラムよ
りも大きく、あなたがやって欲しいと思うさまざまな奇妙なことを、あ
なたのいないところで行ってくれるものです。例えば、あなたは時たま
新着メールをチェックしてもらいたくなるかも知れません。あるいは 
Emacs をしばらく放っておいたとき全てのサーバの接続を切断してもら
いたくなるかもしれません。他にも何かそういったことです。

Gnus はさまざまな制御子 @dfn{handlers} を定義することによってそ
のようなことを可能にします。各制御子は三つの要素から成ります。
@var{関数}、@var{時間}、@var{空転} パラメータです。

以下は Emacs が何もしない空転状態が三十分続いたときに接続を切断
する制御子の例です。

@lisp
(gnus-demon-close-connections nil 30)
@end lisp

以下は Emacs が何もしていないとき、一時間毎に PGP ヘッダーを走査
する制御子です。

@lisp
(gnus-demon-scan-pgp 60 t)
@end lisp

この @var{時間} パラメータとそして @var{空転} パラメータは、奇妙でかつ素
晴らしい方法で一緒に動作します。基本的には、@var{空転} が @code{nil} の
時にはこの関数は @var{時間} 分毎に呼び出されます。

もし @var{空転} が @code{t} であれば、この関数は Emacs が何もし
ていない時に限り、@var{時間} 分後に呼び出されます。一旦 Emacs が
ずっと空転状態になった後は、この関数は @var{時間} 分毎に呼び出さ
れます。

@var{空転} が数で @var{時間} も数である場合、この関数は、 Emacs 
の空転状態が @var{空転} 分続いた時に限り、@var{時間} 分毎に呼び
出されます。

@var{空転} が数で @var{時間} が @code{nil} の場合、この関数は、
Emacs の空転状態が @var{空転} 分続く度に一度呼び出されます。

そして @var{時間} が文字列の場合は、@samp{07:31} のような形式で
なければならず、この関数は毎日その頃の時間になると一度呼び出され
ます。もちろん、@var{空転} パラメータで動作が変わります。

@vindex gnus-demon-timestep
(ここで ``分'' と言ったとき、それは実際には
@code{gnus-demon-timestep} 秒のことです。これは初期設定では 60で
す。もしこの変数を変更すると、全ての制御子の計時に影響を与えます。)

@vindex gnus-use-demon
もっとも、これら全部を運転するように設定するには、
@code{gnus-use-demon} を @code{t} に設定しなきゃいけないんだけど
ね。

というわけで、制御子を追加したければ、 @file{.gnus} ファイルに、
以下のようなものを書くことができます。

@findex gnus-demon-add-handler
@lisp
(gnus-demon-add-handler 'gnus-demon-close-connections 30 t)
@end lisp

@findex gnus-demon-add-nocem
@findex gnus-demon-add-scanmail
@findex gnus-demon-add-rescan
@findex gnus-demon-add-scan-timestamps
@findex gnus-demon-add-disconnection
このための既製関数がいくつか作成されています。
@code{gnus-demon-add-nocem}、 
@code{gnus-demon-add-disconnection}、
@code{gnus-demon-add-nntp-close-connection}、
@code{gnus-demon-add-scan-timestamps}、 
@code{gnus-demon-add-rescan}、@code{gnus-demon-add-scanmail} で
す。これらの能力が欲しければ、単にこれらの関数を @file{.gnus} に
入れてください。

@findex gnus-demon-init
@findex gnus-demon-cancel
@vindex gnus-demon-handlers
もし @code{gnus-demon-handlers} で制御子を直接追加した場合には、
それを効かせるために @code{gnus-demon-init} を実行してください。
全てのデーモンを取り消すには、@code{gnus-demon-cancel} 関数を使
うことができます。

デーモンの追加は、やりすぎるのはとってもお行儀のよくないことです。
全てのサーバーから全てのニュースとメールを二秒毎に調べまわす関数
を付け加えちゃったりすると、どんな立派なシステムでも間違いなくお
払い箱にしてしまいます。そう動くんだもん。


@node NoCeM
@section NoCeM
@cindex nocem
@cindex spam

スパム @dfn{Spam} とは、同じ記事を何回も何回も何回も投稿すること
です。スパムは悪いことです。スパムは凶悪です。

スパムは通常一日かそこらで、さまざまな反スパム機関から取り消しさ
れます。これらの機関は通常一緒に、@dfn{NoCeM} メッセージも送信し
ます。@dfn{NoCeM} は ``no see-'em'' (彼らを見たくない)と発音され、
意味はその名前の通りです --- このメッセージは、罪を犯している記
事を、つまり、消してしまいます。

どうせその記事が取り消しされてしまうのなら、これら NoCeM メッセー
ジは何に使われるのでしょう? あるサイトでは取り消しメッセージを引
き受けず、あるサイトでは特定の数人からの取り消しメッセージのみし
か引き受けません。それで、あなたは NoCeM メッセージを使いたくな
るかもしれないわけです。これらは @samp{alt.nocem.misc} ニュース
グループで配布されています。

Gnus はこのグループのメッセージを自動的に読み、解釈することがで
き、これでスパムを消し去ります。

もちろん、これらをカスタマイズするための変数がいくつかあります。

@table @code
@item gnus-use-nocem
@vindex gnus-use-nocem
この変数を @code{t} に設定することで活動を開始させます。初期設定
では @code{nil} です。

@item gnus-nocem-groups
@vindex gnus-nocem-groups
Gnus はこのグループリストから NoCeM メッセージを探します。初期設
定値は @code{("news.lists.filters" "news.admin.net-abuse.bulletins"
"alt.nocem.misc" "news.admin.net-abuse.announce")} です。

@item gnus-nocem-issuers
@vindex gnus-nocem-issuers
NoCeM メッセージを発行する人はたくさんいます。このリストでは、誰
の言うことに従いたいかを指定します。初期設定値は @code{("Automoose-1"
"rbraver@@ohww.norman.ok.us" "clewis@@ferret.ocunix.on.ca"
"jem@@xpat.com" "snowhare@@xmission.com" "red@@redpoll.mrfs.oh.us
(Richard E. Depew)")} です。彼らはみんな、立派で高潔な市民です。

このリストに含められる有名な反スパム家は以下です。

@table @samp
@item clewis@@ferret.ocunix.on.ca;
@cindex Chris Lewis
Chris Lewis --- 主要なカナダの反スパム家。おそらく誰よりも多く、
ネットニュースの濫用を取り消しています。

@item Automoose-1
@cindex CancelMoose[tm]
自動運転の CancelMoose[tm]。 CancelMoose[tm] はノルウェー人とさ
れ、NoCeM を発明した人でした。

@item jem@@xpat.com;
@cindex Jem
John Milburn --- 韓国の反スパム家。最近はかなり忙しくなってきて
いるようです。

@item red@@redpoll.mrfs.oh.us (Richard E. Depew)
Richard E. Depew --- アメリカの単独反スパム家。主に非バイナリグ
ループへのバイナリ投稿の取り消しと、spew (逆流記事) を削除してい
ます。
@end table

これら全ての人々の NoCeM メッセージに留意する必要はありません --- 言うこ
とを聞きたい人だけでいいんです。またその人からの NoCeMメッセージ全てを受
け入れる必要もありません。NoCeM メッセージにはそれぞれ種別 @dfn{type} ヘッ
ダーがついており、これはそのメッセージの厳密な定義を与えています(多少は
厳密な、程度ね。たいていは少だけど)。良く使われる種別には、@samp{spam}、 
@samp{spew}、 @samp{mmf}、@samp{binary}、@samp{troll} があります。これを
指定するには、リストの中で @var{(発行者 条件 ...)} 要素を使う必要があり
ます。各条件は文字列 (使いたい種別にマッチする正規表現) か、または 
@code{(not 文字列)} という形式のリストです。この場合は @var{文字列} は使
いたくない種別にマッチする正規表現です。

例えば、Chris Lewis からの NoCeM メッセージで、@samp{troll} メッ
セージ以外の全てを欲しい場合には、

@lisp
("clewis@@ferret.ocunix.on.ca" ".*" (not "troll"))
@end lisp

一方、彼の @samp{spam} と @samp{spew} メッセージ以外は何もしたく
なければ、以下のようにできます。

@lisp
("clewis@@ferret.ocunix.on.ca" (not ".*") "spew" "spam")
@end lisp

この指定は左から右に適用されます。


@item gnus-nocem-verifyer
@vindex gnus-nocem-verifyer
@findex mc-verify
これは NoCeM 発行者が誰であるかと言っているかを証明する関数でな
くてはなりません。初期設定では @code{mc-verify} であり、これは
Mailcrypt 関数です。もしこれが非常に遅くて、あなたが証明結果を気
にしない (これはたぶん危険です) のであれば、この変数を
@code{nil} にすることができます。

もし署名済みの NoCeM メッセージを証明済み、未署名のメッセージを
未証明(でもそれを使う)としたいのなら、以下のようにすることができ
ます。

@lisp
(setq gnus-nocem-verifyer 'my-gnus-mc-verify)

(defun my-gnus-mc-verify ()
  (not (eq 'forged
           (ignore-errors
             (if (mc-verify)
                 t
               'forged)))))
@end lisp

まあ、これはたぶん危険でしょうけどね。

@item gnus-nocem-directory
@vindex gnus-nocem-directory
これは gnus が NoCeM キャッシュファイルを保存する場所です。初期
設定値は @file{~/News/NoCeM/} です。

@item gnus-nocem-expiry-wait
@vindex gnus-nocem-expiry-wait
古い NoCeM 項目をキャッシュから消すまでの日数。初期設定値は 15
です。これを短くするほど gnus は速くなりますが、古いスパムを見る
ことになってしまうかもしれません。

@end table

NoCeM を使うと、もしかするとメモリ喰いになるかもしれません。あな
たがたくさんの生きたグループ (つまり購読あるいは非購読グループ) 
を持っているのなら、Emacs プロセスは大きくなってしまうでしょう。
もしこれが問題であれば、非購読のグループを全部 (あるいはその多く
を) 消し去ってしまった方が良いです (@pxref{Subscription
Commands})。


@node Undo
@section やり直し
@cindex undo

実行したことのやり直しができると、とても便利です。普通の Emacs
バッファでは、これは十分簡単です --- 単に @code{undo} ボタンを押
すだけです。しかし gnus のバッファでは、これは簡単ではありません。

Gnus がバッファー内に表示しているものは、gnus にとっては全く何の
価値もありません --- これはみんな、利用者に奇麗に見えるようにデ
ザインされているただのデータなのです。@kbd{C-k} でグループバッファ
からグループを消去するのは、その行は消え去りますが、それは実際の
動作 --- 問題のグループを gnus の内部構造体から削除すること、の
単なる副作用でしかありません。これらのやり直しは、通常の Emacs
の @code{undo} 関数では行なうことができません。

Gnus は、利用者が何をするかを憶えておき、その利用者の動作の逆を
行なう動作を提供することによって、これを何とか救済しようとします。
そして利用者が @code{undo} キーを押したとき、gnus はその一つ手前
の動作あるいは動作群の逆のコードを実行します。しかし、全ての動作
が簡単に可逆であるわけではないので、gnus は現在、やり直し可能な
キー関数は僅かしか提供していません。これらは、グループの削除、グルー
プの貼り付け、グループの既読記事のリストの変更、それだけなんです。
将来はもっと関数が追加されるかもしれませんが、関数の追加はそれぞ
れ保存するべきデータを増やすことになるので、gnus は決して完全や
り直し可能にはならないでしょう。

@findex gnus-undo-mode
@vindex gnus-use-undo
@findex gnus-undo
やり直し機能は @code{gnus-undo-mode} マイナーモードによって提供
されます。これは @code{gnus-use-undo} が @code{nil} 以外であれば
使用され、これが初期設定です。@kbd{M-C-_} キーが
@code{gnus-undo} 命令を実行します。これは通常の Emacs の
@code{undo} 命令にちょっとだけ似ていると思われるでしょう。


@node Moderation
@section 司会役
@cindex moderation

もしあなたが司会者 (モデレーター) ならば、@file{gnus-mdrtn.el} 
パッケージを使うことができます。これは標準 gnus パッケージには含
まれません。@samp{larsi@@gnus.org} に、どのグループの司会を行な
うのかを述べたメールを書いてください。そうすればコピーを手に入れ
られます。

司会者用パッケージは概略バッファのマイナーモードとして実装されて
います。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-moderate)
@end lisp

をあなたの @file{.gnus.el} ファイルに入れてください。

あなたが @samp{rec.zoofle} の司会者だとすると、これは以下のよう
に動作するようになっています。

@enumerate
@item
@samp{Newsgroups:.*rec.zoofle} にマッチする受信メールを分離しま
す。これは投稿されようとしている記事を全てあるメールグループ --- 
例えば @samp{nnml:rec.zoofle} に入れます。

@item
あなたは時折このグループに入り、@kbd{e} (edit-and-post) あるいは
@kbd{s} (just send unedited) 命令を使って記事を投稿します。

@item
@samp{rec.zoofle} ニュースグループを読んでいる途中で、もしあなたが承認し
ていない記事をたまたま見つけたとしたら、@kbd{c} 命令で取り消しできます。
@end enumerate

二つのグループで司会者モードを使うとすれば、こうなります。

@lisp
(setq gnus-moderated-list
      "^nnml:rec.zoofle$\\|^rec.zoofle$")
@end lisp


@node XEmacs Enhancements
@section XEmacs 拡張
@cindex XEmacs

XEmacs は絵やその他のものを表示することができるので、gnus はこれ
を利用することにします。

@menu
* Picons::    あなたが読んでいるものの絵を表示する方法。
* Smileys::   表示されるべく生まれた幸せそうな顔を表示する方法。
* Toolbar::   クリック猿。
* XVarious::  その他の XEmacs で Gnus な変数。
@end menu


@node Picons
@subsection Picons

それで…、あなたはこのニュースリーダーをさらにもっと遅くしたいっ
てわけだね! これはそうするのにぴったりな方法です。さらにこれは、
あなたがニュースを読んでいるんだということを、あなたの肩越しに見
つめている人に印象づけるための素晴らしい方法でもあります。

@menu
* Picon Basics::           picon とは何で、どうやって手に入れるのか。
* Picon Requirements::     XEmacs を使ってなければここからは読まないで。
* Easy Picons::            picon の表示 --- 楽な方法。
* Hard Picons::            本来すべきこと。何かを学ぶことができるだろう。
* Picon Useless Configuration:: その他のぶっ壊したりひねったりいじったり遊んだりする変数。
@end menu


@node Picon Basics
@subsubsection Picon の基礎

Picon とはなんでしょう? Picons ウェブサイトから直接引用しましょう。

@quotation
@dfn{Picon} とは、``個人アイコン (personal icons)'' の略です。こ
れは、ネット上の利用者やドメインを表現するのに使われるための小さ
な画像で、データベースを持たせて、ある電子メールアドレスがあった
ら、それに適切な画像を見つけられるようにしておくものです。利用者
とドメイン以外にも、Usenet ニュースグループや天気予報のための
picon データベースがあります。picon は白黒の @code{XBM} 形式でも
カラーの @code{XPM} 形式でも @code{GIF} 形式でも構いません。
@end quotation

@vindex gnus-picons-piconsearch-url
あなたがインターネットへ常時接続しているのならば、
@code{gnus-picons-piconsearch-url} に文字列 @*
@file{http://www.cs.indiana.edu/picons/search.html} を設定するこ
とで、Steve Kinzler の picon 検索エンジンを使うことができます。

@vindex gnus-picons-database
そうでなければ、彼のデータベースを手元に複製する必要があります。picon デー
タベースの入手とインストールの手順は、ウェブブラウザーで @*
@file{http://www.cs.indiana.edu/picons/ftp/index.html} に行ってみてくだ
さい。Gnus は picons が @code{gnus-picons-database} で示される場所にイン
ストールしてあるものと期待します。


@node Picon Requirements
@subsubsection Picon の動作条件

Gnus に picon を表示させるには、XEmacs 19.13 かそれ以降を実行し
ていなければなりません。他の版の Emacs ではどれもまだ画像を表示
できないからです。

さらに、@code{x} サポート付きで XEmacs をコンパイルしていなくて
はなりません。白黒よりももっと奇麗な色付きの picon を表示するた
めには、@code{xpm} か @code{gif} どちらかを XEmacs と一緒にコン
パイルしている必要もあります。

@vindex gnus-picons-convert-x-face
@code{X-Face} ヘッダーの顔を表示したいのなら、XEmacs を
@code{xface} サポート付きでコンパイルしなければなりません。そう
でなければ、@code{netpbm} ユーティリティをインストールしておくか、
あるいは他の何かを使うように @code{gnus-picons-convert-x-face}
変数をいじくってください。


@node Easy Picons
@subsubsection 楽々 Picons

picon 表示を有効にするには、単に以下の行を @file{~/.gnus} ファイ
ルに入れて、gnus を起動してください。

@lisp
(setq gnus-use-picons t)
(add-hook 'gnus-article-display-hook 
          'gnus-article-display-picons t)
(add-hook 'gnus-article-display-hook 
          'gnus-picons-article-display-x-face)
@end lisp

@code{gnus-picons-database} が picon データベースが含まれている
ディレクトリを指していることを確認してください。

その代わりに Web 上の picon 検索エンジンを使いたければ、これを追
加します。

@lisp
(setq gnus-picons-piconsearch-url 
      "http://www.cs.indiana.edu:800/piconsearch")
@end lisp


@node Hard Picons
@subsubsection 難解 Picons

Gnus は、グループや記事に入ったり出たりするのに従って picon を表
示することができます。Gnus は picon データベースの三つの章とどう
相互作用すればよいかを知っています。すなわち、gnus はニュースグ
ループの絵、著者の顔の絵、著者のドメインの picon を表示すること
ができます。この機能を有効にするには、picon をどこから持ってくる
か、そしてどこに表示するかを選択する必要があります。

@table @code

@item gnus-picons-database
@vindex gnus-picons-database
picon データベースの場所。@file{news}、 @file{domains}、
@file{users} (などなど) のサブディレクトリーが含まれているディレ
クトリーを指していなければなりません。これは
@code{gnus-picons-piconsearch-url} が @code{nil} であるときのみ
使用されます。初期設定値は @file{/usr/local/faces/} です。

@item gnus-picons-piconsearch-url
@vindex gnus-picons-piconsearch-url
Web 上の picon 検索エンジンの URL。現在知られている唯一のエンジ
ンは @file{http://www.cs.indiana.edu:800/piconsearch} です。ネッ
トワーク遅延を回避するために icon はバックグラウンドで取得されま
す。もしこれが @code{nil} (初期設定値) であれば、picon は
@code{gnus-picons-database} で示されるローカルのデータベースから
取得されます。

@item gnus-picons-display-where
@vindex gnus-picons-display-where
picon 画像が表示される場所。これは初期設定では @code{picons} で
す (これは初期設定で @samp{*Picons*} バッファに位置します)。他の
有効な場所としては @code{article}、 @code{summary}、あるいは
@samp{*scratch*} だろうと知ったことではありません。ただそのバッ
ファを標準の gnus 窓配置処理 --- @pxref{Windows Configuration}に
よって見えるようにしておくことを確認してください。

@item gnus-picons-group-excluded-groups
@vindex gnus-picons-group-excluded-groups
この正規表現にマッチするグループではそのグループアイコンを表示さ
せません。

@end table

注意: もし @code{gnus-use-picons} を @code{t} に設定すると、窓配
置に @code{picons} バッファを含めるように設定されます。

さて、これらを決定した後には、これらの絵が正しい時に表示されるよ
うに、以下の関数を適切なフックに追加する必要があります。

@vindex gnus-article-display-hook
@vindex gnus-picons-display-where
@table @code
@item gnus-article-display-picons
@findex gnus-article-display-picons
著者と著者のドメインの picon を探し、
@code{gnus-picons-display-where} バッファに表示します。
@code{gnus-article-display-hook} に追加してください。

@item gnus-picons-article-display-x-face
@findex gnus-article-display-picons
X-Face ヘッダーがあればそれを復号化し表示します。この関数は
@code{gnus-article-display-hook} に追加してください。

@end table

注意: これらはフックに追加しなくてはならないので、
@code{add-hook} の追加フラグに 't' を指定するのを忘れないでください。

@lisp
(add-hook 'gnus-article-display-hook 'gnus-article-display-picons t)
@end lisp


@node Picon Useless Configuration
@subsubsection 無意味な Picon 設定

以下の変数は、さらにこれらをどう実行するか、どこに配置するか、そ
の他役にも立たないどうでもよいことを制御できるようにします。

@table @code

@item gnus-picons-news-directories
@vindex gnus-picons-news-directories
@code{gnus-picons-database} からニュースグループフェイスを探すた
めのサブディレクトリーのリスト。@code{("news")} が初期設定値です。

@item gnus-picons-user-directories
@vindex gnus-picons-user-directories
@code{gnus-picons-database} から利用者フェイスを探すためのサブディ
レクトリーのリスト。 @code{("local" "users" "usenix" "misc")} が
初期設定値です。

@item gnus-picons-domain-directories
@vindex gnus-picons-domain-directories
@code{gnus-picons-database} からドメイン名フェイスを探すためのサ
ブディレクトリーのリスト。初期設定値は @code{("domains")} です。
このリストに @samp{"unknown"} を追加しておきたくなる人もいるでしょ
う。

@item gnus-picons-convert-x-face
@vindex gnus-picons-convert-x-face
もし XEmacs に @code{xface} サポートが組み込まれていなければ、こ
の命令が @code{X-Face} ヘッダーを X ビットマップ (@code{xbm}) に
変換するのに使用されます。初期設定値は @code{(format "@{ echo '/* Width=48,
Height=48 */'; uncompface; @} | icontopbm | pbmtoxbm > %s"
gnus-picons-x-face-file-name)} です。

@item gnus-picons-x-face-file-name
@vindex gnus-picons-x-face-file-name
@code{X-Face} ビットマップを格納しておく一時ファイルの名前。初期
設定値は @code{(format "/tmp/picon-xface.%s.xbm"
(user-login-name))}。 

@item gnus-picons-has-modeline-p
@vindex gnus-picons-has-modeline-p
@code{gnus-picons-display-where} を @code{picons} に設定してしま
うと、XEmacs のフレームはめちゃめちゃになってしまうでしょう。こ
れを多少なりとも軽減するには、@code{gnus-picons-has-modeline-p} 
を @code{nil} に設定してください。これは picon バッファからモー
ド行を取り除きます。これは @code{gnus-picons-display-where} が
@code{picons} のときのみ意味があります。

@item gnus-picons-refresh-before-display
@vindex gnus-picons-refresh-before-display
nil 以外であれば、picon を計算する前に記事バッファを表示。
初期設定値は @code{nil} です。

@item gnus-picons-display-as-address
@vindex gnus-picons-display-as-address
@code{t} であれば絵と一緒に文字で電子メールアドレスを表示。
初期設定値は @code{t} です。

@item gnus-picons-file-suffixes
@vindex gnus-picons-file-suffixes
picon ファイル名として試してみる拡張子の順序リスト。初期設定値は 
@code{("xpm" "gif" "xbm")} から XEmacs に組み込まれていないもの
を引いたものです。

@item gnus-picons-display-article-move-p
@vindex gnus-picons-display-article-move-p
picon を表示しているときにカーソル位置を最初の空行まで動かすかど
うかを指定。これは @code{gnus-picons-display-where} の値が
@code{article} であるときのみ効果があります。

@item gnus-picons-clear-cache-on-shutdown
@vindex gnus-picons-clear-cache-on-shutdown
Gnus を終了するときに picon キャッシュを消し去るかどうか。Gnus
は実行中に見つけた picon を全てキャッシュします。これは検索処理
の時間を多少節約できますが、メモリをいくらか食います。もしこの変
数を @code{nil} に設定すれば、gnus はそのキャッシュを決して消し
ません。それを消し去るには手で @code{gnus-picons-clear-cache} を
呼び出す必要があります。@code{nil} でなければキャッシュは gnus
が終了するたびに消去されます。初期設定値は @code{t} です。

@end table

@node Smileys
@subsection スマイリー
@cindex smileys

スマイリー @dfn{smiley} は gnus とは別のパッケージですが、スマイ
リーを使っているパッケージは現在 gnus だけですので、ここで説明し
ます。

一言で言えば --- gnus でスマイリーを使うには、以下を
@file{.gnus.el} ふぁいるに書いてください。

@lisp
(add-hook 'gnus-article-display-hook 'gnus-smiley-display t)
@end lisp

スマイリーは、文字の顔マーク --- @samp{:-)}、@samp{:-=}、
@samp{:-(} などといったもの --- を絵に対応させ、文字の顔マークの
代わりにその絵を表示します。この変換は文字にマッチする正規表現と
それのファイル名への対応のリストで制御されます。

@vindex smiley-nosey-regexp-alist
@vindex smiley-deformed-regexp-alist
スマイリーは初期設定では二つの変換連想リストの例を提供しています。
@code{smiley-deformed-regexp-alist} (@samp{:)}、 @samp{:(} など
にマッチする) と、@code{smiley-nosey-regexp-alist} (@samp{:-)}、
@samp{:-(} などにマッチする) です。

使用される連想リストは @code{smiley-regexp-alist} 変数で指定され
ます。この初期設定値は @code{smiley-deformed-regexp-alist} です。

各要素の最初の項目はマッチさせたい正規表現で、二番目の要素は絵で
置き換えたいグループにマッチする正規表現、そして三番目の要素は表
示させたいファイルの名前です。

以下の変数は、スマイリーがこれらのファイルを探す場所、あるいはど
の色を使うかと、その他のものをカスタマイズします。

@table @code

@item smiley-data-directory
@vindex smiley-data-directory
スマイリーが顔ファイルを探す場所。

@item smiley-flesh-color
@vindex smiley-flesh-color
肌の色。初期設定値は、人種差別的だけど @samp{yellow} です。

@item smiley-features-color
@vindex smiley-features-color
フェイスの機能の色。初期設定値は @samp{black} です。

@item smiley-tongue-color
@vindex smiley-tongue-color
舌の色。初期設定値は @samp{red} です。

@item smiley-circle-color
@vindex smiley-circle-color
顔の周りの丸の色。初期設定値は @samp{black} です。

@item smiley-mouse-face
@vindex smiley-mouse-face
マウスで強調表示したときの顔。

@end table


@node Toolbar
@subsection ツールバー

@table @code

@item gnus-use-toolbar
@vindex gnus-use-toolbar
@code{nil} ならばツールバーを表示しない。@code{nil} 以外の場合は、
@code{default-toolbar}、@code{top-toolbar}、
@code{bottom-toolbar}、@code{right-toolbar}、@code{left-toolbar}
のどれかでなくてはなりません。

@item gnus-group-toolbar
@vindex gnus-group-toolbar
グループバッファ内のツールバー。

@item gnus-summary-toolbar
@vindex gnus-summary-toolbar
概略バッファ内のツールバー。

@item gnus-summary-mail-toolbar
@vindex gnus-summary-mail-toolbar
メールグループの概略バッファ内のツールバー。

@end table


@node XVarious
@subsection さまざまな XEmacs 変数

@table @code
@item gnus-xmas-glyph-directory
@vindex gnus-xmas-glyph-directory
これは gnus が絵を探す場所です。Gnus は通常このディレクトリを自
動検出しますが、もし標準的でないディレクトリー構造を持っている場
合は、これを手動で設定することができます。

@item gnus-xmas-logo-color-alist
@vindex gnus-xmas-logo-color-alist
これは連想リストで、キーは種別シンボル、値はタイトル頁絵文字の前
面色と背景色です。

@item gnus-xmas-logo-color-style
@vindex gnus-xmas-logo-color-style
これは前記の連想リストで色を検索するのに使われるキーです。有効な
値には @code{flame}、 @code{pine}、 @code{moss}、@code{irish}、 
@code{sky}、 @code{tin}、 @code{velvet}、 @code{grape}、
@code{labia}、 @code{berry}、 @code{neutral}、@code{september}
があります。


@item gnus-xmas-modeline-glyph
@vindex gnus-xmas-modeline-glyph
全ての gnus モード行で表示される絵文字。これは初期設定ではちいさ
なヌー (gnu) の頭です。

@end table




@node Fuzzy Matching
@section ファジーな一致
@cindex fuzzy matching

Gnus は、スコア付け、スレッドの形成、スレッド比較などを行うとき
に、@code{Subject} 行のファジーな一致 @dfn{fuzzy matching} 方法
を提供しています。

正規表現一致とは違って、ファジーな一致はとってもファジーです。あ
まりにもファジーすぎて、何がファジー @dfn{fuzziness} であるかと
いう定義さえありませんし、実装も何度も変更されています。

基本的には、これは比較の前に行から邪魔物を取り除こうとします。
@samp{Re: } や挿入句の印や空白文字等々は文字列から除去され、その
結果を比較します。これはほとんどの場合妥当な結果を出します --- 
たとえニュースリーダーの仮面をかぶった文字列切り刻み機で生成され
た文字列が差し出されても、です。


@node Thwarting Email Spam
@section spam メールの裏をかく
@cindex email spam
@cindex spam
@cindex UCE
@cindex unsolicited commercial email

ここ最近の USENET では、宣伝のハゲタカどもが、彼らの詐欺や製品を
押し付けるための電子メールアドレスを探そうとして、気違いのように
ニュース上をうろついて grep しまくっています。これに対する反動と
して、多くの人々が @code{From} 行に無意味なアドレスを入れはじめ
るようになってしまいました。これは非生産的なことだと私は思います
--- あなたが書いたことに対する返信として正当なメールを送ることを
面倒にさせ、また誰が書いたものなのかを分かりづらくします。こんな
書き換えは結局は、押し付け宣伝メールそれ自身よりも大きな脅威とな
るかもしれません。

私にとっての spam メールの最大の問題は、嘘の口実で入ってくるから
です。私が @kbd{g} を押したとすると、gnus は 10 通の新着メールが
ありますと陽気に私に教えてくれます。私は ``おおっ、わーい! 僕っ
て幸せ!'' と言ってメールグループを選択します。しかしそこには、二
つのネズミ講と、七つの広告 (`` 最新! 奇跡の増毛トニック、ふさふ
さでつやつやの髪を、あなたのつま先まで!'') と、悔い改め神を信じ
よ、という一つのメールがあるだけなのです。

これは不愉快です。

これに対処する方法は、gnus に全ての spam を @samp{spam} メールグ
ループに分離させてしまうことです (@pxref{Splitting Mail})。

最初に、あなたに到達性のある正しいメールアドレスを一つ選び、それ
を全てのあなたのニュース記事の @code{From} ヘッダーに入れます。
(ここでは @samp{larsi@@trym.ifi.uio.no} を選びましたが、
@samp{larsi+usenet@@ifi.uio.no} 形式のたくさんのアドレスの方が良
い選択です。あなたのサイトの sendmail の設定がメールアドレスのロー
カル部としてどんなキーワードを受け付けるかは、あなたのサイトのシ
ステム管理者に聞いてください。)

@lisp
(setq message-default-news-headers
      "From: Lars Magne Ingebrigtsen <larsi@@trym.ifi.uio.no>\n")
@end lisp

そして @code{nnmail-split-fancy} に以下の分離規則を入れます
(@pxref{Fancy Mail Splitting})。

@lisp
(
 ...
 (to "larsi@@trym.ifi.uio.no"
      (| ("subject" "re:.*" "misc")
         ("references" ".*@@.*" "misc")
         "spam"))
 ...
)
@end lisp

この意味は、このアドレスに届いた全てのメールをまず疑いますが、
@samp{Re:} で始まる @code{Subject} がついているか、
@code{References} ヘッダーがついていればおそらく OK だろう、とい
うことです。残りは全て @samp{spam} グループに行きます。(このアイ
デアはおそらく Tim Pierce 氏によるものです。)

これに加えて、多くのメール spam 屋は、あなたのところの
@code{smtp} サーバーと直接話し、@code{To} ヘッダーにあなたのメー
ルアドレスが明示されないようにします。なんでそんなことをするのか
はわかりませんが --- おそらく私たちの裏をかく機構の裏をかくため
かな? どちらにしても、対処は簡単なことです --- あなた宛てで
ないものを全部 @samp{spam} グループにいれるだけです。これはお好
み分離規則の最後にこんな風に入れることでできます。

@lisp
(
 ...
 (to "larsi" "misc")
 "spam")
@end lisp

私の経験では、これで事実上全てが正しいグループに分類されます。ま
あ、それでもときどき @samp{spam} グループをチェックして、正しい
メールがあるかチェックしなくてはいけませんけどね。もしあなたは自
分が良いネットワーク市民であると思っているなら、それぞれの押し付
け宣伝メールの関係当局に苦情を送り付けることさえもできます ---
暇なときにでもね。

また、あなたが怠け者のネットワーク市民でもあるなら、
@file{gnus-junk.el} パッケージによって自動的に苦情をいう方が良い
と思うかもしれません。これは @*
@file{<URL:http://stud2.tuwien.ac.at/~e9426626/gnus-junk.html>}
から「無料で」利用できます。ほとんどの spam メールは自動的に送ら
れているので、ちょっとだけ宇宙のバランスがとれるかもしれません。

これで私のところでは動いています。これでみんなは簡単な方法で私に
連絡を取ることができ (普通に @kbd{r} を押すだけでできる)、私は
spam に煩わされることは全くありません。得々状態です。私の意見と
しては、 @code{From} ヘッダーに偽造して存在しないドメインに送ら
せるのはキタナイです。


@node Various Various
@section いろいろのいろいろ
@cindex mode lines
@cindex highlights

@table @code

@item gnus-home-directory
全ての gnus のパス変数はこの変数によって初期化されます。その初期
設定値は @file{~/} です。

@item gnus-directory
@vindex gnus-directory
たくさんの gnus 格納パス変数はこの変数によって初期化されます。そ
の初期設定値は @samp{SAVEDIR} 環境変数の値か、その変数が設定され
ていない場合は @file{~/News/} です。

@file{.gnus.el} ファイルが読まれたときは gnus のほとんどはすでに
読み込まれているということに注意してください。これはつまり、この
変数を @file{.gnus.el} の中で設定しても、この変数によって初期化
される他のディレクトリー変数は正しく設定されないだろうということ
です。この変数は代わりに @file{.emacs} で設定してください。

@item gnus-default-directory
@vindex gnus-default-directory
上記の変数には全く関係ありません --- この変数は全ての gnus バッ
ファーのディフォルトディレクトリーをどうすべきかを設定します。も
し @kbd{C-x C-f} のような命令を実行すると、現在のバッファーのディ
フォルトディレクトリーを起点にしたプロンプトが出てくるでしょう。



この変数が @code{nil} (これが初期設定値) であれば、 gnus を起動
したときにあなたがいたバッファーのディフォルトディレクトリーがディ
フォルトディレクトリーになるでしょう。

@item gnus-verbose
@vindex gnus-verbose
この変数は 0 から 10 まで間の整数です。大きい数字ほどたくさんの
メッセージが表示されます。この変数が 0 であれば gnus は何のメッ
セージも見せません。これが 7 (初期設定値) であれば特に重要なメッ
セージが表示され、10 であれば gnus は決してお喋りを止めず、たく
さんのメッセージであなたにめまいを起こさせるでしょう。

@item gnus-verbose-backends
@vindex gnus-verbose-backends
この変数は @code{gnus-verbose} と同様に動作しますが、gnus 本体で
はなく gnus のバックエンドに対して適用されます。

@item nnheader-max-head-length
@vindex nnheader-max-head-length
バックエンドが記事のヘッダーをまっすぐ読んでいるときは、できる限
り少ない量だけを読もうと努力します。この変数 (初期設定値 4096)
は、バックエンドがヘッダーと本文の間の区切り行を見つけるまでに読
み込もうとする絶対最大長を指定します。この変数が @code{nil} であ
れば、読み込み上限はありません。もし @code{t} であれば、バックエ
ンドは記事を部分部分で読み込もうとはせず、記事全体を読み込みます。
これは @code{ange-ftp} や @code{efs} のあるバージョンで意味をも
ちます。

@item nnheader-head-chop-length
@vindex nnheader-head-chop-length
この変数 (初期設定値 2048) は、前記の操作を行っているときに、ど
れくらいの大きさの単位で各記事を読み込むかを設定します。

@item nnheader-file-name-translation-alist
@vindex nnheader-file-name-translation-alist
@cindex file names
@cindex invalid characters in file names
@cindex characters in file names
これはファイル名の文字をどのように変換するかを指定する連想リスト
です。例えば、もし @samp{:} があなたのシステムではファイル名の文
字としては使えない場合 (あなたは OS/2 ユーザです) 、以下のように
することができます。

@lisp
(setq nnheader-file-name-translation-alist
      '((?: . ?_)))
@end lisp

実際には、これは OS/2 と (くそ) MS Windows システム上でのこの変
数の初期設定値です。

@item gnus-hidden-properties
@vindex gnus-hidden-properties
これは ``不可視'' テキストを隠すために使われる属性のリストです。
ほとんどのシステムでは初期設定値は @code{(invisible t intangible
t)} で、これは不可視テキストを見えなくして触れなくします。

@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
ヘッダーを解釈する前に呼び出されるフック。これは例えば、取得した
ヘッダーの統計情報を取るとか、あるいはある種のヘッダーを取り除く
ことに使うことができます。まあ、私は何でこんなものが欲しいかよく
わかんないんだけどね。

@item gnus-shell-command-separator
@vindex gnus-shell-command-separator
二つのシェル命令を区切るのに使用される文字列。初期設定値は
@samp{;} です。


@end table



@node The End
@chapter 終わり

はい、以上がマニュアルです---あなたはもう自分自身の人生を送る事ができま
す。連絡をとって下さい。あなたの猫に今日は、といっておいて下さい。

おお、@strong{神よ}---さよならを耐える事はできません。(すすり泣き。)

Ol' Charles Reznikoff はそれを非常によく現していますので、ここは彼のため
に譲ります:

@quotation
@strong{Te Deum}

@sp 1
Not because of victories @*
I sing,@*
having none,@*
but for the common sunshine,@*
the breeze,@*
the largess of the spring.

@sp 1
Not for victory@*
but for the day's work done@*
as well as I was able;@*
not for a seat upon the dais@*
but at the common table.@*
@end quotation

試訳:

@quotation
@strong{Te Deum}

@sp 1
勝利したからではなく @*
私は歌う @*
何も無いけれど @*
あの日光や @*
息吹や @*
春の大きさのために @*

@sp 1
勝利のためではなく @*
一日の労働のために @*
また、それを達成できたことに @*
高座の上の席のためではなく @*
普通のテーブルのところで @*
@end quotation


@node Appendices
@chapter 付録

@menu
* History::                        どうやって gnus が今日のようになったか。
* Terminology::                    我々は本当に難しい、語のような語を使う。
* Customization::                  あなたの要求に沿って gnus を仕立てる。
* Troubleshooting::                上手く行かなかったときに試すかもしれない事。
* A Programmers Guide to Gnus::    色々な技術的なもの。
* Emacs for Heathens::             Emacs の用語の手短な導入。
* Frequently Asked Questions::     質問と答。
@end menu


@node History
@section 歴史

@cindex history
@sc{gnus} は 梅田 政信氏によって書かれました。94年の夏が忍び寄ってくるこ
ろ、Lars Magne Ingebrigtsen は飽きてきて、Gnus を書き直そうと決心しまし
た。

この無礼を行った人物を調べてみたいのなら、あなたの (くそ！) ウェブブラウ
ザーを @file{http://www.stud.ifi.uio.no/~larsi/} に向ける事ができます。
これは新しくて粋な版の gnus の第一配布場所で、Newsrc をぶっ壊して人々を
激怒されるサイトとして知られています。

最初のアルファ版の開発期間に、新しい Gnus は ``(ding) Gnus'' と呼ばれて
いました。@dfn{(ding)} はもちろん、@dfn{ding is not Gnus} の短縮形で、こ
れは全く完全な嘘ですが、だれがそんなことを気にするでしょうか？(ところで、
この短縮形の ``Gnus'' はおそらく梅田さんの意図通り ``ニュース'' と発音さ
れるべきで、そうするともっと適切な名前になります。そう思いませんか？)

どちらにせよ、全てのエネルギーを新しい元気の良い名前を付けるのに使い果た
した後、その名前は @emph{あまりに} 元気が良すぎるという事になり、それを 
``Gnus'' と再び命名しました。でも、今回は大文字と小文字を混ぜています。 
``Gnus'' と ``@sc{gnus}'' です。 新しいもの と 古いもの。

最初の ``適切な'' Gnus 5 のリリースは1995年11月に Emacs 19.30 の配布に含
まれたときになされました (132 の (ding) Gnus のリリース 足すことの 
Gnus5.0 の15リリース)。

1996年3月に次の世代の Gnus (別名 ``September Gnus'' (99リリースの後で)) 
が ''Gnus 5.2`` という名前でリリースされました (40リリース)。

1996年の7月28日に Red Gnus の作業が始まり、それは1997年1月25日に (84リリー
スの後で) ``Gnus 5.4'' としてリリースされました (67 リリース)。

1997年9月13日に、Quassia Gnus が開始され、37リリース続きました。それは 
``Gnus 5.6'' として1998年3月8日にリリースされました。

もし接頭辞を持った版の Gnus -- ``(ding) Gnus'', ``September Gnus'',
``Red Gnus'', ``Quassia Gnus'' -- に出会っても、混乱しないでください。あ
なたが恐がっている事を知られてはいけません。後ろに下がりなさい。ゆっくり
と。他に何をしても、走ってはいけません。それが届かくなるまで、静かに歩き
去りなさい。適切にリリースされた版の Gnus を見つけて、代わりにそれに寄り
添って下さい。

@menu
* Why?::                Gnus の目的は何？
* Compatibility::       Gnus は @sc{gnus} とどれくらい互換性があるの？
* Conformity::          Gnus は全ての標準を満たそうとする。
* Emacsen::             Gnus はいくつかの現代的な Emacs 環境で実行できる。
* Contributors::        大量の人々。
* New Features::        Gnus の新しい事に関する手がかり。
* Newest Features::     あまりにも新しいためにまだ書かれていないもの。
@end menu


@node Why?
@subsection なぜ？

Gnus の目的は何ですか？

私は、あなたの考え付く事を全てできる ``すばらしい'' ``かっこいい'' ``い
かす'' ``はやりの'' ニュースリーダを提供したいと思います。これは私の大元
の動機ですが、Gnus の作業をしている間に、この世代のニュースリーダーは本
当に石器時代に属しているという事が明らかになりました。ニュースリーダーは、
インターネットの幼児期からほとんど発展していませんでした。もし現在の増加
率で量が増加しつづければ、全ての現在のニュースリーダーは全く役に立たなく
なるでしょう。一日に1000やもっとたくさんの新しい記事のあるニュースグルー
プを扱うにはどうすれば良いのでしょう？ 投稿をする百万やそれより多い人々
に遅れないように付いていくにはどうすれば良いのでしょう？

Gnus はこれらの質問に本当の解決を提案しますが、私は Gnus がニュースを読
み、取得するための新しい方法を実験する場として使われて欲しいです。梅田さ
んのニュースリーダーをバックエンドから分離するという賢明な方針を拡張する
事によって、Gnus はメールを取得したり、違ったところからニュースを取得す
るための新しいバックエンドを書きたい人のために、簡単で単純なインターフェー
スを提供しています。私は、役に立つであろうという部分にすべて、カスタマイ
ズのためのフックを加えました。それをする事によって、探検し、発明したい全
ての人を招いているのです。

おそらく Gnus は完成する事はないのかもしれません。 @kbd{C-u 100 M-x
all-hail-emacs} と @kbd{C-u 100 M-x all-hail-xemacs} です。


@node Compatibility
@subsection 互換性

@cindex compatibility
Gnus は @sc{gnus} と完全に互換性があるように設計されています。ほとんど全
てのキーバインディングはそのまま残っています。もちろん、多くのキーバイン
ディングが追加されましたが、一つか二つのあいまいな場合を除いて、古いバイ
ンディングが変更された事はありません。

我々のモットーは:
@quotation
@cartouche
@center 鋼鉄の骨組みの空高く。
@end cartouche
@end quotation
です。

全ての命令はその名前が変わっていません。いくつかの内部関数は名前を変えま
した。

@code{gnus-uu} パッケージは劇的に変化しています。@xref{Decoding
Articles}.

一つの主要な互換性の質問は、いくつかの概略バッファが存在する事です。全て
のグループを読み込むときに関連する変数はそれが属する概略バッファのバッファ
固有です。多くの重要な変数はそれの全体の版にも複製されますが、概略バッファ
で命令が実行されると、この変更は、あなたが注意していないと、正しくない値
になるかも知れません。

@sc{gnus} の内部の知識に依存した全てのコードは実行できないでしょう。2つ
例を挙げます: @code{gnus-newsrc-alist} の並び替え (もしくは、実際は何ら
かの方法でそれを変更する事) は絶対に禁止されています。 Gnus はこの連想リ
ストの登録を指し示すハッシュテーブルを保持しており (それは多くの関数の速
度を上げます)、直接連想リストを変更する事は異常な結果をもたらすでしょう。

@cindex hilit19
@cindex highlighting
古い hilit19 のコードは全く動作しません。実際のところ、おそらく全ての 
hilit コードを全ての Gnus のフック (@code{gnus-group-prepare-hook} と 
@code{gnus-summary-prepare-hook}) から取り除くべきでしょう。Gnus はハイ
ライトのためのいろいろな統合された関数を提供します。これらはもっと速くもっ
と正確です。全ての人の人生を楽にするために、Gnus は初期設定で全ての 
hilit フックから全ての hilit 呼び出しを取り除きます。きたないもの！ とん
でけ！

@code{expire-kill} のようなパッケージはもう動作しません。実際、Gnus を使
い始めたときには、おそらく全ての古い @sc{gnus} パッケージ (と他のコード)
を消去するべきでしょう。@sc{gnus} に実行させるために書いたコードは、Gnus 
が既に実行しているという事は良くある事です。 (くすくす。)

物事を実行する古い方法はまだ使用できますが、新しい方法だけがこのマニュア
ルに記載されています。もしこのマニュアルを読んでいる間に何かをする新しい
方法を発見しても、古い方法を止めなければならないという事ではありません。

Gnus は全ての @sc{gnus} 起動ファイルを理解します。

@kindex M-x gnus-bug
@findex gnus-bug
@cindex reporting bugs
@cindex bugs
全体として、@sc{gnus} の内部に依存したコードをほとんど書いていない普通の
利用者は問題に苦しむ事はないでしょう。問題が起これば、魔法の命令 
@kbd{M-x gnus-bug} を実行する事によって私に知らせて下さい。

@vindex gnus-bug-create-help-buffer
@emph{非常に} よくバグ報告を送る癖があるのであれば、しばらくすると役に立
つ help バッファがうるさいと感じるかもしれません。そうであれば、それが表
示されるのを避けるために、@code{gnus-bug-create-help-buffer} を
@code{nil} に設定して下さい。


@node Conformity
@subsection 一致性

これは、理由無き反抗、じゃないですよ、奥さん。我々は全ての知られている標
準に沿っています。もちろん、我々が賛成できない標準と/もしくは習慣は除き
ますが。

@table @strong

@item RFC 822
@cindex RFC 822
この標準への知られている違反はありません。

@item RFC 1036
@cindex RFC 1036
この標準も知られている違反はありません。

@item Son-of RFC 1036
@cindex Son-of RFC 1036
これにはいくつかの違反があります。

@table @emph

@item MIME
Gnus は MIME の扱いをせず、この標準になるものは すごく良いと考えているの
で、我々はここに大きな穴が空いている事になります。

@item X-Newsreader
これは ``つまらないヘッダー'' と考えられていますが、私は消費者の情報であ
ると見なしています。@code{tin} と @code{Netscape} から送られてくる非常に
多くの様式に沿っていない記事を見た後で、私はそれらを記事を投稿するために
は使わない方が良いという事を知りました。もし @code{X-Newsreader} ヘッダー
が無ければ私はその情報を得る事はなかったでしょう。
@end table

@end table

上に書かれている文章に関する事で、Gnus がそれを満たしていないような動作
をしている事に気付いたら、ためらわずに Gnus タワーと我々に知らせて下さい。


@node Emacsen
@subsection Emacsen
@cindex Emacsen
@cindex XEmacs
@cindex Mule
@cindex Emacs

Gnus は以下のもので動作します:

@itemize @bullet

@item
Emacs 19.32 とそれ以降。

@item
XEmacs 19.14 とそれ以降。

@item
Emacs 19.32 とそれ以降に基づいた Mule。

@end itemize

Gnus はこれより古いどんな Emacsen でも完全に動作しないでしょう。少なくと
も、信頼できる動作はしないでしょう。

いろいろなプラットフォームの Gnus の間にはいくつかの漠然とした違いがあり
ます---XEmacs はもっと画像機能 (ロゴとツールバー) を特徴にしています--し
かし、その他は、全ての Emacsen でほとんど同じはずです。


@node Contributors
@subsection 貢献者
@cindex contributors

新しい Gnus の版は (ding) メーリングリストの全ての人の助けが無ければでき
なかったでしょう。一年以上、私は毎日とてもたくさんの素敵なバグレポートを
受け取り、そのそれぞれが私を喜びで満たしました。愛撫。このリストの人々は
忍耐を超えて私の ``あぁ、それはすばらしい考えだ <type type>、うん、私は
待たずにそれをすぐリリースしよう <ship off>、それは全く動作しない <type
type>、うん、私はすぐに出そう <ship off> いや、纏う、それは全く動作しな
いぞ''' というリリースに関する主義を変えて試してきた人々です。
Micro$oft---あぁ。アマチュア。私は @emph{もっと} 悪い。 (もしくは、``よ
り悪い''？ ``もっと悪い''？ ``最悪''？)

私はこの機会にこの学会に... おおっと、違った。

@itemize @bullet

@item
梅田 政信---元の @sc{gnus} を書いた人です。

@item
Per Abrahamsen--custom、スコア、ハイライトと @sc{soup} コード (他の多く
の事と共に)。

@item
Luis Fernandes---デザインとグラフィック。

@item
Erik Naggum---援助、考え、サポート、コードとその他。

@item
Wes Hardaker---@file{gnus-picon.el} と @dfn{picon} の部分のマニュアル 
(@pxref{Picons})。

@item
Kim-Minh Kaplan---picon コードに置ける更なる作業。

@item
Brad Miller---@file{gnus-gl.el} と Grouplens の部分のマニュアル 
(@pxref{GroupLens})。

@item
Sudish Joseph---数え切れないほどのバグの修正。

@item
Ilja Weis---@file{gnus-topic.el}。

@item
Steven L. Baur---たくさんのたくさんのたくさんのバグの発見と修正。

@item
Vladimir Alexiev---refcard とリファレンスの小冊子。

@item
Felix Lee & Jamie Zawinski---私は Felix Lee と JWZ の XGnus 配布からいく
つかの部分を盗みました。

@item
Scott Byer---@file{nnfolder.el} の拡張と改訂。

@item
Peter Mutsaers---古事記事のスコアコード。

@item
Ken Raebburn---POP メールサポート。

@item
Hallvard B Furuseth---いろいろな小さな物や部分、特に .newsrc ファイルを
扱う部分。

@item
Brian Edmonds---@file{gnus-bbdbb.el}。

@item
David Moore--@file{nnvirtual.el} の改訂と多くの他の事。

@item
Kevin Davidson---@dfn{ding} の名前を思い付きました。ですから、彼を責めて
下さい。

@item
Fran,Agois Pinard---多くの、多くの興味深く完全なバグレポートと autoconf の
サポート。

@end itemize

このマニュアル (Gnus 英語版) は Adrian Aichner と Ricardo Nassif、Mark
Borges によって校正され、Jost Krieger によって一部分を校正されました。

以下の人々は多くのパッチと提案で貢献しました:

Christopher Davis,
Andrew Eskilsson,
Kai Grossjohann,
David K,Aegedal,
Richard Pieri,
Fabrice Popineau,
Daniel Quinlan,
Jason L. Tibbitts, III,
and
Jack Vinson.

それと、以下の人にもパッチやその他のものを感謝します:

Jari Aalto,
Adrian Aichner,
Vladimir Alexiev,
Russ Allbery,
Peter Arius,
Matt Armstrong,
Marc Auslander,
Frank Bennett,
Robert Bihlmeyer,
Chris Bone,
Mark Borges,
Mark Boyns,
Lance A. Brown,
Kees de Bruin,
Martin Buchholz,
Joe Buehler,
Kevin Buhr,
Alastair Burt,
Joao Cachopo,
Zlatko Calusic,
Massimo Campostrini,
Castor,
David Charlap,
Dan Christensen,
Kevin Christian,
Michael R. Cook,
Glenn Coombs,
Frank D. Cringle,
Geoffrey T. Dairiki,
Andre Deparade,
Ulrik Dickow,
Dave Disser,
Rui-Tao Dong, @c ?
Joev Dubach,
Michael Welsh Duggan,
Dave Edmondson,
Paul Eggert,
Enami Tsugutomo, @c Enami
Michael Ernst,
Luc Van Eycken,
Sam Falkner,
Nelson Jose dos Santos Ferreira,
Sigbjorn Finne,
Decklin Foster,
Gary D. Foster,
Paul Franklin,
Guy Geens,
Arne Georg Gleditsch,
David S. Goldberg,
Michelangelo Grigni,
D. Hall,
Magnus Hammerin,
Kenichi Handa, @c Handa
Raja R. Harinath,
Yoshiki Hayashi, @c ?
P. E. Jareth Hein,
Hisashige Kenji, @c Hisashige
Marc Horowitz,
Gunnar Horrigmo,
Richard Hoskins,
Brad Howes,
Fran,Agois Felix Ingrand,
Ishikawa Ichiro, @c Ishikawa
Lee Iverson,
Iwamuro Motonori, @c Iwamuro
Rajappa Iyer,
Andreas Jaeger,
Randell Jesup,
Fred Johansen,
Gareth Jones,
Simon Josefsson,
Greg Klanderman,
Karl Kleinpaste,
Peter Skov Knudsen,
Shuhei Kobayashi, @c Kobayashi
Koseki Yoshinori, @c Koseki
Thor Kristoffersen,
Jens Lautenbacher,
Martin Larose,
Seokchan Lee, @c Lee
Carsten Leonhardt,
James LewisMoss,
Christian Limpach,
Markus Linnala,
Dave Love,
Mike McEwan,
Tonny Madsen,
Shlomo Mahlab,
Nat Makarevitch,
Istvan Marko,
David Martin,
Jason R. Mastaler,
Gordon Matzigkeit,
Timo Metzemakers,
Richard Mlynarik,
Lantz Moore,
Morioka Tomohiko, @c Morioka
Erik Toubro Nielsen,
Hrvoje Niksic,
Andy Norman,
Fred Oberhauser,
C. R. Oldham,
Alexandre Oliva,
Ken Olstad,
Masaharu Onishi, @c Onishi
Hideki Ono, @c Ono
William Perry,
Stephen Peters,
Jens-Ulrik Holger Petersen,
Ulrich Pfeifer,
Matt Pharr,
John McClary Prevost,
Bill Pringlemeir,
Mike Pullen,
Jim Radford,
Colin Rafferty,
Lasse Rasinen,
Lars Balker Rasmussen,
Joe Reiss,
Renaud Rioboo,
Roland B. Roberts,
Bart Robinson,
Christian von Roques,
Jason Rumney,
Wolfgang Rupprecht,
Jay Sachs,
Dewey M. Sasser,
Loren Schall,
Dan Schmidt,
Ralph Schleicher,
Philippe Schnoebelen,
Andreas Schwab,
Randal L. Schwartz,
Justin Sheehy,
Danny Siu,
Matt Simmons,
Paul D. Smith,
Jeff Sparkes,
Toby Speight,
Michael Sperber,
Darren Stalder,
Richard Stallman,
Greg Stark,
Sam Steingold,
Paul Stodghill,
Kurt Swanson,
Samuel Tardieu,
Teddy,
Chuck Thompson,
Philippe Troin,
James Troup,
Trung Tran-Duc,
Aaron M. Ucko,
Aki Vehtari,
Didier Verna,
Jan Vroonhof,
Stefan Waldherr,
Pete Ware,
Barry A. Warsaw,
Christoph Wedler,
Joe Wells,
Katsumi Yamaoka, @c Yamaoka
and
Shenghuo Zhu. @c Zhu

それぞれの人々が行った事の完全な概観を得るために、ChangeLog が Gnus のア
ルファ配布には含まれていて、豊富な読み物を与えるでしょう。(550KB といく
らか)。

私が忘れた全ての人に謝罪します。間違いなくたくさんの人を忘れている事でしょ
う。

わぁ、これはなんとも多い人のリストだなぁ。おそらく実際に Gnus 入るという
事に違いないでしょう。それに誰が感謝したでしょう！


@node New Features
@subsection 新しい機能
@cindex new features

@menu
* ding Gnus::          最初の新しい Gnus である Gnus 5.0/5.1 の新しい事。
* September Gnus::     公式に GNus 5.2/5.3 として知られているもの。
* Red Gnus::           3番目の最上のもの---Gnus 5.4/5.5
* Quassia Gnus::       2かける2は4、もしくは Gnus 5.6/5.7。
@end menu

このリストは、もちろん、@emph{たいていの} 重要な新しい機能に関する 
@emph{短い}概観でしかありません。いいえ、本当はそうではありません。もっ
ともっとたくさんのものがあります。はい、我々は創造性の完全な効果を感じて
いるのです。


@node ding Gnus
@subsubsection (ding) Gnus

Gnus 5.0/5.1 の新しい機能:

@itemize @bullet

@item
全てのバッファの外観はフォーマットのような変数 (@pxref{Group Buffer
Format} と @pxref{Summary Buffer Format}) によって設定を変える事ができる
ようになりました。

@item
ローカルスプールと、いくつかの @sc{nntp} サーバーを同時に使う事がでるよ
うになりました (@pxref{Select Methods})。

@item
グループを事実上のグループに結合できるようになりました (@pxref{Virtual
Groups})。

@item
多くの違ったメール様式 (@pxref{Getting Mail}) を読めるようになりました。
全てのメールバックエンドは便利なメール期限切れ消去機構を実装しています 
(@pxref{Expiring Mail})。

@item
Gnus は根っこ (root) を失ったスレッドを集めるためのいろいろな戦略 (それ
によってまばらな副スレッドを一つのスレッドにする) を使ったり、一旦戻って
完全なスレッドをくみ上げるのに十分なヘッダーを取得しする事ができます 
(@pxref{Customizing Threading})。

@item
切られたグループ (killed group) はぐループバッファに表示する事ができて、
それも読む事ができます (@pxref{Listing Groups})。

@item
Gnus は部分的グループ更新をする事ができます---2,3 のグループの新しい記事
を調べるためにアクティブファイル全体を取得する必要はありません 
(@pxref{The Active File})。

@item
Gnus はグループの段階的購読度を実装しました (@pxref{Group Levels})。

@item
任意の数の基準に従って記事にスコアを付ける事ができます (@pxref{Scoring})。
あなたのために記事をどのようにスコアを付けるかを Gnus に見つけさせる事も
できます (@pxref{Adaptive Scoring})。

@item
Gnus は普通の Emacs の方法で自動保存されるドリブルバッファを保持していま
すので、あなたのマシンが落っこちたときでもあまりデータを失わないでしょう 
(@pxref{Auto Save})。

@item
Gnus は今やファイル @file{.emacs} をぐちゃぐちゃにする事を避けるために専
用の起動ファイル (@file{.gnus}) を持つようになりました。

@item
グループと記事の両方にプロセス印を付けることができ、全ての印の付いた項目
に演算をする事ができます (@pxref{Process/Prefix})。

@item
グループの一部を grep して、その結果からグループを作る事ができます 
(@pxref{Kibozed Groups})。

@item
えーと、全てにしたがって、グループの一覧を挙げる事ができます 
(@pxref{Listing Groups})。

@item
外部サーバーを概観して、それらのサーバーのグループを購読する事ができます 
(@pxref{Browse Foreign Server})。

@item
Gnus はサーバーとの2つ接続で、記事を非同期にとってくる事ができます 
(@pxref{Asynchronous Fetching})。

@item
記事をローカルにキャッシュする事ができます (@pxref{Article Caching})。

@item
uudecode の関数が拡張され、一般化されました (@pxref{Decoding Articles})。

@item
過去の @sc{gnus} のあまり知られていない機能の uuencode された記事をまだ
投稿する事ができます (@pxref{Uuencoding and Posting})。

@item
親記事 (と他の記事) の取得は今や、実際に突然故障する事無く動作するように
なりました (@pxref{Finding the Parent})。

@item
Gnus は FAQ とグループの記述を取得する事ができます (@pxref{Group
Information})。

@item
記事をハイライトし、カスタマイズする事ができます (@pxref{Customizing
Articles})。

@item
URL と他の外部参照がボタンになるようになりました (@pxref{Article
Buttons})。

@item
Gnus のウィンドウとフレームの設定でたくさんの変な事をできるようになりま
した (@pxref{Windows Configuration})。

@item
キーボードを使う代わりに、ボタンをクリックできるようになりました 
(@pxref{Buttons})。

@end itemize


@node September Gnus
@subsubsection September Gnus

Gnus 5.2/5.3 の新しい機能:

@itemize @bullet

@item
新しいメッセージ作成モードが使われます。@code{mail-mode}、
@code{rnews-reply-mode} と @code{gnus-msg} の全ての古いカスタマイズ変数
は今や旧式になりました。

@item
Gnus は @dfn{まばら} スレッドを作成する事ができるようになりました---スレッ
ドの失われた記事があるところは空の節で表現されるようになっています 
(@pxref{Customizing Threading})。

@lisp
(setq gnus-build-sparse-threads 'some)
@end lisp

@item
外に出ていく記事は特別な保管サーバーに保存されるようになりました 
(@pxref{Archived Messages})。

@item
記事が参照されたときに、スレッドの部分作成が起こるようになりました。

@item
Gnus は GroupLens の予言を使う事ができるようになりました 
(@pxref{GroupLens})。

@item
Picons (personal icons) (個人アイコン) が XEmacs で表示できるようになり
ました (@pxref{Picons})。

@item
@code{trn} のような木バッファが表示されるようになりました (@pxref{Tree
Display})。

@lisp
(setq gnus-use-trees t)
@end lisp

@item
@code{nn} のような取って読むマイナーモードが概略バッファで使う事ができる
ようになりました (@pxref{Pick and Read})。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@item
バイナリーグループで特別なバイナリーマイナーモードを使う事ができるように
なりました (@pxref{Binary Groups})。

@item
Group が折り畳みトピック階層にグループ分けできるようになりました 
(@pxref{Group Topics})。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@item
Gnus が失敗メールを再送できるようになりました (@pxref{Summary Mail
Commands})。

@item
グループがスコアを持つ事ができるようになり、訪れる回数に基づいて並び替えを
できるようになりました (@pxref{Group Score})。

@lisp
(add-hook 'gnus-summary-exit-hook 'gnus-summary-bubble-group)
@end lisp

@item
グループにプロセス印を付けられるようになり、グループのぐループに命令が実行
できるようになりました (@pxref{Marking Groups})。

@item
事実上のグループでキャッシュができるようになりました。

@item
@code{nndoc} は全ての集配配送、メールボックス、rnews ニュース一括、
ClariNet 短収集、そして全てのその他を理解できるようになりました 
(@pxref{Document Groups})。

@item
Gnus は SOUP パケットを作成/読み込みをするための新しいバックエンド 
(@code{nnsoup}) を持っています。

@item
Gnus キャッシュがずっと速くなりました。

@item
グループを多くの基準に従って並び替えできるようになりました 
(@pxref{Sorting Groups})。

@item
アドレスのリストと期限切れ消去の時間を設定する新しいグループパラメータが
導入されました (@pxref{Group Parameters})。

@item
全てのフォーマット指定が使われるフェイスを指定できるようになりました 
(@pxref{Formatting Fonts})。

@item
@kbd{M P} 副マップにプロセス印の付いた記事の設定/削除/実行のためのいくつ
かの命令があります (@pxref{Setting Process Marks})。

@item
広い範囲の基準に基づいて、概略バッファが可能な記事の部分の表示に制限でき
るようになりました。これらの命令は @kbd{/} 副マップのキーにバインドされ
ています (@pxref{Limiting})。

@item
@kbd{*} 命令によって、記事を永続にする事ができるようになりました 
(@pxref{Persistent Articles})。

@item
記事の要素を隠す全ての関数は切り替え関数になりました。

@item
記事のヘッダーがボタンにする事ができるようになりました (@pxref{Article
Washing})。

@lisp
(add-hook 'gnus-article-display-hook
          'gnus-article-add-buttons-to-head)
@end lisp

@item
全てのメールバックエンドで @code{Message-ID} による記事の取得を使用でき
るようになりました。

@item
重複メールを適切に扱う事ができるようになりました (@pxref{Duplicates})。

@item
全ての概略モード命令が記事バッファから直接使用できるようになりました 
(@pxref{Article Keymap})。

@item
フレームが @code{gnus-buffer-configuration} の部分になる事ができます 
(@pxref{Windows Configuration})。

@item
デーモンのプロセスでメールを再走査することができるようになりました 
(@pxref{Daemons})。

@item
Gnus はスパムを根絶やしにするために NoCeM ファイルを使う事ができるように
なりました (@pxref{NoCeM})。

@lisp
(setq gnus-use-nocem t)
@end lisp

@item
グループを永久可視にする事ができるようになりました (@pxref{Listing
Groups})。

@lisp
(setq gnus-permanently-visible-groups "^nnml:")
@end lisp

@item
カスタマイズを簡単にするために多くの新しいフックが導入されました。

@item
Gnus は @code{Mail-Copies-To} ヘッダーに注意を払うようになりました。

@item
@code{References} ヘッダーを集める事によりスレッドを集める事ができるよう
になりました (@pxref{Customizing Threading})。

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp

@item
既読記事は再取得を避けるために特別なバックログバッファに貯められるように
なりました (@pxref{Article Backlog})。

@lisp
(setq gnus-keep-backlog 50)
@end lisp

@item
簡単な扱いのために、現在の記事のきれいな複製がいつも別バッファに蓄積され
るようになりました。

@item
Gnus がどこに記事を保存するかを提案できるようになりました (@pxref{Saving
Articles})。

@item
Gnus は保存するときに同じくらいの促進をしなくても良いようになりました 
(@pxref{Saving Articles})。

@lisp
(setq gnus-prompt-before-saving t)
@end lisp

@item
@code{uu} は記事を取得している間に非同期で復号化されたファイルを閲覧でき
るようになりました (@pxref{Other Decode Variables})。

@lisp
(setq gnus-uu-grabbed-file-functions 'gnus-uu-grab-view)
@end lisp

@item
引用された文章に対して、記事バッファでの折り返しが適切に動作するようにな
りました (@pxref{Article Washing})。

@item
隠された引用文は隠す事を切り替えるボタンを加え、どのくらいの引用文を隠す
かをカスタマイズできるようになりました (@pxref{Article Hiding})。

@lisp
(setq gnus-cited-lines-visible 2)
@end lisp

@item
退屈なヘッダーを隠す事ができます (@pxref{Article Hiding})。

@lisp
(add-hook 'gnus-article-display-hook
          'gnus-article-hide-boring-headers t)
@end lisp

@item
スコアの初期値がメニューバーから設定できるようになりました。

@item
出て行く記事の更なる構文チェックができるようになりました。

@end itemize


@node Red Gnus
@subsubsection Red Gnus

Gnus 5.4/5.5 の新しい機能:

@itemize @bullet

@item
@file{nntp.el} は非同期の流儀で完全に改訂されました。

@item
スコア付けは @code{and}、@code{or}、@code{not} のような論理演算子と、親
の再方向で実行できるようになりました (@pxref{Advanced Scoring})。

@item
記事の洗濯状態が記事モード行に表示されるようになりました (@pxref{Misc
Article})。

@item
@file{gnus.el} が多くの小さいファイルに分割されました。

@item
Message-ID に基づいた、重複記事の抑制がなされるようになりました 
(@pxref{Duplicate Suppression})。

@lisp
(setq gnus-suppress-duplicates t)
@end lisp

@item
どのスコアと適応ファイルがホームのスコアと適応ファイルであるかを指定する 
(@pxref{Home Score File}) 新しい変数が加えられました。

@item
@code{nndoc} が簡単に拡張可能になるように改訂されました (@pxref{Document
Server Internals})。

@item
グループは親のトピックからグループパラメータを継承できるようになりました 
(@pxref{Topic Parameters})。

@item
記事編集が改訂され、実際に使用可能になりました。

@item
署名がもっと知的な方法で認識されるようになりました (@pxref{Article
Signature})。

@item
概略ピックモードがもっと @code{nn} のようになりました。行数が表示されて、
命令 @kbd{.} が記事を取るために使う事ができるようになりました 
(@code{Pick and Read})。

@item
あるサーバーから別のサーバーへ @file{.newsrc.eld} を移動する命令が加えら
れました (@pxref{Changing Servers})。

@item
今や、バッファの行を作成するときに、抑制される ``おもしろくない'' 部分を
指定する方法があります (@pxref{Advanced Formatting})。

@item
グループバッファでのいくつかの命令は @kbd{M-C-_} で元に戻す事ができるよ
うになりました (@pxref{Undo})。

@item
新しいスコアの型 @code{w} を使う事で、語にスコア付けをする事が可能になり
ました (@pxref{Score File Format})。

@item
表題に1語1語を基にして適応スコアをできるようになりました 
(@pxref{Adaptive Scoring})。

@lisp
(setq gnus-use-adaptive-scoring '(word))
@end lisp

@item
スコアが腐敗できるようになりました (@pxref{Score Decays})。

@lisp
(setq gnus-decay-scores t)
@end lisp

@item
日付のヘッダーに正規表現を使ってスコア付けを実行できるようになりました。
日付はまず短縮 ISO 8601 様式で正規化されます (@pxref{Score File Format})。

@item
基本サーバーの記事に関する全てのデータを取り除く命令が加えられました 
(@pxref{Changing Servers})。

@item
文書の集合を読むための新しい命令 (@code{nndoc} と @code{nnvirtual} の上
で) が加えられました---@kbd{M-C-d} (@pxref{Really Various Summary
Commands})。

@item
プロセス印の設定が push と pop できるようになりました (@pxref{Setting
Process Marks})。

@item
新しいメールからニュースへのバックエンドが NNTP サーバーが投稿を許可して
いない場合でも、投稿できるようになりました (@pxref{Mail-To-News
Gateways})。

@item
ウェブ検索エンジン (@dfn{DejaNews}、@dfn{Alta Vista}、@dfn{InReference}) 
からの検索結果を読む新しいバックエンドが加えられました (@pxref{Web
Searches})。

@item
標準の並び替え関数を使ってグループの中のトピックを並び代えする事ができ、
それぞれのトピックが独立して並び替えできるようになりました (@pxref{Topic
Sorting})。

@item
グループの一部分が独立して並び替えできるようになりました 
(@code{Sorting})。

@item
キャッシュされた記事がグループに入れられるようになりました 
(@pxref{Summary Generation Commands})。

@item
スコアファイルがもっと信頼できる順番で適用できるようになりました 
(@pxref{Score Variables})。

@item
メールメッセージがどこに行くかの報告を作成する事ができるようになりました 
(@pxref{Splitting Mail})。

@item
入って来たメールを保存する前にがらくたを取り除くフックと関数がもっと追加
されました (@pxref{Washing Mail})。

@item
強調文が適切にフォントが変更されるようになりました:

@lisp
(add-hook 'gnus-article-display-hook 
          'gnus-article-emphasize)
@end lisp

@end itemize


@node Quassia Gnus
@subsubsection Quassia Gnus

Gnus 5.6 の新しい機能:

@itemize @bullet

@item
Gnus をオフラインニュースリーダーとして使う新機能が加えられました。過剰
なほどの新しい命令とモードが追加されました。完全な話に付いては 
@pxref{Gnus Unplugged} を見て下さい。

@item
@code{nndraft} バックエンドが戻ってきましたが、依然とは違うように動作す
るようになりました。全てのメッセージバッファは @code{nndraft} グループの
記事でもあり、それは自動的に作成されます。

@item
@code{gnus-alter-header-function} がヘッダーの値を変えるために使われるよ
うになりました。

@item
@code{gnus-summary-goto-article} が Message-ID を受け付けるようになりま
した。

@item
リージョンの外のメッセージの本文の文章を消去するための新しいメッセージ命
令があります: @kbd{C-c C-v}。

@item
@kbd{C-u C-c C-c} によって @code{nnvirtual} グループを生成しているグルー
プに投稿できるようになりました。

@item
@code{nntp-rlogin-program}---カスタマイズを簡単にするための新しい変数で
す。

@item
@code{gnus-article-edit-mode} の @code{C-u C-c C-c} は記事バッファの再ハ
イライトを禁止するようになりました。

@item
@code{gnus-boring-article-headers} に新しい要素があります---
@code{long-to}。

@item
@kbd{M-i} シンボル接頭引数命令があります。詳細は "Symbolic Prefixes" の
部分を見て下さい。

@item
概略バッファの @kbd{L} と @kbd{I} はファイル "all.SCORE" にスコア法則を
加えるためにシンボル接頭引数 @kbd{a} を受け付けるようになりました。

@item
変数 @code{gnus-simplify-subject-functions} により単純化をもっと制御でき
るようになりました。

@item
@kbd{A T}---現在のスレッドを取得するための新しい命令です。

@item
@kbd{/ T}---現在のスレッドを制限に含めるための新しい命令です。

@item
@kbd{M-RET} は引用文を止めるための新しいメッセージ命令です。

@item
@samp{\\1} 表現が @code{nnmail-split-methods} で有効になりました。

@item
関数 @code{custom-face-lookup} が取り除かれました。あなたの初期化ファイ
ルでこの関数を使っているのなら、代わりに @code{face-spec-set} を使うよう
に書き直さなければなりません。

@item
投稿取り消しは現在の選択方法を使うようになりました。シンボル接頭辞 
@kbd{a} は普通の投稿方法を強制します。

@item
M******** sm*rtq**t*s を適切な文章に翻案する新しい命令があります---
@kbd{W d}。

@item
@code{nntp} のより簡単なデバッグのために、@code{nntp-record-commands} を 
@code{nil} でない値に設定する事ができます。

@item
@code{nntp} は @file{~/.authinfo} を使うようになり、これは @file{.netrc} 
のようなファイルで、どこでどのように @sc{authinfo} を @sc{nntp} サーバー
に送るかを制御するためのものです。

@item
概略バッファのグループパラメータを編集するための命令が加えられました。

@item
メールがどこに分割されたかの履歴を使用可能になりました。

@item
新しい記事日付命令が加えられました---@code{article-date-iso8601}。

@item
@code{gnus-score-thread-simplify} を設定する事によりスレッドを作成してい
るときは表題が単純化されるようになりました。

@item
メッセージで引用をするための新しい関数が加えられました---
@code{message-cite-original-without-signature}。

@item
@code{article-strip-all-blank-lines}---新しい記事命令です。

@item
記事の終わりまでを切る新しいメッセージ命令が加えられました。

@item
変数 @code{gnus-adaptive-word-minimum} を使う事により最小限適応スコアを
指定する事ができます。

@item
命令 @code{gnus-start-date-timer} により ``過失日付'' 記事ヘッダーが継続
的に更新されるようになりました。

@item
ウェブ listserv アーカイブが @code{nnlistserv} バックエンドにより読む事
ができるようになりました。

@item
古い dejanews アーカイブが @code{nnweb} から読む事ができるようになりまし
た。

@end itemize



@node Newest Features
@subsection 最新の機能
@cindex todo

@dfn{todo list} としても知られています。次の千年祭までには確実に実装され
るでしょう。

恐れて下さい。非常に恐れて下さい。

(この一覧に現われている機能は必ずしも私がそれを実際に実装しようと決めた
というわけではありません。それは私がおもしろそうだな、と思ったというだけ
です。)

(はい、これは実際の、最優先からその次への todo list です。)

@itemize @bullet

@item
Native @sc{mime} support is something that should be done.

@item
Really do unbinhexing.

@item
 I would like the zombie-page to contain an URL to the source of the
latest version of gnus or some explanation on where to find it.

@item
 A way to continue editing the latest Message composition.

@item
 http://www.sonicnet.com/feature/ari3/

@item
 facep is not declared.

@item
 Include a section in the manual on why the number of articles
isn't the same in the group buffer and on the SPC prompt.

@item
 Interacting with rmail fcc isn't easy.

@item
@example
 Hypermail:
<URL:http://www.falch.no/people/pepper/DSSSL-Lite/archives/>
<URL:http://www.eit.com/software/hypermail/hypermail.html>
<URL:http://homer.ncm.com/>
<URL:http://www.yahoo.com/Computers_and_Internet/Internet/World_Wide_Web/HTML_Converters/>
http://www.uwsg.indiana.edu/hypermail/linux/kernel/9610/index.html
<URL:http://union.ncsa.uiuc.edu/HyperNews/get/www/html/converters.html>
http://www.miranova.com/gnus-list/

@end example

@item
@samp{^-- } is made into - in LaTeX.

@item
 gnus-kill is much slower than it was in GNUS 4.1.3.

@item
 when expunging articles on low score, the sparse nodes keep hanging on?
@item
 starting the first time seems to hang Gnus on some systems.  Does
NEWGROUPS answer too fast?
@item
 nndir doesn't read gzipped files.
@item
 FAQ doesn't have an up node?
@item
 when moving mail from a procmail spool to the crash-box,
the crash-box is only appropriate to one specific group.
@item
 `t' `t' makes X-Faces disappear.
@item
 nnmh-be-safe means that crossposted articles will
be marked as unread.
@item
 Orphan score entries don't show on "V t" score trace
@item
 when clearing out data, the cache data should also be reset.
@item
 rewrite gnus-summary-limit-children to be non-recursive
to avoid exceeding lisp nesting on huge groups.
@item
 expunged articles are counted when computing scores.
@item
 implement gnus-batch-brew-soup
@item
 ticked articles aren't easy to read in pick mode -- `n' and
stuff just skips past them.  Read articles are the same.
@item
 topics that contain just groups with ticked
articles aren't displayed.
@item
 nndoc should always allocate unique Message-IDs.
@item
 If there are mail groups the first time you use Gnus, Gnus'll
make the mail groups killed.
@item
 no "no news is good news" when using topics.
@item
 when doing crosspost marking, the cache has to be consulted
and articles have to be removed.
@item
 nnweb should fetch complete articles when they are split into several
parts.
@item
 scoring on head immediate doesn't work.
@item
 finding short score file names takes forever.
@item
 canceling articles in foreign groups.
@item
 nntp-open-rlogin no longer works.
@item
 C-u C-x C-s (Summary) switches to the group buffer.
@item
 move nnmail-split-history out to the backends.
@item
 nnweb doesn't work properly.
@item
 using a virtual server name as `gnus-select-method' doesn't work?
@item
 when killing/yanking a group from one topic to another in a slave, the
master will yank it first to one topic and then add it to another.
Perhaps.

@item
 warn user about `=' redirection of a group in the active file?
@item
 really unbinhex binhex files.
@item
 take over the XEmacs menubar and offer a toggle between the XEmacs
bar and the Gnus bar.
@item
@example
 push active file and NOV file parsing down into C code.
`(canonize-message-id id)'
`(mail-parent-message-id references n)'
`(parse-news-nov-line &optional dependency-hashtb)'
`(parse-news-nov-region beg end &optional dependency-hashtb fullp)'
`(parse-news-active-region beg end hashtb)'

@end example

@item
 nnml .overview directory with splits.
@item
 asynchronous cache
@item
 postponed commands.
@item
 the selected article show have its Subject displayed in its summary line.
@item
 when entering groups, get the real number of unread articles from
the server?
@item
 sort after gathering threads -- make false roots have the
headers of the oldest orphan with a 0 article number?
@item
 nndoc groups should inherit the score files of their parents?  Also
inherit copy prompts and save files.
@item
 command to start up Gnus (if not running) and enter a mail mode buffer.
@item
 allow editing the group description from the group buffer
for backends that support that.
@item
gnus-hide,show-all-topics
@item
 groups and sub-topics should be allowed to mingle inside each topic,
and not just list all subtopics at the end.
@item
 a command to remove all read articles that are not needed to connect
threads -- `gnus-summary-limit-to-sparse-unread'?
@item
 a variable to turn off limiting/cutting of threads in the tree buffer.
@item
 a variable to limit how many files are uudecoded.
@item
 add zombie groups to a special "New Groups" topic.
@item
 server mode command: close/open all connections
@item
 put a file date in gnus-score-alist and check whether the file
has been changed before using it.
@item
 on exit from a digest group, go to the next article in the parent group.
@item
 hide (sub)threads with low score.
@item
 when expiring, remove all marks from expired articles.
@item
 gnus-summary-limit-to-body
@item
 a regexp alist that says what level groups are to be subscribed
on.  Eg. -- `(("nnml:" . 1))'.
@item
 easier interface to nnkiboze to create ephemeral groups that
contain groups that match a regexp.
@item
 allow newlines in <URL:> urls, but remove them before using
the URL.
@item
 If there is no From line, the mail backends should fudge one from the
"From " line.
@item
 fuzzy simplifying should strip all non-alpha-numerical info
from subject lines.
@item
 gnus-soup-brew-soup-with-high-scores.
@item
 nntp-ping-before-connect
@item
 command to check whether NOV is evil.  "list overview.fmt".
@item
 when entering a group, Gnus should look through the score
files very early for `local' atoms and set those local variables.
@item
 message annotations.
@item
 topics are always yanked before groups, and that's not good.
@item
 (set-extent-property extent 'help-echo "String to display in minibuf")
to display help in the minibuffer on buttons under XEmacs.
@item
 allow group line format spec to say how many articles there
are in the cache.
@item
 AUTHINFO GENERIC
@item
 support qmail maildir spools
@item
 `run-with-idle-timer' in gnus-demon.
@item
 stop using invisible text properties and start using overlays instead
@item
 C-c C-f C-e to add an Expires header.
@item
 go from one group to the next; everything is expunged; go to the
next group instead of going to the group buffer.
@item
 gnus-renumber-cache -- to renumber the cache using "low" numbers.
@item
 record topic changes in the dribble buffer.
@item
 `nnfolder-generate-active-file' should look at the folders it
finds and generate proper active ranges.
@item
 nneething-look-in-files-for-article-heads variable to control
whether nneething should sniff all files in the directories.
@item
 gnus-fetch-article -- start Gnus, enter group, display article
@item
 gnus-dont-move-articles-to-same-group variable when respooling.
@item
 when messages are crossposted between several auto-expirable groups,
articles aren't properly marked as expirable.
@item
 nneething should allow deletion/moving.
@item
 TAB on the last button should go to the first button.
@item
 if the car of an element in `mail-split-methods' is a function,
and the function returns non-nil, use that as the name of the group(s) to
save mail in.
@item
 command for listing all score files that have been applied.
@item
 a command in the article buffer to return to `summary' config.
@item
 `gnus-always-post-using-current-server' -- variable to override
`C-c C-c' when posting.
@item
 nnmail-group-spool-alist -- says where each group should use
as a spool file.
@item
 when an article is crossposted to an auto-expirable group, the article
should be marker as expirable.
@item
 article mode command/menu for "send region as URL to browser".
@item
 on errors, jump to info nodes that explain the error.  For instance,
on invalid From headers, or on error messages from the nntp server.
@item
 when gathering threads, make the article that has no "Re: " the parent.
Also consult Date headers.
@item
 a token in splits to call shrink-window-if-larger-than-buffer
@item
 `1 0 A M' to do matches on the active hashtb.
@item
 duplicates -- command to remove Gnus-Warning header, use the read
Message-ID, delete the "original".
@item
 when replying to several messages at once, put the "other" message-ids
into a See-Also header.
@item
 support setext: URL:http://www.bsdi.com/setext/
@item
 support ProleText: <URL:http://proletext.clari.net/prole/proletext.html>
@item
 when browsing a foreign server, the groups that are already subscribed
should be listed as such and not as "K".
@item
 generate font names dynamically.
@item
 score file mode auto-alist.
@item
 allow nndoc to change/add/delete things from documents.  Implement
methods for each format for adding an article to the document.
@item
 `gnus-fetch-old-headers' `all' value to incorporate
absolutely all headers there is.
@item
 function like `|', but concatenate all marked articles
and pipe them to the process.
@item
 cache the list of killed (or active) groups in a separate file.  Update
the file whenever we read the active file or the list
of killed groups in the .eld file reaches a certain length.
@item
 function for starting to edit a file to put into
the current mail group.
@item
 score-find-trace should display the total score of the article.
@item
 "ghettozie" -- score on Xref header and nix it out after using it
to avoid marking as read in other groups it has been crossposted to.
@item
 look at procmail splitting.  The backends should create
the groups automatically if a spool file exists for that group.
@item
 function for backends to register themselves with Gnus.
@item
 when replying to several process-marked articles,
have all the From end up in Cc headers?  Variable to toggle.
@item
 command to delete a crossposted mail article from all
groups it has been mailed to.
@item
 `B c' and `B m' should be crosspost aware.
@item
 hide-pgp should also hide PGP public key blocks.
@item
 Command in the group buffer to respool process-marked groups.
@item
 `gnus-summary-find-matching' should accept
pseudo-"headers" like "body", "head" and "all"
@item
 When buttifying <URL: > things, all white space (including
newlines) should be ignored.
@item
 Process-marking all groups in a topic should process-mark
groups in subtopics as well.
@item
 Add non-native groups to the list of killed groups when killing them.
@item
 nntp-suggest-kewl-config to probe the nntp server and suggest
variable settings.
@item
 add edit and forward secondary marks.
@item
 nnml shouldn't visit its .overview files.
@item
 allow customizing sorting within gathered threads.
@item
 `B q' shouldn't select the current article.
@item
 nnmbox should support a newsgroups file for descriptions.
@item
 allow fetching mail from several pop servers.
@item
 Be able to specify whether the saving commands save the original
or the formatted article.
@item
 a command to reparent with the child process-marked (cf. `T ^'.).
@item
 I think the possibility to send a password with nntp-open-rlogin
should be a feature in Red Gnus.
@item
 The `Z n' command should be possible to execute from a mouse click.
@item
 more limiting functions -- date, etc.
@item
 be able to limit on a random header; on body; using reverse matches.
@item
 a group parameter (`absofucking-total-expiry') that will make Gnus expire
even unread articles.
@item
 a command to print the article buffer as postscript.
@item
 variable to disable password fetching when opening by nntp-open-telnet.
@item
 manual: more example servers -- nntp with rlogin, telnet
@item
 checking for bogus groups should clean topic alists as well.
@item
 canceling articles in foreign groups.
@item
 article number in folded topics isn't properly updated by
Xref handling.
@item
 Movement in the group buffer to the next unread group should go to the
next closed topic with unread messages if no group can be found.
@item
 Extensive info pages generated on the fly with help everywhere --
in the "*Gnus edit*" buffers, for instance.
@item
 Topic movement commands -- like thread movement.  Up, down, forward, next.
@item
 a way to tick/mark as read Gcc'd articles.
@item
 a way to say that all groups within a specific topic comes
from a particular server?  Hm.
@item
 `gnus-article-fill-if-long-lines' -- a function to fill
the article buffer if there are any looong lines there.
@item
 `T h' should jump to the parent topic and fold it.
@item
 a command to create an ephemeral nndoc group out of a file,
and then splitting it/moving it to some other group/backend.
@item
 a group parameter for nnkiboze groups that says that
all kibozed articles should be entered into the cache.
@item
 It should also probably be possible to delimit what
`gnus-jog-cache' does -- for instance, work on just some groups, or on
some levels, and entering just articles that have a score higher than
a certain number.
@item
 nnfolder should append to the folder instead of re-writing
the entire folder to disk when accepting new messages.
@item
 allow all backends to do the proper thing with .gz files.
@item
 a backend for reading collections of babyl files nnbabylfolder?
@item
 a command for making the native groups into foreign groups.
@item
 server mode command for clearing read marks from all groups
from a server.
@item
 when following up multiple articles, include all To, Cc, etc headers
from all articles.
@item
 a command for deciding what the total score of the current
thread is.  Also a way to highlight based on this.
@item
 command to show and edit group scores
@item
 a gnus-tree-minimize-horizontal to minimize tree buffers
horizontally.
@item
 command to generate nnml overview file for one group.
@item
 `C-u C-u a' -- prompt for many crossposted groups.
@item
 keep track of which mail groups have received new articles (in this session).
Be able to generate a report and perhaps do some marking in the group
buffer.
@item
 gnus-build-sparse-threads to a number -- build only sparse threads
that are of that length.
@item
 have nnmh respect mh's unseen sequence in .mh_profile.
@item
 cache the newsgroups descriptions locally.
@item
 asynchronous posting under nntp.
@item
 be able to control word adaptive scoring from the score files.
@item
 a variable to make `C-c C-c' post using the "current" select method.
@item
 `limit-exclude-low-scored-articles'.
@item
 if `gnus-summary-show-thread' is a number, hide threads that have
a score lower than this number.
@item
 split newsgroup subscription variable up into "order" and "method".
@item
 buttonize ange-ftp file names.
@item
 a command to make a duplicate copy of the current article
so that each copy can be edited separately.
@item
 nnweb should allow fetching from the local nntp server.
@item
 record the sorting done in the summary buffer so that
it can be repeated when limiting/regenerating the buffer.
@item
 nnml-generate-nov-databses should generate for
all nnml servers.
@item
 when the user does commands in the group buffer, check
the modification time of the .newsrc.eld file and use
ask-user-about-supersession-threat.  Also warn when trying
to save .newsrc.eld and it has changed.
@item
 M-g on a topic will display all groups with 0 articles in
the topic.
@item
 command to remove all topic stuff.
@item
 allow exploding incoming digests when reading incoming mail
and splitting the resulting digests.
@item
 nnsoup shouldn't set the `message-' variables.
@item
 command to nix out all nnoo state information.
@item
 nnmail-process-alist that calls functions if group names
matches an alist -- before saving.
@item
 use buffer-invisibility-spec everywhere for hiding text.
@item
 variable to activate each group before entering them
to get the (new) number of articles.  `gnus-activate-before-entering'.
@item
 command to fetch a Message-ID from any buffer, even
starting Gnus first if necessary.
@item
 when posting and checking whether a group exists or not, just
ask the nntp server instead of relying on the active hashtb.
@item
 buttonize the output of `C-c C-a' in an apropos-like way.
@item
 `G p' should understand process/prefix, and allow editing
of several groups at once.
@item
 command to create an ephemeral nnvirtual group that
matches some regexp(s).
@item
 nndoc should understand "Content-Type: message/rfc822" forwarded messages.
@item
 it should be possible to score "thread" on the From header.
@item
 hitting RET on a "gnus-uu-archive" pseudo article should unpack it.
@item
 `B i' should display the article at once in the summary buffer.
@item
 remove the "*" mark at once when unticking an article.
@item
 `M-s' should highlight the matching text.
@item
 when checking for duplicated mails, use Resent-Message-ID if present.
@item
 killing and yanking groups in topics should be better.  If killing one copy
of a group that exists in multiple topics, only that copy should
be removed.  Yanking should insert the copy, and yanking topics
should be possible to be interspersed with the other yankings.
@item
 command for enter a group just to read the cached articles.  A way to say
"ignore the nntp connection; just read from the cache."
@item
 `X u' should decode base64 articles.
@item
 a way to hide all "inner" cited text, leaving just the most
recently cited text.
@item
 nnvirtual should be asynchronous.
@item
 after editing an article, gnus-original-article-buffer should
be invalidated.
@item
 there should probably be a way to make Gnus not connect to the
server and just read the articles in the server
@item
 allow a `set-default' (or something) to change the default
value of nnoo variables.
@item
 a command to import group infos from a .newsrc.eld file.
@item
 groups from secondary servers have the entire select method
listed in each group info.
@item
 a command for just switching from the summary buffer to the group
buffer.
@item
 a way to specify that some incoming mail washing functions
should only be applied to some groups.
@item
 Message `C-f C-t' should ask the user whether to heed
mail-copies-to: never.
@item
 new group parameter -- `post-to-server' that says to post
using the current server.  Also a variable to do the same.
@item
 the slave dribble files should autosave to the slave file names.
@item
 a group parameter that says what articles to display on group entry, based
on article marks.
@item
 a way to visually distinguish slave Gnusae from masters.  (Whip instead
of normal logo?)
@item
 Use DJ Bernstein "From " quoting/dequoting, where applicable.
@item
 Why is hide-citation-maybe and hide-citation different?  Also
clear up info.
@item
 group user-defined meta-parameters.



From: John Griffith <griffith@@sfs.nphil.uni-tuebingen.de>
@item
 I like the option for trying to retrieve the FAQ for a group and I was
thinking it would be great if for those newsgroups that had archives
you could also try to read the archive for that group.  Part of the
problem is that archives are spread all over the net, unlike FAQs.
What would be best I suppose is to find the one closest to your site.

In any case, there is a list of general news group archives at @*
ftp://ftp.neosoft.com/pub/users/claird/news.lists/newsgroup_archives.html




@item
@example
From: Jason L Tibbitts III <tibbs@@hpc.uh.edu>
(add-hook 'gnus-select-group-hook
  (lambda ()
    (gnus-group-add-parameter group
       (cons 'gnus-group-date-last-entered (list (current-time-string))))))

(defun gnus-user-format-function-d (headers)
  "Return the date the group was last read."
  (cond ((car (gnus-group-get-parameter gnus-tmp-group 'gnus-group-date-last-entered)))
      (t "")))
@end example

@item
 tanken var at n,Aer du bruker `gnus-startup-file' som prefix (FOO) til ,Ae lete
opp en fil FOO-SERVER, FOO-SERVER.el, FOO-SERVER.eld, kan du la den v,Afre en
liste hvor du bruker hvert element i listen som FOO, istedet.  da kunne man
hatt forskjellige serveres startup-filer forskjellige steder.


@item
LMI> Well, nnbabyl could alter the group info to heed labels like
LMI> answered and read, I guess.

It could also keep them updated (the same for the Status: header of
unix mbox files).

They could be used like this:


@example
`M l <name> RET' add label <name> to current message.
`M u <name> RET' remove label <name> from current message.
`/ l <expr> RET' limit summary buffer according to <expr>.

<expr> would be a boolean expression on the labels, e.g.

`/ l bug & !fixed RET'
@end example

would show all the messages which are labeled `bug' but not labeled
`fixed'.

One could also imagine the labels being used for highlighting, or
affect the summary line format.


@item
Sender: abraham@@dina.kvl.dk

I'd like a gnus-find-file which work like find file, except that it
would recognize things that looks like messages or folders:

- If it is a directory containing numbered files, create an nndir
summary buffer.

- For other directories, create a nneething summary buffer.

- For files matching "\\`From ", create a nndoc/mbox summary.

- For files matching "\\`BABYL OPTIONS:", create a nndoc/baby summary.

- For files matching "\\`[^ \t\n]+:", create an *Article* buffer.

- For other files, just find them normally.

I'd like `nneething' to use this function, so it would work on a
directory potentially containing mboxes or babyl files.

@item
Please send a mail to bwarsaw@@cnri.reston.va.us (Barry A. Warsaw) and
tell him what you are doing.

@item
Currently, I get prompted:

decend into sci?
- type y
decend into sci.something ?
- type n
decend into ucd?

The problem above is that since there is really only one subsection of
science, shouldn't it prompt you for only descending sci.something?  If
there was a sci.somethingelse group or section, then it should prompt
for sci? first the sci.something? then sci.somethingelse?...

@item
Ja, det burde v,Afre en m,Aete ,Ae si slikt.  Kanskje en ny variabel?
`gnus-use-few-score-files'?  S,Ae kunne score-regler legges til den
"mest" lokale score-fila.  F. eks. ville no-gruppene betjenes av
"no.all.SCORE", osv.

@item
What i want is for Gnus to treat any sequence or combination of the following
as a single spoiler warning and hide it all, replacing it with a "Next Page"
button:


^L's

more than n blank lines

more than m identical lines
(which should be replaced with button to show them)

any whitespace surrounding any of the above


@item
Well, we could allow a new value to `gnus-thread-ignore-subject' --
`spaces', or something.  (We could even default to that.)  And then
subjects that differ in white space only could be considered the
"same" subject for threading purposes.

@item
Modes to preprocess the contents (e.g. jka-compr) use the second form
"(REGEXP FUNCTION NON-NIL)" while ordinary modes (e.g. tex) use the first
form "(REGEXP . FUNCTION)", so you could use it to distinguish between
those two types of modes. (auto-modes-alist, insert-file-contents-literally.)

@item
 Under XEmacs -- do funny article marks:
tick - thumb tack
killed - skull
soup - bowl of soup
score below - dim light bulb
score over - bright light bulb

@item
Yes. I think the algorithm is as follows:

@example
Group-mode

   show-list-of-articles-in-group
        if (key-pressed == SPACE)
                if (no-more-articles-in-group-to-select)
                        if (articles-selected)
                                start-reading-selected-articles;
                        junk-unread-articles;
                        next-group;
                 else
                        show-next-page;

         else if (key-pressed = '.')
                if (consolidated-menus)         # same as hide-thread in Gnus
                        select-thread-under-cursor;
                else
                        select-article-under-cursor;


Article-mode
        if (key-pressed == SPACE)
                if (more-pages-in-article)
                        next-page;
                else if (more-selected-articles-to-read)
                        next-article;
                else
                        next-group;
@end example

@item
My precise need here would have been to limit files to Incoming*.
One could think of some `nneething-only-files' variable, but I guess
it would have been unacceptable if one was using many unrelated such
nneething groups.

A more useful approach would be to, in response to the `G D' prompt, be
allowed to say something like: `~/.mail/Incoming*', somewhat limiting
the top-level directory only (in case directories would be matched by
the wildcard expression).

@item
It would be nice if it also handled

        <URL:news://sunsite.auc.dk/>

which should correspond to `B nntp RET sunsite.auc.dk' in *Group*.


@item

  Take a look at w3-menu.el in the Emacs-W3 distribution - this works out
really well.  Each menu is 'named' by a symbol that would be on a
gnus-*-menus (where * would be whatever, but at least group, summary, and
article versions) variable.

  So for gnus-summary-menus, I would set to '(sort mark dispose ...)

  A value of '1' would just put _all_ the menus in a single 'GNUS' menu in
the main menubar.  This approach works really well for Emacs-W3 and VM.


@item
 nndoc should take care to create unique Message-IDs for all its
articles.
@item
 gnus-score-followup-article only works when you have a summary buffer
active.  Make it work when posting from the group buffer as well.
(message-sent-hook).
@item
 rewrite gnus-demon to use run-with-idle-timers.

@item
 * Enhancements to Gnus:

  Add two commands:

  * gnus-servers (gnus-start-server-buffer?)--enters Gnus and goes
    straight to the server buffer, without opening any connections to
    servers first.

  * gnus-server-read-server-newsrc--produces a buffer very similar to
    the group buffer, but with only groups from that server listed;
    quitting this buffer returns to the server buffer.

@item
 add a command to check the integrity of an nnfolder folder --
go through the article numbers and see that there are no duplicates,
and stuff.

@item
 `unsmileyfy-buffer' to undo smileification.

@item
 a command to give all relevant info on an article, including all
secondary marks.

@item
 when doing `-request-accept-article', the backends should do
the nnmail duplicate checking.

@item
 allow `message-signature-file' to be a function to return the
value of the signature file.

@item
 In addition, I would love it if I could configure message-tab so that it
could call `bbdb-complete-name' in other headers.  So, some sort of
interface like

(setq message-tab-alist
      '((message-header-regexp message-expand-group)
        ("^\\(To\\|[cC]c\\|[bB]cc\\)"  bbdb-complete-name)))

then you could run the relevant function to complete the information in
the header

@item
 cache the newsgroups file locally to avoid reloading it all the time.

@item
 a command to import a buffer into a group.

@item
 nnweb should allow fetching by Message-ID from servers.

@item
 point in the article buffer doesn't always go to the
beginning of the buffer when selecting new articles.

@item
 a command to process mark all unread articles.

@item
 `gnus-gather-threads-by-references-and-subject' -- first
do gathering by references, and then go through the dummy roots and
do more gathering by subject.

@item
 gnus-uu-mark-in-numerical-order -- process mark articles in
article numerical order.

@item
 (gnus-thread-total-score
 (gnus-id-to-thread (mail-header-id (gnus-summary-article-header))))
bind to a key.

@item
 sorting by score is wrong when using sparse threads.

@item
 a command to fetch an arbitrary article -- without having to be
in the summary buffer.

@item
 a new nncvs backend.  Each group would show an article, using
version branches as threading, checkin date as the date, etc.

@item
 http://www.dejanews.com/forms/dnsetfilter_exp.html ?
This filter allows one to construct advance queries on the Dejanews
database such as specifying start and end dates, subject, author,
and/or newsgroup name.

@item
 new Date header scoring type -- older, newer

@item
 use the summary toolbar in the article buffer.

@item
 a command to fetch all articles that are less than X days old.

@item
 in pick mode, `q' should save the list of selected articles in the
group info.  The next time the group is selected, these articles
will automatically get the process mark.

@item
 Isn't it possible to (also?) allow M-^ to automatically try the
default server if it fails on the current server?  (controlled by a
user variable, (nil, t, 'ask)).

@item
 make it possible to cancel articles using the select method for the
current group.

@item
 `gnus-summary-select-article-on-entry' or something.  It'll default
to t and will select whatever article decided by `gnus-auto-select-first'.

@item
 a new variable to control which selection commands should be unselecting.
`first', `best', `next', `prev', `next-unread', `prev-unread' are
candidates.

@item
 be able to select groups that have no articles in them
to be able to post in them (using the current select method).

@item
 be able to post via DejaNews.

@item
 `x' should retain any sortings that have been performed.

@item
 allow the user to specify the precedence of the secondary marks.  Also
allow them to be displayed separately.

@item
 gnus-summary-save-in-pipe should concatenate the results from
the processes when doing a process marked pipe.

@item
 a new match type, like Followup, but which adds Thread matches on all
articles that match a certain From header.

@item
 a function that can be read from kill-emacs-query-functions to offer
saving living summary buffers.

@item
 a function for selecting a particular group which will contain
the articles listed in a list of article numbers/id's.

@item
 a battery of character translation functions to translate common
Mac, MS (etc) characters into ISO 8859-1.

@example
(defun article-fix-m$word ()
  "Fix M$Word smartquotes in an article."
  (interactive)
  (save-excursion
    (let ((buffer-read-only nil))
      (goto-char (point-min))
      (while (search-forward "\221" nil t)
        (replace-match "`" t t))
      (goto-char (point-min))
      (while (search-forward "\222" nil t)
        (replace-match "'" t t))
      (goto-char (point-min))
      (while (search-forward "\223" nil t)
        (replace-match "\"" t t))
      (goto-char (point-min))
      (while (search-forward "\224" nil t)
        (replace-match "\"" t t)))))
@end example

@item
@example
 (add-hook 'gnus-exit-query-functions
'(lambda ()
   (if (and (file-exists-p nnmail-spool-file)
            (> (nnheader-file-size nnmail-spool-file) 0))
       (yes-or-no-p "New mail has arrived.  Quit Gnus anyways? ")
       (y-or-n-p "Are you sure you want to quit Gnus? "))))
@end example

@item
 allow message-default-headers to be a function.

@item
 new Date score match types -- < > = (etc) that take floating point
numbers and match on the age of the article.

@item
@example
>  > > If so, I've got one gripe: It seems that when I fire up gnus 5.2.25
>  > > under xemacs-19.14, it's creating a new frame, but is erasing the
>  > > buffer in the frame that it was called from =:-O
>
>  > Hm.  How do you start up Gnus?  From the toolbar or with
>  > `M-x gnus-other-frame'?
>
>    I normally start it up from the toolbar; at
> least that's the way I've caught it doing the
> deed before.
@end example

@item
 all commands that react to the process mark should push
the current process mark set onto the stack.

@item
 gnus-article-hide-pgp
Selv ville jeg nok ha valgt ,Ae slette den dersom teksten matcher
@example
"\\(This\s+\\)?[^ ]+ has been automatically signed by"
@end example
og det er maks hundre tegn mellom match-end og ----linja.  Men -det-
er min type heuristikk og langt fra alles.

@item
 `gnus-subscribe-sorted' -- insert new groups where they would have been
sorted to if `gnus-group-sort-function' were run.

@item
 gnus-(group,summary)-highlight should respect any `face' text props set
on the lines.

@item
 use run-with-idle-timer for gnus-demon instead of the
home-brewed stuff for better reliability.

@item
 add a way to select which NoCeM type to apply -- spam, troll, etc.

@item
 nndraft-request-group should tally autosave files.

@item
 implement nntp-retry-on-break and nntp-command-timeout.

@item
 gnus-article-highlight-limit that says when not to highlight (long)
articles.

@item
 (nnoo-set SERVER VARIABLE VALUE)

@item
 nn*-spool-methods

@item
 interrupitng agent fetching of articles should save articles.

@item
 command to open a digest group, and copy all the articles there to the
current group.

@item
 a variable to disable article body highlights if there's more than
X characters in the body.

@item
 handle 480/381 authinfo requests separately.

@item
 include the texi/dir file in the distribution.

@item
 format spec to "tab" to a position.

@item
 Move all prompting to the new `M-n' default style.

@item
 command to display all dormant articles.

@item
 gnus-auto-select-next makeover -- list of things it should do.

@item
 a score match type that adds scores matching on From if From has replied
to something someone else has said.

@item
 Read Netscape discussion groups:
snews://secnews.netscape.com/netscape.communicator.unix

@item
One command to edit the original version if an article, and one to edit
the displayed version.

@item
@kbd{T v} -- make all process-marked articles the children of the
current article.

@item
Switch from initial text to the new default text mechanism.

@item
How about making it possible to expire local articles?  Will it be
possible to make various constraints on when an article can be
expired, e.g. (read), (age > 14 days), or the more interesting (read
& age > 14 days)?

@item
New limit command---limit to articles that have a certain string
in the head or body.

@item
Allow breaking lengthy NNTP commands.

@item
gnus-article-highlight-limit, to disable highlighting in big articles.

@item
Editing an article should put the article to be edited
in a special, unique buffer.

@item
A command to send a mail to the admin-address group param.

@item
A Date scoring type that will match if the article
is less than a certain number of days old.

@item
New spec: %~(tab 56) to put point on column 56

@item
Allow Gnus Agent scoring to use normal score files.

@item
Rething the Agent active file thing.  `M-g' doesn't update the active
file, for instance.

@item
With dummy roots, `^' and then selecing the first article
in any other dummy thread will make gnus highlight the
dummy root instead of the first article.

@item
Propagate all group properties (marks, article numbers, etc) up to the
topics for displaying.

@item
`n' in the group buffer with topics should go to the next group
with unread articles, even if that group is hidden in a topic.

@item
gnus-summary-limit-include-cached is slow when there are
many articles in the cache, since it regenerates big parts of the
summary buffer for each article.

@item
Implement gnus-batch-brew-soup.

@item
Group parameters and summary commands for un/subscribing to mailing
lists. 

@item
Introduce nnmail-home-directory.

@item
gnus-fetch-group and friends should exit Gnus when the user
exits the group.

@item
Solve the halting problem.

@c TODO
@end itemize

@iftex

@page
@node The Manual
@section マニュアル
@cindex colophon
@cindex manual

このマニュアルは TeXinfo ファイルから作成され、それから @code{texi2dvi}
を実行して、手元にあるもになりました。

以下の習慣が用いられました:

@enumerate
これは @kbd{キー打鍵} です。

@item
これは @file{ファイル} です。

@item
これは @code{シンボル} です。

@end enumerate

ですから、私が ``@code{flargnoze} を @samp{yes} に設定する'' と言ったと
きは、次のような意味です:

@lisp
(setq flargnoze "yes")
@end lisp

もし、私が ``@code{flargnoze} を @code{yes} に設定する'' と言ったときは、
次のような意味です:

@lisp
(setq flumphel 'yes)
@end lisp

@samp{yes} と @code{yes} は2つの @emph{全く} 違ったものです---絶対に混同
しないでください。


@end iftex


@page
@node Terminology
@section 用語

@cindex terminology
@table @dfn

@item ニュース (news)
@cindex news
これはあなたがそのためにこのものを使いたいと思っているものです---ニュー
スを読む事です。ニュースは一般的には近くの @sc{nntp} サーバーから取得さ
れ、普通は全ての人に広く利用可能なものです。もしニュースを投稿すれば、全
世界があなたがちょうど書いたものを読む可能性があり、それらは全ていたずらっ
ぽくクスクス笑われるでしょう。あなたの知らないところで。

@item メール (mail)
@cindex mail
あなたに個人的に配送されるもの全てがメールです。いくつかのニュース/メー
ルリーダー (gnus のような) はメールとニュースの違いをぼやけさせますが、
そこには違いは存在します。メールは私的です。ニュースは公的です。メールを
送信する事は投稿ではなく、返信はフォローアップではありません。

@item 返信 (reply)
@cindex reply
あなたが読んでいるものを書いた人にメールを送る事です。

@item フォローアップ (follow up)
@cindex follow up
あなたが読んでいる記事に応答して現在のニュースグループに記事を投稿する事
です。

@item バックエンド (backend)
@cindex backend
Gnus はニュースとメールの両方のいろいろなバックエンドが与えた記事を得ま
す。Gnus は、いわゆる下に横たわっているメディアを扱う事はしません---これ
はすべてバックエンドによってなされます。

@item 基本 (native)
@cindex native
Gnus はいつも一つの方法 (とバックエンド) をニュースを得るための @dfn{基
本}、もしくは初期設定 として使います。

@item 外部 (foreign)
@cindex foreign
同時に任意の数の外部グループを活動状態にすることもできます。これらはニュー
スを取得するための、基本でなく、2番目でもないバックエンドを使うグループ
です。

@item 二番目 (secondary)
@cindex secondary
2番目のバックエンドは、基本と外部の間くらいにあるバックエンドで、ほとん
ど基本と同じように動作するものです。

@item 記事 (article)
@cindex article
ニュースとして投稿されたメッセージです。

@item メールメッセージ (mail message)
@cindex mail message
メールで送られたメッセージです。

@item メッセージ
@cindex message
メールメッセージもしくはニュース記事です。

@item ヘッド (head)
メッセージの最上部で、認証情報 (等) が入れられているところです。

@item 本体 (body)
@cindex body
記事の残りの部分です。ヘッドでないものはすべて本体です。

@item ヘッダー (header)
@cindex header
記事のヘッドからの行です。

@item ヘッダー群 (headers)
@cindex headers
そのような行の集合もしくは、ヘッドの集合です。もしくは、@sc{nov} 行の集
合です。

@item @sc{nov}
@cindex nov
Gnus がグループに入ると、グループの全ての未読記事のヘッダーをバックエン
ドに求めます。ほとんどのサーバーは News OverView 様式が使用可能で、それ
は普通の @sc{head} 様式よりもっと手短でもっと速く読んで解析 (parse) する
ことができます。

@item レベル (level)
@cindex levels
それぞれのグループは何らかの @dfn{レベル} か他のもの (1-9) で購読されて
います。低いレベルのものは高いレベルのものより ``より'' 購読されています。
実際のところ、レベル 1-5 のグループは @dfn{購読}; 6-7 は @dfn{未購読}; 8 
は @dfn{ゾンビ}; 9 は @dfn{切られた} と見なされます。グループをリストした
り、新しいグループを走査したりする命令はすべて数値接頭引数を @dfn{動作レ
ベル} として使います。

@item 切られたグループ (killed groups)
@cindex killed groups
切られたグループの情報は蓄積されたり更新されたりしませんので、切られたグ
ループを購読されたグループより簡単に扱えるようになります。

@item ゾンビグループ (zombie groups)
@cindex zombie groups
ほとんど切られたグループと同じで、それより少し死んでいるだけです。

@item アクティブファイル (active file)
@cindex active file
ニュースサーバーはどの記事を運んでいるか、どのグループが存在するかを記録
しておかなければなりません。全てのこの情報は現状ファイルに蓄積され、それ
はあなたが想像するように比較的大きいです。

@item 偽グループ (bogus groups)
@cindex bogus groups
ファイル @file{.newsrc} に存在するグループですが、サーバーに知られていな
いグループ (すなわち、それはアクティブファイルにありません) は @emph{偽
グループ} です。これは、おそらく (すでに) そのグループは存在していないの
でしょう。

@item 活動化 (activating)
@cindex activating groups
サーバーにグループの情報を尋ね、未読記事の数を演算する行為は @dfn{グルー
プを活動化する} と呼ばれています。非活動グループはグループバッファに 
@samp{*} とともに一覧表示されます。

@item サーバー (server)
@cindex server
接続して、ニュース (もしくはメール) を取得する事のできるグループです。

@item 選択方法 (select method)
@cindex select method
バックエンド、サーバーと、事実上のサーバー設定を指定する構造です。

@item 事実上のサーバー (virtual server)
@cindex virtual server
命名された選択方法です。選択方法は (物理的) サーバーに接続するために必要
な方法を定義するため、物事を全体として受けるのは事実上のサーバーになりま
す。

@item 洗濯 (washing)
@cindex washing
バッファを持ってきて、何らかの種類の選別機にかける事です。結果は (多かれ
少なかれ) 元のものよりもよりきれいで喜ばしいものになるでしょう。

@item 一時グループ (ephemeral groups)
@cindex ephemeral groups
たいていのグループはどの記事を読んだかのデータを蓄積します。@dfn{一時} 
グループはデータが溜められないグループです---グループを出ると、それは天
空に消え去ります。

@item 固定グループ (solid groups)
@cindex solid groups
これは一時グループの反対です。グループバッファに挙げられている全てのグルー
プは固定グループです。

@item まばら記事 (sparse articles)
@cindex sparse articles
@code{gnus-build-sparse-threads} の機能を使用しているときは、概略バッファ
に記事の入れ場所が表示されます。

@item スレッド作り (threading)
@cindex threading
それが応答した記事の直後にその記事への応答を置くことです---階層的流儀で。

@item 根 (root)
@cindex root
@cindex thread root
スレッドの最初の記事が根です。それはスレッドの全ての記事の祖先です。

@item 親 (parent)
@cindex parent
応答のある記事です。

@item 子 (child)
@cindex child
違った記事---その親 に応答する記事です。

@item 集配 (digest)
@cindex digest
複数のメッセージを一つのファイルに集めたものです。もっとも普通の集配様式
は RFC1153 で指定されています。

@end table


@page
@node Customization
@section カスタマイズ
@cindex gerenal customization

全ての変数はこのマニュアルのどこか別のところで適切に説明されています。こ
の部分は非常に良くある状況でどのように gnus をカスタマイズすれば良いかの
総合適指示先を与えるために考案されています。

@menu
* Slow/Expensive Connection:: ローカルの Emacs を立ち上げて、
                              他のところからニュースを得る事ができる。
* Slow Terminal Connection::  遠隔 Emacs を実行する。
* Little Disk Space::         大きな起動ファイルを持つ事はまずい。
* Slow Machine::              速い機械を買おうと感じるであろう。
@end menu


@node Slow/Expensive Connection
@subsection 遅い/高い @sc{nntp} 接続

もし Emacs をローカルのマシンで実行していて、非常に細い線の向こうのマシ
ンからニュースを取得しているのであれば、gnus が @sc{nntp} サーバーから取
得するデータの総量を減らしたいと思うでしょう。

@table @code

@item gnus-read-activie-file
これを @code{nil} にして下さい。そうすれば、gnus にサーバーからアクティ
ブファイル全体を要求する事を禁止できます。このファイルはしばしば非常に大
きくなっています。それに加えて、gnus が突然とにかく現状ファイルを取得し
ようと決定しない事を確実にするために、@code{gnus-check-new-newsgroups} 
と @code{gnus-check-bogus-newsgroups} も @code{nil} に設定しなければなり
ません。

@item gnus-nov-is-evil
これも @code{nil} にしていなければなりません。もしそうでなければ、
@sc{nntp} サーバーから記事のヘッダーをつかんでくるのがあまり速くなりませ
ん。全ての @sc{nntp} サーバーが @sc{xover} の機能を提供しているわけでは
ありません。Gnus が自分自身でそれを検査します。
@end table


@node Slow Terminal Connection
@subsection 遅いターミナル接続。

あなたは、ホームコンピューターを Emacs と gnus を実行しているシステムに
ダイアルアップするために使っているとしましょう。もしあなたのモデムが遅け
れば、(可能な限り) 線を伝って送られているデータの総量を減らしたいと思う
でしょう。

@table @code

@item gnus-auto-center-summary
Gnus が常に概略バッファを中心再設定をすることを禁止するためにこれを 
@code{nil} に設定して下さい。これが @code{vertical} であると、垂直方向の 
(vertical) 中心再設定のみをします。@code{nil} でも @code{vertical} でも
無ければ、水平方向と垂直方向の両方の中心再設定を行います。

@item gnus-visible-headers
記事に含まれるヘッダーを最小限に減らします。実際のところ、全部なくしてし
まっても何とかなります---とにかく、たいていの役に立つデータは概略バッファ
にあります。この変数を @samp{^NEVVVVER} や @samp{From:} や、何でも好きな
ものに設定して下さい。

@item gnus-article-display-hook
このフックに全ての使用可能な隠匿命令を設定します:
@lisp
(setq gnus-article-display-hook
      '(gnus-article-hide-headers 
        gnus-article-hide-signature
        gnus-article-hide-citation))
@end lisp

@item gnus-use-full-window
これを @code{nil} に設定する事で、全てのウィンドウを小さくする事ができま
す。これは総じてそんなに減らしません。これは、記事をどっちにしろ読みたく
ないという事を決定する前に、少しの部分しか見る必要が無いという事です。

@item gnus-threada-hide-subtree
これが @code{nil} でなければ、全ての概略バッファのスレッドは初めに隠され
ます。

@item gnus-updated-mode-lines
これが @code{nil} であると、gnus はバッファのモード行に情報を入れません
ので、時間を節約できるでしょう。
@end table


@node Little Disk Space
@subsection 少しのディスク容量
@cindex disk space

起動ファイルは比較的大きくなりますので、空き容量が少なくなってきていると
きはその大きさを少し小さくしたいと思うでしょう。

@table @code

@item gnus-save-newsrc-file
これが @code{nil} であると、gnus は決して @file{.newsrc} を保存しません---
それは @file{.newsrc.eld} のみを保存します。これは、gnus の他のニュース
リーダーを使えないという事です。この変数は初期設定で @code{t} です。

@item gnus-save-killed-list
これが @code{nil} であると、gnus は死んだグループのリストを保存しません。
この変数を @code{nil} に設定したときは、@code{gnus-check-new-newsgroups} 
を @code{ask-server} に、@code{gnus-check-bogus-newsgroups} を 
@code{nil} に設定するべきでしょう。この変数は初期設定で @code{t} です。

@end table


@node Slow Machine
@subsection 遅い機械
@cindex slow machine

もし遅い機械を持っているか、もしくは単に本当に忍耐力がない時は、gnus の
実行を把握するためにできる事が少しあります。

起動を速くするために @code{gnus-check-new-newsgroups} と 
@code{gnus-check-bogus-newsgroups} を @code{nil} に設定して下さい。

概略バッファに入る事と抜ける事を速くするために、@code{gnus-show-threads} 
と @code{gnus-use-cross-reference} と @code{gnus-nov-is-evil} を 
@code{nil} に設定して下さい。

記事に関する実行を少し速くするために、@code{gnus-article-display-hook} 
を @code{nil} に設定して下さい。


@page
@node Troubleshooting
@section 問題解決
@cindex troubleshooting

Gnus は箱から出してすぐに @emph{非常に} よく動作します---何も問題の起こ
ることは想像できません、本当に。

オッホン。

@enumerate

@item
あなたのコンピュータのスイッチが入っている事を確かめて下さい。

@item
本当に現行の gnus 版を読み込んでいる事を確認して下さい。今まで @sc{gnus} 
を実行してきたのであれば、gnus が動作するように一度 Emacs を終了して再起
動する必要があります。

@item
@kbd{M-x gnus-version} を試して下さい。もし、
@samp{Semi-gnus 6.10 (based on Gnus 5.6.45; for SEMI 1.12, FLIM 1.12)}
のようなものが出てきたなら、正しいファイルが読み込まれています。
もし、@samp{NNTP 3.x} や @samp{nntp flee} のようなものが出てきたときは、
そこにあるいくつかの古い @file{.el} ファイルが読み込まれています。それら
を消して下さい。

@item
FAQ と how-to を読むためにヘルプグループ (グループバッファで @kbd{G h}) 
を読んで下さい。

@item
@vindex max-lisp-eval-depth
Gnus は多くの多くの再帰構造で動作し、何らかの極端な (そして非常にまれな) 
事例では、gnus は再帰を ``あまりに深く'' 降りすぎて、Emacs があなたにビー
プ音を鳴らす事があります。もしこれが起こったなら、
@code{max-lisp-eval-depth} を 500 かそれくらいの値に設定して下さい。
@end enumerate

もし他の全てが失敗したなら、バグとして問題を報告して下さい。

@cindex bugs
@cindex reporting bugs

@kindex M-x gnus-bug
@findex gnus-bug
もし gnus のバグを見つけたなら、命令 @kbd{M-x gnus-bug} によってそれを報
告する事ができます。@kbd{M-x set-variable RET debug-on-error RET t RET} 
として、それから私にバックトレースを送って下さい。私はバグを修正しようと
しますが、あなたがバグを再現させる方法を正確に書いてくれたときのみ、それ
を修正する事ができます。

バグ報告では、詳細すぎることは決してありません。バグ報告をするときは、そ
れが使うたびに 10Kb メールを作り、もしあなたの環境を以前私に 500 回送っ
てきたとしても、命令 @kbd{M-x gnus-bug} を使って下さい。

私は、記憶という種類のものは全く持っていない事を覚えておく事も重要です。
もしあなたがバグ報告を送ると、私が返答を送ります。そして、それからあなた
が ``いや、そうではない！ このばか者！'' とだけ送り返してくると、私はあ
なたが何に対して私を侮辱しているかがわかりません。常に、全てを説明しすぎ
て下さい。それは我々全てにとってもっと簡単になります---もし私が必要な全
ての情報を得られなかったら、私はあなたにメールを送ってさらなる情報を求め、
その結果全てがより多くの時間を取る事になります。

もしあなたの直面している問題が非常に視覚的で、それを上手く説明できない場
合は、Emacs のウィンドウをファイルにコピーして (例えば、@kbd{xwd} で)、
それをどこか手の届くどこかにおいて、その画像の URL をバグ報告に含めて下
さい。

もし援助が欲しいだけであれば、@samp{gnu.emacs.gnus} で尋ねるのが良いでしょ
う。私はあまり役に立ちません。

@cindex gnu.emacs.gnus
@cindex ding mailing list
また、ding メーリングリスト---@samp{ding@@gnus.org} に訊ねる事もでき
ます。購読するためには @samp{ding-request@@gnus.org} に書いて下さい。


@page
@node A Programmers Guide to Gnus
@section Gnus のプログラマーズガイド

私の願いは、他の誰かが gnus でできる何か賢いものを考え出し、その
上その賢いものを書いてくれるということです。これを容易にするため
には、gnus の内部動作を記述するのが良い方法だろうと私は思いまし
た。あと、そんなに内部じゃない動作をいくつかと、私が今やってるこ
とと。

プログラムの内部構造が変更されることはない、などと思ってはいけま
せんが、gnus とそのバックエンド間のインターフェース(これは完全に
記述されている)や、スコアファイルの形式(これも同様)、データ構造
(これは他より変更されやすいものもある)、操作用の一般メソッド、な
どを(細部にわたって)定義していきます。

@menu
* Gnus Utility Functions::   使用できる共通の関数と変数。
* Backend Interface::        Gnus はどうやってサーバーと通信するのか。
* Score File Syntax::        スコアファイル規格の BNF 定義。
* Headers::                  Gnus はヘッダーを内部的にどのように格納するか。
* Ranges::                   たくさんの数を格納する便利な形式。
* Group Info::               グループ情報形式。
* Extended Interactive::     記号接頭辞など。
* Emacs/XEmacs Code::        Gnus は全ての近代 Emacsen で動作する。
* Various File Formats::     Gnus の使用するファイルの形式。
@end menu


@node Gnus Utility Functions
@subsection Gnus の有用な関数
@cindex Gnus utility functions
@cindex utility functions
@cindex functions
@cindex internal variables

フックなどから実行される小さな関数を書くときは、gnus の内部関数
や変数にアクセスすることは絶対必要です。以下が最もよく使われるも
のの一覧です。

@table @code

@item gnus-newsgroup-name
@vindex gnus-newsgroup-name
この変数は現在のニュースグループの名前を保持しています。

@item gnus-find-method-for-group
@findex gnus-find-method-for-group
@var{group} の選択方法を返す関数です。

@item gnus-group-real-name
@findex gnus-group-real-name
正規の (接頭辞付きの) gnus グループ名を受け取り、接頭辞無しの名前
を返します。

@item gnus-group-prefixed-name
@findex gnus-group-prefixed-name
接頭辞無しのグループ名と選択方法を受け取り、正規の (接頭辞付きの)
gnus グループ名を返します。

@item gnus-get-info
@findex gnus-get-info
@var{group} のグループ情報一覧を返します。

@item gnus-group-unread
@findex gnus-group-unread
@var{group} の未読記事の数か、もしくはそれが分からない場合は @code{t} で
す。

@item gnus-active
@findex gnus-active
@var{group} の活動登録です。

@item gnus-set-active
@findex gnus-set-active
@var{group} に活動登録を設定します。

@item gnus-add-current-to-buffer-list
@findex gnus-add-current-to-buffer-list
Gnus 終了時に消去するバッファの一覧に現在のバッファを追加します。

@item gnus-continuum-version
@findex gnus-continuum-version
引数として gnus のバージョン文字列を受け取り、浮動小数点数を返し
ます。古いバージョンは必ず新しいバージョンよりも小さい数になりま
す。

@item gnus-group-read-only-p
@findex gnus-group-read-only-p
@var{group} が読み出し専用であるかどうかを示します。

@item gnus-news-group-p
@findex gnus-news-group-p
@var{group} がニュースバックエンドであるかどうかを示します。

@item gnus-ephemeral-group-p
@findex gnus-ephemeral-group-p
@var{group} が短期グループであるかどうかを示します。

@item gnus-server-to-method
@findex gnus-server-to-method
@var{server} に対応している選択方法を返します。

@item gnus-server-equal
@findex gnus-server-equal
二つの仮想サーバーが同一のものであるかどうかを示します。

@item gnus-group-native-p
@findex gnus-group-native-p
@var{group} が基本グループであるかどうかを示します。

@item gnus-group-secondary-p
@findex gnus-group-secondary-p
@var{group} が二次グループであるかどうかを示します。

@item gnus-group-foreign-p
@findex gnus-group-foreign-p
@var{group} が外部グループであるかどうかを示します。

@item group-group-find-parameter
@findex group-group-find-parameter
@var{group} のパラメータ一覧を返します。二つ目の引数を与えると、
@var{group} 用のそのパラメータの値を返します。

@item gnus-group-set-parameter
@findex gnus-group-set-parameter
三つの引数 @var{group}、 @var{parameter}、@var{value} を取ります。

@item gnus-narrow-to-body
@findex gnus-narrow-to-body
現在のバッファの記事の本文を制限表示します。

@item gnus-check-backend-function
@findex gnus-check-backend-function
二つの引数 @var{function}、@var{group} を取ります。@var{group}
バックエンドが @var{function} をサポートしているなら、
@code{nil} 以外を返します。

@lisp
(gnus-check-backend-function "request-scan" "nnml:misc")
=> t
@end lisp

@item gnus-read-method
@findex gnus-read-method
利用者に選択方法をプロンプト入力してもらいます。

@end table


@node Backend Interface
@subsection バックエンドインターフェース

Gnus は @sc{nntp} やスプール、メール、仮想グループについては何に
も知りません。ただ仮想サーバー @dfn{virtual servers} と対話する
方法を知っているだけです。仮想サーバーはバックエンド 
@dfn{backend} といくつかのバックエンド変数 @dfn{backend
variables} からなります。前者の例としては @code{nntp}、
@code{nnspool}、 @code{nnmbox} などがあります。後者の例としては 
@code{nntp-port-number} や @code{nnmbox-directory} があります。

Gnus がバックエンド --- 例えば @code{nntp} --- に何かの情報を要
求するときは、通常関数の引数として仮想サーバー名を含めます。 (も
しなければ、バックエンドは ``現在の'' 仮想サーバーを使用します。)
例えば、@code{nntp-request-list} はその唯一の (省略可能な) 引数
として仮想サーバーを取ります。もしこの仮想サーバーが開かれていな
ければ、この関数は失敗します。

仮想サーバー名は、物理的なサーバー名とは何の関係も無いことに注意
してください。この例を見てください。

@lisp
(nntp "odd-one"
      (nntp-address "ifi.uio.no")
      (nntp-port-number 4324))
@end lisp

ここで、物理サーバー名は @samp{ifi.uio.no} であるのに対し、仮想
サーバー名は @samp{odd-one} です。

バックエンドは複数の仮想サーバーを切り替え可能でなければなりませ
ん。標準のバックエンドはこれを、仮想サーバー環境を必要なときに取
り出し・押し込みを行なう連想リストを保持することによって実現して
います。

インターフェース関数は二つのグループがあります。必ず存在しなけれ
ばならない必須関数 @dfn{required functions} と、gnus が呼び出し
を行なう前にそれが存在するかを常に確認する任意関数 @dfn{optional
functions} です。

これらの関数は全て、返却データを @code{nntp-server-buffer}
(@samp{ *nntpd*}) バッファーに返すことが求められます。これはちょっ
と不運な名前付けですが、これで我慢しなければなりません。私が結果
のデータ @dfn{resulting data} と言ったときは、そのバッファーの中
のデータを指しています。返却値 @dfn{return value} と言ったときは、
関数呼び出しによって返される関数の値のことを言っています。関数が
失敗したときは返却値として @code{nil} を返さなくてはいけません。

バックエンドにはサーバー形式 @dfn{server-forming} のバックエンド
であると呼ばれるものがあり、またそう呼ばれないものもあります。後
者は一般には、同時には一つだけしか操作しないバックエンドで、``サー
バー'' の概念がありません。このサーバーとは、グループを持ち、そ
のグループに情報を配送するもので、それ以上のものではありません。

ここでの例と定義では、想像上のバックエンド @code{nnchoke} を引き
合いに出すことにします。

@cindex @code{nnchoke}

@menu
* Required Backend Functions::        実装しなければならない関数。
* Optional Backend Functions::        実装しなくてもよい関数。
* Error Messaging::                   メッセージやエラー報告を得る方法。
* Writing New Backends::              古いバックエンドの拡張。
* Hooking New Backends Into Gnus::    Gnus 側でしなければならないこと。
* Mail-like Backends::                メール風バックエンドのための助言
@end menu


@node Required Backend Functions
@subsubsection 必須バックエンド関数

@table @code

@item (nnchoke-retrieve-headers ARTICLES &optional GROUP SERVER FETCH-OLD)

@var{articles} は記事番号の範囲かあるいは @code{Message-ID} のリ
ストです。現在のバックエンドではどちらも完全にはサポートしていま
せん --- 連続した記事番号 (のリスト) だけで、多くのバックエンド
では @code{Message-ID} による取得はサポートしていません。でもど
ちらもサポートしていくべきでしょう。

結果のデータは HEAD か NOV 行のいずれかであり、返却値はこれを反
映した @code{headers} か @code{nov} のいずれかでなくてはなりませ
ん。これは今後、HEAD と NOV 行が混在する @code{various} に拡張さ
れるかもしれませんが、現在の gnus ではサポートされていません。

@var{fetch-old} が @code{nil} 以外であれば、ある意味での「余分な
ヘッダー」を取得しようとします。これは通常、@code{articles} の中
の最小番号の記事よりも小さい記事から (少なくとも) 
@var{fetch-old} 個の余分なヘッダーを取得し、空所を埋めることを行
ないます。もしバックエンドがこの要求に従うことを煩わしいと思った
場合には、このパラメータの存在は無視されることもあります。この値
が @code{nil} でも数字でもなければ、最大限の取得を行ないます。

これが HEAD の例です。

@example
221 1056 Article retrieved.
Path: ifi.uio.no!sturles
From: sturles@@ifi.uio.no (Sturle Sunde)
Newsgroups: ifi.discussion
Subject: Re: Something very droll
Date: 27 Oct 1994 14:02:57 +0100
Organization: Dept. of Informatics, University of Oslo, Norway
Lines: 26
Message-ID: <38o8e1$a0o@@holmenkollen.ifi.uio.no>
References: <38jdmq$4qu@@visbur.ifi.uio.no>
NNTP-Posting-Host: holmenkollen.ifi.uio.no
.
@end example

つまり、返却値が @code{headers} であるときは、データバッファにこ
れらヘッダーがいくつかあるということを意味します。

これがそのバッファーの BNF 定義です。

@example
headers        = *head
head           = error / valid-head
error-message  = [ "4" / "5" ] 2number " " <error message> eol
valid-head     = valid-message *header "." eol
valid-message  = "221 " <number> " Article retrieved." eol
header         = <text> eol
@end example

もし返却値が @code{nov} であれば、データバッファーには 
@dfn{network overview database} 行が含まれてなくてはなりません。
これは基本的には複数の欄をタブで区切ったものです。

@example
nov-buffer = *nov-line
nov-line   = 8*9 [ field <TAB> ] eol
field      = <text except TAB>
@end example

これらの欄にどのようなものが含まれるかをより詳しく見たければ、
@pxref{Headers} を参照してください。


@item (nnchoke-open-server SERVER &optional DEFINITIONS)

ここでの @var{server} は仮想サーバー名です。@var{definitions} は
この仮想サーバーを定義する @code{(VARIABLE VALUE)} 組のリストで
す。

もしサーバーを開くことができなければ、エラーはシグナルでは通知さ
れません。そしてバックエンドは、それ以後のこのサーバーへの接続要
求を拒否することもできます。実際、そうすべきです。

もしそのサーバーがすでに開いていれば、この関数は @code{nil} 以外
の値を返却しなければなりません。このとき、返される結果のデータは
ありません。


@item (nnchoke-close-server &optional SERVER)

@var{server} への接続を閉じ、これに関連するすべての資源を開放し
ます。もし何らかの理由でサーバーを閉じることができなければ、
@code{nil} を返却します。

返される結果のデータはありません。


@item (nnchoke-request-close)

全てのサーバーの接続を閉じ、バックエンドが保有している全ての資源
を開放します。このバックエンドによって作成されたバッファは全て削
除されます。(@code{nntp-server-buffer} は削除されませんが。) こ
の関数は通常、gnus が終了するときにのみ呼び出されます。

返される結果のデータはありません。


@item (nnchoke-server-opened &optional SERVER)

もし @var{server} が現在の仮想サーバーで、その物理サーバーへの接
続が生きていれば、この関数は @code{nil} 以外の値を返します。この
関数はどんな場合でも、接続が失われたサーバーへの再接続を行なうこ
とはありません。

返される結果のデータはありません。


@item (nnchoke-status-message &optional SERVER)

この関数は @var{server} からの最後のエラーメッセージを返却します。

返される結果のデータはありません。


@item (nnchoke-request-article ARTICLE &optional GROUP SERVER TO-BUFFER)

この関数の結果のデータは、@var{article} で指定された記事です。こ
の指定は @code{Message-ID} か番号のいずれかです。
@code{Message-ID} による記事の取得を実装するかどうかは任意ですが、
可能であると嬉しいですね。

@var{to-buffer} が @code{nil} 以外であれば、結果のデータは通常の
データバッファの代わりに、このバッファに返されます。これにより多
量のデータをあるバッファから別のバッファにコピーすることを避ける
ことができ、そして gnus は通常、記事バッファに直接記事を挿入する
ように要求しています。

もし可能であるのなら、この関数は、@code{car}が取得した記事のある
グループ名で、@code{cdr} が記事番号である cons セルを返すべきで
す。これにより @code{Message-ID} によって記事を取得したとき、
gnus が本当のグループと記事番号を知ることができるようになるでしょ
う。これが不可能な場合には、記事の取得が成功したときは @code{t} 
を返します。


@item (nnchoke-request-group GROUP &optional SERVER FAST)

@var{group} のデータを取得します。この関数は、@var{group} を現在
のグループにする、という副作用もあります。

@var{FAST} があれば、便利なデータを返す面倒を行なわずに、単に
@var{group} を現在のグループにします。

これが結果のデータの例と、それの定義です。

@example
211 56 1000 1059 ifi.discussion
@end example

最初の数字は状態で、これは 211 でなくてはなりません。次はそのグ
ループにある記事の総数、最小の記事番号、最大の記事番号、そして最
後がグループ名です。記事の総数は、最大・最小記事番号から単純に考
えられる数よりも小さいことがあることに注意してください。いくつか
の記事は取り消されているかもしれません。Gnus は総数は単に捨てて
しまっているので、(もしそれが問題となるときに) 正しい値を生成す
る面倒を負うべきかどうかは、読者への課題として残してあります。

@example
group-status = [ error / info ] eol
error        = [ "4" / "5" ] 2<number> " " <Error message>
info         = "211 " 3* [ <number> " " ] <string>
@end example


@item (nnchoke-close-group GROUP &optional SERVER)

@var{group} を閉じ、それに接続されている全ての資源を開放します。
これはほとんどのバックエンドでは何もすることがないでしょう。

返される結果のデータはありません。


@item (nnchoke-request-list &optional SERVER)

@var{server} 上で利用可能な全てのグループの一覧を返します。これ
は @emph{全部} という意味です。

これが、たった二つしかグループを持っていないサーバーからの例です。

@example
ifi.test 0000002200 0000002000 y
ifi.discussion 3324 3300 n
@end example

各行にはグループ名があり、そしてそのグループ内の最大の記事番号、
最小の記事番号、そして最後にフラグです。

@example
active-file = *active-line
active-line = name " " <number> " " <number> " " flags eol
name        = <string>
flags       = "n" / "y" / "m" / "x" / "j" / "=" name
@end example

フラグは、そのグループが読み出し専用 (@samp{n}) であるか、司会者
付き (@samp{m}) であるか、死んでいる (@samp{x}) か、どこか他のグ
ループの別名 (@samp{=other-group}) であるか、上記のどれでもない
(@samp{y}) か、ということを示しています。


@item (nnchoke-request-post &optional SERVER)

この関数は、現在のバッファを投稿します。これは投稿が成功したかど
うかを返却しても構いませんが、必須ではありません。例えば、投稿が
非同期に行われるのであれば、この関数が終了した時点では投稿は普通
完了していません。その場合この関数は、投稿を完了させることができ
ないとき、それをはっきりと利用者に知らせる見張り関数のようなもの
を設定するべきでしょう。

この関数から返される結果のデータはありません。

@end table


@node Optional Backend Functions
@subsubsection 任意バックエンド関数

@table @code

@item (nnchoke-retrieve-groups GROUPS &optional SERVER)

@var{groups} はグループのリストであり、この関数はそれら全部のグ
ループのデータを要求します。どうやってそれを行なうかは gnus の知っ
たことではありませんが、これはできるだけ迅速な方法で行なわなけれ
ばなりません。

この関数の返却値は @code{active} か @code{group} のいずれかで、
結果のデータの形式が何であるかを示します。前者は
@code{nnchoke-request-list} によるデータと同じ形式であり、一方後
者は @code{nnchoke-request-group} が与えるものと同じ形式の行でバッ
ファは埋められます。

@example
group-buffer = *active-line / *group-status
@end example


@item (nnchoke-request-update-info GROUP INFO &optional SERVER)

Gnus グループ情報 (@pxref{Group Info}) が変更箇所としてバックエ
ンドに渡されます。これはバックエンドが (仮想グループや imap グルー
プの場合のように) 本当に全ての情報を持っている場合に便利になりま
す。この関数は、その要求に適合させる情報を破壊的に置き換え、その
(置き換えられた) グループ情報を返します。

この関数から返される結果のデータはありません。


@item (nnchoke-request-type GROUP &optional ARTICLE)

利用者が ``ニュースを送信する'' 命令 (例えば、概略バッファで
@kbd{F}) を実行したとき、gnus は利用者がフォローアップしようとし
ている記事がニュースであるかメールであるかを知らなくてはなりませ
ん。この関数は @var{group} の中の @var{article} がニュースであれ
ば @code{news} を、メールであれば @code{mail} を、その種別を決定
できなければ @code{unknown} を返却します。(@var{article} 引数は、
メールグループとニュースグループがごちゃまぜになってるかもしれな
い @code{nnvirtual} において必要です。) @var{group} と
@var{article} は両方とも @code{nil} であるかもしれません。

この関数から返される結果のデータはありません。


@item (nnchoke-request-update-mark GROUP ARTICLE MARK)

もし利用者が、このバックエンドの気に入らない印を設定しようとした
ら、この関数が印を変更することができます。Gnus はもとの 
@var{mark} の代わりに、この関数が返したものを @var{article} への
印として使います。バックエンドが気にすることが特になければ、元の 
@var{mark} を返さなければなりません。@code{nil} やその他のゴミを
返してはいけません。

私が知っているこれのこれの利用法は、@code{nnvirtual} が行なって
いることだけです --- もし構成グループが自動期限切れ消去可能であ
れば、この仮想グループで既読の印を付けると、結果としてその記事に
期限切れ消去の印が付けられます。

この関数から返される結果のデータはありません。


@item (nnchoke-request-scan &optional GROUP SERVER)

この関数は、バックエンドが到着記事を確認する要求を行なうときにい
つでも (gnus かそれ以外によって) 、あれやこれやと呼び出されるこ
とがあります。メールバックエンドはこの関数が起動されたとき、典型
的にはスプールファイルを読むか POP サーバーに問い合わせにいきま
す。@var{group} は特に気に留める必要はありません --- もしバック
エンドが、一つだけのグループを走査するのは大変すぎると判断した場
合には、全グループの全走査を行なっても構いません。ですが、実用的
にできればそれを局所的に閉じておく方が良いでしょう。

この関数に返される結果のデータはありません。


@item (nnchoke-request-group-description GROUP &optional SERVER)

この関数によって返される結果のデータは、@var{group} の説明です。

@example
description-line = name <TAB> description eol
name             = <string>
description      = <text>
@end example

@item (nnchoke-request-list-newsgroups &optional SERVER)

この関数によって返される結果のデータは、サーバー上で利用できるグ
ループ全ての説明です。

@example
description-buffer = *description-line
@end example


@item (nnchoke-request-newgroups DATE &optional SERVER)

この関数から返される結果のデータは、@samp{date} 以降に作成された
全てのグループです。@samp{date} は通常の人間が読める日付の形式で
す。データは active バッファの形式でなければなりません。


@item (nnchoke-request-create-group GROUP &optional SERVER)

この関数は、@var{group} という名前の空のグループを作成します。

返される結果のデータはありません。


@item (nnchoke-request-expire-articles ARTICLES &optional GROUP SERVER FORCE)

この関数は、@var{articles} の範囲の全ての記事に対して期限切れ消
去処理を行ないます。 (@var{articles} は現在は記事番号の単純なリ
ストです。) この関数で消去される前の、記事がどれだけ古い記事であ
るかの決定はバックエンドに任されています。@var{force} が
@code{nil} 以外であれば、それがどんなに新しいものであっても、全
ての @var{articles} が消去されます。

この関数は削除しなかった、あるいは削除することができなかった記事
のリストを返します。

返される結果のデータはありません。


@item (nnchoke-request-move-article ARTICLE GROUP SERVER ACCEPT-FORM
&optional LAST)

この関数は @var{article} (番号) を、 @var{group} から
@var{accept-form} を呼び出して移動します。

この関数は、問題の記事を移動させるための準備として、記事に付加さ
れたヘッダー行を全て削除し、一般に記事を「きれいさっぱり」にしま
す。そして ``きれいな'' 記事のあるバッファーで @var{accept-form}
を @code{eval} します。これは本当に複製を行ないます。もし
@code{eval} が @code{nil} 以外の値を返したら、その記事は削除され
ません。

@var{last} が @code{nil} であれば、この直後にさらに要求が発行さ
れる見込みが高い、という意味になり、これによって最適化がいくらか
できるようになります。

この関数は、グループ名が @code{car} で、その記事の移動先の記事番
号が @code{cdr} である cons セルを返します。

返される結果のデータはありません。


@item (nnchoke-request-accept-article GROUP &optional SERVER LAST)

この関数は、現在のバッファを取り、それを @var{group} の中に挿入
します。@var{last} が @code{nil} であれば、この関数へのさらなる
呼び出しが直ちに行われるという意味です。

この関数はグループ名が @code{car} で、その記事の移動先の記事番号
が @code{cdr} である cons セルを返します。

返される結果のデータはありません。


@item (nnchoke-request-replace-article ARTICLE GROUP BUFFER)

この関数は @var{article} (番号) を @var{group} から削除し、代わ
りに @var{buffer} をそこに挿入します。

返される結果のデータはありません。


@item (nnchoke-request-delete-group GROUP FORCE &optional SERVER)

この関数は @var{group} を消去します。 もし @var{force} があれば、
そのグループ内の全ての記事を本当に消去し、そしてそのグループ自身
を消去します。 (もし ``グループ自身'' というものがあれば。)

返される結果のデータはありません。


@item (nnchoke-request-rename-group GROUP NEW-NAME &optional SERVER)

この関数は @var{group} から @var{new-name} に名前を変更します。
@var{group} 内にある記事は全て @var{new-name} に移動します。

返される結果のデータはありません。

@end table


@node Error Messaging
@subsubsection エラーメッセージ表示

@findex nnheader-report
@findex nnheader-get-report
バックエンドはエラー状況を報告するのに @code{nnheader-report} を
使わなくてはなりません --- 要求を実行できないときにエラーを生起
させてはいけません。この関数の最初の引数はバックエンド名のシンボ
ルで、残りは、複数の引数があれば @code{format} への引数として解
釈され、一つであればただの文字列になります。この関数は常に
@code{nil} を返さなくてはなりません。

@lisp
(nnheader-report 'nnchoke "You did something totally bogus")

(nnheader-report 'nnchoke "Could not request group %s" group)
@end lisp

一方 gnus は、サーバーから @code{nil} を返されたときに
@code{nnheader-get-report} を呼び出し、そしてこの関数が問題のバッ
クエンドに対して最後に報告されたメッセージを返します。この関数は
一つの引数 --- サーバーのシンボルを取ります。

内部的には、これらの関数は @var{backend}@code{-status-string} に
アクセスます、つまり @code{nnchoke} バックエンドはそのエラーメッ
セージを @code{nnchoke-status-string} に格納します。


@node Writing New Backends
@subsubsection 新しいバックエンドを書く

多くのバックエンドはとても類似しています。@code{nnml} は
@code{nnspool} にとても似ていますが、サーバー上の記事を編集する
ことができます。@code{nnmh} は @code{nnml} にとても似ていますが、
これはアクティブファイルを使わず、概要データベースも保持しません。
@code{nndir} は @code{nnml} にとても似ていますが、これには ``グ
ループ'' の概念はなく、記事の修正はできません。

新しいバックエンドを書くときに他のバックエンドから関数を ``継承'' 
することが可能であってほしい、と思うのは理に適っています。そして
まさに、あなたがそうしたければ、それができるのです。(あなたがそ
うしたくなければしなくても良いですよ、もちろん。)

全てのバックエンドは公開変数と公開関数を、 @code{nnoo} と呼ばれ
るパッケージを使って宣言します。

他のバックエンドから関数を継承するには (そして現在のバックエンド
から他のバックエンドに関数を継承できるようにするには) 、以下のマ
クロを使用しなければなりません。

@table @code

@item nnoo-declare
このマクロは、最初の引数を、その後に続く引数の子供であることを宣
言します。例えば、

@lisp
(nnoo-declare nndir
  nnml nnmh)
@end lisp

これで @code{nndir}は、@code{nnml} と @code{nnmh} の両方から関数
を継承しようとしていることを宣言します。

@item defvoo
このマクロは @code{defvar} と同義ですが、その変数を公開サーバー
変数として登録します。ほとんどの状態指向型の変数は @code{defvar}
ではなく @code{defvoo} によって宣言するべきです。

通常の @code{defvar} 引数に加えて、このマクロは親バックエンドの
変数のリストを取り、この関数がそのバックエンド内で実行されるとき
に変数を置き換えます。

@lisp
(defvoo nndir-directory nil
  "Where nndir will look for groups."
  nnml-current-directory nnmh-current-directory)
@end lisp

これは @code{nndir} のために @code{nnml} の関数が呼び出されたと
きに、@code{nnml-current-directory} は @code{nndir-directory} に
設定されるという意味です。(@code{nnmh} も同様です。)

@item nnoo-define-basics
このマクロは、ほとんど全部のバックエンドが持つべき共通関数をいく
つか定義します。

@example
(nnoo-define-basics nndir)
@end example

@item deffoo
このマクロはまさに @code{defun} のようなもので、同一の引数を取り
ます。通常の @code{defun} 処理に加えて、このマクロはその関数を公
開しているものとして登録し、他のバックエンドがそれを継承できるよ
うにします。

@item nnoo-map-functions
このマクロは現在のバックエンドの関数から親バックエンドの関数への
置き換えを行なえるようにします。

@example
(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0))
@end example

これは @code{nndir-retrieve-headers} が呼び出されたとき、一番目、
三番目、四番目の引数が @code{nnml-retrieve-headers} に渡され、一
方、二番目の引数は @code{nndir-current-group} の値として設定され
る、という意味です。

@item nnoo-import
このマクロは他のバックエンドから関数を取り込みます。これは単にま
だ定義されていない関数を定義するだけなので、ソースファイルの最後
の処理として書かなければなりません。

@example
(nnoo-import nndir
  (nnmh
   nnmh-request-list
   nnmh-request-newgroups)
  (nnml))
@end example

これは、 @code{nndir-request-list} への呼び出しは単に
@code{nnmh-request-list} に引き渡され、一方、@code{nnml} の公開
関数でまだ @code{nndir} で定義されていないものをここで定義します。

@end table

以下は @code{nndir} バックエンドのちょっと短縮した版です。

@lisp
;;; nndir.el --- single directory newsgroup access for Gnus
;; Copyright (C) 1995,96 Free Software Foundation, Inc.

;;; Code:

(require 'nnheader)
(require 'nnmh)
(require 'nnml)
(require 'nnoo)
(eval-when-compile (require 'cl))

(nnoo-declare nndir
  nnml nnmh)

(defvoo nndir-directory nil
  "Where nndir will look for groups."
  nnml-current-directory nnmh-current-directory)

(defvoo nndir-nov-is-evil nil
  "*Non-nil means that nndir will never retrieve NOV headers."
  nnml-nov-is-evil)

(defvoo nndir-current-group "" nil nnml-current-group nnmh-current-group)
(defvoo nndir-top-directory nil nil nnml-directory nnmh-directory)
(defvoo nndir-get-new-mail nil nil nnml-get-new-mail nnmh-get-new-mail)

(defvoo nndir-status-string "" nil nnmh-status-string)
(defconst nndir-version "nndir 1.0")

;;; Interface functions.

(nnoo-define-basics nndir)

(deffoo nndir-open-server (server &optional defs)
  (setq nndir-directory
        (or (cadr (assq 'nndir-directory defs))
            server))
  (unless (assq 'nndir-directory defs)
    (push `(nndir-directory ,server) defs))
  (push `(nndir-current-group
          ,(file-name-nondirectory (directory-file-name nndir-directory)))
        defs)
  (push `(nndir-top-directory
          ,(file-name-directory (directory-file-name nndir-directory)))
        defs)
  (nnoo-change-server 'nndir server defs))

(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0)
  (nnmh-request-group nndir-current-group 0 0)
  (nnmh-close-group nndir-current-group 0))

(nnoo-import nndir
  (nnmh
   nnmh-status-message
   nnmh-request-list
   nnmh-request-newgroups))

(provide 'nndir)
@end lisp


@node Hooking New Backends Into Gnus
@subsubsection 新しいバックエンドを gnus に繋げる

@vindex gnus-valid-select-methods
あなたの新しいバックエンドを gnus で使いはじめるのはとても簡単で
す --- 単に @code{gnus-declare-backend} 関数で宣言するだけです。
これはバックエンドを @code{gnus-valid-select-methods} 変数に追加
します。

@code{gnus-declare-backend} は二つの引数を取ります --- バックエ
ンドの名前と適当な数の能力 @dfn{abilities} です。

これが例です。

@lisp
(gnus-declare-backend "nnchoke" 'mail 'respool 'address)
@end lisp

能力には以下のものがあります。

@table @code
@item mail
これはメール風バックエンドです --- フォローアップは (たいていは)
メールで送られます。
@item post
これはニュース風バックエンドです --- フォローアップは (たいてい
は) ニュースで送られます。
@item post-mail
このバックエンドはメールとニュースの両方をサポートします。
@item none
これはニュースでもメールでもないバックエンドです --- 全く違った
何かです。
@item respool
これは再スプールをサポートします --- というよりは、その元の記事
とグループを修正することができます。
@item address
仮想サーバー名の中にサーバーの名前が含まるということです。これは
ほとんど全部のバックエンドで必要になります。
@item prompt-address
グループバッファで @kbd{B} などでこの命令を実行したとき、ユーザ
はアドレスのプロンプト入力を求められます。これは例えば、
@code{nntp} のようなバックエンドでは必要で、@code{nnmbox} では必
要ではありません。
@end table


@node Mail-like Backends
@subsubsection メール風バックエンド

メールバックエンドがその他のバックエンドに対して一線を画している
点は、メールバックエンドは @file{nnmail.el} の中の共通関数に強く
依存しているという点です。例えば、@code{nnml-request-scan} の定
義はこのようになります。

@lisp
(deffoo nnml-request-scan (&optional group server)
  (setq nnml-article-file-alist nil)
  (nnmail-get-new-mail 'nnml 'nnml-save-nov nnml-directory group))
@end lisp

単に @code{nnmail-get-new-mail} にいくつか引数を与えて呼び出すだ
けで、@code{nnmail} がメールの移動や分離を全ての面倒を見てくれま
す。

この関数は四つの引数を取ります。

@table @var
@item method
これは、この呼び出しをどのバックエンドが責任を負うかを指示するシ
ンボルです。

@item exit-function
この関数は分離が実行された後に呼び出されます。

@item temp-directory
一時ファイルを格納する場所です。

@item group
この省略可能な引数は、分離が一つのグループに対してのみ実行される
べきであるときのグループ名です。
@end table

@code{nnmail-get-new-mail} は各記事を保存するために
@var{backend}@code{-save-mail} を呼び出します。
@var{backend}@code{-active-number} はこの記事に割り当てられた記
事番号を調べるために呼び出されます。

この関数は次の変数も使用します。
@var{backend}@code{-get-new-mail} (このバックエンドの新着メール
を調べるかどうか) と、新しいアクティブファイルを生成するための
@var{backend}@code{-group-alist} と
@var{backend}@code{-active-file} です。
@var{backend}@code{-group-alist} グループのアクティブ連想リスト
で、以下のようなものです。

@example
(("a-group" (1 . 10))
 ("some-group" (34 . 39)))
@end example


@node Score File Syntax
@subsection スコアファイルの構文

スコアファイルは簡単に分析可能で、しかし非常に柔軟なように意図されていま
す。それには Emacs Lisp のリストと同じ読み込み構文な様なものがその指定に
合うだろうという事が決定されました。

これは良くあるスコアファイルです:

@lisp
(("summary"
  ("win95" -10000 nil s)
  ("Gnus"))
 ("from"
  ("Lars" -1000))
 (mark -100))
@end lisp

スコアファイルの BNF 定義です。

@example
score-file       = "" / "(" *element ")"
element          = rule / atom
rule             = string-rule / number-rule / date-rule
string-rule      = "(" quote string-header quote space *string-match ")"
number-rule      = "(" quote number-header quote space *number-match ")"
date-rule        = "(" quote date-header quote space *date-match ")"
quote            = <ascii 34>
string-header    = "subject" / "from" / "references" / "message-id" /
                   "xref" / "body" / "head" / "all" / "followup"
number-header    = "lines" / "chars"
date-header      = "date"
string-match     = "(" quote <string> quote [ "" / [ space score [ "" /
                   space date [ "" / [ space string-match-t ] ] ] ] ] ")"
score            = "nil" / <integer>
date             = "nil" / <natural number>
string-match-t   = "nil" / "s" / "substring" / "S" / "Substring" /
                   "r" / "regex" / "R" / "Regex" /
                   "e" / "exact" / "E" / "Exact" /
                   "f" / "fuzzy" / "F" / "Fuzzy"
number-match     = "(" <integer> [ "" / [ space score [ "" /
                   space date [ "" / [ space number-match-t ] ] ] ] ] ")"
number-match-t   = "nil" / "=" / "<" / ">" / ">=" / "<="
date-match       = "(" quote <string> quote [ "" / [ space score [ "" /
                   space date [ "" / [ space date-match-t ] ] ] ] ")"
date-match-t     = "nil" / "at" / "before" / "after"
atom             = "(" [ required-atom / optional-atom ] ")"
required-atom    = mark / expunge / mark-and-expunge / files /
                   exclude-files / read-only / touched
optional-atom    = adapt / local / eval
mark             = "mark" space nil-or-number
nil-or-number    = "nil" / <integer>
expunge          = "expunge" space nil-or-number
mark-and-expunge = "mark-and-expunge" space nil-or-number
files            = "files" *[ space <string> ]
exclude-files    = "exclude-files" *[ space <string> ]
read-only        = "read-only" [ space "nil" / space "t" ]
adapt            = "adapt" [ space "ignore" / space "t" / space adapt-rule ]
adapt-rule       = "(" *[ <string> *[ "(" <string> <integer> ")" ] ")"
local            = "local" *[ space "(" <string> space <form> ")" ]
eval             = "eval" space <form>
space            = *[ " " / <TAB> / <NEWLINE> ]
@end example

スコアファイルの認識不可能な要素は無視されるべきですが、捨てられるわけで
はありません。

ご覧の通り、空白が必要ですが、空白の量と型は無関係です。これはスコアファ
イルの様式はプログラマーに任されているという事です---全てを一つの長ーー
い行に吐き出すのが簡単であれば、それは構いません。

いろいろなアトムの意味はこのマニュアルのどこかで説明されています 
(@pxref{Score File Format})。


@node Headers
@subsection ヘッダー

内部的には gnus は不思議な流儀で、@sc{nov} 様式に対応する記事のヘッダー
を溜めておく様式を使います。ある人は、作者が @sc{nov} の仕様を見て恥じる
事無く全てを @emph{盗んだ} と思うかもしれませんが、その人は正しいです。

@dfn{ヘッダー} は非常に負担のかけられすぎた語です。 ``ヘッダー'' は 
RFC1036 では記事の頭の行の事 (例えば、@code{From}) を話すのに用いられて
います。それは多くの人から ``ヘッド''---``ヘッダーと本体'' の同義語とし
て使われています。 (これは、私の意見では避けられるべきです。) そして、
gnus は内部では ``ヘッダー'' と呼ぶ様式を使っており、私はここでそれにつ
いて説明します。これは9つの要素からなるベクトルで、基本的に、それぞれの
ヘッダー (あ痛) が一つの空き場所を占めています。

これらの空き場所は、順番に: @code{number}、@code{subject}、@code{from}、
@code{date}、@code{id}、@code{chars}、@code{lines}、@code{xref} です。こ
れらの空き場所に触って設定するマクロがあります---それらは全て、それぞれ 
@code{mail-header-} と @code{mail-header-set-} いう予想される名前を持っ
ています。

場所 @code{xref} は本当は @code{misc} の場所です。いろんな追加の情報はそ
こに入れられます。


@node Ranges
@subsection 範囲

@sc{gnus} は私には非常に役に立つと思われる概念を導入しましたので、私はそ
れをたくさん使い、かなり念入りに作り上げてきました。

質問は単純です: もしあなたが大量の数字により同一性を保証される もの 
(object) (@emph{乱暴な} 例を挙げると、記事がそうです) を ``含まれている'' 
として見なしたいときは、普通の連続的行為はあまり役に立ちません。 (長さ 
200,000 の連続物は少し息が長すぎます。)

これの解決策は質問と同じくらい単純です。単にその連続物を壊せば良いだけで
す。

@example
(1 2 3 4 5 6 10 11 12)
@end example

は次のものに変形されます。

@example
((1 . 6) (10. 12))
@end example

あの嫌な @samp{(13. 13)} のような要素を避けるために、それのみの もの 
(object) を示すために @samp{13} は有効な要素になっています。

@example
((1 . 6) 7 (10 . 12))
@end example

これは2つの範囲を比較してそれが等価 (equal) であるかを調べる事は少し手の
こんだことになります:

@example
((1 . 5) 7 8 (10 . 12))
@end example

と

@example
((1 . 5) (7. 8) (10 . 12))
@end example

は等価です。実際のところ、下降しないリストは範囲です:

@example
(1 2 3 4 5)
@end example

は完全に有効な範囲です。とても息の長いものですが。これも有効です:

@example
(1 . 5)
@end example

そして、これは前の範囲と等価です。

これは範囲の BNF 定義です。もちろん、数字の意味上の要求は下降していない
という事は覚えておく必要があります。 (任意の回数の同じ数字の繰り返しは許
されていますが、範囲の扱いからは消え去る傾向があります。)

@example
range           = simple-range / normal-range
simple-range    = "(" number " . " number ")"
normal-range    = "(" start-contents ")"
contents        = "" / simple-range *[ " " contents ] /
                  number *[ " " contents ]
@end example

Gnus は現在のところ既読記事と記事の印の情報を付けておくために範囲を使っ
ています。私は 次の権力者 が私にさせてくれるのであれば、C で数の範囲の実
装を計画しています。 (私はまだその人に尋ねていません。と言うのは、私はそ
れを普通の連続物に変換し直さないで世の中を完全に範囲に基づいたものにする
ためにもう少し考える必要があるからです。)


@node Group Info
@subsection グループ情報

Gnus はグループの全ての永続情報を @dfn{group info} リストに保存します。
このリストの長さは3から6 (もしくはもっと) の要素で徹底的にグループを記述
します。

ここにあるのはグループ情報 (group info) の2つの例です。1つは非常に単純な
グループで、2つめはもっと複雑なものです:

@example
("no.group" 5 (1 . 54324))

("nnml:my.mail" 3 ((1 . 5) 9 (20 . 55))
                ((tick (15 . 19)) (replied 3 6 (19 . 3)))
                (nnml "")
                ((auto-expire . t) (to-address . "ding@@gnus.org")))
@end example

最初の要素は @dfn{グループ名} です---どのようにしろ、gnus がそれによって
グループを知っているものです。2番目の要素は @dfn{購読度} で、普通は小さ
な整数です。(それは @dfn{階級} になる事もできます。それは、コンスセルで、
@code{car} がレベルで、@code{cdr} がスコアです。) 3番目の要素は既読記事
の範囲のリストです。4番目の要素はいろいろな種類の記事の印のリストのリス
トです。5番目の要素は選択方法です (もしくは、こちらの方が良いのであれば
事実上のサーバーです)。6番目の要素は @dfn{グループパラメータ} のリストで、
この部分はそのためにあります。

最後の3つの要素はどれでも、必要が無ければ存在しない事もあります。実際、
グループの非常に大部分は最初の3つの要素だけを持ち、それはたくさんのコン
スセルを節約する事ができます。

これはグループ情報様式の BNF 定義です:

@example
info          = "(" group space ralevel space read
                [ "" / [ space marks-list [ "" / [ space method [ "" /
                space parameters ] ] ] ] ] ")"
group         = quote <string> quote
ralevel       = rank / level
level         = <integer in the range of 1 to inf>
rank          = "(" level "." score ")"
score         = <integer in the range of 1 to inf>
read          = range
marks-lists   = nil / "(" *marks ")"
marks         = "(" <string> range ")"
method        = "(" <string> *elisp-forms ")"
parameters    = "(" *elisp-forms ")"
@end example

実のところ法則 @samp{marks} は嘘です。@samp{marks} は @samp{<string>} が 
@samp{range} の上に校正されているものですが、疑似 BNF でそれを現すのは不
愉快なものです。

もし gnus 情報を持っていて、要素を調べたいのときは、gnus はそれらの要素
を取得/設定 (get/set) するための一連のマクロを提供しています。

@table @code
@item gnus-info-group
@itemx gnus-info-set-group
@findex gnus-info-group
@findex gnus-info-set-group
グループ名を取得/設定 (get/set) します。

@item gnus-info-rank
@itemx gnus-info-set-rank
@findex gnus-info-rank
@findex gnus-info-set-rank
グループの階級 (rank) を取得/設定します (@pxref{Group Score})。

@item gnus-info-level
@itemx gnus-info-set-level
@findex gnus-info-level
@findex gnus-info-set-level
グループのレベルを取得/設定します。

@item gnus-info-score
@itemx gnus-info-set-score
@findex gnus-info-score
@findex gnus-info-set-score
グループスコアを取得/設定します (@pxref{Group Score})。

@item gnus-info-read
@itemx gnus-info-set-read
@findex gnus-info-read
@findex gnus-info-set-read
既読記事の範囲を取得/設定します。

@item gnus-info-marks
@itemx gnus-info-set-marks
@findex gnus-info-marks
@findex gnus-info-set-marks
印しつき記事の範囲のリストを取得/設定します。

@item gnus-info-method
@itemx gnus-info-set-method
@findex gnus-info-method
@findex gnus-info-set-method
グループ選択方法を取得/設定します。

@item gnus-info-params
@itemx gnus-info-set-params
@findex gnus-info-params
@findex gnus-info-set-params
グループパラメータを取得/設定します。
@end table

全ての取得関数は1つの引数を取ります---情報のリストです。設定関数は2つの
引数を取ります---情報リストと新しい値です。

グループ情報の最後の3つの要素は強制的なものではありませんので、要素を設
定する前にグループ情報を拡張する必要があるかも知れません。もしこれが必要
な場合は、これが自動的に起こるために @code{nil} でない3番目の引数を3つの
最終設定関数に与えるだけです。


@node Extended Interactive
@subsection 拡張対話
@cindex interactive
@findex gnus-interactive

Gnus は Emacs の標準の @code{interactive} 指定をシンボル接頭辞を簡単に使
えるために少し拡張しています (@pxref{Symbolic Prefixes})。これはその使い
方の例です:

@lisp
(defun gnus-summary-increase-score (&optional score symp)
  (interactive (gnus-interactive "P\ny"))
  ...
  )
@end lisp

最上の方法は @code{gnus-interactive} を式 @code{interactive} を返すマク
ロとして実装する事でしょうが、これは Emacs は関数が対話的であるかどうか
をラムダ式に対して単純に @code{assq} を行う事により調べる事から不可能で
す。

この関数は (ほとんど) 全ての @code{interactive} 指定を受付けますが、もう
少し加えます。

@table @samp
@item y
@vindex gnus-current-prefix-symbol
現在の接頭引数シンボル---変数 @code{gnus-current-prefix-symbol} です。

@item Y
@vindex gnus-current-prefix-symbols
現在の接頭引数シンボルのリストです---変数 
@code{gnus-current-prefix-symbol} です。

@item A
現在の記事番号です---関数 @code{gnus-summary-article-number} です。

@item H
現在の記事ヘッダーです---関数 @code{gnus-summary-article-header} です。

@item g
現在のグループ名です---関数 @code{gnus-group-group-name} です。
@end table


@node Emacs/XEmacs Code
@subsection Emacs/XEmacs コード
@cindex XEmacs
@cindex Emacsen

Gnus は Emacs、XEmacs と Mule で動作しますので、そのうちの一つを主環境と
する事に決めました。私は Emacs を選びました。私が XEmacs や Mule を好き
ではないと言う事ではなく、それがアルファベットで最初に来たからです。

これは gnus は Emacs で全く警告なくバイトコンパイルできるのに対して、
XEmacs はバイトコンパイルをしている間にギガバイトくらいの警告を出すと言
う事です。私は些細な失敗を見つけ出すことを助けるためにバイトコンパイルの
警告を使っていますので、それは非常に役に立ちます。

私は継続的に Emacs の関数の界面 (interface) を使ってきましたが、関数には 
gnus の別名関数 (alias) を使ってきました。例を出しましょう: Emacs は関数 
@code{run-at-time} を定義していますが、XEmacs は関数 @code{start-itimer} 
を定義しています。そこで私は @code{gnus-run-at-time} と呼ばれる関数を定
義し、それは Emacs の @code{run-at-time} と同じ引数を取ります。Gnus を 
Emacs で実行しているときは、前の関数は単に後のものの別名関数 (alias) に
なっています。しかし、XEmacs で実行したときは、前者は次の関数の別名関数 
(alias) となっています:

@lisp
(defun gnus-xmas-run-at-time (time repeat function &rest args)
  (start-itimer
   "gnus-run-at-time"
   `(lambda ()
      (,function ,@@args))
   time repeat))
@end lisp

この種類のものが多くの関数に対してなされています。Gnus は XEmacs で実行
しているときに、元からある Emacs の関数を再定義しません---それは、代わり
に gnus の等価なものと @code{defalias} をする事によって実行します。全体
的に、よりきれいになります。

XEmacs の関数界面の方が明らかにきれいな場合は、私は代わりにそれを使いま
す。例えば、@code{gnus-region-active-p} は XEmacs では 
@code{region-active-p} の別名であるのに対して、Emacs では関数です。

もちろん、私は XEmacs を私の基本プラットフォームに選んで、関数の割り当て
を逆にする事もできました。でも、私はそうしませんでした。XEmacs で gnus 
を実行するときに、こういう逆向きのための速度低下は少しでしょう。


@node Various File Formats
@subsection いろいろなファイル様式

@menu
* Active File Format::      使用可能な記事グループの情報。
* Newsgroups File Format::  グループの記述。
@end menu


@node Active File Format
@subsubsection アクテイブファイル様式

アクティブファイルは当のサーバーの全ての使用可能なグループの一覧を挙げま
す。それはそれぞれのグループの最低と最高の記事番号の一覧もあります。

これは普通のアクティブファイルからの抜粋です:

@example
soc.motss 296030 293865 y
alt.binaries.pictures.fractals 3922 3913 n
comp.sources.unix 1605 1593 m
comp.binaries.ibm.pc 5097 5089 y
no.general 1000 900 y
@end example

これはこのファイルの疑似 BNF 定義です。

@example
active      = *group-line
group-line  = group space high-number space low-number space flag <NEWLINE>
group       = <non-white-space string>
space       = " "
high-number = <non-negative integer>
low-number  = <positive integer>
flag        = "y" / "n" / "m" / "j" / "x" / "=" group
@end example

このファイルの完全な記述を得るためには、@samp{innd} のマニュアル頁、特に 
@samp{active(5)} を見て下さい。


@node Newsgroups File Format
@subsubsection ニュースグループファイル様式

ニュースグループファイルはグループをその記述と共に一覧を挙げます。サーバー
にある全てのグループが一覧にされなければならないのではなく、また、ファイ
ルの全てのグループがサーバーに存在しなければならないのではありません。こ
のファイルは純粋に利用者の情報のためにあります。

様式は非常に簡単です: グループ名、タブ、そして記述です。これは定義です:

@example
newsgroups    = *line
line          = group tab description <NEWLINE>
group         = <non-white-space string>
tab           = <TAB>
description   = <string>
@end example


@page
@node Emacs for Heathens
@section 異教徒への Emacs

信じるかどうかは知りませんが、gnus を使う人の中には Gnus Love Boat での
旅に搭乗する前にあまり Emacs を使った事が無いという人がいます。もしあな
たが ``@kbd{M-C-a}'' や ``リージョンを切る''、そして 
``@code{gnus-flargblossen} を連想リストに設定してください。そのキーはグ
ループ名に合致するために使われる正規表現です'' が少しの意味か全く意味の
無い魔法の言葉である不幸な人であれば、この付録はあなたのためにあります。
もしあなたが既に Emacs に親しんでいるのであれば、これを無視して車を可愛
がりに行って下さい。

@menu
* Keystrokes::      文章を入力して命令を実行する。
* Emacs Lisp::      備え付けの Emacs プログラミング言語。
@end menu


@node Keystrokes
@subsection 打鍵

@itemize @bullet
@item
Q: 経験のある Emacs の利用者とは何ですか?

@item
A: 端末がペダルを持っていたらなぁと願う人の事です。
@end itemize

はい、あなたが Emacs を使うと、あなたはコントロールキー、シフトキー、メ
タキーをたくさん使うようになるでしょう。これは一部の人 (主に、@code{vi} 
利用者) には非常にうるさく感じられるでしょう。残りの人々は、それによりも
たらされる地獄を愛します。あきらめて服従して下さい。Emacs は本当は 
``Escape-Meta-Alt-Control-Shift'' の略で、他の評判の悪い出所 (Emacs の作
者のような) から聞いた ``Editing Macros'' ではありません。

シフトキーは普通は小指の近くに位置しており、普通は大文字やその他のもを得
るために使われます。あなたはずっとそれを使う事でしょう。コントロールキー
は普通は ``CTRL'' やそのようなもので印が付いています。メタキーは、おもし
ろい事に、どのキーボードでもそのように印が付けられていません。それは普通
はキーボードの左手側に位置していて、普通は最下段にあります。

これから、我々 Emacs の人々は、それがあまりに不便なため、
``meta-control-m キーを押す'' とは言いません。私たちは ``@kbd{M-C-m} を
押す'' と言います。@kbd{M-} は ``メタ'' を現す接頭辞で、``C-'' は ``コン
トロール'' を意味する接頭辞です。ですから、``@kbd{C-k} を押す'' は ``コ
ントロールキーを下に押し、@kbd{k} を押している間、それを下に保ちなさい'' 
と言う事です。``@kbd{M-C-k} を押す'' は ``メタキーとコントロールキーを押
して下に保った後で @kbd{k} を押す'' と言う事です。簡単でしょ。ね？

これは全てのキーボードがメタキーを持っているわけではないと言う事実により
少し複雑になっています。そのような場合は、``エスケープ'' キーを使う事が
できます。それはメタキーを持っているときよりもっと作業が大変になりますの
で、そういう場合は、私はメタキーのあるキーボードを手に入れる事を恭しくお
勧め致します。それ無しでは生きて行けないでしょう。



@node Emacs Lisp
@subsection Emacs Lisp

Emacs はそれが本当は Lisp インタープリターである事から、エディターの王様
です。あなたが叩く、それぞれの全てのキーは何らかの Emacs Lisp のコードの
小片を実行し、Emacs Lisp はインタープリターで実行される言語である事から、
それはどんなキーでも任意のいろいろなコードを実行するように設定できると言
う事です。あなたは、単に、そうすれば良いだけです。

Gnus は Emacs Lisp によって書かれていて、それはたくさんの逐次解釈実行さ
れる関数により実行されます。 (これらは速度のためにバイトコンパイルされて
いますが、それでもまだ逐次解釈されます。) もし gnus がするある事を好きで
はないと思ったなら、違ったように実行させるのは取るに足らない事です。 (えー
と、少なくとも Lisp コードの書き方を知っていれば。) しかし、それはこのマ
ニュアルの範囲外なので、我々は単に gnus をカスタマイズするためにファイル 
@file{.emacs} で普通使われるいくつかの普通の構文についてだけ話をします。

もし変数@code{gnus-florgbnize} を四 (4) に設定したいのであれば、以下のも
のを書きます:

@lisp
(setq gnus-florgbnize 4)
@end lisp

この関数 @code{setq} (本当は ``特殊形式'' (special form)) を使って、変数
を何かの値に設定する事ができます。これは本当にあなたが知るべき全ての事で
す。これからは gnus の動作を変更するために、たくさんのこのようなものでファ
イル @code{.emacs} を埋め尽くす事ができます。

もしあなたがそのようなものをファイル @code{.emacs} に入れたら、それは次
回に Emacs を起動したときに読み込まれ @code{評価} (それは ``実行'' の 
lisp 語です) されます。もし変数をすぐに変更したいのであれば、閉じ括弧の
後で単に @kbd{C-x C-e} とするだけです。それは前にある ``式'' を @code{評
価} し、それはここでは簡単な @code{setq} 文です。

がんばって---もしあなたが Emacs の前にあるのであればちょっと試して下さい。
@kbd{C-x C-e} の後で、反響区域 (echo area) に @samp{4} が現われるのが見
えるでしょう。それはあなたが @code{評価} した式の返り値です。

いくつかの落とし穴:

もしマニュアルが ``@code{gnus-read-active-file} を @code{some} に設定し
なさい'' と言ったなら、それは:

@lisp
(setq gnus-read-active-file 'some) 
@end lisp

と言う事です。

一方、マニュアルが ``@code{gnus-nntp-server} を @samp{nntp.ifi.uio.no} 
に設定しなさい'' と言ったなら、それは:

@lisp
(setq gnus-nntp-server "nntp.ifi.uio.no")
@end lisp

と言う事です。

ですから、文字列 (後者) を シンボル (前者) と混同しないように注意して下
さい。マニュアルは明確に区別していますが、混乱しやすいかもしれません。

@page
@include gnus-faq-ja.texi

@node Index
@chapter Index
@printindex cp

@node Key Index
@chapter Key Index
@printindex ky

@summarycontents
@contents
@bye


@c End:
