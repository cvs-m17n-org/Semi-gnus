\input texinfo

@setfilename gnus-ja
@settitle T-gnus 6.15 Manual
@synindex fn cp
@synindex vr cp
@synindex pg cp
@dircategory Emacs
@direntry
* Gnus-ja: (gnus-ja).         The newsreader gnus (Japanese).
@end direntry
@iftex
@finalout
@end iftex
@setchapternewpage odd

@iftex
@iflatex
\documentclass[twoside,a4paper,openright,11pt]{book}
\usepackage[latin1]{inputenc}
\usepackage{pagestyle}
\usepackage{epsfig}
\usepackage{pixidx}
\input{gnusconfig.tex}

\ifx\pdfoutput\undefined
\else
\usepackage[pdftex,bookmarks,colorlinks=true]{hyperref}
\usepackage{thumbpdf}
\pdfcompresslevel=9
\fi

\makeindex
\begin{document}

\newcommand{\gnusversionname}{T-gnus v6.15}
\newcommand{\gnuschaptername}{}
\newcommand{\gnussectionname}{}

\newcommand{\gnusbackslash}{/}

\newcommand{\gnusref}[1]{``#1'' on page \pageref{#1}}
\ifx\pdfoutput\undefined
\newcommand{\gnusuref}[1]{\gnustt{#1}}
\else
\newcommand{\gnusuref}[1]{\href{#1}{\gnustt{#1}}}
\fi
\newcommand{\gnusxref}[1]{See ``#1'' on page \pageref{#1}}
\newcommand{\gnuspxref}[1]{see ``#1'' on page \pageref{#1}}

\newcommand{\gnuskindex}[1]{\index{#1}}
\newcommand{\gnusindex}[1]{\index{#1}}

\newcommand{\gnustt}[1]{{\gnusselectttfont{}#1}}
\newcommand{\gnuscode}[1]{\gnustt{#1}}
\newcommand{\gnussamp}[1]{``{\fontencoding{OT1}\gnusselectttfont{}#1}''}
\newcommand{\gnuslisp}[1]{\gnustt{#1}}
\newcommand{\gnuskbd}[1]{`\gnustt{#1}'}
\newcommand{\gnusfile}[1]{`\gnustt{#1}'}
\newcommand{\gnusdfn}[1]{\textit{#1}}
\newcommand{\gnusi}[1]{\textit{#1}}
\newcommand{\gnusstrong}[1]{\textbf{#1}}
\newcommand{\gnusemph}[1]{\textit{#1}}
\newcommand{\gnusvar}[1]{{\fontsize{10pt}{10}\selectfont\textsl{\textsf{#1}}}}
\newcommand{\gnussc}[1]{\textsc{#1}}
\newcommand{\gnustitle}[1]{{\huge\textbf{#1}}}
\newcommand{\gnusversion}[1]{{\small\textit{#1}}}
\newcommand{\gnusauthor}[1]{{\large\textbf{#1}}}
\newcommand{\gnusresult}[1]{\gnustt{=> #1}}

\newcommand{\gnusbullet}{{${\bullet}$}}
\newcommand{\gnusdollar}{\$}
\newcommand{\gnusampersand}{\&}
\newcommand{\gnuspercent}{\%}
\newcommand{\gnushash}{\#}
\newcommand{\gnushat}{\symbol{"5E}}
\newcommand{\gnusunderline}{\symbol{"5F}}
\newcommand{\gnusnot}{$\neg$}
\newcommand{\gnustilde}{\symbol{"7E}}
\newcommand{\gnusless}{{$<$}}
\newcommand{\gnusgreater}{{$>$}}
\newcommand{\gnusbraceleft}{{$>$}}
\newcommand{\gnusbraceright}{{$>$}}

\newcommand{\gnushead}{\raisebox{-1cm}{\epsfig{figure=ps/gnus-head,height=1cm}}}
\newcommand{\gnusinteresting}{
\marginpar[\mbox{}\hfill\gnushead]{\gnushead}
}

\newcommand{\gnuscleardoublepage}{\ifodd\count0\mbox{}\clearpage\thispagestyle{empty}\mbox{}\clearpage\else\clearpage\fi}

\newcommand{\gnuspagechapter}[1]{
{\mbox{}}
}

\newdimen{\gnusdimen}
\gnusdimen 0pt

\newcommand{\gnuschapter}[2]{
\gnuscleardoublepage
\ifdim \gnusdimen = 0pt\setcounter{page}{1}\pagestyle{gnus}\pagenumbering{arabic} \gnusdimen 1pt\fi
\chapter{#2}
\renewcommand{\gnussectionname}{}
\renewcommand{\gnuschaptername}{#2}
\thispagestyle{empty}
\hspace*{-2cm}
\begin{picture}(500,500)(0,0)
\put(480,350){\makebox(0,0)[tr]{#1}}
\put(40,300){\makebox(500,50)[bl]{{\Huge\bf{#2}}}}
\end{picture}
\clearpage
}

\newcommand{\gnusfigure}[3]{
\begin{figure}
\mbox{}\ifodd\count0\hspace*{-0.8cm}\else\hspace*{-3cm}\fi\begin{picture}(440,#2)
#3
\end{picture}
\caption{#1}
\end{figure}
}

\newcommand{\gnusicon}[1]{
\marginpar[\mbox{}\hfill\raisebox{-1.5cm}{\epsfig{figure=ps/#1-up,height=1.5cm}}]{\raisebox{-1cm}{\epsfig{figure=ps/#1-up,height=1cm}}}
}

\newcommand{\gnuspicon}[1]{
\margindex{\epsfig{figure=#1,width=2cm}}
}

\newcommand{\gnusxface}[2]{
\margindex{\epsfig{figure=#1,width=1cm}\epsfig{figure=#2,width=1cm}}
}

\newcommand{\gnussmiley}[2]{
\margindex{\makebox[2cm]{\hfill\epsfig{figure=#1,width=0.5cm}\hfill\epsfig{figure=#2,width=0.5cm}\hfill}}
}

\newcommand{\gnusitemx}[1]{\mbox{}\vspace*{-\itemsep}\vspace*{-\parsep}\item#1}

\newcommand{\gnussection}[1]{
\renewcommand{\gnussectionname}{#1}
\section{#1}
}

\newenvironment{codelist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{kbdlist}%
{\begin{list}{}{
\labelwidth=0cm
}
}{\end{list}}

\newenvironment{dfnlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{stronglist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{samplist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{varlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{emphlist}%
{\begin{list}{}{
}
}{\end{list}}

\newlength\gnusheadtextwidth
\setlength{\gnusheadtextwidth}{\headtextwidth}
\addtolength{\gnusheadtextwidth}{1cm}

\newpagestyle{gnuspreamble}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\mbox{}}\textbf{\hfill\roman{page}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\roman{page}\hfill\mbox{}}}
}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnusindex}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\gnuschaptername\hfill\arabic{page}}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnus}%
{
{
\ifodd\count0
{
\makebox[12cm]{\hspace*{3.1cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{chapter}.\arabic{section}} \textbf{\gnussectionname\hfill\arabic{page}}}}}
}
\else
{
\makebox[12cm]{\hspace*{-2.95cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\pagenumbering{roman}
\pagestyle{gnuspreamble}

@end iflatex
@end iftex

@iftex
@iflatex
\begin{titlepage}
{

%\addtolength{\oddsidemargin}{-5cm}
%\addtolength{\evensidemargin}{-5cm}
\parindent=0cm
\addtolength{\textheight}{2cm}

\gnustitle{\gnustitlename}\hfill\gnusversion{\gnusversionname}\\
\rule{15cm}{1mm}\\
\vfill
\hspace*{0cm}\epsfig{figure=ps/gnus-big-logo,height=15cm}
\vfill
\rule{15cm}{1mm}\\
\gnusauthor{by Lars Magne Ingebrigtsen}
\newpage
}

\mbox{}
\vfill

\thispagestyle{empty}

Copyright \copyright{} 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.


Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License'' in the Emacs manual.

この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契約書
第 1.1 版またはそれ以降の版が定める条件の下で複製、配布、あるいは変更す
ることを許可します。変更不可部分は指定しません。「A GNU Manual」は表表紙
テキスト、以下の (a) は裏表紙テキストです。この利用許諾契約書の複写は
「Emacs manual」の「GNU フリー文書利用許諾契約書」という章に含まれていま
す。

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''

(a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフトウェア
のように複製したり変更する自由があります。複製はフリーソフトウェア財団に
よって出版されました。(フリーソフトウェア財団は) GNU の開発のために必要
な資金を集めています。」

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.

この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集著作物
の一部です。もしあなたがこの文書を収集著作物から分離して配布したいときは、
契約書の第 6 項に記述されているように、文書に契約書の複写を付加すること
によって、行なうことができます。
\newpage
\end{titlepage}
@end iflatex
@end iftex

@ifnottex

This file documents gnus, the GNU Emacs newsreader.

このファイルは GNU Emacs のニュースリーダである gnus に関する説明書です。

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
        Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License'' in the Emacs manual.

この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契約書
第 1.1 版またはそれ以降の版が定める条件の下で複製、配布、あるいは変更す
ることを許可します。変更不可部分は指定しません。「A GNU Manual」は表表紙
テキスト、以下の (a) は裏表紙テキストです。この利用許諾契約書の複写は
「Emacs manual」の「GNU フリー文書利用許諾契約書」という章に含まれていま
す。

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''

(a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフトウェア
のように複製したり変更する自由があります。複製はフリーソフトウェア財団に
よって出版されました。(フリーソフトウェア財団は) GNU の開発のために必要
な資金を集めています。」

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.

この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集著作物
の一部です。もしあなたがこの文書を収集著作物から分離して配布したいときは、
契約書の第 6 項に記述されているように、文書に契約書の複写を付加すること
によって、行なうことができます。
@end ifnottex

@tex

@titlepage
@title T-gnus 6.15 Manual

@author by Lars Magne Ingebrigtsen
@author by members of Semi-gnus mailing-list
@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
        Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License'' in the Emacs manual.

この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契約書
第 1.1 版またはそれ以降の版が定める条件の下で複製、配布、あるいは変更す
ることを許可します。変更不可部分は指定しません。「A GNU Manual」は表表紙
テキスト、以下の (a) は裏表紙テキストです。この利用許諾契約書の複写は
「Emacs manual」の「GNU フリー文書利用許諾契約書」という章に含まれていま
す。

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''

(a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフトウェア
のように複製したり変更する自由があります。複製はフリーソフトウェア財団に
よって出版されました。(フリーソフトウェア財団は) GNU の開発のために必要
な資金を集めています。」

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.

この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集著作物
の一部です。もしあなたがこの文書を収集著作物から分離して配布したいときは、
契約書の第 6 項に記述されているように、文書に契約書の複写を付加すること
によって、行なうことができます。

@end titlepage
@page

@end tex

@node Top
@top The gnus Newsreader

@ifinfo

Gnus を使うことによって Emacs でニュース (news) を (それにメー
ル (mail) も) 読むことができます。ニュースは @sc{nntp}、ローカルスプール、
mbox ファイルなどのあらゆる極悪な手段を駆使して手に入れることができます。
運試しをしてみようと思うならば、全てを同時に用いることもできます。

T-gnus は @sc{semi} API に基づく @sc{mime} 機能を提供します。そういう訳
で、T-gnus は大きな絵が入っていたりさまざまな形式を用いたりしているちょっ
と変わった記事を読む権利を擁護します。T-gnus は MULE API に基づく国際化・
地域化、および、多字化機能を提供します。よって、T-gnus はさまざまな言語
圏を差別しません。ああ、クリンゴンの方は Unicode Next Generation をお待
ちください。

この説明書は T-gnus 6.15 に対応します。

@end ifinfo

@iftex

@iflatex
\tableofcontents
\gnuscleardoublepage
@end iflatex

Gnus は GNU Emacs の先進的で、説明のある、カスタマイズ可能で、拡張可能な、
リアルタイムでないニュースリーダーです。

おおっと。不思議なことに以前にも似たようなことを聞いたことがあるような気
がします。真似をしたと非難されないうちに説明を始めましょう:

Gnus はメッセージを読むことに関する実験場です。Gnus はすべてをニュースグ
ループのように表示します。Gnus でメールを読み、ディレクトリーをブラウズ
し、@code{ftp} をすることができます。ああ、それに、ニュースを読むことさ
えできます!

Emacs が文章を編集する人に力を与えるように、gnus はニュースを読む人に力
を与えようとしています。Gnus は利用者が実行可能なことに制限を設けません。
利用者が自分で望む動作をするように gnus を拡張することを奨励しています。
プログラムが人を操作するべきではありません。人がプログラムを使う (もしく
は濫用する) ことによって、やりたいことをできるようになっているべきなので
す。

@end iftex

@menu
* Starting Up::                 ニュースを見つけるのには苦労が伴うかも知
                                れない
* Group Buffer::                グループを選択し、購読し、削除する
* Summary Buffer::              記事を読み、保存し、投稿する
* Article Buffer::              記事を表示し、扱う
* Composing Messages::          メールとニュースを送るための情報
* Select Methods::              Gnus は全てのメッセージをいろいろな選択
                                方法で読む
* Scoring::                     記事に値をつける
* Various::                     一般的な設定
* The End::                     さらば、そしてさようなら
* Appendices::                  用語、Emacs 入門、FAQ、歴史、内部構造
* Index::                       変数、関数、概念の索引
* Key Index::                   キー索引

@detailmenu
 --- The Detailed Node Listing ---

Starting Gnus

* Finding the News::            ニュースを取得する方法を選ぶ
* The First Time::              最初に起動したときに gnus は何をするか
* The Server is Down::          どうすればそのようなときにメールを手に入
                                れることができるか
* Slave Gnusae::                同時に一つ以上の gnus を作動させることが
                                できる
* Fetching a Group::            グループを読むためだけに gnus を起動する
* New Groups::                  Gnus が新しいグループに対して何をするか
* Changing Servers::            あるサーバから別のサーバへ移りたいかもし
                                れない
* Startup Files::               やっかいなスタートアップファイル --
                                @file{.newsrc}
* Auto Save::                   クラッシュからの回復
* The Active File::             遅い回線からのファイルの取得には時間がか
                                かる
* Startup Variables::           変更したいと思うかもしれない変数

New Groups

* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して gnus は何をすべき
                                か
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる

Group Buffer

* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印をつけておいて、後で処理でき
                                ます
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメータを持たせられ
                                ます
* Listing Groups::              Gnus はグループをいろいろな分け方で表示
                                できます
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな @file{.newsrc} の保ち方
* Browse Foreign Server::       サーバを概観できる。何が読めるのか見てみ
                                よう
* Exiting Gnus::                ニュース読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割
                                する
* Misc Group Stuff::            他にできること

Group Buffer Format

* Group Line Specification::    グループバッファの見え方を決める
* Group Modeline Specification::  グループバッファのモード行
* Group Highlighting::          グループバッファにきれいに色をつける

Group Topics

* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックの全てのグループに適用される
                                パラメータ

Misc Group Stuff

* Scanning New Messages::       Gnus に新しいメッセージが到着したかどう
                                かを聞く
* Group Information::           グループと gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記
                                録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理

Summary Buffer

* Summary Buffer Format::       概略バッファの外観を決定する
* Summary Maneuvering::         概略バッファを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            
* Marking Articles::            記事に既読や期限切れ削除可能等の印を付け
                                る
* Limiting::                    概略バッファに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられる
                                か
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Article Backlog::             既に読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱
                                える
* Article Treatment::           記事バッファはお望みどおりに目茶苦茶にで
                                きる
@c * MIME Commands::               Doing MIMEy things with the articles.
@c * Charsets::                    Character set issues.
* Article Commands::            記事バッファでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファを並べ替える
* Finding the Parent::          子記事に援助が無いって? 親記事を取得しな
                                さい
* Alternative Approaches::      初期設定でない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使う
                                ことができる
* Various Summary Stuff::       他のどの場所にも合わなかったもの
* Exiting the Summary Buffer::  グループバッファに戻る、
                                または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われ
                                るか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手
                                段
@c * Security::                    Decrypt and Verify.
* Mailing List::                メーリングリストマイナーモード

Summary Buffer Format

* Summary Buffer Lines::        概略バッファがどのように見えるべきかを指
                                定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファをきれいで素敵にする

Choosing Articles

* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数

Reply, Followup and Post

* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::   

Marking Articles

* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印

Marking Articles

* Setting Marks::               印の付け方と消し方
* Generic Mark Commands::       印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方

Threading

* Customizing Threading::       変更可能なスレッドに影響する変数
* Thread Commands::             概略バッファでのスレッドに基づいた命令

Customizing Threading

* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッ
                                ドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう... でもあ
                                なたは間違っていた!

Decoding Articles

* Uuencoded Articles::          記事を uuencode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せな復号化のための変数
* Viewing Files::               復号化の結果を見たい?

Decoding Variables

* Rule Variables::              ファイルがどのように表示されるかを決める
                                変数
* Other Decode Variables::      他の復号化の変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数

Article Treatment

* Article Highlighting::        記事を果物サラダのように見えるようにした
                                い
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた
                                関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID や アドレスなどをクリッ
                                クする
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             X-Face, Picons, Smileys を表示する
* Article Signature::           署名って何?
* Article Miscellania::         他のいろいろなもの

Alternative Approaches

* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動-復号化する

Various Summary Stuff

* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::  
* Really Various Summary Commands::  あのやっかいな他に適合しない命令

Article Buffer

* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  @sc{mime} 記事として見せる
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファで使えるキー操作
* Misc Article::                その他

Composing Messages

* Mail::                        メールと返答
* Posting Server::              どのサーバーを通してニュースを投稿または
                                メールを送信するべきか?
* Mail and Post::               同時にメールを出し返答する
* Archived Messages::           送ったメッセージを gnus が貯めておくとこ
                                ろ
* Posting Styles::              あなたが誰であるかを指定するより簡単な方
                                法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を好きでないときに
                                何が起こる?
@c * Signing and encrypting::      How to compose secure messages.

Select Methods

* Server Buffer::               事実上のサーバーを作って編集する
* Getting News::                USENET ニュースを gnus で読む
* Getting Mail::                個人的なメールを gnus で読む
* Browsing the Web::            過剰なウェブの資源からメッセージを取得す
                                る
* IMAP::                        gnus を @sc{imap} のクライアントとして使う
* Other Sources::               ディレクトリー、ファイル、SOUP パケット
                                を読む
* Combined Groups::             複数のグループを一つのグループに結合する
* Gnus Unplugged::              ニュースとメールをオフラインで読む

Server Buffer

* Server Buffer Format::        このバッファの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使う事ができる
* Unavailable Servers::         接続しようと試みたサーバーのいくつかが落
                                ちているかもしれない

Getting News

* NNTP::                        @sc{nntp} サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む

@sc{nntp}

* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数

Getting Mail

* Mail in a Newsreader::        ニュースリーダでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              どのようにメールグループを作成するか
* Mail Sources::                Gnus にどこからメールを取ってくるかを知
                                らせる
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを、身の毛のよだ
                                つような分割をすることができる
* Group Mail Splitting::        メール分割を駆動するためにグループカスタ
                                マイズを使う
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               欲しくないメールを取り除く
* Washing Mail::                取得したメールから嫌なものを取り除く
* Duplicates::                  重複したメールを扱う
* Not Reading Mail::            他のファイルを読むためにメールバックエ
                                ンドを使う
* Choosing a Mail Back End::    Gnus は色々なメール様式を読む事ができる

Mail Sources

* Mail Source Specifiers::      メールの元がどこかを指定する
* Mail Source Customization::   世の中に影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使用する

Choosing a Mail Back End

* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Rmail Babyl::                 Emacs のプログラムは rmail の babyl フォー
                                マットを使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Mail Folders::                それぞれのグループに対して一つのファイル
                                を持つ
* Comparing Mail Back Ends::    得失の深い洞察

Browsing the Web

* Archiving Mail::              
* Web Searches::                文字列にマッチする記事からグループを作る
* Slashdot::                    Slashdot のコメントを読む
* Ultimate::                    Ultimate Bulletin Board システム
* Web Archive::                 ウェブに保管されたメーリングリストを読む
* Web Newspaper::               ウェブに保管された新聞を読む
* RSS::                         RDF Site Summary を読む
* Customizing w3::              Gnus から Emacs/W3 を操作する

@sc{imap}

* Splitting in IMAP::           nnimap でメールを分割する
* Editing IMAP ACLs::           メールボックスへの他の利用者の使用を制限
                                /許可する
* Expunging mailboxes::         "メールボックス圧縮" ボタンと等価なもの

Other Sources

* Directory Groups::            ディレクトリーをニュースグループのように
                                読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* SOUP::                        @sc{soup} パケットを ``オフライン'' で読む
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通し
                                て記事を投稿する

Document Groups

* Document Server Internals::   あなた独自の文書種別を追加する方法

SOUP

* SOUP Commands::               @sc{soup} パケットを作成、送出する命令
* SOUP Groups::                 @sc{soup} パケットを読むバックエンド
* SOUP Replies::                @code{nnsoup} にメールとニュースを引き継がせ
                                る方法

Combined Groups

* Virtual Groups::              たくさんのグループの記事を結合する
* Kibozed Groups::              ニューススプールの中からの記事を検索する

Gnus Unplugged

* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを gnus エージェン
                                トに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を消す方法
* Agent and IMAP::              エージェントを IMAP で使う方法
* Outgoing Messages::           投稿、メールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための @file{.gnus.el} の例
* Batching Agents::             @code{cron} ジョブによるニュース取得方法
* Agent Caveats::               あなたが予想することと、それが実際にする
                                こと
* Control Agents::              Offline をコントロールする gnus-offline

Agent Categories

* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス

Agent Commands

* Group Agent Commands::        
* Summary Agent Commands::      
* Server Agent Commands::       

Scoring

* Summary Score Commands::      現在のグループのためのスコア登録を追加す
                                る
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする
                                (まぁ、なんて用語でしょう)
* Score File Format::           スコアファイルに何を入れるか
* Score File Editing::          手でスコアファイルを編集する事もできる
* Adaptive Scoring::            大姉 (Big Sister) Gnus はあなたが何を読
                                んだか知っている
* Home Score File::             新しいスコア登録がどこへ行くかをどのよう
                                に指定するか
* Followups To Yourself::       人があなたに返答したときに gnus に気付か
                                せる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                どうやって効果的にスコアを付けるか
* Reverse Scoring::             古いものの子であるという問題は問題ではな
                                い
* Global Score Files::          地をつかみ、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにありますが、無視する事
                                ができる
* Converting Kill Files::       消去ファイルをスコアファイルに変換する
* GroupLens::                   どれを読むのが好きかの予言を得る
* Advanced Scoring::            スコアの法則を作るために論理表現を使う
* Score Decays::                スコアを枯れていかせるのは役に立つ事もあ
                                る

GroupLens

* Using GroupLens::             どのように gnus に GroupLens を使わせる
                                ようにするか
* Rating Articles::             GropLens にあなたがどのように値を付ける
                                かを知らせる
* Displaying Predictions::      GropuLens によって与えられた予言を表示す
                                る
* GroupLens Variables::         GoupLens をカスタマイズする

Advanced Scoring

* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限利用する

Various

* Process/Prefix::              多くの扱い命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの gnus の関数に選択権を提供する
                                方法
* Formatting Variables::        バッファがどのように見えるべきかを指定す
                                る事ができる
* Window Layout::               Gnus バッファウィンドウを設定する
* Faces and Fonts::             フェイスがどのように見えるかを変更する
* Compilation::                 どのようにして gnus の速度を上げるか
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファを素敵で心地よく見せる
* Buttons::                     簡単な十歩でアキレス腱を得る
* Daemons::                     Gnus はあなたの裏で物事を実行する事がで
                                きる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻す事ができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Image Enhancements::          最新の Emacs/XEmacs は絵を表示できる
* Fuzzy Matching::              大きな綿毛って何?
* Thwarting Email Spam::        余計な商業的電子メールを避ける方法
* Various Various::             本当にいろいろなもの

Formatting Variables

* Formatting Basics::           書法仕様変数は基本的に書法指定文字列であ
                                る
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの
                                規則
* Advanced Formatting::         色々な方法で出力を修正する
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う

Image Enhancements

* Picons::                      あなたが読んでいるものの絵を表示する方法
* Smileys::                     表示されるべく生まれた幸せそうな顔を表示
                                する方法
* X-Face::                      ファンキーなちっちゃな白黒の絵を表示する
* Toolbar::                     クリック猿
* XVarious::                    その他の XEmacs で Gnus な変数

Picons

* Picon Basics::                picon とは何で、どうやって手に入れるのか
* Picon Requirements::          XEmacs を使ってなければここからは読まな
                                いで
* Easy Picons::                 picon の表示 --- 楽な方法
* Hard Picons::                 本来すべきこと。何かを学ぶことができるだ
                                ろう
* Picon Useless Configuration::  その他のぶっ壊したりひねったりいじった
                                り遊んだりする変数

Thwarting Email Spam

* Anti-Spam Basics::            たくさんの spam を減らす簡単な方法
* SpamAssassin::                Spam 対策ツールの使い方
* Hashcash::                    CPU 時間を費やして spam 退治する

Appendices

* XEmacs::                      XEmacs でインストールするための要件
* History::                     どうやって gnus が今日のようになったか
* On Writing Manuals::          なぜこれが初心者用の案内でないか
* Terminology::                 我々は本当に難しい、語のような語を使う
* Customization::               あなたの要求に沿って gnus を仕立てる
* Troubleshooting::             上手く行かなかったときに試すかもしれない
                                こと
* Gnus Reference Guide::        色々な技術的なもの
* Emacs for Heathens::          Emacs の用語の手短な導入
* Frequently Asked Questions::

History

* Gnus Versions::               どんなバージョンの Gnus がリリースされて
                                いるか
* Other Gnus Versions::         リリースされている他のバージョンの Gnus
* Why?::                        Gnus の目的は何?
* Compatibility::               Gnus は @sc{gnus} とどれくらい互換性がある
                                の?
* Conformity::                  Gnus は全ての標準を満たそうとする
* Emacsen::                     Gnus はいくつかの現代的な Emacs 環境で実
                                行できる
* Gnus Development::            Gnus が開発されている方法
* Contributors::                大量の人々
* New Features::                Gnus の新しい事に関する手がかり

New Features

* ding Gnus::                   最初の新しい Gnus である Gnus 5.0/5.1 の
                                新しい事
* September Gnus::              公式に Gnus 5.2/5.3 として知られているも
                                の
* Red Gnus::                    三番目の最上のもの---Gnus 5.4/5.5
* Quassia Gnus::                2 かける 2 は 4、もしくは Gnus 5.6/5.7
* Pterodactyl Gnus::            五番目、P で始まる、もしくは Gnus 5.8
                                /5.9 として知られているもの

Customization

* Slow/Expensive Connection::   ローカルの Emacs を立ち上げて、他のとこ
                                ろからニュースを得る事ができる
* Slow Terminal Connection::    遠隔 Emacs を実行する
* Little Disk Space::           大きな起動ファイルを持つ事はまずい
* Slow Machine::                速い機械を買おうと感じるであろう

Gnus Reference Guide

* Gnus Utility Functions::      使用できる共通の関数と変数
* Back End Interface::          Gnus はどうやってサーバーと通信するのか
* Score File Syntax::           スコアファイル規格の BNF 定義
* Headers::                     Gnus はヘッダーを内部的にどのように格納
                                するか
* Ranges::                      たくさんの数を格納する便利な形式
* Group Info::                  グループ情報形式
* Extended Interactive::        記号接頭辞など
* Emacs/XEmacs Code::           Gnus は全ての近代 Emacsen で動作する
* Various File Formats::        Gnus の使用するファイルの形式

Back End Interface

* Required Back End Functions::  実装しなければならない関数
* Optional Back End Functions::  実装しなくてもよい関数
* Error Messaging::             メッセージやエラー報告を得る方法
* Writing New Back Ends::       古いバックエンドの拡張
* Hooking New Back Ends Into Gnus::  Gnus 側でしなければならないこと
* Mail-like Back Ends::         メール風バックエンドのための助言

Various File Formats

* Active File Format::          使用可能な記事グループの情報
* Newsgroups File Format::      グループの記述

Emacs for Heathens

* Keystrokes::                  文章を入力して命令を実行する
* Emacs Lisp::                  備え付けの Emacs プログラミング言語

@end detailmenu
@end menu

@node Starting Up
@chapter gnus の起動
@cindex starting up

@kindex M-x gnus
@findex gnus
システム管理者が適切な設定をしていたならば、gnus を起動してニュースを読
むのは非常に簡単です。そう、Emacs で @kbd{M-x gnus} と打つだけです。

@findex gnus-other-frame
@kindex M-x gnus-other-frame
別のフレーム (frame) で gnus を起動したいときは、命
令 @kbd{M-x gnus-other-frame} を使うことができます。

開始時に何かがうまくいかないときは @file{~/.gnus} ファイルの中で変数をい
くつかいじくりまわさなければならないでしょう。このファイル
は @file{~/.emacs} と似ていますが、こちらは gnus が起動するときに読み込
まれます。

この説明書でよくわからない用語がでてきたときは、用語の
項 (@pxref{Terminology}) を参照してください。

@menu
* Finding the News::            ニュースを取得する方法を選ぶ
* The First Time::              最初に起動したときに gnus は何をするか
* The Server is Down::          どうすればそのようなときにメールを手に入
                                れることができるか
* Slave Gnusae::                同時に一つ以上の gnus を作動させることが
                                できる
* Fetching a Group::            グループを読むためだけに gnus を起動する
* New Groups::                  Gnus が新しいグループに対して何をするか
* Changing Servers::            あるサーバから別のサーバへ移りたいかもし
                                れない
* Startup Files::               やっかいなスタートアップファイル --
                                @file{.newsrc}
* Auto Save::                   クラッシュからの回復
* The Active File::             遅い回線からのファイルの取得には時間がか
                                かる
* Startup Variables::           変更したいと思うかもしれない変数
@end menu

@node Finding the News
@section ニュースを見つける
@cindex finding news

@vindex gnus-select-method
@c @head
変数 @code{gnus-select-method} は gnus がどこでニュースを探すべきかを示
します。この変数ははじめの要素が @dfn{方法}、二番目の要素
が @dfn{場所} を表すリストである必要があります。この方法はあなたの基本方
法 (native method) になります。この方法で取ってこないグループは全て外
部 (foreign) グループです。

たとえば、@sc{nntp} サーバー @samp{news.somewhere.edu} から毎日 (薬のよ
うに) 一定の量のニュースを摂取したいのであれば、

@lisp
(setq gnus-select-method '(nntp "news.somewhere.edu"))
@end lisp

@noindent
のようにすることができます。

ローカル・スプールのディレクトリを読み込みたい場合は、

@lisp
(setq gnus-select-method '(nnspool ""))
@end lisp

@noindent
のようにできます。

ローカルのスプールを使えるのであれば、かなりの確率でその方がずっと速いで
しょうし、それを使うべきでしょう。でも、もしあなたのサーバー
が Leafnode であるならばローカルスプールを使ってはいけません。この場合
は @code{(nntp "localhost")} にしましょう。

@vindex gnus-nntpserver-file
@cindex NNTPSERVER
@cindex @sc{nntp} server
もしこの変数が設定されていなければ、gnus は @code{NNTPSERVER} 環境変数を
読みにいきます。もしその変数が設定されていなければ、
gnus は @code{gnus-nntpserver-file} (設定されていない場合
は @file{/etc/nntpserver}) がこの件に関して何かを言っていないかを調べま
す。もしそれも失敗したなら、gnus は Emacs が動作しているサーバー
を @sc{nntp} サーバーとして使おうとします。随分な当て推量ですけどね。

@vindex gnus-nntp-server
@code{gnus-nntp-server} が設定されていると、この変数
は @code{gnus-select-method} を上書きします。ですから、
@code{gnus-nntp-server} は @code{nil} に設定するべきで、初期設定でもその
ようになっています。

@vindex gnus-secondary-servers
@vindex gnus-nntp-server
Gnus に @sc{nntp} サーバーの名前の入力を対話的に指定することもできます。
@code{gnus} に数値でない接頭引数を渡すと (例: @kbd{C-u M-x gnus})、
gnus は @code{gnus-secondary-servers} リスト (もし存在するならば) からサー
バーを選ぶことができるようにします。ただ単に接続したいと思ったサーバーの
名前を打つこともできます。(これは @code{gnus-nntp-server} を設定し、これ
は後の Emacs のセッションで @kbd{M-x gnus} とすると、gnus は同じサーバー
に接続しようとするということです。)

@findex gnus-group-browse-foreign-server
@kindex B (グループ)
しかし、普段日常的には一つの @sc{nntp} サーバを使い、違ったサーバーには
興味のあるグループが少ししかない場合、グループバッファで @kbd{B} 命令を
使うことの方が良いでしょう。それは、選択可能なグループを表示し、その中か
らどれでも好きなものを購読することができます。これは、@file{.newsrc} の
保持をずっとやりやすくします。@xref{Foreign Groups, 外部グループ}.

@vindex gnus-secondary-select-methods
@c @head
外部グループに対する少し違ったやり方は、変
数 @code{gnus-secondary-select-methods} を設定する方法です。この変数に表
されている選択方法は、多くの点で @code{gnus-select-method} サーバーの択
方法と同じように扱われます。起動中にアクティブファイルを探しにいき (もし
要求されていれば)、これらのサーバー上にできた新しいニュースグループは元々
のグループと同じように購読 (もしくは非購読) されます。

たとえば、メールを読むために @code{nnmbox} バックエンド (back end) を使
いたいときは、普通、この変数を、

@lisp
(setq gnus-secondary-select-methods '((nnmbox "")))
@end lisp

@noindent
と設定します。

@node The First Time
@section 一番初め
@cindex first time usage

起動用ファイルが存在しないときは、gnus はディフォルトでどのグループが購
読されているべきかを決定しようとします。

@vindex gnus-default-subscribed-newsgroups
変数 @code{gnus-default-subscribed-newsgroups} が設定されていると、
gnus はそのリストの中のグループを購読し、残りを削除します。システム管理
者はこの変数を何か役に立つものに設定しておくことが望まれます。

そうでないときは、gnus は少しの任意のグループを購読します (例:
@samp{*.newusers})。(@dfn{任意}はここでは、@dfn{Lars さんが読むべきであ
ると考えるもの}というように定義されています)

また、たいていの共通の問題の解決の手助けになるよう、gnus に関する文書の
グループも購読することになるでしょう。

@code{gnus-default-subscribed-newsgroups} が @code{t} のときは、gnus は
新しいグループを扱うのに普通の関数を使い、特別なことは何もしません。

@node The Server is Down
@section サーバーが落ちている
@cindex server errors

初期設定 (default) のサーバーが落ちているときは、当然 gnus の起動にいく
つかの問題が発生します。しかし、ニュースグループの他にいくつかメールのグ
ループがあれば、それにもかかわらず gnus を起動したいと思うかもしれません。

Gnus は、信頼できるプログラムの一つとして、サーバーと接続できないときは
基本選択方法なしで続けるかどうかを尋ねます。これは実際にはサーバーが存在
しないとき (例えば、アドレスを間違えた場合) やサーバーが何らかの理由で一
時的に調子がおかしくなっているときに起こります。もしそのまま続行すること
にして、外部グループが一つも無い場合、実はグループバッファではほとんど何
もできないということに気がつくでしょう。でも、ねぇ、それはあなたの問題で
す。ハハハッ。

@findex gnus-no-server
@kindex M-x gnus-no-server
@c @head
サーバーが完全に落ちているのを知っているか、サーバーでわずらうことなくメー
ルだけを読みたいときは、gnus を起動するのに、@code{gnus-no-server} 命令
を使うことができます。急いでいるときにもぴったりでしょう。この命令は本来
のサーバーには接続しません――その代わりに、レベル 1 と 2 にあるすべての
グループを活動状態にします (基本グループでないグループはその二つのレベル
にしておくのが望ましいでしょう)。@pxref{Group Levels} も参照して下さい。

@node Slave Gnusae
@section gnus をスレーブにする
@cindex slave

あなたは二つ以上の Emacs と、二つ以上の gnus を同時に動かしたいと思うか
もしれません。違った @file{.newsrc} ファイルを使っているなら (例えば、
二つの違ったサーバーから読み込むために、二つの違った gnus を動作させてい
る場合)、まったく問題はありません。それを行えば良いだけです。

問題は、同じ @code{.newsrc} ファイルを使う二つの gnus を動かそうとしたと
きに起こります。

この問題に対処するために、gnus タワーのシンクタンクにいる我々は新しい概
念にたどりつきました。@dfn{マスター} と @dfn{スレーブ} です。(我々はこの
概念に特許を申請しました。そして、その言葉の著作権を得ました。お互いに関
連してこれらの言葉を使いたいなら、一回使う毎に、私に $1 を送らなければな
りません。もっちろん、@dfn{コンピューターアプリケーションのマスター／ス
レーブ関係} の使用料はもっと高くなります。)

とにかく、@kbd{M-x gnus} (もしくは、普段やっている方法) で gnus を普通に
起動します。その後のスレーブ gnus はそれぞれ @kbd{M-x gnus-slave} で起動
します。スレーブは普通の @file{.newsrc} は保存しませんが、代わり
に @dfn{スレーブファイル} にスレーブの起動中にどのようなグループが読まれ
たかという情報だけを保存します。マスター gnus が起動するとき、それはそれ
らのスレーブファイルを読み込み (そして消し)、それらからすべての情報を取
り込みます。(スレーブファイルは、最終的な変更が優先されるようにそれらが
作られた順番で読まれます。)

もちろん、スレーブファイルからの情報は普通の (すなわち、マスターの) ファ
イルよりも優先されます。

スレーブを起動するときにもしマスターの @code{.newsrc*} ファイル群がセー
ブされていなかったら、自動保存されたファイルを読むかどうかを尋ねられるか
もしれません。"yes" と答えると、マスターにセーブされていない変更はスレー
ブに反映されません。"no" と答えると、マスターで読まれたいくつかの記事が、
スレーブでは未読であると見なされるかもしれません。

@node Fetching a Group
@section グループを取得する
@cindex fetching a group

@findex gnus-fetch-group
時々、“このグループを読みたいのであって、gnus が起動しているかどうかを
気にしたくない。”ということができれば便利なことがあります。これは、利用
者よりもプログラムのコードを書く人に便利な機能ですが、どちらにしろ、コマ
ンド @code{gnus-fetch-group} はこの機能を提供します。そのコマンドは、グ
ループの名前を引数としてとります。

@node New Groups
@section 新しいグループ
@cindex new groups
@cindex subscription

@vindex gnus-check-new-newsgroups
新しいニュースグループを全く見ないで満足であるならば、
@code{gnus-check-new-newsgroups} を @code{nil} に設定することができます。
これを設定した場合、起動にかかる時間が短くなります。この変数
が @code{nil} に設定されていても、グループバッファで @kbd{U} を押せばい
つでも新しいグループを購読することができます (@pxref{Group Maintenance})。
初期設定ではこの変数は @code{ask-server} です。この変数
が @code{always} に設定されていると、命令 @kbd{g} を実行したときで
も gnus はバックエンドに新しいグループを探すことを求めま
す (@pxref{Scanning New Messages})。

@menu
* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して gnus は何をすべき
                                か
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる
@end menu

@node Checking New Groups
@subsection 新しいグループを調べる

Gnus は、普通はグループが新しいかどうかを、購読しているグループと削除さ
れているグループのリストとアクティブファイルを比較することにより決定して
います。この方法は特に速いというわけではありません。
@code{gnus-check-new-newsgroups} が @code{ask-server} であると、gnus は
サーバーに、最後に接続してから新しいグループができているかどうかを尋ねま
す。この方法は速いし、安上がりです。これにより、削除されたグループのリス
トを保持しておくことからから完全に開放されます。ですから、
@code{gnus-save-killed-list} を @code{nil} にすることができるでしょう。
そうすれば、起動、終了の両方、そして全体にわたって時間を節約できます。ディ
スク消費量も少なくなります。それなら、どうしてこれが初期設定ではないので
しょう? 残念ながら、すべてのサーバーがこの命令を理解するわけではないので
す。

私は今あなたが何を考えているかを当てられます。どうすればサーバー
が @code{ask-server} を理解するかがわかるのでしょう? え、違うのです
か? あぁ、良かった。というのは、確実な答は存在しないのです。私に言えるこ
とは、この変数を @code{ask-server} に設定して、数日間新しいグループが現
れるかどうかを調べてください、ということだけです。もしいくつかのグループ
が現れたなら、それで動作しています。一つも現れなければ、それは動作してい
ません。私は、gnus にサーバーが @code{ask-server} を理解するかどうかを推
量させる関数を書くこともできますが、それは単に推量しているにすぎません。
ですから、その関数を書くことはないでしょう。他の方法としては、サーバー
に @code{telnet} をして、@code{HELP} と打ち、サーバーが理解するコマンド
の中に @samp{NEWGROUPS} があるかどうかを調べることもできます。もしあれば、
おそらく動作するでしょう (しかし、適切に機能を提供することな
く @samp{NEWGROUPS} をリストに含めるサーバーもあります)。

この変数は、選択方法のリストであることもできます。そのときは、gnus は命
令 @code{ask-server} をそれぞれの選択方法に対して実行し、普通の方法で購
読 (もしくは、非購読) します。これの副作用は、起動にかなり時間がかかるの
で、待っている間に瞑想できることです。永久の幸福を達成するために、マント
ラ ``dingnusdingnusdingnus'' を使ってください。

@node Subscription Methods
@subsection 購読方法

@vindex gnus-subscribe-newsgroup-method
新しいグループに遭遇したときに gnus が何をするかは、変
数 @code{gnus-subscribe-newsgroup-method} によって決定されます。

この変数は関数を含んでいる必要があります。この関数は新しいグループの名前
を唯一の引数として呼ばれます。

いくつかの手軽なプレハブ関数は、以下のようになっています。

@table @code
@item gnus-subscribe-zombies
@vindex gnus-subscribe-zombies
すべての新しいグループをゾンビ (zombie) にします。これが初期設定 になっ
ています。後でゾンビを (@kbd{A z} によって) 概観したり、(@kbd{S z} によっ
て) 適切に全てを削除したり、(@kbd{u} によって) 購読したりできます。

@item gnus-subscribe-randomly
@vindex gnus-subscribe-randomly
任意の順番ですべての新しいグループを購読します。実際には、すべての新しい
グループはグループバッファの『一番上』に加えられます。

@item gnus-subscribe-alphabetically
@vindex gnus-subscribe-alphabetically
すべての新しいグループをアルファベット順に購読します。

@item gnus-subscribe-hierarchically
@vindex gnus-subscribe-hierarchically
すべての新しいグループを階層的に購読します。この関数
と @code{gnus-subscribe-alphabetically} の違いは少ししかありません。
@code{gnus-subscribe-alphabetically} は新しいグループを厳密にアルファベッ
ト順にならべますが、この関数はグループをその階層の中に入れます。ですから、
@samp{rec} の階層を @samp{comp} の階層の前に持ってきたい場合、この関数は
その配置をぐちゃぐちゃにはしません。もしくは、そのようなものです。

@item gnus-subscribe-interactively
@vindex gnus-subscribe-interactively
新しいグループを対話的に購読します。これは gnus が @strong{全て} のグルー
プに対して尋ねることを意味しています。購読するグループは階層的に購読され
ます。

@item gnus-subscribe-killed
@vindex gnus-subscribe-killed
すべての新しいグループを削除します。

@item gnus-subscribe-topics
@vindex gnus-subscribe-topics
グループを合致する @code{subscribe} トピックパラメータのあるグループに入
れます (@pxref{Topc Parameters})。例えば、以下のよう
な @code{subscribe} パラメータ

@example
"nnslashdot"
@end example

はその正規表現に合致する全てのグループはそのトピックの下で購読されるとい
うことです。

グループに合致するトピックが無い場合、グループは最上位のトピックで購読さ
れます。
@end table

@vindex gnus-subscribe-hierarchical-interactive
上の変数と良く関係した変数は、
@code{gnus-subscribe-hierarchical-interactive} です。この変数
が @code{nil} でないと、gnus は階層的な方法で新しいグループを購読するか
どうかを尋ねます。gnus はそれぞれの階層で、それを下に降りるかどうかを尋
ねます。

よくある間違いは、数段落前の変
数 (@code{gnus-subscribe-newsgroup-method}) を @code{gnus-subscribe-herarchical-interactive} に
設定することです。これは誤りです。これは動作しません。これはおめでたい人
のすることです。ですから、絶対にしないでください。

@node Filtering New Groups
@subsection 新しいグループを選別する

どの新しいグループが購読 (もしくは、無視) されるべきかを管理する快適で手
軽な方法は、ファイル @file{.newsrc} の先頭に @dfn{options} 行を挿入する
ことです。次は、例です。

@example
options -n !alt.all !rec.all sci.all
@end example

@vindex gnus-subscribe-options-newsgroup-method
この行は、明らかにまじめで理知的で科学的な人間 (もしくは単なる古く退屈な
人間) が書いたものです。なぜなら、これは @samp{alt} と @samp{rec} で始ま
る名前を持つグループは全て無視され、@samp{sci} で始まる名前を持つグルー
プは全て購読する、ということを表しているからです。Gnus はこれらのグルー
プを購読するのに、普通の購読方法を用いません。代わりに、
@code{gnus-subscribe-options-newsgroup-method} が用いられます。この変数
は初期設定では @code{gnus-subscribe-alphabetically} です。

@vindex gnus-options-not-subscribe
@vindex gnus-options-subscribe
ファイル @file{.newsrc} をいじりたくない場合は、
@code{gnus-options-subscribe} と @code{gnus-options-not-subscribe} の二
つの変数だけを設定することもできます。この二つの変数はファイ
ル @file{.newsrc} の @samp{optinos -n} 行と全く同じことをします。どちら
の変数も正規表現で、新しいグループは前者に合致すれば無条件に購読され、後
者に合致すると無視されます。

@vindex gnus-auto-subscribed-groups
さらにここでおせっかいをする変数は、
@code{gnus-auto-subscribed-groups} です。それ
は @code{gnus-options-subscribe} と全く同じように動作しますので、本当は
余分なものです。しかし、私はこの二つがあった方が良いと思いました。もう一
方の変数はユーザがいじくるのに使われるのに対して、この変数はいくつかの基
本的な規則を設定するためのものです。初期設定ではこの変数はメールバックエ
ンド (@code{nnml}, @code{nnbabyl}, @code{nnfolder}, @code{nnmbox},
@code{nnmh} および @code{nnmaildir}) からできる全ての新しいグループを購
読するようになっています。それが嫌であれば、この変数を @code{nil} に設定
してください。

この正規表現に合致する新しいグループ
は @code{gnus-subscribe-options-newsgroup-method} を使って購読されます。

@node Changing Servers
@section サーバーを換える
@cindex changing servers

ときどき、ある @sc{nntp} サーバーから別のサーバーへ移動しなければならな
いことがあります。このようなことはめったにおきませんが、おそらくあなたが
仕事を変えたり、使っているサーバーがとても不安定で、別のものに乗り換えた
いというときに必要になるでしょう。

サーバーを変更するのはとても簡単ですよね? @code{gnus-select-method} を新
しいサーバーを指し示すように変更すればいいだけですね?

@emph{違います!}

記事の番号は違った @sc{nntp} サーバーでも (どうにかして) 同じにしてある、
ということはありません。そして、gnus がどの記事を読んだかを記録する唯一
の方法は、記事番号を記録することです。ですから、
@code{gnus-select-method} を変更したときは、ファイル @file{.newsrc} は意
味がなくなります。

Gnus はファイル @file{.newsrc} をあるサーバー用から別のサーバー用に変換
する関数を二、三用意しています。それらには一つ共通点があります---実行に
ながーーい時間がかかることです。おそらく、どうしても必要になったとき以外
にこの関数を使おうとは思わないでしょう。

@kindex M-x gnus-change-server
@findex gnus-change-server
もし両方のサーバーに接続できるなら、gnus はあなたが読んだ記事全てに対し
てヘッダー (headers) を要求して、@code{Message-ID} を比較し、読んだ記事
と記事の印を新しく記録します。コマンド @kbd{M-x gnus-change-server} はこ
れをすべての基本グループに対して行います。そのコマンドは移動先の方法の入
力を促します。

@kindex M-x gnus-group-move-group-to-server
@findex gnus-group-move-group-to-server
個々のグループを命令 @kbd{M-x gnus-group-move-group-to-server} で移
動することもできます。これはあるサーバーから別のサーバーへ一つ
の (外部) グループを移動したいときに役に立ちます。

@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
古いサーバーと新しいサーバーの両方に接続することができないとき、印と読ん
だ範囲はすべて意味が無くなります。そのようなときは、コマンド @kbd{M-x
gnus-group-clear-data-on-native-groups} を使って、基本グループに関するデー
タをすべて消去することができます。このコマンドは注意して使ってください。

@kindex M-x gnus-group-clear-data
@findex gnus-group-clear-data
現在のグループの全てのデータをクリアします――マークと既読記事のリストを
消し去ります (@code{gnus-group-clear-data})。

サーバーを変更した後で、キャッシュ階層を移動させなければ@strong{なりませ
ん}。というのは、キャッシュ記事は間違った記事番号になっており、それ
は gnus がどの記事を読んだとみなすかに影響します。
@code{gnus-group-clear-data-on-native-groups} はそれを自動で行なってしま
うかどうかを尋ねます。@code{gnus-group-clear-data} で
は @kbd{M-x gnus-cache-move-cache} が使えます (でも気を付けて、それはす
べてのグループのキャッシュを移動してしまいますから)。

@node Startup Files
@section 起動ファイル
@cindex startup files
@cindex .newsrc
@cindex .newsrc.el
@cindex .newsrc.eld

今や、あなたはファイル @file{.newsrc} についてすべて知っています。すべて
の購読情報は伝統的にこのファイルに蓄積されます。

@sc{gnus} では物事が少々複雑になっています。ファイル @file{.newsrc} を最
新のものにするだけではなく、ファイル @file{.newsrc} には合わない情報を保
存しておくために @file{.newsrc.el} と呼ばれるファイルを使います。(実際
は、ファイル @file{.newsrc} の全ての情報を複製して保持していま
す。) @sc{gnus}はこれらの中で一番最後に保存されたものを使います。これを
することにより、@sc{gnus} と他のニュースリーダーを切り替えて使うことがで
きます。

これはちょっとばかな方法なので、gnus はもっと良い方法を編み出しました。
@file{.newsrc} と @file{.newsrc.el} ファイルに加えて、
gnus は @file{.newsrc.eld} と呼ばれるファイルも持っています。Gnus はこれ
らの中で一番新しいファイルを読みますが、ファイル @file{.newsrc.el} に書
き込むことはありません。ファイル @file{.newsrc.eld} は絶対に消すべきでは
ありません。---それはファイル @file{.newsrc} にはないたくさんの情報を保
持しています。

@vindex gnus-save-newsrc-file
@vindex gnus-read-newsrc-file
@code{gnus-save-newsrc-file} を @code{nil} にすることによってファイ
ル @file{.newsrc} に書き込むのを止めることができます。そうすれば、そのファ
イルを削除することができ、ディスク容量を節約することができ、gnus の終了
が速くなります。しかし、そうすると他のニュースリーダーを使えなくなります。
でも、ちょっと、誰かそうしたい人がいるでしょうか。同じよう
に @code{gnus-read-newsrc-file} を @code{nil} にすることによっ
て @file{.newsrc} とすべての @file{.newsrc-SERVER} を作らないようになり
ます。もしあなたが時々 Netscape を使うのならば、こうするのが都合が良いで
しょう。

@vindex gnus-save-killed-list
@code{gnus-save-killed-list} (初期設定では @code{t}) が @code{nil} であ
ると、gnus は削除されたグループを起動ファイルに保存しません。これは、(起
動時と終了時の) 時間と、(ディスクの) 容量を節約します。こうすると、
gnus がどのグループが新しいかの記録を持っていないことになりますので、新
しいグループの自動購読方法は意味が無くなります。この変数を @code{nil} に
したときは、@code{gnus-check-new-newsgroups} を常
に @code{nil} か @code{ask-server} にしておくべきでしょ
う (@pxref{New Groups})。この変数は正規表現であることもできます。そのよ
うな場合は、ファイルを保存する直前にその正規表現に合致しないすべてのグルー
プを消去します。これは、すべてのサーバーが @code{ask-server} を理解する
わけではない、といったような、特定のあいまいな状況のときに役に立つでしょ
う。

@vindex gnus-startup-file
変数 @code{gnus-startup-file} は起動ファイルがどこにあるかを指定します。
初期値は @file{~/.newsrc} で、それがどのようなものであれ、末尾
に @samp{.eld} をつけたものが gnus (El Dingo) の起動ファイルになります。

@vindex gnus-save-newsrc-hook
@vindex gnus-save-quick-newsrc-hook
@vindex gnus-save-standard-newsrc-hook
@code{gnus-save-newsrc-hook} は newsrc ファイルの中のどれかを保存する前
に実行されるのに対し、@code{gnus-save-quick-newsrc-hook} はファイ
ル @file{.newsrc.eld} を保存する前に実行され、
@code{gnus-save-standard-newsrc-hook} はファイル @file{.newsrc} を保存す
る前に実行されます。後の二つは普通は版管理を入れたり切ったりするのに使わ
れます。初期設定では、起動ファイルを保存するときに版管理に入ります。バッ
クアップファイルの作成を止めたいときは、次のようにしてください。

@lisp
(defun turn-off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'gnus-save-quick-newsrc-hook 'turn-off-backup)
(add-hook 'gnus-save-standard-newsrc-hook 'turn-off-backup)
@end lisp

@vindex gnus-init-file
Gnus が起動すると、@code{gnus-site-init-file} (初期設定で
は @file{.../site-lisp/gnus}) と @code{gnus-init-file} (初期設定で
は @file{~/.gnus}) のファイルを読み込みます。これらは普通
の Emacs Lisp ファイルで、@file{~/.emacs} や @file{site-init} ファイル
を gnus 関係のもので乱雑にしないようにするために使うことができます。
Gnus はこれらと同じ名前のファイルを調べますが、接尾
語 @file{.elc} と @file{.el} がついているものも調べます。言い換えれば、
@code{gnus-init-file} を @file{~/.gnus} に設定すると、gnus は (この順番
に) @file{~/.gnus.elc}, @file{~/.gnus.el} を探し、最後
に @file{~/.gnus} を探します。

@node Auto Save
@section 自動保存
@cindex dribble file
@cindex auto-save

何か gnus のデータを変更すること (記事を読む、印を付ける、グループを削除
または購読する) をしたとき、変更は特別な@dfn{ドリブルバッファ (dribble
buffer)} に書き込まれます。このバッファはEmacs が普通するように自動保存
されます。ファイル @file{.newsrc} を保存する前に Emacsが落ちたときは、す
べての変更をこのファイルから回復することができるでしょう。

起動時に gnus がこのファイルの存在を発見すると、gnus はそれを読み込むか
どうかを利用者に尋ねます。本当の起動ファイルが保存されれば、自動保存ファ
イルは削除されます。

@vindex gnus-use-dribble-file
@code{gnus-use-dribble-file} が @code{nil} であると、gnus はドリブルバッ
ファをつくったり、維持したりしません。初期値は @code{t} です。

@vindex gnus-dribble-directory
Gnus はドリブルファイルを @code{gnus-dribble-directory} に置きます。ディ
フォルトではそのようになっていますが、この変数が @code{nil} であると、
gnus はファイル@file{.newsrc} の置かれているディレクトリ (これは普通は利
用者のホームディレクトリです) に入っていってドリブルファイルを作ります。
ドリブルファイルは @code{.newsrc} と同じ許可属性を与えられます。

@vindex gnus-always-read-dribble-file
もし @code{gnus-always-read-dribble-file} が @code{nil} でなければ、
gnus は利用者に尋ねる事無く、ドリブルファイルを起動時に読み込みます。

@node The Active File
@section アクティブファイル
@cindex active file
@cindex ignored groups

Gnus は起動したときや、実際に新しい記事が到着しているかを決定しようとす
るときに、アクティブファイルを読み込みます。これはとても大きなファイルで、
そのサーバーの活動中のグループと記事のすべてのリストが入っています。

@vindex gnus-ignored-newsgroups
アクティブファイルを検査する前に、gnus は正規表
現 @code{gnus-ignored-newsgroups} に合うすべての行を削除します。これは主
に偽の名前を持つグループを排除するために使われてきましたが、興味の無いグ
ループの階層を無視するために使うこともできます。しかし、これはお勧めでき
ません。本当のことを言うと、全く賛成できません。代わりに、そのような用途
に用いられる変数の概略を知るために、@pxref{New Groups} を参照してくださ
い。

@c This variable is
@c @code{nil} by default, and will slow down active file handling somewhat
@c if you set it to anything else.

@vindex gnus-read-active-file
@c @head
アクティブファイルは比較的大きくなる傾向があるので、遅い回線を使っている
ときは、アクティブファイルを読み込まないよう
に @code{gnus-read-active-file} を @code{nil} に設定することができます。
この変数は初期設定では @code{some} です。

そのような時は、gnus は実際に購読されているグループに関する情報だけを得
てやっていこうとします。

気を付けてほしいのは、あなたが山ほどのたくさんのグループを購読していると
きにこの変数を @code{nil} 設定すると、gnus は速くなるどころか、遅くなっ
てしまうということです。現状では、ニュースを 2400bps 以上のモデムを通し
て読んでいるのでない限り、gnus の速度はかなり遅くなるでしょう。

この変数は @code{some} という値も取ることができます。その時は、gnus は現
状の情報を購読されているグループのものだけを得ようとします。いくつかのサー
バー (命令 @code{LIST ACTIVE group} を使うことのできる、最新鋭の INN サー
バー) では、非常に早くなるでしょうが、他のサーバーでは速くはありません。
どのようにせよ、遅い回線では @code{some} は @code{nil} よりも速く、それ
はもちろん@code{t} よりも速くなります。

いくつかのニュースサーバー (例えば古い Leafnode や古い INN) には命
令 @code{LIST ACTIVE group} がありません。そういうサーバーに
は @code{nil} をこの変数の値に設定するのが、おそらくもっとも有効でしょう。

もしこの変数が @code{nil} であると、gnus は完全にがんじがらめの方法でグ
ループの情報を得ようとします。そして、これはあまり速くありません。もしそ
れが @code{some} で @sc{nntp} サーバーを使っているときは、gnus はできる
だけ速く命令を出し、一撃ですべての返答を読み込みます。この方が普通はより
良い結果をもたらしますが、サーバーが命令 @code{LIST ACTIVE group} を理解
しないなら、サーバーにとってはあまり良いとは言えません。

Gnus の起動にあまりに時間がかかると思ったなら、この変数にこれらの三つの
違った値を試してみて、どれが一番良いかを探してください。

@code{some} か @code{nil} を使うのであれば、どちらにしろ速度を上げるため
にすべての興味の無いグループを必ず削除するべきでしょう。

この変数は二次 (secondary) 選択方法のアクティブファイル取得にも影響する
ことに気を付けてください。

@node Startup Variables
@section 起動変数

@table @code
@item gnus-load-hook
@vindex gnus-load-hook
Gnus が読み込まれているときに実行されるフックです。何度 gnus を起動して
も、Emacs が起動してから終了するまでに普通はこのフックは一回しか実行され
ないことに注意してください。

@item gnus-before-startup-hook
@vindex gnus-before-startup-hook
Gnus の起動に成功した後に実行されるフックです。

@item gnus-startup-hook
@vindex gnus-startup-hook
Gnus が起動された後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook
Gnus の起動に成功した後に、一番最後に実行されるフックです。

@item gnus-setup-news-hook
@vindex gnus-setup-news-hook

ファイル @file{.newsrc} を読み込んだ後で、グループバッファを作成する前に
実行されるフックです。

@item gnus-check-bogus-newsgroups
@vindex gnus-check-bogus-newsgroups
もし @code{nil} でないと、gnus は起動時に調べてすべての偽グループを削除
します。@dfn{偽グループ (bogus group)} はあなたの @file{.newsrc} ファイ
ルには存在するけれど、ニュースサーバーには実際には存在しない、というグルー
プのことです。偽グループを調べるのにはかなり時間がかかりますので、時間と
資源を節約するために、この機能は使わないほうがいいでしょう。そして、代わ
りにグループバッファで時々偽グループを調べるのが良いでしょ
う (@pxref{Group Maintenance})。

@item gnus-inhibit-startup-message
@vindex gnus-inhibit-startup-message
もし @code{nil} でないと、起動時のメッセージは表示されません。そのように
すれば、仕事の代わりにニュースを読んでいるのを上司に気付かれにくくなるで
しょう。この変数は @file{.gnus.el} がロードされる前に使われますので、
@code{.emacs} に設定するべきである点を注意してください。

@item gnus-no-groups-message
@vindex gnus-no-groups-message
グループが一つも存在しないときに gnus が表示するメッセージです。

@item gnus-play-startup-jingle
@vindex gnus-play-startup-jingle
もし @code{nil} でないと、起動時に gnus の短い曲を演奏します。

@item gnus-startup-jingle
@vindex gnus-startup-jingle
上の変数が @code{nil} でないときに演奏される短い曲です。初期値
は @samp{Tuxdemoon.Jingle4.au} です。
@end table

@node Group Buffer
@chapter グループバッファ
@cindex group buffer

@c Alex Schroeder suggests to rearrange this as follows:
@c
@c <kensanata> ok, just save it for reference.  I'll go to bed in a minute.
@c   1. Selecting a Group, 2. (new) Finding a Group, 3. Group Levels,
@c   4. Subscription Commands, 5. Group Maneuvering, 6. Group Data,
@c   7. Group Score, 8. Group Buffer Format
@c <kensanata> Group Levels should have more information on levels 5 to 9.  I
@c   suggest to split the 4th paragraph ("Gnus considers groups...") as follows:
@c <kensanata> First, "Gnus considers groups... (default 9)."
@c <kensanata> New, a table summarizing what levels 1 to 9 mean.
@c <kensanata> Third, "Gnus treats subscribed ... reasons of efficiency"
@c <kensanata> Then expand the next paragraph or add some more to it.
@c    This short one sentence explains levels 1 and 2, therefore I understand
@c    that I should keep important news at 3 and boring news at 4.
@c    Say so!  Then go on to explain why I should bother with levels 6 to 9.
@c    Maybe keep those that you don't want to read temporarily at 6,
@c    those that you never want to read at 8, those that offend your
@c    human rights at 9...

グループバッファ (@dfn{group buffer}) は有効なグループを全部 (あるいは一
部を) 一覧表示します。これは gnus を起動したときに最初に表示されるバッファ
で、gnus が生きている限り決して消されることはありません。

@iftex
@iflatex
\gnusfigure{The Group Buffer}{320}{
\put(75,50){\epsfig{figure=ps/group,height=9cm}}
\put(120,37){\makebox(0,0)[t]{Buffer name}}
\put(120,38){\vector(1,2){10}}
\put(40,60){\makebox(0,0)[r]{Mode line}}
\put(40,58){\vector(1,0){30}}
\put(200,28){\makebox(0,0)[t]{Native select method}}
\put(200,26){\vector(-1,2){15}}
}
@end iflatex
@end iftex

@menu
* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印をつけておいて、後で処理でき
                                ます
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメータを持たせられ
                                ます
* Listing Groups::              Gnus はグループをいろいろな分け方で表示
                                できます
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな @file{.newsrc} の保ち方
* Browse Foreign Server::       サーバを概観できる。何が読めるのか見てみ
                                よう
* Exiting Gnus::                ニュース読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割
                                する
* Misc Group Stuff::            他にできること
@end menu

@node Group Buffer Format
@section グループバッファの形式

@menu
* Group Line Specification::    グループバッファの見え方を決める
* Group Modeline Specification::  グループバッファのモード行
* Group Highlighting::          グループバッファにきれいに色をつける
@end menu

@node Group Line Specification
@subsection グループ行の仕様
@cindex group buffer format

グループバッファの初期設定形式はきれいでつまんないけど、これは君の好きな
ように、サイコーにダサくすることもできます。

これがグループ行の例です。

@example
     25: news.announce.newusers
 *    0: alt.fan.andrea-dworkin
@end example

とっても簡単でしょ?

@samp{news.announce.newusers} には 25 の未読記事があるのがわかります。
@samp{alt.fan.andrea-dworkin} には未読記事はないけれども、印をつけた記事
がいくつかあります (行頭のちっちゃなアスタリスクが見える?)。

@vindex gnus-group-line-format
この形式は @code{gnus-group-line-format} 変数をいじることで、どんな風に
でも変えられます。この変数は @code{format} の仕様風に動作します。つま
り (あのクソ) C 言語を使う人たちのため、printf の仕様とほぼ同じです。
@xref{Formatting Variables}

@samp{%M%S%5y: %(%g%)\n} という値で上記の行を生成します。

コロンは、この行の中に必ず無くてはいけません。カーソルは、何かの操作をし
た後は常にコロンのところに移動するからです。@xref{Positioning Point}。他
には何も必要ではありません――グループ名さえもです。表示されている文字は
全てただの画面の飾りであり、gnus がそれを調べることはありません。Gnus は
必要とする全ての実情報を、テキスト属性を使って憶えています。

(もし君が、すごくヘンな、素晴らしい、表計算風のレイアウトを作ったとした
ら、みんな、君は会計の仕事が忙しくって、ニュースを読んで時間を無駄使いし
たりなんかしてない、って信じてくれるよ。)

以下が使用できるフォーマット文字のリストです。

@table @samp
@item M
そのグループが印のついた記事だけのときは、アスタリスク文字。

@item S
そのグループが購読されているかどうか。

@item L
購読度のレベル。

@item N
未読記事の数。

@item I
保留記事の数。

@item T
印付き記事の数。

@item R
既読記事の数。

@item t
推定全記事数 (これは実際は @var{max-number} - @var{min-number} + 1)。

gnus がこの推定を使うのは、@sc{nntp} プロトコルは能率の良
い @var{max-number} と @var{min-number} へのアクセスを提供するものの、本
当の未読記事の数を得るには必ずしも能率的ではないからです。ヒステリックな
レーズン (訳注: 歴史的な理由のモジりか?) により、メールバックエンドにお
いても、限定された同じインターフェースを使って、本当の未読記事の数を能率
的に得ることはできるかもしれません。この制限を Gnus から取り払うことはバッ
クエンドのインターフェースを変更することを意味し、それは楽な仕事ではあり
ません。あなたがこの仕事をやりたいならば、どうぞ Gnus メーリングリストに
連絡して下さい。

@item y
未読でも、印付きでも、保留でもない記事の数。

@item i
印付き記事と保留記事の数。

@item g
グループ名のフルネーム。

@item G
グループ名。

@item C
グループパラメータにコメントの要素が無い場合のコメン
ト (@pxref{Group Parameters}) またはグループ名。

@item D
ニュースグループの説明。

@item o
司会者付きの場合 @samp{m}.

@item O
司会者付きの場合 @samp{(m)}.

@item s
選択方法。

@item n
どこからの選択か。

@item z
外部選択方法が使われている場合、@samp{<%s:%n>} と同じ文字列。

@item P
トピック (@pxref{Group Topics}) のレベルに応じた字下げ。

@item c
@vindex gnus-group-uncollapsed-levels
短い (省略した) グループ名。@code{gnus-group-uncollapsed-levels} 変数は、
どのレベルまでグループ名を全部残すかを示します。初期値は 1 です――こ
の意味は、@samp{gnu.emacs.gnus} のようなグループ名
を @samp{g.e.gnus} に短縮するということです。

@item m
@vindex gnus-new-mail-mark
@cindex %
そのグループに最近新着メールが届いている場合
は @samp{%} (@code{gnus-new-mail-mark})。

@item p
@samp{#} (@code{gnus-process-mark}) で、そのグループにプロセスマークが付
いていることを示します。

@item d
最後にいつこのグループを読んだかを示す文字列 (@pxref{Group Timestamp})。

@item u
利用者定義指定。フォーマット文字列中で、この次の文字はアルファベット文字
でなければいけません。
Gnus は @code{gnus-user-format-function-}@samp{X} 関数を呼び出します。こ
こで @samp{X} は @samp{%u} に続いている文字です。この関数は引数に、一つ
のダミーパラメータを渡されます。この関数は、他の各指定文字の情報と同様に、
バッファに挿入される文字列を返さなければなりません。
@end table

@cindex *
全ての「〜の数」の指定で、もしその情報が利用できない場合にはアスタリス
ク (@samp{*}) が埋められます――例えば、起動されていない外部グループや、
不正な基本グループの場合です。

@node Group Modeline Specification
@subsection グループモード行の仕様
@cindex group modeline

@vindex gnus-group-mode-line-format
モード行
は @code{gnus-group-mode-line-format} (@pxref{Mode Line Formatting}) を
設定することで変更できます。こいつは指定文字をあんまりたくさん知ってませ
ん。

@table @samp
@item S
基本ニュースサーバー。
@item M
基本選択方法。
@end table

@node Group Highlighting
@subsection グループのハイライト
@cindex highlighting
@cindex group highlighting

@vindex gnus-group-highlight
グループバッファのハイライトは @code{gnus-group-highlight} 変数によって
制御されています。これは @code{(@var{form} . @var{face})} のようなものを
要素に持つ連想リストです。@var{form} が何か @code{nil} 以外に評価される
ものなら、その行に対して @var{face} が使用されます。

以下がこの変数の値の例です。これは背景が暗い設定ではきれいに見えるかも知
れません。

@lisp
(cond (window-system
       (setq custom-background-mode 'light)
       (defface my-group-face-1
         '((t (:foreground "Red" :bold t))) "First group face")
       (defface my-group-face-2
         '((t (:foreground "DarkSeaGreen4" :bold t))) "Second group face")
       (defface my-group-face-3
         '((t (:foreground "Green4" :bold t))) "Third group face")
       (defface my-group-face-4
         '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
       (defface my-group-face-5
         '((t (:foreground "Blue" :bold t))) "Fifth group face")))

(setq gnus-group-highlight
      '(((> unread 200) . my-group-face-1)
        ((and (< level 3) (zerop unread)) . my-group-face-2)
        ((< level 3) . my-group-face-3)
        ((zerop unread) . my-group-face-4)
        (t . my-group-face-5)))
@end lisp

@pxref{Faces and Fonts} も参照してください。

この form が評価されるときに動的に束縛されている変数には以下のものがあり
ます。

@table @code
@item group
グループ名。
@item unread
そのグループの未読記事の数。
@item method
選択方法。
@item mailp
そのグループがメールのグループかどうか。
@item level
そのグループのレベル。
@item score
そのグループのスコア。
@item ticked
そのグループ中の印の付いた記事の数。
@item total
そのグループ中の全記事数。もっと正確に言うと、MAX-NUMBER - MIN_NUMBER +
1.
@item topic
トピックマイナーモードを使用している時、この変数は挿入されている現在のト
ピックに束縛されます。
@end table

この form が評価 (@code{eval}) されるときは、ポイントは問題のグループの
行頭にあります。従って、通常の gnus の関数のほとんどを使ってそのグループ
の情報を取ってくることができます。

@vindex gnus-group-update-hook
@findex gnus-group-highlight-line
@code{gnus-group-update-hook} はグループ行が変更されたときに呼び出されま
す。これは @code{gnus-visual} が @code{nil} のときは呼び出されません。こ
のフックは初期設定では @code{gnus-group-highlight-line} を呼び出します。

@node Group Maneuvering
@section グループ操作
@cindex group movement

全ての移動コマンドは数字接頭引数を理解するので、期待する通りの動作をしま
す。たぶんね。

@table @kbd
@item n
@kindex n (グループ)
@findex gnus-group-next-unread-group
次の未読記事のあるグループに移動しま
す (@code{gnus-group-next-unread-group})。

@item p
@itemx DEL
@kindex DEL (グループ)
@kindex p (グループ)
@findex gnus-group-prev-unread-group
一つ前の未読記事のあるグループに移動しま
す (@code{gnus-group-prev-unread-group})。

@item N
@kindex N (グループ)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item P
@kindex P (グループ)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item M-n
@kindex M-n (グループ)
@findex gnus-group-prev-unread-group-same-level
一つ前の同じレベル (もしくはそれより小さいレベル) の未読グループに移動し
ます (@code{gnus-group-prev-unread-group-same-level})。

@item M-p
@kindex M-p (グループ)
@findex gnus-group-next-unread-group-same-level
次の同じレベル(もしくはそれより小さいレベル)の未読グループに移動しま
す (@code{gnus-group-next-unread-group-same-level})。
@end table

次の三つの命令はグループにジャンプするためのものです:

@table @kbd
@item j
@kindex j (グループ)
@findex gnus-group-jump-to-group
グループにジャンプします (それが見えるようになっていなかったら見えるよう
にします) (@code{gnus-group-jump-to-group})。kill されているグループも、
生きているグループと同様にジャンプできます。

@item ,
@kindex , (グループ)
@findex gnus-group-best-unread-group
最も小さいレベルの未読グループにジャンプしま
す (@code{gnus-group-best-unread-group})。

@item .
@kindex . (グループ)
@findex gnus-group-first-unread-group
最初の未読記事のあるグループにジャンプしま
す (@code{gnus-group-first-unread-group})。
@end table

@vindex gnus-group-goto-unread
@code{gnus-group-goto-unread} を @code{nil} にすると、全ての移動コマンド
は、次の未読グループではなく次のグループに移動するようになります。そのコ
マンドが次の未読グループに移動する、と言い張っていても、です。初期値
は @code{t} です。

@node Selecting a Group
@section グループの選択
@cindex group selection

@table @kbd
@item SPACE
@kindex SPACE (グループ)
@findex gnus-group-read-group
現在のグループを選択し、概略バッファに切り替えて最初の未読記事を表示しま
す (@code{gnus-group-read-group})。もしそのグループに未読記事が無い、も
しくはこの命令に数字以外のプレフィックスを与えると、gnus はサーバからこ
のグループの全ての古い記事を取得しようとします。@var{N} の数字接頭引数を
与えると、gnus の取得する記事数は @var{N} になります。@var{N} が正の数で
あれば gnus は新しい方から @var{N} 個の記事を取得し、@var{N} が負の数で
あれば gnus は古い方から @code{abs(@var{N})} 個の記事を取得します。

したがって、@kbd{SPC} では普通にグループに入り、@kbd{C-u SPC} では古い記
事が現れます。@kbd{C-u 4 2 SPC} では 42 個の最新の記事を取得し、@kbd{C-u
- 4 2 SPC} では 42 個の最も古い記事を取得します。

グループにいる (概略バッファにいる) ときは、@kbd{M-g} で新しい記事を取得
できるし、@kbd{C-u M-g} では古い記事を表示することができます。

@item RET
@kindex RET (グループ)
@findex gnus-group-select-group
現在のグループを選択し、概略バッファに切り替えま
す (@code{gnus-group-select-group})。@code{gnus-group-read-group} と同じ
引数を取ります――唯一の違いは、グループに入ったときに最初の未読記事を表
示しない、ということです。

@item M-RET
@kindex M-RET (グループ)
@findex gnus-group-quick-select-group
これは上記のコマンドと同じ動作をしますが、「ゴタゴタ」は最低限にしようと
します (@code{gnus-group-quick-select-group})。スコア・kill の処理は行わ
れず、ハイライトも記事消去もしません。これは、あなたが本当に急いでいて、
どっかのやたらでっかいグループに入らなければいけないときに役に立つかもし
れません。また、接頭辞に 0 を与えれば (すなわち @kbd{0 M-RET})、gnus は
概略バッファを作ろうとさえしません。これは概略バッファを作る前にスレッド
表示を切り替えたいとき役に立ちます (@pxref{Summary Generation Commands})。

@item M-SPACE
@kindex M-SPACE (グループ)
@findex gnus-group-visible-select-group
これは @kbd{RET} コマンドと同じ動作をするさらにもう一つのコマンドですが、
このコマンドは記事消去と保留記事を隠す処理を行いませ
ん (@code{gnus-group-visible-select-group})。

@item C-M-RET
@kindex C-M-RET (グループ)
@findex gnus-group-select-group-ephemerally
最後にこのコマンドは、現在のグループを一度限り、その内容に一切の処理をす
ることのないように選択しま
す (@code{gnus-group-select-group-ephemerally})。スレッド表示さえも行わ
れません。この方法で選択した後にこのグループに対して行ったことは全て、そ
の後に影響を与えることはありません。
@end table

@vindex gnus-large-newsgroup
@code{gnus-large-newsgroup} 変数は、何を大きなグループと考えるべきか、
を gnus に与えます。これは初期設定では 200 です。グループに (未読と印付
きの) 記事がこの数以上あれば、gnus はそのグループに入る前に利用者に確認
を求めます。利用者はサーバからいくつの記事を取得するかを指定できます。も
し利用者が負の数 (@code{-n}) を指定すれば、古い方から @code{n} 個の記事
を取得します。正の数であれば、新しく到着した方から @code{n} 個の記事を取
得します。

@vindex gnus-select-group-hook
@vindex gnus-auto-select-first
もし @code{gnus-auto-select-first} が非-@code{nil} だったら、
@kbd{SPACE} コマンドでグループに入ったときに自動的に記事を選択します。ど
の記事が選択されるかは、変数 @code{gnus-auto-select-subject} で制御され
ます。この変数に設定できる有効な値は:

@table @code
@item unread
最初の未読記事の表題の行にポイントを移動させます。

@item first
最初の記事の表題の行にポイントを移動させます。

@item unseen
まだ読まれたことが無い最初の記事の表題の行にポイントを移動させます。

@item unseen-or-unread
まだ読まれたことが無い最初の記事があれば、その記事の表題の行にポイントを
移動させ、無かったら最初の未読記事の表題の行にポイントを移動させます。

@item best
スコアが最も高い未読記事の表題の行にポイントを移動させます。
@end table

この変数は関数であることもできます。その場合、その関数は表題の行にポイン
トを移動させるために呼ばれます。

もしあるグループで自動記事選択をやめたいのであれば (例えばでっかい記事の
あるバイナリグループでは、とか)、グループが選択されたときに呼び出され
る @code{gnus-select-group-hook} の中で変
数 @code{gnus-auto-select-first} を @code{nil} に設定することができます。

@node Subscription Commands
@section 購読制御コマンド
@cindex subscription

@table @kbd
@item S t
@itemx u
@kindex S t (グループ)
@kindex u (グループ)
@findex gnus-group-unsubscribe-current-group
@c @icon{gnus-group-unsubscribe}
現在のグループの購読を切り替えま
す (@code{gnus-group-unsubscribe-current-group})。

@item S s
@itemx U
@kindex S s (グループ)
@kindex U (グループ)
@findex gnus-group-unsubscribe-group
グループを購読するかどうかを確認し、購読します。すでに購読するようになっ
ている場合には、購読を止めます (@code{gnus-group-unsubscribe-group})。

@item S k
@itemx C-k
@kindex S k (グループ)
@kindex C-k (グループ)
@findex gnus-group-kill-group
@c @icon{gnus-group-kill-group}
現在のグループを kill します (@code{gnus-group-kill-group})。

@item S y
@itemx C-y
@kindex S y (グループ)
@kindex C-y (グループ)
@findex gnus-group-yank-group
最後に kill したグループを yank します (@code{gnus-group-yank-group})。

@item C-x C-t
@kindex C-x C-t (グループ)
@findex gnus-group-transpose-groups
二つのグループの順序を置き換えます (@code{gnus-group-transpose-groups})。
これはホントは購読コマンドではありませんが、kill と yank を何度か続ける
代わりにこのコマンドが使えます。

@item S w
@itemx C-w
@kindex S w (グループ)
@kindex C-w (グループ)
@findex gnus-group-kill-region
リージョン内の全てのグループを kill しま
す (@code{gnus-group-kill-region})。

@item S z
@kindex S z (グループ)
@findex gnus-group-kill-all-zombies
全てのゾンビグループを kill します (@code{gnus-group-kill-all-zombies})。

@item S C-k
@kindex S C-k (グループ)
@findex gnus-group-kill-level
あるレベルのグループを全て kill します (@code{gnus-group-kill-level})。
kill した後、これらのグループを yank で戻すことはできないので、このコマ
ンドはいくらか注意して使ってください。このコマンドが本当に便利になるのは、
@file{.newsrc} に捨てちゃいたい未購読のグループがたくさんあるときだけで
す。レベル 7 で @kbd{S C-k} を行うと、@file{.newsrc} ファイル中にメッセー
ジ番号がない未購読グループを全て kill します。
@end table

@ref{Group Levels} も参照してくください。

@node Group Data
@section グループデータ

@table @kbd
@item c
@kindex c (グループ)
@findex gnus-group-catchup-current
@vindex gnus-group-catchup-group-hook
@c @icon{gnus-group-catchup-current}
そのグループ内の全ての無印の記事を既読にす
る (@code{gnus-group-catchup-current})。グループバッファから既読にした場
合は @code{gnus-group-catchup-group-hook} が呼び出されます。

@item C
@kindex C (グループ)
@findex gnus-group-catchup-current-all
そのグループの全記事を、印付きの記事も含めて既読にしま
す (@code{gnus-group-catchup-current-all})。

@item M-c
@kindex M-c (グループ)
@findex gnus-group-clear-data
現在のグループの全てのデータをクリアします――マークと既読記事のリストを
消し去ります (@code{gnus-group-clear-data})。

@item M-x gnus-group-clear-data-on-native-groups
@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
もし @sc{nntp} サーバを別のものに切り替えたとすると、全てのマークと既読
情報はもう役には立ちません。このコマンドを使って基本グループの全てのデー
タをクリアすることができます。注意して使ってね。
@end table

@node Group Levels
@section グループレベル
@cindex group level
@cindex level

全てのグループは @dfn{購読度} (@dfn{subscribedness}) のレベルを持ちます。
例えば、あるグループがレベル 2 だとすれば、それはレベル 5 のグループより
も「より購読している」ということです。Gnus に対して、あるレベルかそれよ
り小さいレベルのグループのみ一覧表示するように頼むこともできる
し (@pxref{Listing Groups})、あるレベルかそれより小さいレベルのグループ
の新着記事のみを確認することもできます(@pxref{Scanning New Messages})。

忘れないで: グループのレベルが大きいほど、重要度は低くなるということ。

@table @kbd
@item S l
@kindex S l (グループ)
@findex gnus-group-set-current-level
現在のグループのレベルを設定する。数字プレフィックスが与えられると、そこ
から @var{n} 個のグループのレベルが設定されます。レベルを入力するための
プロンプトが出ます。
@end table

@vindex gnus-level-killed
@vindex gnus-level-zombie
@vindex gnus-level-unsubscribed
@vindex gnus-level-subscribed
Gnus はレベル 1 から @code{gnus-level-subscribed} (この値を含む) (初期値
は 5) までのグループを購読、@code{gnus-level-subscribed} (この値を含まな
い) から@code{gnus-level-unsubscribed} (この値を含む) (初期値は 7) まで
のグループを非購読、@code{gnus-level-zombie} をゾンビ (歩く屍) (初期値
は 8)、@code{gnus-level-killed} を kill されている (完全に死んで
る) (初期値は 9) と判断します。Gnus は購読と非購読のグループは全く同様に
扱いますが、ゾンビと kill グループは、どの記事を読んだか、存在するかなど
の情報を一切持ちません。この死んでるグループと生きてるグループの区別は、
別にそれがきれいだからとか賢いからというわけではなく、純粋に効率的な理由
のためです。

メール用のグループは (もしあれば) 非常に小さいレベル (例えば 1 か 2) に
しておくことをお勧めします。

次の gnus のディフォルトの動作の説明は、ことによると、これらのレベルの全
てを理解する助けになるかもしれません。ディフォルトでは、gnus は講読して
いる空でないグループを表示しますが、@kbd{L} を叩くことによって空のグルー
プや非講読のグループも表示させることができます。つまり、非講読のグループ
は隠されている、と言っても良いでしょう。

ゾンビと kill グループは、ディフォルトでは隠されている点で非講読のグルー
プに似ています。しかし、gnus がニュースサーバーに対してゾンビと kill グ
ループに関する情報 (記事数、未読記事数) の問い合わせをしない点で、購読お
よび非購読のグループとは違っています。ふつう、あなたは興味の無いグループ
を @kbd{C-k} で kill しますよね。もし、ほとんどのグループが kill されて
いると、gnus は速くなります。

なぜ gnus はゾンビと kill グループを区別するのでしょう?  ええと、サーバー
に新しいグループができると、gnus はディフォルトでそれをゾンビにします。
これは、あなたがふつうは新しいグループに煩わされないことを意味しますが、
あなたは @kbd{A z} で新しいグループのリストを得ることができます。あなた
は好みのものを講読し、要らないものは kill すれば良いのです。
(@kbd{A k} で kill されたグループのリストを表示します。)

もしレベル変数で遊びたいのであれば、多少注意をしてまわる必要があります。
一旦それを設定したら、二度とそれに触らないでください。さらに言えば、自分
で何をやっているかを正確に理解していない限り、一切触らないでください。

@vindex gnus-level-default-unsubscribed
@vindex gnus-level-default-subscribed
身近に関係する二つの変数は @code{gnus-level-default-subscribed} (初期値
は 3) と @code{gnus-level-default-unsubscribed} (初期値は 6) です。これ
らは新しいグループが (非) 購読されたときのレベルです。もちろん、これ
ら二つの変数の値は、意味のある正しい範囲でなくてはなりません。

@vindex gnus-keep-same-level
@code{gnus-keep-same-level} が @code{nil} 以外であれば、移動コマンドのい
くつかは同一 (あるいはそれより小さい) レベルのグループのみの移動になりま
す。特に、あるグループの最後の記事から次のグループに移るとき、次の同
一 (あるいはそれより小さい) レベルのグループに移動します。これは残りのグ
ループを読むより先に、より重要なグループを読んでおきたいときには便利かも
しれません。

もしこの値が @code{best} だったら、最も重要な (最もレベルの値が小さ
い) グループに移動します。

@vindex gnus-group-default-list-level
初期設定では @code{gnus-group-default-list-level} と同じかそれより小さい
レベルのグループが、グループバッファに一覧表示されます。

@vindex gnus-group-list-inactive-groups
@code{gnus-group-list-inactive-groups} が @code{nil} 以外であれば、未読
のグループに一緒にアクティブでないグループも表示します。この変数は初期設
定では @code{t} です。もしこれが @code{nil} であれば、アクティブでないグ
ループは表示されません。

@vindex gnus-group-use-permanent-levels
@code{gnus-group-use-permanent-levels} が @code{nil} 以外であれば、一旦
レベルを @kbd{g} や @kbd{l} のプレフィックスに与えると、その後の全てのコ
マンドにおいてそのレベルが「作用する」レベルになります。

@vindex gnus-activate-level
Gnus は通常、@code{gnus-activate-level} かそれより小さいレベルのグループ
のみを起動します (つまりサーバに問い合わせをする)。購読していないグルー
プを起動したくなければ、この変数を例えば 5 に設定するとよいかもしれませ
ん。ディフォルトは 6 です。

@node Group Score
@section グループのスコア
@cindex group score
@cindex group rank
@cindex rank

普通は重要なグループは高レベルにしておくでしょうけれども、この方法では少々
制限がきついですよね。ひょっとしたら、グループをどれくらい頻繁に読むかに
よってグループバッファをソートしたいなあ、なんて思わない? 理にかなってる
でしょ?

@dfn{グループスコア} (@dfn{group score}) はそのためのものです。Gnus に以
下で説明されている機構で、それぞれのグループに対してスコアを指定させるこ
とができます。そしてグループバッファをこのスコアを基にソートすることがで
きます。あるいは、スコア順でソートしてその後レベルでソートすることもでき
ます。(レベルとスコアをひとまとめにして、グループ
の @dfn{ランク} (@dfn{rank}) と呼びます。レベルが 4 でスコアが 1 のグルー
プは、レベルが 5 でスコアが 300 のグループよりも高いランクとなります。
(レベルの方が重要度が高く、スコアの方は重要度が低くなります。))

@findex gnus-summary-bubble-group
頻繁に読むグループに、めったに読まないグループよりも高いスコアを与えたい
ときは、@code{gnus-summary-exit-hook} フック
に @code{gnus-summary-bubble-group} 関数を追加することができます。これで
バブルソートの実行結果が (ソートの後で) 得られるでしょう。概略モードを終
了するたびにこの活動をさせたいのであれば、同じフック
に @code{gnus-group-sort-groups-by-rank} か @code{gnus-group-sort-groups-by-score} を
追加できますが、いくらか遅くなるでしょう。

@node Marking Groups
@section グループへの印
@cindex marking groups

もしいくつかのグループに対して何らかの命令を実行したい場合で、それらがグ
ループバッファに連続してある場合には、通常通り命令に対して数字接頭辞を与
えるだけです。そうすればほとんどのグループ命令は、これらのグループに対し
てあなたの命令に従います。

しかしそれらのグループが順番に並んでいない場合においても、いくつかのグルー
プに対して命令を実行することができます。単に始めにプロセス印でグループに
印をつけておき、そして命令を実行するだけです。

@table @kbd
@item #
@kindex # (グループ)
@itemx M m
@kindex M m (グループ)
@findex gnus-group-mark-group
現在のグループに印をつける (@code{gnus-group-mark-group})。

@item M-#
@kindex M-# (グループ)
@itemx M u
@kindex M u (グループ)
@findex gnus-group-unmark-group
現在のグループから印を削除する (@code{gnus-group-unmark-group})。

@item M U
@kindex M U (グループ)
@findex gnus-group-unmark-all-groups
全てのグループから印を削除する (@code{gnus-group-unmark-all-groups})。

@item M w
@kindex M w (グループ)
@findex gnus-group-mark-region
ポイントとマークの間の全てのグループに印をつけ
る (@code{gnus-group-mark-region})。

@item M b
@kindex M b (グループ)
@findex gnus-group-mark-buffer
バッファ内の全てのグループに印をつける (@code{gnus-group-mark-buffer})。

@item M r
@kindex M r (グループ)
@findex gnus-group-mark-regexp
ある正規表現に合致する全てのグループに印をつけ
る (@code{gnus-group-mark-regexp})。
@end table

@ref{Process/Prefix} も参照してください。

@findex gnus-group-universal-argument
プロセス印が付けられている全てのグループに対して何かの命令を実行したいと
きは、@kbd{M-&} (@code{gnus-group-universal-argument}) 命令を使うことが
できます。プロンプトから実行したい命令を入力します。

@node Foreign Groups
@section 外部グループ
@cindex foreign groups

以下では、一般的な外部グループの作成、変更を行うグループモードの命令をい
くつか、および特別な目的のグループを簡単に作成する命令を紹介します。これ
らの命令は全て、新規に作成したグループをポイント位置に挿入しま
す――@code{gnus-subscribe-newsgroup-method} は参照されません。

@table @kbd
@item G m
@kindex G m (グループ)
@findex gnus-group-make-group
@cindex making groups
新しいグループを作成します (@code{gnus-group-make-group})。Gnus はプロン
プトを表示して、名前と方法と、場合によっては @dfn{address} の入力を求め
てきます。より簡単に @sc{nntp} グループを購読する方法は、
@pxref{Browse Foreign Server}。

@item G n
@kindex G n (グループ)
@findex gnus-group-make-shimbun-group
@cindex making groups
@cindex nnshimbun
@cindex Web Newspaper
新しい @code{nnshimbun} グループを作成しま
す (@code{gnus-group-make-shimbun-group})。gnus はプロンプトを表示して、
サーバーのアドレスを示すシンボル名と記事グループ名の入力を求めてきます。
@code{nnshimbun} に関する詳細は @pxref{Web Newspaper} を参照して下さい。

@item G r
@kindex G r (グループ)
@findex gnus-group-rename-group
@cindex renaming groups
現在のグループの名前を、何か別のものに変更しま
す (@code{gnus-group-rename-group})。これはある種のグループ――主にメー
ルグループに対してのみ有効です。このコマンドはバックエンドによっては非常
に遅いことも有り得ます。

@item G c
@kindex G c (グループ)
@cindex customizing
@findex gnus-group-customize
グループパラメータをカスタマイズする (@code{gnus-group-customize})。

@item G e
@kindex G e (グループ)
@findex gnus-group-edit-group-method
@cindex renaming groups
現在のグループの選択方法を修正するためのバッファに移動しま
す (@code{gnus-group-edit-group-method})。

@item G p
@kindex G p (グループ)
@findex gnus-group-edit-group-parameters
グループパラメータを修正するためのバッファに移動しま
す (@code{gnus-group-edit-group-parameters})。

@item G E
@kindex G E (グループ)
@findex gnus-group-edit-group
グループ情報を修正するためのバッファに移動しま
す (@code{gnus-group-edit-group})。

@item G d
@kindex G d (グループ)
@findex gnus-group-make-directory-group
@cindex nndir
ディレクトリグループを作成します (@pxref{Directory Groups})。ディレクト
リ名をプロンプトで入力します (@code{gnus-group-make-directory-group})。

@item G h
@kindex G h (グループ)
@cindex help group
@findex gnus-group-make-help-group

Gnus ヘルプグループを作成します (@code{gnus-group-make-help-group})。

@item G a
@kindex G a (グループ)
@cindex (ding) archive
@cindex archive group
@findex gnus-group-make-archive-group
@vindex gnus-group-archive-directory
@vindex gnus-group-recent-archive-directory
Gnus アーカイブグループを作成しま
す (@code{gnus-group-make-archive-group})。初期設定では最も最近の記事を
指しているグループが作成されます
が (@code{gnus-group-recent-archive-directory})、接頭引数を与えると全て
の記事を含むグループが @code{gnus-group-archive-directory} を基に作成さ
れます。

@item G k
@kindex G k (グループ)
@findex gnus-group-make-kiboze-group
@cindex nnkiboze
kiboze グループを作成します。プロンプトで名前と、kiboze グループに「含め
たい」グループに合う正規表現と、ヘッダーに合う文字列の組を入力しま
す (@code{gnus-group-make-kiboze-group})。@xref{Kibozed Groups}.

@item G D
@kindex G D (グループ)
@findex gnus-group-enter-directory
@cindex nneething
任意のディレクトリを @code{nneething} バックエンドニュースグループである
かのように読み込みます (@code{gnus-group-enter-directory})。
@xref{Anything Groups}.

@item G f
@kindex G f (グループ)
@findex gnus-group-make-doc-group
@cindex ClariNet Briefs
@cindex nndoc
ファイルなどをもとにグループを作成しま
す (@code{gnus-group-make-doc-group})。このコマンドに接頭辞を与えた場合、
ファイル名とファイルタイプをプロンプトで入力します。現在サポートされてい
るファイルタイプは @code{mbox}, @code{babyl}, @code{digest}, @code{news},
@code{rnews}, @code{mmdf}, @code{forward}, @code{rfc934},
@code{rfc822-forward}, @code{mime-parts}, @code{standard-digest},
@code{slack-digest}, @code{clari-briefs}, @code{nsmail}, @code{outlook},
@code{oe-dbx} および @code{mailman} です。接頭辞なしでこのコマンドを実行
すると、gnus はファイルタイプを推測します。
@xref{Document Groups}。

@item G u
@kindex G u (グループ)
@vindex gnus-useful-groups
@findex gnus-group-make-useful-group
@code{gnus-useful-groups} にあるグループの一つをつくりま
す (@code{gnus-group-make-useful-group})。

@item G w
@kindex G w (グループ)
@findex gnus-group-make-web-group
@cindex Google
@cindex nnweb
@cindex gmane
ウェブ検索結果をもとに一時的なグループを作成しま
す (@code{gnus-group-make-web-group})。このコマンドに接頭辞を与えると、
一時的ではなく固定したグループを作成します。プロンプトで検索エンジンの種
類 (search engine type) と検索文字列を入力します。有効な検索エンジンの種
類には @code{google}, @code{dejanews}, @code{gmane} があります。
@xref{Web Searches}.

もし、@code{google} 検索エンジンを用いる場合には、
@samp{shaving group:alt.sysadmin.recovery} のような合致する文字列を用い
ることによって、検索対象を特定のグループに限定することが可能です。

@item G DEL
@kindex G DEL (グループ)
@findex gnus-group-delete-group
この関数は現在のグループを削除します (@code{gnus-group-delete-group})。
接頭辞が与えられると、この関数はそのグループ内の全記事を本当に削除し、グ
ループ自身をこの世から強制的に抹殺してしまいます。接頭辞は、あなたが何を
やろうとしているか、本当に自信があるときにのみ使ってください。まあ、この
コマンドは (@code{nntp} グループのような) 読み出し専用グループには使えま
せんけど。

@item G V
@kindex G V (グループ)
@findex gnus-group-make-empty-virtual
新しい、新鮮な、空の @code{nnvirtual} グループを作成しま
す (@code{gnus-group-make-empty-virtual})。@xref{Virtual Groups}.

@item G v
@kindex G v (グループ)
@findex gnus-group-add-to-virtual
現在のグループを @code{nnvirtual} グループに追加しま
す (@code{gnus-group-add-to-virtual})。これはプロセス印/接頭引数の習慣に
従います。
@end table

さまざまな選択方法に関するさらなる情報は @xref{Select Methods} を参照し
てください。

@vindex gnus-activate-foreign-newsgroups
もし @code{gnus-activate-foreign-newsgroups} が正の数であれば、gnus は起
動時に、この数かそれよりも小さいレベルの外部グループを全てチェックします。
これは特に違った @sc{nntp} サーバからたくさんのグループを購読している場
合など、しばらく時間がかかるかもしれません。@pxref{Group Levels} も参照
して下さい。@code{gnus-activate-level} も外部ニュースグループの活動化に
影響を及ぼします。

@node Group Parameters
@section グループパラメータ
@cindex group parameters

グループパラメータは、ある特定のグループに固有な情報を格納します。以下は
グループパラメータリストの例です:

@example
((to-address . "ding@@gnus.org")
 (auto-expire . t))
@end example

それぞれの要素は『点対』(dotted pair)――つまり点 (dot) の前に鍵、点の後
ろに値があるもの、で構成されます。全てのパラメータはこの形式を取りますが、
@emph{例外}として局所変数の指定は点対ではなく通常のリストになります。

いくつかのパラメータは対応するカスタマイズ可能な変数を持っています。それ
らは正規表現と値の連想リストです。

以下は利用可能なグループパラメータです:

@table @code
@item to-address
@cindex to-address
フォローアップとニュースへの投稿をするときに使用されるアドレス。

@example
(to-address . "some@@where.com")
@end example

これは主に、閉じたメーリングリストを表わすメールグループにおいて便利なも
のです――すなわちメーリングリストに投稿する人は全てそれを購読しているは
ず、というメーリングリストのことです。このパラメータを使用すると、メール
はそのメーリングリストにしか投稿されないことが保証されるので、参加者はあ
なたのフォローアップ記事を二通受け取ることはありません。

@code{to-address} を指定すると、そのグループが外部グループであるかどうか
に関わらず有効になります。例えば @samp{fa.4ad-l} というグループがサーバ
上にあったとしましょう。これは本当のニュースグループですが、サーバはメー
ルニュースゲートウェイを通して記事を受け付けます。つまりこのグループに対
して直接投稿することは不可能で、代わりにそのメーリングリストにメールを送
信しなければなりません。

@code{gnus-parameter-to-address-alist} も参照して下さい。

@item to-list
@cindex to-list
そのグループで @kbd{a} を押したときに使用されるアドレス。

@example
(to-list . "some@@where.com")
@end example

これはフォローアップをしたときは完全に無視されます――例外はそれがニュー
スグループを表わしているときは、@kbd{f} を押したときにメールグループのルー
ルが適用されるということです。

もし @kbd{a} コマンドをメールグループで実行したときに、@code{to-list} グ
ループパラメータも @code{to-address} もグループパラメータも無ければ、
@code{to-list} グループパラメータは、
@code{gnus-add-to-list} が @code{t} に設定されていればメッセージ送信時に
自動的に付加されます。
@vindex gnus-add-to-list

もし @kbd{a} コマンドをメールグループで実行したとき、@code{to-list} グルー
プパラメータがなければ、送信時に自動的に付加されます。

@findex gnus-mailing-list-mode
@cindex Mail List Groups
もしこのグループパラメータが設定されていると、概略バッファに入ったとき
に @code{gnus-mailing-list-mode} が有効になります。

@code{gnus-parameter-to-list-alist} も参照して下さい。

@anchor{subscribed}
@item subscribed
@cindex subscribed
もしこのパラメータが @code{t} に設定されていると、gnus はあなたがこのグ
ループを to-address と to-list パラメータのアドレスで購読しているメーリ
ングリストであると解釈します。この情報を gnus に与えることは、あなたがそ
れらのメーリングリストに投稿するときに正しい Mail-Followup-To ヘッダーを
生成するための (ほんの) 第一歩です。利用できる MFT 対応機能を完全に扱う
には、ここ @pxref{(message)Mailing Lists} を見て下さい。

@code{gnus-find-subscribed-addresses} も参照して下さい。この関数はこのグ
ループパラメータを直接に使います。

@item visible
@cindex visible
グループパラメータのリスト中に @code{(visible . t)} という要素があれば、
そのグループはグループバッファにおいて、未読記事があるかどうかに関わらず、
常に表示されます。

@item broken-reply-to
@cindex broken-reply-to
@code{(broken-reply-to . t)} という要素があれば、そのグループで
は @code{Reply-To} は無視される、という意味です。これはある listserv に
よるメーリングリストを購読していて、それが @code{Reply-To} 欄
を listserv 自身に返すようにつけられている場合に有効でしょう。これはおか
しな振る舞いです。だからこれが要るんです!

@item to-group
@cindex to-group
@code{(to-group . "some.group.name")} という要素は、そのグループへの投稿
は全て @code{some.group.name} に送られる、という意味です。

@item newsgroup
@cindex newsgroup
グループパラメータリストに @code{(newsgroup . t)} があれば、gnus は全て
の応答をニュース記事に対する応答であるかのように扱います。これは実際には
ニュースグループのミラーであるメールグループに対して有効です。

@item gcc-self
@cindex gcc-self
グループパラメータリストに @code{(gcc-self . t)} があれば、新しく作成す
るメッセージは現在のグループに @code{Gcc} されます。も
し @code{(gcc-self . none)} があれば、@code{Gcc:} 欄は生成されず、
@code{(gcc-self . "string")} があればこの文字列はそのまま @code{gcc} 欄
に挿入されます。このパラメータは以下で説明する全ての @code{Gcc} の初期規
則よりも優先されます (@pxref{Archived Messages})。警告:: @code{nntp} サー
バーなどのグループで @code{(gcc-self . t)} を設定するとエラーを引き起こ
します。なぜなら @code{nntp} サーバーは記事を受け入れませんから。

@item auto-expire
@cindex auto-expire
グループパラメータに @code{(auto-expire . t)} のような要素があれば、全て
の既読記事は時限消去されるように印を付けられます。他の方法は、
@pxref{Expiring Mail}。

@code{gnus-auto-expirable-newsgroups} も参照して下さい。

@item total-expire
@cindex total-expire
グループパラメータに @code{(total-expire . t)} のような要素があれば、既
読記事は、時限消去の印がついていなくとも全て時限消去処理を施されます。注
意して使用してください。未読記事、印付き記事、保留記事は時限消去されませ
ん。

@code{gnus-total-expirable-newsgroups} も参照して下さい。

@item expiry-wait
@cindex expiry-wait
@vindex nnmail-expiry-wait-function
グループパラメータに @code{(expiry-wait . 10)} のような要素があれば、こ
の値は記事を時限消去するとき
に @code{nnmail-expiry-wait} と @code{nnmail-expiry-wait-function} の設
定よりも優先されます。この値は時限消去の日数 (整数である必要はない) かも
しくは @code{never} か @code{immediate} のシンボルを指定できます。

@item score-file
@cindex score file group parameter
@code{(score-file . "file")} のような要素は、@file{file} を現在のグルー
プに適用されるスコアファイルにします。適用されるスコア登録は全てこのファ
イルに入ります。

@item adapt-file
@cindex adapt file group parameter
@code{(adapt-file . "file")} のような要素は、@file{file} を現在のグルー
プの適応ファイルにします。全ての適応スコア登録はこのファイルに入ります。

@item admin-address
@cindex admin-address
メーリングリストから脱会するときは、脱会通知メールをそのメーリングリスト
自身に送信してはいけません。代わりに管理用アドレスにメッセージを送信しま
す。このパラメータにはどこか便利な管理用アドレスを書いておくことができま
す。

@item display
@cindex display
@code{(display . MODE)} のような要素は、グループに入るときにどの記事を表
示するかを指定します。有効な値は、

@table @code
@item all
未読、既読記事の両方を全て表示します。

@item an integer
そのグループの最後の整数個の記事を表示します。これは C-u 整数 でそのグルー
プに入るのと同じです。

@item default
初期設定での表示記事を表示します。これは通常は未読記事と印付き記事です。

@item 配列
述語を満足するように記事を表示します。

いくつか例を挙げます:

@table @code
@item [unread]
未読の記事だけを表示します。

@item [not expire]
期限切れ消去可能な記事以外のすべてを表示します。

@item [and (not reply) (not expire)]
期限切れ消去可能とすでに返信した記事以外のすべてを表示します。
@end table

利用できる演算子は @code{not}, @code{and} および @code{or} です。述語
は @code{tick}, @code{unsend}, @code{undownload}, @code{unread},
@code{dormant}, @code{expire}, @code{reply}, @code{killed},
@code{bookmark}, @code{score}, @code{save}, @code{cache}, @code{forward},
@code{unseen} および @code{recent} を含みます。
@end table

@code{display} パラメータは、概略バッファを指定した一部の組だけに制限す
るように働きます。制限をスタックから取り出すのは @kbd{/ w} コマンドでで
きます (@pxref{Limiting})。

@item comment
@cindex comment
@code{(comment . "This is a comment")} のような要素は、そのグループに対
する任意のコメントです。グループ行に表示することができま
す (@pxref{Group Line Specification})。

@ignore
@item charset
@cindex charset
Elements that look like @code{(charset . iso-8859-1)} will make
@code{iso-8859-1} the default charset; that is, the charset that will be
used for all articles that do not specify a charset.

See also @code{gnus-group-charset-alist}.

@item ignored-charsets
@cindex ignored-charsets
Elements that look like @code{(ignored-charsets x-unknown iso-8859-1)}
will make @code{iso-8859-1} and @code{x-unknown} ignored; that is, the
default charset will be used for decoding articles.

See also @code{gnus-group-ignored-charsets-alist}.
@end ignore
@item posting-style
@cindex posting-style
このグループの追加の投稿様式をここのみに保存することができま
す (@pxref{Posting Styles})。書式は @code{gnus-posting-style} 連想リスト
と同じですが、ここにはグループ名に合致する正規表現はありません (当然で
す)。このグループの様式の要素は @code{gnus-posting-styles} で見つかった
ものよりも優先されます。

例えば、このグループのみ、かっこいい名前と署名にしたいなら、
@code{gnus-posting-styles} をいじらずに、このようなものをグループパラメー
タに入れることができます:

@example
(posting-style
  (name "Funky Name")
  (signature "Funky Signature"))
@end example

@item post-method
@cindex post-method
もしこれが設定されていると、メッセージを送信するための選択方法とし
て @code{gnus-post-method} の代わりに使われます。

@item banner
@cindex banner
@code{(banner . "regex")} のような項目は、記事のすべての場所で正規表
現 "regex" にマッチするものを削除します。"regex" の代わりにシンボ
ル @code{signature} (最後の署名を削
除) や連想リスト @code{gnus-article-banner-alist} の各要素を使うこともで
きます。

@item sieve
@cindex sieve
このパラメータは、入ってきたメールがこのグループに置くに値するかどうかを
調べる Sieve (ふるい) テストを持ちます。このグループパラメータを元
に @samp{fileinto "group.name";} というテスト条件を本体に持つ、
Sieve の @samp{IF} 制御構造体が作られます。

例えば、もし INBOX.list.sieve グループが @code{(sieve address "sender"
"sieve-admin@@extundo.com")} というグループパラメータを持っていたならば、
グループパラメータを Sieve スクリプトに変換す
る (@pxref{Sieve Commands}) ときに、以下の Sieve コードが作られます:

@example
if address \"sender\" \"sieve-admin@@extundo.com\" @{
        fileinto \"INBOX.list.sieve\";
@}
@end example

Sieve 言語は RFC 3028 で述べられています。@xref{Top, , Top, sieve, Emacs
Sieve}。

@item (@var{variable} @var{form})
グループに入るときに、そのグループローカルの変数を設定するグループパラメー
タを使用することができます。@samp{news.answers} においてスレッド表示を行
いたくないときは、そのグループにグループパラメータ
に @code{(gnus-show-threads nil)} と書けます。
@code{gnus-show-threads} は、その概略バッファの中のローカル変数になり、
form の @code{nil} はそこで評価されます。

@vindex gnus-list-identifiers
この機能の用途の一つは、記事の題名欄からメーリングリストの標識タグをはぎ
取ることです。もしニュースグルー
プ @samp{nntp+news.gnus.org:gmane.text.docbook.apps} が、すべての記事の
題名に @samp{DOC-BOOK-APPS:} というタグを持っているならば、そのグループ
のグループパラメータに @code{(gnus-list-identifiers "DOCBOOK-APPS:")} を
入れることによって、そのグループの概略バッファに表示される記事の題名から
タグをはぎ取ることができます。

これはもし必要であれば、グループ毎のフック関数としても使用できます。もし
あるグループに入ったときにビープ音を鳴らしたければ、そのグループのパラメー
タに @code{(dummy-variable (ding))} みたいなものを書いておくこともできま
す。@code{dummy-variable} という変数に @code{(ding)} の評価結果が設定さ
れますが、まあ、誰も気にしないでしょ?
@end table

グループパラメータの修正には @kbd{G p} か @kbd{G c} 命令を使ってくださ
い (@kbd{G p} は Lisp ベースの、@kbd{G c} は Custom ふうのインターフェー
スを提供します)。トピックパラメータについて読んでみることも面白いでしょ
う (@pxref{Topic Parameters})。

グループパラメータは @code{gnus-parameters} 変数を介在して設定することも
できます。でもいくつかのパラメータ、例えば @code{visible} は効力を発揮し
ません。例です。

@example
(setq gnus-parameters
      '(("mail\\..*"
         (gnus-show-threads nil)
         (gnus-use-scoring nil)
         (gnus-summary-line-format
          "%U%R%z%I%(%[%d:%ub%-23,23f%]%) %s\n")
         (gcc-self . t)
         (display . all))

        ("^nnimap:\\(foo.bar\\)$"
         (to-group . "\\1"))

        ("mail\\.me"
         (gnus-use-scoring  t))

        ("list\\..*"
         (total-expire . t)
         (broken-reply-to . t))))
@end example

文字列の値は、@code{to-group} の例が示すように、正規表現による置き換えを
受けることがあります。

@node Listing Groups
@section グループの一覧表示
@cindex group listing

これらのコマンドは、利用できるグループをいろいろに切り分けて表示します。

@table @kbd
@item l
@itemx A s
@kindex A s (グループ)
@kindex l (グループ)
@findex gnus-group-list-groups
未読記事を持つ全てのグループを表示します (@code{gnus-group-list-groups})。
数字接頭引数を使うと、このコマンドは引数の数かそれよりも小さいレベルのグ
ループのみを表示します。初期設定では、これはレベル 5 (つま
り @code{gnus-group-default-list-level}) かそれより小さいレベル (すなわ
ち購読しているグループのみ) を表示します。

@item L
@itemx A u
@kindex A u (グループ)
@kindex L (グループ)
@findex gnus-group-list-all-groups
未読記事のあるなしに関わらず、全てのグループを表示しま
す (@code{gnus-group-list-all-groups})。数字接頭引数を使用すると、このコ
マンドは引数の数かそれよりも小さいレベルのグループのみを表示します。初期
設定では 7 かそれよりも小さいレベルのグループ (すなわち購読、非購読のグ
ループのみ) が表示されます。

@item A l
@kindex A l (グループ)
@findex gnus-group-list-level
ある特定のレベルの未読記事のあるグループを表示しま
す (@code{gnus-group-list-level})。接頭辞を与えると、未読記事のないグルー
プも含めて表示します。

@item A k
@kindex A k (グループ)
@findex gnus-group-list-killed
kill されたグループを全て表示します (@code{gnus-group-list-killed})。接
頭引数を与えると、現在購読、非購読となっていない全ての利用可能なグループ
を表示します。これはサーバからアクティブファイルを読むことになるでしょう。

@item A z
@kindex A z (グループ)
@findex gnus-group-list-zombies
全てのゾンビグループを表示します (@code{gnus-group-list-zombies})。

@item A m
@kindex A m (グループ)
@findex gnus-group-list-matching
正規表現に合致する名前を持つグループで、未読記事のある購読グループを全て
表示します (@code{gnus-group-list-matching})。

@item A M
@kindex A M (グループ)
@findex gnus-group-list-all-matching
正規表現に合致するグループを表示す
る (@code{gnus-group-list-all-matching})。

@item A A
@kindex A A (グループ)
@findex gnus-group-list-active
今接続しているサーバのアクティブファイルにあるグループを、本当に全部表示
します (@code{gnus-group-list-active})。これはしばらく時間がかかることも
有り得ます。たぶん @kbd{A M} を実行して、合致させたい部分を @samp{.} と
して全ての合致するリストを表示させた方が良いでしょう。また、このコマンド
は (まだ) 存在しないグループも表示するかも知れません――これは kill され
たグループであるかのように表示されます。出力は多少割り引いて受け取ってね。

@item A a
@kindex A a (グループ)
@findex gnus-group-apropos
正規表現に合致する名前を持つグループを全て表示す
る (@code{gnus-group-apropos})。

@item A d
@kindex A d (グループ)
@findex gnus-group-description-apropos
正規表現に合致する名前か説明文を持つグループを全て表示す
る (@code{gnus-group-description-apropos})。

@item A c
@kindex A c (グループ)
@findex gnus-group-list-cached
キャッシュ記事を持つグループを全て表示す
る (@code{gnus-group-list-cached})。

@item A ?
@kindex A ? (グループ)
@findex gnus-group-list-dormant
保留記事を持つグループを全て表示する (@code{gnus-group-list-dormant})。

@item A /
@kindex A / (グループ)
@findex gnus-group-list-limit
現在の選択された範囲に限定したグループを表示す
る (@code{gnus-group-list-limit})。

@item A f
@kindex A f (グループ)
@findex gnus-group-list-flush
現在の選択されたグループを書き出す (@code{gnus-group-list-flush})。

@item A p
@kindex A p (グループ)
@findex gnus-group-list-plus
現在の選択されたグループを加えたグループを表示す
る (@code{gnus-group-list-plus})。
@end table

@vindex gnus-permanently-visible-groups
@cindex visible group parameter
@code{gnus-permanently-visible-groups} 正規表現に合致するグループは、未
読記事があるかないかに関わらず常に表示されます。あるいはグループパラメー
タにおいて @code{visible} 要素を追加することでも同様の効果を得ることがで
きます。

@vindex gnus-list-groups-with-ticked-articles
印付きの記事のみを持つグループは通常グループバッファに表示されます。も
し @code{gnus-list-groups-with-ticked-articles} が @code{nil} であれば、
そのグループは完全に空のグループであるかのように扱われます。初期値
は @code{t} です。

@node Sorting Groups
@section グループのソート
@cindex sorting groups

@kindex C-c C-s (グループ)
@findex gnus-group-sort-groups
@vindex gnus-group-sort-function
@kbd{C-c C-s} (@code{gnus-group-sort-groups}) 命令は、グループバッファ
を @code{gnus-group-sort-function} 変数で与えられる関数に従って並べ替え
ます。利用可能な並べ替え関数 (sorting function) には以下のものがありま
す:

@table @code
@item gnus-group-sort-by-alphabet
@findex gnus-group-sort-by-alphabet
グループ名でアルファベット順に並べ替えます。これが初期設定です。

@item gnus-group-sort-by-real-name
@findex gnus-group-sort-by-real-name
グループを本当の (前に何もついていない) グループ名でアルファベット順に並
べ変えます。

@item gnus-group-sort-by-level
@findex gnus-group-sort-by-level
グループレベルで並べ替えます。

@item gnus-group-sort-by-score
@findex gnus-group-sort-by-score
グループのスコアで並べ替えます。@xref{Group Score}.

@item gnus-group-sort-by-rank
@findex gnus-group-sort-by-rank
グループのスコアで並べ替え、次にグループレベルで並べ替えます。レベルとス
コアは、ひとまとめにして @dfn{ランク} と呼ばれます。@xref{Group Score}.

@item gnus-group-sort-by-unread
@findex gnus-group-sort-by-unread
未読記事の数で並べ替えます。

@item gnus-group-sort-by-method
@findex gnus-group-sort-by-method
選択方法のアルファベット順で並べ替えます。

@item gnus-group-sort-by-server
@findex gnus-group-sort-by-server
サーバー名のアルファベット順で並べ替えます。
@end table

@code{gnus-group-sort-function} は並べ替え関数のリストであっても構いませ
ん。この場合、もっとも重要な並べ替えの鍵を持つ関数は最後でなくてはなりま
せん。

ある種の並べ替え用には、直接並べ替える命令もいくつかあります。

@table @kbd
@item G S a
@kindex G S a (グループ)
@findex gnus-group-sort-groups-by-alphabet
グループバッファをグループ名のアルファベット順で並べ替えま
す (@code{gnus-group-sort-groups-by-alphabet})。

@item G S u
@kindex G S u (グループ)
@findex gnus-group-sort-groups-by-unread
グループバッファを未読記事の数で並べ替えま
す (@code{gnus-group-sort-groups-by-unread})。

@item G S l
@kindex G S l (グループ)
@findex gnus-group-sort-groups-by-level
グループバッファをグループレベルで並べ替えま
す (@code{gnus-group-sort-groups-by-level})。

@item G S v
@kindex G S v (グループ)
@findex gnus-group-sort-groups-by-score
グループバッファをグループのスコアで並べ替えま
す (@code{gnus-group-sort-groups-by-score})。@xref{Group Score}.

@item G S r
@kindex G S r (グループ)
@findex gnus-group-sort-groups-by-rank
グループバッファをグループのランクで並べ替えま
す (@code{gnus-group-sort-groups-by-rank})。@xref{Group Score}.

@item G S m
@kindex G S m (グループ)
@findex gnus-group-sort-groups-by-method
グループバッファをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-group-sort-groups-by-method})。
@end table

以下の全ての命令はプロセス/接頭辞の習慣に従いま
す (@pxref{Process/Prefix})。

シンボル接頭辞 (@pxref{Symbolic Prefixes}) が与えられたときは、これら全
ての命令は逆順で並び換えます。

また、グループの一部を並べ替えることもできます。

@table @kbd
@item G P a
@kindex G P a (グループ)
@findex gnus-group-sort-selected-groups-by-alphabet
グループをグループ名のアルファベット順で並べ替えま
す (@code{gnus-group-sort-selected-groups-by-alphabet})。

@item G P u
@kindex G P u (グループ)
@findex gnus-group-sort-selected-groups-by-unread
グループを未読記事の数で並べ替えま
す (@code{gnus-group-sort-selected-groups-by-unread})。

@item G P l
@kindex G P l (グループ)
@findex gnus-group-sort-selected-groups-by-level
グループをグループレベルで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-level})。

@item G P v
@kindex G P v (グループ)
@findex gnus-group-sort-selected-groups-by-score
グループをグループのスコアで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-score})。
@xref{Group Score}.

@item G P r
@kindex G P r (グループ)
@findex gnus-group-sort-selected-groups-by-rank
グループをグループのランクで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-rank})。@xref{Group Score}.

@item G P m
@kindex G P m (グループ)
@findex gnus-group-sort-selected-groups-by-method
グループをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-group-sort-selected-groups-by-method})。

@item G P s
@kindex G P s (グループ)
@findex gnus-group-sort-selected-groups
グループを @code{gnus-group-sort-function} に従って並べ替えます。
@end table

最後に、@kbd{C-k} と @kbd{C-y} を使って、手動でグループをあちこちに移動
できることもお忘れなく。

@node Group Maintenance
@section グループの管理
@cindex bogus groups

@table @kbd
@item b
@kindex b (グループ)
@findex gnus-group-check-bogus-groups
不正なグループを見つけて、削除しま
す (@code{gnus-group-check-bogus-groups})。

@item F
@kindex F (グループ)
@findex gnus-group-find-new-groups
新しいグループを見つけて、それらを処理しま
す (@code{gnus-group-find-new-groups})。一回の @kbd{C-u} の後で押される
と、サーバーに新しいグループを尋ねるために方法 @code{ask-server} を使い
ます。二回の @kbd{C-u} の後で押されると、サーバーに新しいグループを尋ね
るために最も完全であると思われる方法を用い、新しいグループをゾンビとして
購読します。

@item C-c C-x
@kindex C-c C-x (グループ)
@findex gnus-group-expire-articles
現在のグループのエクスパイア記事に対して (もしあれば) 全てエクスパイア処
理を行います (@code{gnus-group-expire-articles})。これは、そのグループに
しばらく存在していた期限切れ削除可能なすべての記事を消去するということで
す。(@pxref{Expiring Mail})。

@item C-c C-M-x
@kindex C-c C-M-x (グループ)
@findex gnus-group-expire-all-groups
全てのグループの全ての期限切れ削除可能な記事に対して、エクスパイア処理を
行います。(@code{gnus-group-expire-all-groups})。
@end table

@node Browse Foreign Server
@section 外部サーバの閲覧
@cindex foreign servers
@cindex browsing servers

@table @kbd
@item B
@kindex B (グループ)
@findex gnus-group-browse-foreign-server
選択方法とサーバ名を聞かれます。Gnus はこのサーバに接続し、そこにある
グループを閲覧しようとします (@code{gnus-group-browse-foreign-server})。
@end table

@findex gnus-browse-mode
利用可能なグループのリストを持った新しいバッファが現れます。このバッファ
は @code{gnus-browse-mode} を使用します。このバッファは通常のグループバッ
ファにちょっと (というか、とっても) 似ています。

以下が閲覧モード (browse mode) で使用できるキー操作のリストです:

@table @kbd
@item n
@kindex n (閲覧)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item p
@kindex p (閲覧)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item SPACE
@kindex SPACE (閲覧)
@findex gnus-browse-read-group
現在のグループに入り、最初に記事を表示しま
す (@code{gnus-browse-read-group})。

@item RET
@kindex RET (閲覧)
@findex gnus-browse-select-group
現在のグループに入ります (@code{gnus-browse-select-group})。

@item u
@kindex u (閲覧)
@findex gnus-browse-unsubscribe-current-group
現在のグループを非購読にする、つまりこの場合は購読することになるのだけれ
ど (@code{gnus-browse-unsubscribe-current-group})。

@item l
@itemx q
@kindex q (閲覧)
@kindex l (閲覧)
@findex gnus-browse-exit
閲覧モード (browse mode) を終了します (@code{gnus-browse-exit})。

@item ?
@kindex ? (閲覧)
@findex gnus-browse-describe-briefly
閲覧モード (browse mode) を簡単に説明します (まあ、大して説明することも
ないんだけどさ) (@code{gnus-browse-describe-briefly})。
@end table

@node Exiting gnus
@section Gnus の終了
@cindex exiting gnus

そう、gnus は最後 (サイコー) です (訳注: く、苦しい。
原文は ``Yes, gnus is ex(c)iting.'')。

@table @kbd
@item z
@kindex z (グループ)
@findex gnus-group-suspend
Gnus を中断します (@code{gnus-group-suspend})。これは gnus を実際には終
了させず、グループバッファ以外の全てのバッファを消すだけです。僕はこれの
うれしさがよくわかんないんだけど、誰か分かる人いる?

@item q
@kindex q (グループ)
@findex gnus-group-exit
@c @icon{gnus-group-exit}
Gnus を終了します(@code{gnus-group-exit})。

@item Q
@kindex Q (グループ)
@findex gnus-group-quit
@file{.newsrc} ファイルをセーブせずに gnus を終了しま
す (@code{gnus-group-quit})。ドリブルファイルはセーブされますけ
ど (@pxref{Auto Save})。
@end table

@vindex gnus-exit-gnus-hook
@vindex gnus-suspend-gnus-hook
Gnus を中断するときは @code{gnus-suspend-gnus-hook} が呼び出されます。
Gnusを終了するときは @code{gnus-exit-gnus-hook} が呼び出され、さら
に gnus を終了するときの最後とし
て @code{gnus-after-exiting-gnus-hook} が呼び出されます。

@findex gnus-unload
@cindex unloading
もし gnus とそれに関連するものを完全に処分したいのであれば、
@code{gnus-unload} コマンドが使えます。このコマンドは、メタ変数をカスタ
マイズしようとしているときにも便利です。

Note:

@quotation
ミス Lisa Cannifax は英語の授業中、後ろに座っている少年が彼女のプラスティッ
クの椅子の背越しに、鉛筆で繰り返し線を描くのにつられて、足がしびれて重く
なり、意識が朦朧としてきました。
@end quotation

@node Group Topics
@section Group Topics
@cindex topics

もしあなたがたーくさんのグループを読んでいるのであれば、グループをトピッ
ク毎に階層分けできると便利でしょう。Emacs のグループをこっちへ、セックス
のグループをあっちへ、で、残りを (え? グループが二 つくらいしかない
の?) 邪魔にならないようにその他のセクションに入れましょう。あるい
は Emacs セックスのグループを Emacs グループ、セックスグループのどちらか
の副トピックとすることさえもできます――あるいは両方に! すんごいでしょう!

@iftex
@iflatex
\gnusfigure{Group Topics}{400}{
\put(75,50){\epsfig{figure=ps/group-topic,height=9cm}}
}
@end iflatex
@end iftex

これが例です:

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

@findex gnus-topic-mode
@kindex t (グループ)
この@emph{素晴らしい}機能を使うには、@code{gnus-topic} マイナーモード
を (何と!) 単にスイッチオンするだけ――グループバッファで、@kbd{t} を押
してください (これはトグルコマンドです)。

さあやってみよう。とにかく試してみて。君が戻ってくるまで、僕はここで待っ
てるからさ。ララ、タララン…ん、いい曲だね、これ…ラ、ラ、ラ…え? 戻って
きた? よし、じゃ次は @kbd{l} を押してみて。ほら。これで全てのグループ
が @samp{misc} の下に表示されました。興奮してクラクラしてこない? アツくっ
て、いまいましいくらいでしょ?

これをずっと有効にしたければ、グループモードのフックにこのマイナーモード
を追加してください。以下の行を @file{~/.gnus} ファイルに入れて、ね。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@menu
* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックの全てのグループに適用される
                                パラメータ
@end menu

@node Topic Commands
@subsection トピック命令
@cindex topic commands

トピックマイナーモードが有効であるときは、@kbd{T} サブマップが新しく利用
できるようになります。さらに標準キーの中でも、定義がちょっと変わるものが
少しあります。

だいたいにおいて、次のようなトピックの操作が可能です。まず第一に、あなた
はトピックを作ることを望むでしょう。第二に、あなたはグループをトピックに
入れて、それらをあなたの好みの順序になるまで、あちこちに移動することを望
むでしょう。第三に行なう操作は、それらの一切合切を表示したり隠すことでしょ
う。他のグループの概要を見やすくするために、あなたは副トピックやグループ
によっては、トピックが隠れるようにしたいと思うかもしれませんね。

ここには、あなたの好むやり方でトピックを設定するために必要になりそうな、
基本的なキーのリストがあります。

@table @kbd
@item T n
@kindex T n (トピック)
@findex gnus-topic-create-topic
新しいトピック名の入力を促し、それを作成しま
す (@code{gnus-topic-create-topic})。

@item T TAB
@itemx TAB
@kindex T TAB (トピック)
@kindex TAB (トピック)
@findex gnus-topic-indent
現在のトピックの ``字下げ'' を行い、その前のトピックの副トピックにしま
す (@code{gnus-topic-indent})。接頭引数を与えると、反対にそのトピックの
字下げを回復 (un-indent) します。

@item M-TAB
@kindex M-TAB (トピック)
@findex gnus-topic-unindent
現在のトピックの ``字下げ回復'' (un-indent) を行い、それが現在の親の親の
副トピックになるようにします (@code{gnus-topic-unindent})。
@end table

以下の二つのキーは、グループとトピックをあちこち移動するために使われます。
それらは、よく知られているカット＆ペーストのように動作します。
@kbd{C-k} はカット、@kbd{C-y} はペーストです。もちろん、Emacs ではカット
＆ペーストではなくて kill & yank という用語を使いますが。

@table @kbd
@item C-k
@kindex C-k (トピック)
@findex gnus-topic-kill-group
グループあるいはトピックを kill します (@code{gnus-topic-kill-group})。
トピック内にあったグループも全て、トピックと一緒に削除されます。

@item C-y
@kindex C-y (トピック)
@findex gnus-topic-yank-group
直前の kill されたグループあるいはトピックを yank しま
す (@code{gnus-topic-yank-group})。全てのトピックは、全てのグループの前
に yank されることに気をつけてください。

ですから、あるトピックをトピックのリストの先頭に移動するには、単にそこ
で @kbd{C-k} を叩きます。これはカット＆ペーストのカットに相当します。
なあんだ、簡単じゃん。

@kbd{C-k} と @kbd{C-y} はトピックと同様にグループにも使えます。すなわち、
あなたはグループと同じようにトピックの移動もできるのです。
@end table

あなたの望みのままにトピックを使えるようにした後で、あなたはトピックを隠
したり再び見えるようにしようと思うでしょう。そのために以下のキーを用意し
ています。

@table @kbd
@item RET
@kindex RET (トピック)
@findex gnus-topic-select-group
@itemx SPACE
グループを選択するか、あるいはトピックを折りたたみま
す (@code{gnus-topic-select-group})。グループの上でこのコマンドを実行す
ると、通常通りそのグループに入ります。トピック行の上で行うと、そのトピッ
クは (既に表示されているときは) 折りたたまれるか、(既に折りたたまれてい
るときは) 展開されます。つまりトピックに対してはこれはトグルコマンドです。
さらに、数字プレフィックスを与えると、そのレベル (とそれよりも小さいレベ
ル) のグループが表示されます。
@end table

さてお次は、他のコマンドのリストです。順序には特に意味はありません。

@table @kbd
@item T m
@kindex T m (トピック)
@findex gnus-topic-move-group
現在のグループを、どこか他のトピックに移動させま
す (@code{gnus-topic-move-group})。このコマンドはプロセス印/接頭引数の習
慣に従います (@pxref{Process/Prefix})。

@item T j
@kindex T j (トピック)
@findex gnus-topic-jump-to-topic
トピックにジャンプします (@code{gnus-topic-jump-to-topic})。

@item T c
@kindex T c (トピック)
@findex gnus-topic-copy-group
現在のグループを、どこか他のトピックにコピーしま
す (@code{gnus-topic-copy-group})。このコマンドはプロセス印/接頭引数の習
慣に従います (@pxref{Process/Prefix})。

@item T h
@kindex T h (トピック)
@findex gnus-topic-hide-topic
現在のトピックを隠します。もしプレフィックスが与えられたなら、そのトピッ
クを永久に隠します。

@item T s
@kindex T s (トピック)
@findex gnus-topic-show-topic
現在のトピックを表示します。もしプレフィックスが与えられたなら、そのトピッ
クを永久に表示します。

@item T D
@kindex T D (トピック)
@findex gnus-topic-remove-group
グループを現在のトピックから削除します (@code{gnus-topic-remove-group})。
この命令は主にいくつかのトピックに同じグループがあって、それをトピックの
一つから取り除きたいときに役立ちます。あなたはグループを全てのトピックか
ら取り除きたいと思うかも知れませんが、その場合は、gnus はあなたが次回
に gnus を起動したときにそれをルートトピックに付け加えます。実際のところ、
全ての新しいグループ (もちろん、それはどのトピックにも属していません) は
ルートトピックに現われます。

この命令はプロセス印/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item T M
@kindex T M (トピック)
@findex gnus-topic-move-matching
正規表現にマッチする全てのグループを、あるトピックに移動させま
す (@code{gnus-topic-move-matching})。

@item T C
@kindex T C (トピック)
@findex gnus-topic-copy-matching
正規表現にマッチする全てのグループを、あるトピックにコピーしま
す (@code{gnus-topic-copy-matching})。

@item T H
@kindex T H (トピック)
@findex gnus-topic-toggle-display-empty-topics
空のトピックの表示・非表示を切り替えま
す (@code{gnus-topic-toggle-display-empty-topics})。

@item T #
@kindex T # (トピック)
@findex gnus-topic-mark-topic
現在のトピックにあるグループ全てにプロセスマークをつけま
す (@code{gnus-topic-mark-topic})。

@item T M-#
@kindex T M-# (トピック)
@findex gnus-topic-unmark-topic
現在のトピックにある全てのグループからプロセスマークを消しま
す (@code{gnus-topic-unmark-topic})。

@item C-c C-x
@kindex C-c C-x (トピック)
@findex gnus-topic-expire-articles
(もしあれば) 現在のグループかトピックかの全ての時限消去可能記事を時限消
去します (@code{gnus-topic-expire-articles})。(@pxref{Expiring Mail})。

@item T r
@kindex T r (トピック)
@findex gnus-topic-rename
トピックの名前を変更します (@code{gnus-topic-rename})。

@item T DEL
@kindex T DEL (トピック)
@findex gnus-topic-delete
空のトピックを削除します (@code{gnus-topic-delete})。

@item A T
@kindex A T (トピック)
@findex gnus-topic-list-active
Gnus が知っているトピック化されたグループを全て表示しま
す (@code{gnus-topic-list-active})。

@item T M-n
@kindex T M-n (トピック)
@findex gnus-topic-goto-next-topic
次のトピックに移動します (@code{gnus-topic-goto-next-topic})。

@item T M-p
@kindex T M-p (トピック)
@findex gnus-topic-goto-previous-topic
前のトピックに移動します (@code{gnus-topic-goto-previous-topic})。

@item G p
@kindex G p (トピック)
@findex gnus-topic-edit-parameters
@cindex group parameters
@cindex topic parameters
@cindex parameters
トピックパラメータを修正します (@code{gnus-topic-edit-parameters})。
@xref{Topic Parameters}.
@end table

@node Topic Variables
@subsection トピック変数
@cindex topic variables

前の項では、どのトピックを表示するかを gnus に言う方法を説明しました。
この項では、それぞれのトピックの何を表示するかをgnus に言う方法を説明し
ます。

@vindex gnus-topic-line-format
トピック行それ自体は、@code{gnus-topic-line-format} 変数の値に従って作成
されます (@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item i
字下げ。
@item n
トピック名。
@item v
見えるかどうか。
@item l
レベル。
@item g
トピック中のグループの数。
@item a
トピック中の未読記事の数。
@item A
トピックと全ての副トピックの未読記事の数。
@end table

@vindex gnus-topic-indent-level
各副トピック (と副トピック内のグループ) は、トピックレベル数
の @code{gnus-topic-indent-level} 倍の空白分の字下げが行われます。初期値
は 2 です。

@vindex gnus-topic-mode-hook
@code{gnus-topic-mode-hook} はトピックマイナーモードバッファで呼び出され
ます。

@vindex gnus-topic-display-empty-topics
@code{gnus-topic-display-empty-topics} はトピックの中に未読記事が無い場
合でもそのトピックを表示するようにします。初期値は @code{t} です。

@node Topic Sorting
@subsection トピックの並べ替え
@cindex topic sorting

以下に示す命令で、各トピック毎に別々にグループを並べ替えることができます:

@table @kbd
@item T S a
@kindex T S a (トピック)
@findex gnus-topic-sort-groups-by-alphabet
現在のトピックをグループ名のアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-alphabet})。

@item T S u
@kindex T S u (トピック)
@findex gnus-topic-sort-groups-by-unread
現在のトピックを未読記事の数で並べ替えま
す (@code{gnus-topic-sort-groups-by-unread})。

@item T S l
@kindex T S l (トピック)
@findex gnus-topic-sort-groups-by-level
現在のトピックをグループのレベルで並べ替えま
す (@code{gnus-topic-sort-groups-by-level})。

@item T S v
@kindex T S v (トピック)
@findex gnus-topic-sort-groups-by-score
現在のトピックをグループのスコアで並べ替えま
す (@code{gnus-topic-sort-groups-by-score})。@xref{Group Score}.

@item T S r
@kindex T S r (トピック)
@findex gnus-topic-sort-groups-by-rank
現在のトピックをグループのランクで並べ替えま
す (@code{gnus-topic-sort-groups-by-rank})。@xref{Group Score}.

@item T S m
@kindex T S m (トピック)
@findex gnus-topic-sort-groups-by-method
現在のトピックをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-method})。

@item T S e
@kindex T S e (トピック)
@findex gnus-topic-sort-groups-by-server
現在のトピックをサーバーの名前でアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-server})。

@item T S s
@kindex T S s (トピック)
@findex gnus-topic-sort-groups
現在のトピックを、変数 @code{gnus-group-sort-function} で与えられる関数
に従って並べ替えます (@code{gnus-topic-sort-groups})。
@end table

接頭引数が与えられたら、これらすべてのコマンドは逆順の並べ替えを行ないま
す。グループのソートについてのさらなる情報は @xref{Sorting Groups} を参
照してください。

@node Topic Topology
@subsection トピックの位相構造
@cindex topic topology
@cindex topology

それでは、グループバッファの例を見ていきましょう。

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

つまり、ここでは一つのトップレベルのトピック (@samp{Gnus}) があり、その
下に二つのトピックがあり、そのうちの一方の副トピック中に一つ副トピックが
あります (トップレベルトピックは常に一つしかありません)。この構造は、以
下のように表現できます:

@lisp
(("Gnus" visible)
 (("Emacs -- こいつはすげーぜ!" visible)
  (("えっちな Emacs" visible)))
 (("その他" visible)))
@end lisp

@vindex gnus-topic-topology
これは実に、上記の表示を行うための、変数 @code{gnus-topic-topology} の値
そのものなのです。この変数は @file{.newsrc.eld} ファイルに保存され、手で
いじくり回してはいけません――本当にやりたいときは別ですが。この変数
は @file{.newsrc.eld} ファイルから読み込まれるので、その他のスタートアッ
プファイルの設定には全く影響を与えません。

この構造は、どのトピックがどのトピックの副トピックであるかと、どのトピッ
クが表示されているかを示しています。現在は二つの設定
値――@code{visible} と @code{invisible} が許されています。

@node Topic Parameters
@subsection トピックパラメータ
@cindex topic parameters

トピック内の全てのグループはグループパラメータを、その親 (と先祖) のトピッ
クパラメータから継承します。グループパラメータとして正しいものは全て、ト
ピックパラメータとしても正しいものです(@pxref{Group Parameters})。

さらに、以下のパラメータはトピックパラメータとしてのみ有効です:

@table @code
@item subscribe
トピックで新しいグループを購読している場
合 (@pxref{Subscription Methods})、@code{subscribe} トピックパラメータは
どのグループがどのトピックに行くかを指定します。値はそのトピックに行くグ
ループに合致する正規表現である必要があります。

@item subscribe-level
トピックで新しいグループを購読している場
合 (@code{subscribe} パラメータを参照)、そのグループの購読度のレベル
は @code{gnus-level-default-subscribed} の代わり
に @code{subscribe-level} トピックパラメータの値になります。
@end table

グループパラメータは (もちろん) トピックパラメータよりも優先され、副トピッ
クのトピックパラメータは親トピックのトピックパラメータよりも優先されます。
分かるよね。ごく普通の継承ルールです (ルール (@dfn{Rules}) はここでは名
詞であって、動詞の「線を引く」ではありません。このルールには反対したくな
るかも知れないけど、それはご自由に)。

@example
Gnus
  Emacs
     3: comp.emacs
     2: alt.religion.emacs
   452: alt.sex.emacs
    息抜き
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
   452: alt.sex.emacs
@end example

@samp{Emacs} トピックはトピックパラメー
タ @code{(score-file . "emacs.SCORE")} を持っています。
@samp{息抜き} トピックはトピックパラメー
タ @code{(score-file . "relief.SCORE")} を持ち、
@samp{その他} トピックはトピックパラメー
タ @code{(score-file . "emacs.SCORE")} を持っています。
さらに、@samp{alt.religion.emacs} はグループパラメー
タ @code{(score-file . "religion.SCORE")} を持っています。

さて、ここで @samp{息抜き} トピックの @samp{alt.sex.emacs} グループに入っ
たとき、@file{relief.SCORE} が基本スコアファイルとなります。も
し @samp{Emacs} トピックの同じグループに入ると、@file{emacs.SCORE} が基
本スコアファイルになるでしょう。
@samp{alt.religion.emacs} グループに入れば、@file{religion.SCORE} が基本
スコアファイルになるでしょう。

これってとっても簡単で自明のことのように見えるでしょ? まあ、その通りです。
ですが問題がある場合もあります。特に@code{total-expiry} パラメータに関し
てです。例えばあるメールグループを二つのトピックの中に、一方
は @code{total-expiry} ありで、もう一方はそれなしで持っているとしましょ
う。ここで @kbd{M-x gnus-expire-all-expirable-groups} を実行すると、何が
起こるでしょうか? Gnus は、あなたがどちらのトピックから記事をエクスパイ
アしたいのかを知る方法がないため、最悪の事態が発生するかもしれません。実
際、私はこのとき何が起こるのかは「未定義 @dfn{undefined}」である、とここ
に宣言します。この手のことをやりたい場合には十分注意しなければなりません。

@node Misc Group Stuff
@section その他のグループ関連

@menu
* Scanning New Messages::       Gnus に新しいメッセージが到着したかどう
                                かを聞く
* Group Information::           グループと gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記
                                録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理
@end menu

@table @kbd
@item ^
@kindex ^ (グループ)
@findex gnus-group-enter-server-mode
サーババッファモードに入る (@code{gnus-group-enter-server-mode})。
@xref{Server Buffer}。

@item a
@kindex a (グループ)
@findex gnus-group-post-news
メッセージ (ディフォルトはニュース) の作成を開始しま
す (@code{gnus-group-post-news})。もし接頭辞が与えられたら現在位置のグルー
プに投稿します。もし接頭辞が 1 だったら、どのグループに投稿するかを尋ね
ます。この関数の名前から連想されることとは裏腹に、接頭辞でメールグループ
が指定された場合は、ニュースの代わりにメールの様式が用意されます。
@xref{Composing Messages}。

@item m
@kindex m (グループ)
@findex gnus-group-mail
メールをどこかに送ります (@code{gnus-group-mail})。もし接頭辞が与えられ
たら現在位置のグループの投稿様式 (posting style) を使います。もし接頭辞
が 1 だったら、どのグループの投稿様式を使うかを尋ねます。
@xref{Composing Messages}。

@item i
@kindex i (グループ)
@findex gnus-group-news
ニュースの作成を開始します (@code{gnus-group-news})。もし接頭辞が与えら
れたら現在位置のグループに投稿します。もし接頭辞が 1 だったら、どのグルー
プに投稿するかを尋ねます。@xref{Composing Messages}。

この関数は、たとえメールグループで使われたとしても、実際にはニュースの様
式を用意します。これは、メッセージを実際にはネットワーク経由で送らずに、
メールグループに "投稿" するのに便利です; それらは当のグループに単に直接
セーブされます。対応するバックエンドが投稿のためのメソッド (request-post
method) を持っていなければなりませんが。
@end table

以下はグループバッファのための変数です:

@table @code
@item gnus-group-mode-hook
@vindex gnus-group-mode-hook
グループバッファが作成された時に呼び出されます。

@item gnus-group-prepare-hook
@vindex gnus-group-prepare-hook
グループバッファが生成されたあとに呼び出されます。これはバッファを何か変
な、自然じゃない方法で修正したいときに使われるかもしれません。

@item gnus-group-prepared-hook
@vindex gnus-group-prepare-hook
グループバッファが生成された後の一番最後に呼び出されます。例えばポイント
をどこかに移動させたいときなどに使えます。

@item gnus-permanently-visible-groups
@vindex gnus-permanently-visible-groups
この正規表現にマッチするグループは、それが空であるかどうかに関わらず、常
にグループバッファに表示されます。

@item gnus-group-name-charset-method-alist
@vindex gnus-group-name-charset-method-alist
グループ名用の選択方法と文字集合の連想リストです。これは英字ではないグルー
プ名を表示するために使います。

例:
@lisp
(setq gnus-group-name-charset-method-alist
    '(((nntp "news.com.cn") . cn-gb-2312)))
@end lisp

@item gnus-group-name-charset-group-alist
@cindex UTF-8 group names
@vindex gnus-group-name-charset-group-alist
グループ名用のグループ名の正規表現と文字集合の連想リストです。これは英字
ではないグループ名を表示するために使います。ディフォルト値は、UTF-8 がサ
ポートされている場合は @code{((".*" utf-8))}、それ以外の場合は nil です。

例:
@lisp
(setq gnus-group-name-charset-group-alist
    '(("\\.com\\.cn:" . cn-gb-2312)))
@end lisp
@end table

@node Scanning New Messages
@subsection 新着メッセージを探す
@cindex new messages
@cindex scanning new news

@table @kbd
@item g
@kindex g (グループ)
@findex gnus-group-get-new-news
@c @icon{gnus-group-get-new-news}
サーバの新着記事をチェックします。数字プレフィックスを使用すると、この命
令は引数 @var{arg} かそれより小さいレベルのグループのみをチェックしま
す (@code{gnus-group-get-new-news})。数字以外のプレフィックスを与えると、
この命令はそのバックエンドからアクティブファイルを強制的に全部読み直しま
す。

@item M-g
@kindex M-g (グループ)
@findex gnus-group-get-new-news-this-group
@vindex gnus-goto-next-group-when-activating
@c @icon{gnus-group-get-new-news-this-group}
現在のグループに新着記事があるかどうかをチェックしま
す (@code{gnus-group-get-new-news-this-group})。
@code{gnus-goto-next-group-when-activating} はこの命令が次のグループ位置
へ移動するかどうかを決めます。初期値は @code{t} です。

@findex gnus-activate-all-groups
@cindex activating groups
@item C-c M-g
@kindex C-c M-g (グループ)
無条件に全てのグループを起動します (@code{gnus-activate-all-groups})。

@item R
@kindex R (グループ)
@cindex restarting
@findex gnus-group-restart
Gnus をリスタートします (@code{gnus-group-restart})。これ
は @file{.newsrc} ファイルをセーブし、全てのサーバの接続を閉じ、全て
の gnus ランタイム変数をクリアした後、gnus をもう一度最初から開始します。
@end table

@vindex gnus-get-new-news-hook
@code{gnus-get-new-news-hook} は新着ニュースをチェックする直前に実行され
ます。

@vindex gnus-after-getting-new-news-hook
@code{gnus-after-getting-new-news-hook} 新着ニュースをチェックした後に実
行されます。

@node Group Information
@subsection グループ情報
@cindex group information
@cindex information on groups

@table @kbd
@item H f
@kindex H f (グループ)
@findex gnus-group-fetch-faq
@vindex gnus-group-faq-directory
@cindex FAQ
@cindex ange-ftp
現在のグループの FAQ を取得しようとします(@code{gnus-group-fetch-faq})。
Gnus は FAQ を@code{gnus-group-faq-directory} から取得しようとします。こ
れは通常リモートマシン上のディレクトリです。この変数はディレクトリのリス
トであっても構いません。この場合、このコマンドにプレフィックスを与えるこ
とでいくつかのサイトの中から選ぶことができます。ファイルの取得に
は @code{ange-ftp} (または @code{efs}) が使用されます。

もし最初のサイトからの取得が失敗した場合、
gnus は @code{gnus-group-faq-directory} の値を全て、一つ一つオープンして
みようとします。

@item H c
@kindex H c (Group)
@findex gnus-group-fetch-charter
@vindex gnus-group-charter-alist
@cindex charter
現在のグループの憲章を web ブラウザで開こうとしま
す (@code{gnus-group-fetch-charter})。
gnus は @code{gnus-group-charter-alist} を使って憲章の所在を探します。所
在がわからなかったら、gnus はそのグループのコントロールメッセージを取得
します。それには憲章を含んでいることがありますから。

@item H C
@kindex H C (Group)
@findex gnus-group-fetch-control
@vindex gnus-group-fetch-control-use-browse-url
@cindex control message
そのグループのコントロールメッセージを @code{ftp.isc.org} の記録庫から取
得します (@code{gnus-group-fetch-control})。

@code{gnus-group-fetch-control-use-browse-url} が非-@code{nil} だったら、
gnus は @code{browse-url} を使ってコントロールメッセージを開きます。そう
でない場合は @code{ange-ftp} を使って取得され、一時グループ に表示されま
す。

コントロールメッセージは圧縮されていることに注意して下さい。このコマンド
を使うには @code{auto-compression-mode} を on にしておく必要がありま
す (@pxref{(emacs)Compressed Files})。

@item H d
@itemx C-c C-d
@c @icon{gnus-group-describe-group}
@kindex H d (グループ)
@kindex C-c C-d (グループ)
@cindex describing groups
@cindex group description
@findex gnus-group-describe-group
現在のグループの説明を表示する (@code{gnus-group-describe-group})。プレ
フィックスを与えると、説明文をサーバから強制的に再読み込みします。

@item M-d
@kindex M-d (グループ)
@findex gnus-group-describe-all-groups
全てのグループの説明を表示しま
す (@code{gnus-group-describe-all-groups})。プレフィックスを与えると、説
明文ファイルをサーバから強制的に再読み込みします。

@item H v
@itemx V
@kindex V (グループ)
@kindex H v (グループ)
@cindex version
@findex gnus-version
現在の gnus のバージョン番号を表示します (@code{gnus-version})。

@item ?
@kindex ? (グループ)
@findex gnus-group-describe-briefly
とても短いヘルプメッセージを与えま
す (@code{gnus-group-describe-briefly})。

@item C-c C-i
@kindex C-c C-i (グループ)
@cindex info
@cindex manual
@findex gnus-info-find-node
Gnus の info ノードに移動します (@code{gnus-info-find-node})。
@end table

@node Group Timestamp
@subsection グループの日付
@cindex timestamps
@cindex group timestamps

Gnus に、あなたが最後にいつグループを読んだかを記録させると便利かもしれ
ません。この活動を始めさせるには、
@code{gnus-group-set-timestamp} を @code{gnus-select-group-hook} に追加
してください。

@lisp
(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)
@end lisp

これを行った後、あなたがグループに入るたびにそれが記録されます。

この情報はさまざまな方法で表示できます――もっとも簡単なのは、グループ行
フォーマットで @samp{%d} 指定を使う方法です:

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %d\n")
@end lisp

この結果として、各行は以下のように表示されます:

@example
*        0: mail.ding                                19961002T012943
         0: custom                                   19961002T012713
@end example

見て分かるとおり、日付はコンパクトな ISO 8601 形式で表示されます。
これではちょっとあんまりなので、以下のような感じにすると日付だけ
を表示できます。

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %6,6~(cut 2)d\n")
@end lisp

もっと凝った日付の形式をお望みなら、ユーザー定義によるフォーマットの仕様
を使うことができます。以下のようなものはうまくいくでしょう:

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %ud\n")
(defun gnus-user-format-function-d (headers)
  (let ((time (gnus-group-timestamp gnus-tmp-group)))
    (if time
        (format-time-string "%b %d  %H:%M" time)
      "")))
@end lisp

@node File Commands
@subsection ファイル命令
@cindex file commands

@table @kbd
@item r
@kindex r (グループ)
@findex gnus-group-read-init-file
@vindex gnus-init-file
@cindex reading init file
初期化ファイルの再読み込みを行う (@code{gnus-init-file}、このデ
フォルトは @file{~/.gnus}) (@code{gnus-group-read-init-file})。

@item s
@kindex s (グループ)
@findex gnus-group-save-newsrc
@cindex saving .newsrc
@file{.newsrc.eld} ファイル (と、もしそうしたければ @file{.newsrc} ファ
イル) をセーブする (@code{gnus-group-save-newsrc})。

@c @item Z
@c @kindex Z (グループ)
@c @findex gnus-group-clear-dribble
@c ドリブルファイルをクリアする
@c (@code{gnus-group-clear-dribble})。
@end table

@node Sieve Commands
@subsection Sieve コマンド
@cindex group sieve commands

Sieve はサーバー側で使われるメールフィルター言語です。gnus では、各グルー
プに適用される sieve の規則を指定する、@code{sieve} グループパラメー
タ (@pxref{Group Parameters}) を使うことができます。guns はそれらすべて
のグループパラメータを、サーバーで使うことも可能な正しい Sieve スクリプ
トに翻訳する、二つのコマンドを提供します。

@vindex gnus-sieve-file
@vindex gnus-sieve-region-start
@vindex gnus-sieve-region-end
作成された Sieve スクリプトは @code{gnus-sieve-file} (ディフォルト
は @file{~/.sieve}) に置かれます。gnus が作るコードは二つの区切り記
号 @code{gnus-sieve-region-start} と @code{gnus-sieve-region-end} の間に
置かれるので、これらの区切り記号の外に追加の Sieve コードを書いても、次
回 Sieve スクリプトを再作成するときに消されてしまうことはありません。

@vindex gnus-sieve-crosspost
変数 @code{gnus-sieve-crosspost} は Sieve スクリプトがどのように作られる
かを制御します。もし非-nil (ディフォルト) だったら記事は規則にマッチする
すべてのグループに置かれます。そうでない場合、記事は最初の規則にマッチす
るグループだけに置かれます。例えばグループパラメータ @samp{(sieve
address "sender" "owner-ding@@hpc.uh.edu")} は、
@code{gnus-sieve-crosspost} が nil だったら以下の Sieve コードの断片を作
ります。(@code{gnus-sieve-crosspost} が非-nil だった場合は、行が含
む @code{stop} の呼び出しが削除されること以外は同じです。)

@example
if address "sender" "owner-ding@@hpc.uh.edu" @{
        fileinto "INBOX.ding";
        stop;
@}
@end example

@xref{Top, ,Top, sieve, Emacs Sieve}.

@table @kbd
@item D g
@kindex D g (グループ)
@findex gnus-sieve-generate
@vindex gnus-sieve-file
@cindex generating sieve script
@code{sieve} グループパラメータから Sieve スクリプトを再作成して、
@code{gnus-sieve-file} に書き込みます。以前の内容は保存されません。

@item D u
@kindex D u (グループ)
@findex gnus-sieve-update
@vindex gnus-sieve-file
@cindex updating sieve script
@code{sieve} グループパラメータを元に @code{gnus-sieve-file} の gnus が
管理している部分を再作成してファイルにセーブし、@code{sieveshell} プログ
ラムを使ってサーバーにアップロードします。
@end table

@node Summary Buffer
@chapter 概略バッファ
@cindex summary buffer

概略バッファ (summary buffer) ではそれぞれの記事が一行で表示されます。そ
の中を動き回り、記事を読み、投稿し、返答をすることができます。

概略バッファに移る一番普通の方法は、グループバッファでグループを選択する
ことです (@pxref{Selecting a Group})。

概略バッファは望むだけたくさん開いた状態にしておくことができます。

@menu
* Summary Buffer Format::       概略バッファの外観を決定する
* Summary Maneuvering::         概略バッファを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            
* Marking Articles::            記事に既読や期限切れ削除可能等の印を付け
                                る
* Limiting::                    概略バッファに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられる
                                か
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Article Backlog::             既に読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱
                                える
* Article Treatment::           記事バッファはお望みどおりに目茶苦茶にで
                                きる
@c * MIME Commands::               Doing MIMEy things with the articles.
@c * Charsets::                    Character set issues.
* Article Commands::            記事バッファでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファを並べ替える
* Finding the Parent::          子記事に援助が無いって? 親記事を取得しな
                                さい
* Alternative Approaches::      初期設定でない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使う
                                ことができる
* Various Summary Stuff::       他のどの場所にも合わなかったもの
* Exiting the Summary Buffer::  グループバッファに戻る、
                                または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われ
                                るか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手
                                段
@c * Security::                    Decrypt and Verify.
* Mailing List::                メーリングリストマイナーモード
@end menu

@node Summary Buffer Format
@section 概略バッファの様式
@cindex summary buffer format

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{180}{
\put(0,0){\epsfig{figure=ps/summary,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=ps/summary-article,width=7.5cm}}}
}
@end iflatex
@end iftex

@menu
* Summary Buffer Lines::        概略バッファがどのように見えるべきかを指
                                定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファをきれいで素敵にする
@end menu

@findex std11-extract-address-components
@findex mail-extract-address-components
@findex gnus-extract-address-components
@vindex gnus-extract-address-components
Gnus は変数 @code{gnus-extract-address-components} の値を @code{From} ヘッ
ダーの名前とアドレスの部分を手に入れるための関数として使います。すでに定
義されている関数が三つ存在します:
@code{gnus-extract-address-components} は初期値ですが、とても簡単に割り
切った解決法で、非常に速く動作します。
@code{mail-extract-address-components} は良く動作しますが、やや遅くなり
ます。そして、@code{std11-extract-address-components} はとても良く動作し
ますが、遅くなります。ディフォルトの関数は 5% の割合で間違って答えます。
もしこれに我慢ならないのであれば、他の関数を代わりに使うことができます:

@lisp
(setq gnus-extract-address-components
      'mail-extract-address-components)
@end lisp

@vindex gnus-summary-same-subject
@code{gnus-summary-same-subject} は今読んでいる記事が、その前の記事と同
じ表題 (subject) であることを示す文字列です。この文字列は仕様がこれを要
求するときに使われます。初期設定では @code{""} です。

@node Summary Buffer Lines
@subsection 概略バッファの行

@vindex gnus-summary-line-format
変数 @code{gnus-summary-line-format} の値を変えることによって、概略バッ
ファでの行の様式 (format) を変更することができます。いくつかの拡
張 (@pxref{Formatting Variables}) を除いて、普通の @code{format} 文字列
と同じように動作します。

行には常にコロンかポイント位置のマーカーが存在していなければなりません。
操作した後に、カーソルはいつもコロンかポイント位置のマーカーの場所に移動
します。(もちろん、この動作を変えることができないとしたら Gnus にはある
まじきことです。関数 @code{gnus-goto-colon} を、あなたが好きなカーソルの
動きになるように、新たに書けば良いのです。) @xref{Positioning Point}。

初期値の文字列は @samp{%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n} です。

以下の様式指示文字と拡張様式指示を使うことができます:

@table @samp
@item N
記事数。
@item S
表題の文字列。@code{gnus-list-identifiers} の設定によってメーリングリス
トの標識が削除されます。@xref{Article Hiding}。
@item s
スレッド (thread) の基記事であるときか直前の記事が違う表題のときはその題
名で、それ以外は @code{gnus-summary-same-subject}。
(@code{gnus-summary-same-subject} の初期値は @code{""}。)
@item F
完全な @code{From} 欄。
@item n
名前 (@code{From} 欄より)。
@item f
名前、@code{To} ヘッダーか @code{Newsgroups} ヘッダーで
す (@pxref{To From Newsgroups})。
@item a
名前 (@code{From} 欄より)。これと @code{n} との違いは、これは変
数 @code{gnus-extract-address-components} で指定されている関数を使って名
前を取得することです。この方が遅いですが、おそらくより完全に近いでしょう。
@item A
名前 (@code{From} 欄より)。これは @code{a} と同じように動作します。
@item L
記事の行数。
@item c
記事の文字数。この名前指定子は (nnfolder のような) いくつかの選択方法を
サポートしません。
@item k
整形された記事の文字数; 例えば @samp{1.2k} や @samp{0.4M}。
@item I
スレッドのレベルによる字下げ (@pxref{Customizing Threading})。
@item B
複雑な trn 様式のスレッド木 (tree)。どのような応答が行なわれたかの記録を
表示します。
@item T
記事が本記事であれば何も表示せず、そうでない場合はたくさんの空白です (後
のものをすべて画面の外に追い出してしまいます)。
@item [
開き括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます (@pxref{Customizing Threading})。
@item ]
閉じ括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます。
@item >
それぞれのスレッドのレベルに対して一つの空白。
@item <
二十引くスレッドレベルの空白。
@item U
未読。@xref{Read Articles}。

@item R
この紛らわしい名前指定子は @dfn{secondary mark} によって定義されます。こ
のマークは記事が既に返答済みのものか、キャッシュされたものか、あるいは保
存されたものかを表します。@xref{Other Marks}。

@item i
数字としてのスコア (@pxref{Scoring})。
@item z
@vindex gnus-summary-zcore-fuzz
これは、zcore で初期設定のレベルよりも上であれば @samp{+} で、初期設定の
レベルよりも下であれば @samp{-} です。
@code{gnus-summary-default-score} との差
が @code{gnus-summary-zcore-fuzz} よりも小さいと、この仕様は使われません。
@item V
スレッド全体のスコア。
@item x
@code{Xref}.
@item D
@code{日付} (@code{Date})。
@item d
@code{DD-MM}様式による@code{日付}。
@item o
@var{YYYYMMDD}@code{T}@var{HHMMSS}様式による@code{日付}。
@item M
@code{Message-ID}.
@item r
@code{References}.
@item t
現在の副スレッドの記事の数。この仕様を使うと概略バッファの生成が幾分遅く
なります。
@item e
記事に子記事があると、@samp{=} (@code{gnus-not-empty-thread-mark}) が表
示されます。
@item P
行数。
@item O
ダウンロードの印。
@item &user-date;
経過時間の様式。いろいろな様式が @code{gnus-user-date-format-alist} で定
義されています。
@item u
利用者定義指定子。フォーマット文字列の中の次の文字が英字である必要があり
ます。これにより gnus は関
数 @code{gnus-user-format-function-}@samp{X} を呼び出しますが、ここ
で @samp{X} は @samp{%U} の次の文字です。関数には現在の記事のヘッダーが
引数として渡されます。関数は文字列を返し、他の概略指定と同様に概略に挿入
されます。
@end table

@samp{%(} と @samp{%)} の間にあるテキストは、そこにマウスがあるとき
に @code{gnus-mouse-face} でハイライトされます。そういう領域は一つだけで
す。

@samp{%U} (状態), @samp{%R} (返答済み), @samp{%z} (zcore) の扱いには気を
付ける必要があります。効率のために、gnus はこれらの文字がどの桁に現れる
かを計算し、『ハード・コード』します。これは、可変長の仕様の後では、これ
らは意味を持たないということです。まぁ、さすがに逮捕はされないでしょうが、
概略バッファは変になります。それでも十分悲しいでしょうけど。

賢い選択はこれらの指定をできるだけ左に持ってくることです。(でも、そうい
うことはすべてに当てはまるのではないでしょうか。閑話休題。)

この制限は将来の版では無くなるかも知れません。

@node To From Newsgroups
@subsection To From Newsgroups
@cindex To
@cindex Newsgroups

いくつかのグループでは (特にアーカイブグループ), @code{From} ヘッダーは
あまり興味を引きません。そこの全ての記事はあなたによって書かれたものです
から。代わりに、@code{To} や @code{Newsgroups} ヘッダーの情報を表示する
ためには、三つのことを決める必要があります: どの情報を集めるか, どこに表
示するか, いつ表示するか。

@enumerate
@item
@vindex gnus-extra-headers
追加のヘッダーの情報は @code{gnus-extra-headers} により制御されます。こ
れはヘッダーのシンボルのリストです。例えば:

@lisp
(setq gnus-extra-headers
      '(To Newsgroups X-Newsreader))
@end lisp

これは、gnus がこれらの三つのヘッダーを取得しようとし、後の容易な取得の
ためにヘッダー構造に保存するという結果になります。

@item
@findex gnus-extra-header
これらの追加のヘッダーの値は @code{gnus-extra-function} 関数を通じて扱う
ことができます。これは @code{X-Newsreader} ヘッダーを使う書式行の仕様で
す:

@example
"%~(form (gnus-extra-header 'X-Newsreader))@@"
@end example

@item
@vindex gnus-ignored-from-addresses
@code{gnus-ignored-from-addresses} 変数はいつ @samp{%f} 概略行仕様
が @code{To}, @code{Newsreader} や @code{From} ヘッダーを返せば良いかを
決めます。この正規表現が @code{From} ヘッダーの内容と合致すると、
@code{To} や @code{Newsreader} ヘッダーが代わりに仕様されます。

@end enumerate

@vindex nnmail-extra-headers
関連した変数は @code{nnmail-extra-headers} で、overview (@sc{nov}) ファ
イルにいつ追加のヘッダーを含めるかを制御します。古い overview ファイルが
ある場合は、この変数を変更した後にサーバーバッファに `^' で入って適切な
メールサーバー (例えば nnml) で `g' を押し、再生成する必要があります。

@vindex gnus-summary-line-format
gnus に、@code{gnus-summary-line-format} 変数の @code{%n} 仕様
を @code{%f} 仕様に変更することで、データを表示するように指示する必要が
あります。

要約すると、普通は以下のようなものを @file{~/.gnus} に置くことになります:

@lisp
(setq gnus-extra-headers
      '(To Newsgroups))
(setq nnmail-extra-headers gnus-extra-headers)
(setq gnus-summary-line-format
      "%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n")
(setq gnus-ignored-from-addresses
      "Your Name Here")
@end lisp

(上記の値は gnus のディフォルト値です。あなたの役に立つように変えて下さ
い。)

ニュース管理人、またはニュース管理人を説得してサポートの追加をしてもらお
うと思っているユーザーのみなさんへのご注意:

上記のことは、作成される @sc{nov} ファイルを操作できるメールグループでは
たいていの場合役立ちます。しかし、管理人を説得して (特に INN の普通の実
装において) 以下のものを

@example
Newsgroups:full
@end example

@file{overview.fmt} ファイルの最後に追加してもうらうことができれば、メー
ルグループでの追加ヘッダーのようにそれを使うことができます。

@node Summary Buffer Mode Line
@subsection 概略バッファのモード行

@vindex gnus-summary-mode-line-format
概略のモード行の様式も変更することができます (@pxref{Mode Line
Formatting})。@code{gnus-summary-mode-line-format} を何でも好きなものに
変更してください。初期値は @samp{Gnus: %%b [%A] %Z} です。

以下があなたが遊ぶことのできるそれぞれの要素です:

@table @samp
@item G
グループ名。
@item p
接頭語を取り除いた名前。
@item A
現在の記事番号。
@item z
現在の記事スコア。
@item V
Gnus バージョン。
@item U
そのグループでの未読記事の数。
@item e
概略バッファに表示されていない未読記事の数。
@item Z
未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記事があ
る場合は @samp{<%U(+%e) more>} で、未読記事のみの場合
は @samp{<%U more>} です。
@item g
短縮グループ名。例えば、@samp{rec.arts.anime} は @samp{r.a.anime} に短縮
されます。
@item S
現在の記事の表題。
@item u
利用者定義の仕様 (@pxref{User-Defined Specs})。
@item s
現在のスコアファイルの名前 (@pxref{Scoring})。
@item d
保留記事の数 (@pxref{Unread Articles})。
@item t
可視印付き記事の数 (@pxref{Unread Articles})。
@item r
その一連の動作の間に既読として印がついた記事の数。
@item E
スコアファイルによって抹消された記事の数。
@end table

@node Summary Highlighting
@subsection 概略のハイライト

@table @code
@item gnus-visual-mark-article-hook
@vindex gnus-visual-mark-article-hook
このフックは記事を選択した後に実行されます。これは何らかの方法で記事をハ
イライトするように意図されています。も
し @code{gnus-visual} が @code{nil} である場合は実行されません。

@item gnus-summary-update-hook
@vindex gnus-summary-update-hook
このフックは概略行が変更されたときに呼ばれます。も
し @code{gnus-visual} が @code{nil} である場合は実行されません。

@item gnus-summary-selected-face
@vindex gnus-summary-selected-face
これは概略バッファでの現在の記事をハイライトするために使われるフェイ
ス (face) (もしくは、いくらかの人々が @dfn{フォント} (font) と呼ぶような
もの) です。

@item gnus-summary-highlight
@vindex gnus-summary-highlight
概略行はこの変数にしたがってハイライトされます。この変数は要素
が @code{(@var{form} . @var{face})} の形式のリストです。例えば、もし印付
きの記事をイタリック、高いスコアの記事をボールドにしたければ、この変数を
次のようにできます。

@lisp
(((eq mark gnus-ticked-mark) . italic)
 ((> score default) . bold))
@end lisp

ご想像のとおり、もし @var{form} が @code{nil} でない値を返すと、
@var{face} がその行に適用されます。
@end table

@node Summary Maneuvering
@section 概略間の移動
@cindex summary movement

すべての直接移動命令は数値接頭引数を受け付け、あなたの期待によくしたがっ
て動作するでしょう。

これらの命令はどれも記事を選択しません。

@table @kbd
@item G M-n
@item M-n
@kindex M-n (概略)
@kindex G M-n (概略)
@findex gnus-summary-next-unread-subject
概略行の次の未読記事に移る (@code{gnus-summary-next-unread-subject})。

@item G M-p
@itemx M-p
@kindex M-p (概略)
@kindex G M-p (概略)
@findex gnus-summary-prev-unread-subject
概略行の前の未読記事に移る (@code{gnus-summary-prev-unread-subject})。

@item G g
@kindex G g (概略)
@findex gnus-summary-goto-subject
記事番号か @code{Message-ID} を尋ね、それからその記事を表示すること無く、
概略行に行く (@code{gnus-summary-goto-subject})。
@end table

Gnus が次のグループに移動することを確認をするために、キーを押すことを要
求するときがあります。その時は、@kbd{C-n} と @kbd{C-p} を使って、グルー
プバッファに戻ること無く次に読むグループを探すことができます。

概略の移動に関連した変数:

@table @code
@vindex gnus-auto-select-next
@item gnus-auto-select-next
もし移動命令の一つ (@kbd{n} のような) を出し、現在の記事の後に未読が無け
れば、gnus は次のグループに移動することを奨めます。この変数
が @code{t} で次のグループが空であると、gnus は概略モードを終了して、グ
ループバッファに戻ります。この変数が @code{t} や @code{nil} でないと、次
のグループに記事があろうが無かろうが、gnus はそれを選択します。特別な場
合として、この変数が @code{quietly} であると、gnus は確認をせずに、次の
グループを選択します。この変数が @code{almost-quietly} であると、グルー
プの一番最後の記事を読んでいたときに限り同じことが起こります。最後に、も
しこの変数が @code{slightly-quietly} であると、命令 @kbd{Z n} は確認をせ
ずに次のグループに移ります。@pxref{Group Levels} も参照してください。

@item gnus-auto-select-same
@vindex gnus-auto-select-same
@code{nil} でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
しようとします。(@dfn{同じ} はここでは @dfn{大体同じ} という意味かも知れ
ません。詳細は @code{gnus-summary-gather-subject-limit} を見てくださ
い (@pxref{Customizing Threading} も参照してください)。) 同じ表題の記事
が無いときは最初の未読記事に移動します。

この変数は、スレッド表示を行っているときはあまり役に立たないでしょう。

@item gnus-summary-check-current
@vindex gnus-summary-check-current
@code{nil} でないと、すべての『未読』移動命令は、次 (もしくは前) の記事
に移動しません。その代わりに、それらは現在の記事を選びます。

@item gnus-auto-center-summary
@vindex gnus-auto-center-summary
@code{nil} でないと、gnus は概略バッファでのポイントを常に真中に保ちます。
これをすると、とてもこぎれいになりますが、遅いネットワーク接続であったり、
単にこの Emacsism でない行為を好きになれないのであれば、普通の Emacs の
スクロールにするために、この変数を @code{nil} にすることができます。これ
は概略バッファの水平方向の真中への再移動も禁止しますので、非常に長いスレッ
ドを読むときは不便かもしれません。
@end table

@node Choosing Articles
@section 記事の選択
@cindex selecting articles

@menu
* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数
@end menu

@node Choosing Commands
@subsection 命令の選択

以下の移動コマンドはどれも数値接頭引数を受け付けず、記事を選択し、表示し
ます。

新しい記事を取り込んだり、グループを再表示したいときは @ref{Exiting the
Summary Buffer} を参照して下さい。

@table @kbd
@item SPACE
@kindex SPACE (概略)
@findex gnus-summary-next-page
現在の記事か、それが既に読まれている場合は次の未読記事を選択しま
す (@code{gnus-summary-next-page})。

@item G n
@itemx n
@kindex n (概略)
@kindex G n (概略)
@findex gnus-summary-next-unread-article
@c @icon{gnus-summary-next-unread}
次の未読記事に移動します (@code{gnus-summary-next-unread-article})。

@item G p
@itemx p
@kindex p (概略)
@findex gnus-summary-prev-unread-article
@c @icon{gnus-summary-prev-unread}
前の未読記事に移動します (@code{gnus-summary-prev-unread-article})。

@item G N
@itemx N
@kindex N (概略)
@kindex G N (概略)
@findex gnus-summary-next-article
次の記事に移動します (@code{gnus-summary-next-article})。

@item G P
@itemx P
@kindex P (概略)
@kindex G P (概略)
@findex gnus-summary-prev-article
前の記事に移動します (@code{gnus-summary-prev-article})。

@item G C-n
@kindex G C-n (概略)
@findex gnus-summary-next-same-subject
同じ表題の次の記事に移動します (@code{gnus-summary-next-same-subject})。

@item G C-p
@kindex G C-p (概略)
@findex gnus-summary-prev-same-subject
同じ表題の前の記事に移動します (@code{gnus-summary-prev-same-subject})。

@item G f
@itemx .
@kindex G f (概略)
@kindex . (概略)
@findex gnus-summary-first-unread-article
最初の未読記事に移動します (@code{gnus-summary-first-unread-article})。

@item G b
@item ,
@kindex G b (概略)
@kindex , (概略)
@findex gnus-summary-best-unread-article
最高スコアの未読記事に移動しま
す (@code{gnus-summary-best-unread-article})。もし接頭引数が与えられたな
らば、ディフォルトのスコアより大きいスコアを持つ最初の未読記事に移動しま
す。

@item G l
@itemx l
@kindex l (概略)
@kindex G l (概略)
@findex gnus-summary-goto-last-article
直前の記事に移動します (@code{gnus-summary-goto-last-article})。

@item G o
@kindex G o (概略)
@findex gnus-summary-pop-article
概略の履歴 (history) から最後の記事を一つ取り出して選択します。
(@code{gnus-summary-pop-article})。この命令が上の命令と違うのは、
@kbd{l} が最終二つの記事の間を移動するのに対して、これは好きなだけ前の記
事を履歴から選び出すことができる点です。何らかのこれに関係したこと
は (もしこれらの命令をたくさん使うのであれば)、
@pxref{Article Backlog} を参照してください。

@item G j
@item j
@kindex j (概略)
@kindex G j (概略)
@findex gnus-summary-goto-article
記事番号か @code{Message-ID} を尋ね、それからその記事に行く。
(@code{gnus-summary-goto-article})。
@end table

@node Choosing Variables
@subsection 選ぶための変数

記事を移動し、選択するのに関連したいくつかの変数:

@table @code
@item gnus-auto-extended-newsgroup
@vindex gnus-auto-extend-newsgroup
この変数が @code{nil} でないと、すべての移動命令は、もしその記事が概略バッ
ファに表示されていない場合でも、前 (もしくは次) の記事に移動しようとしま
す。その命令の後で、gnus はサーバーから記事を取得して、記事バッファに表
示します。

@item gnus-select-article-hook
@vindex gnus-select-article-hook
このフックは記事が選択されたときに常に呼ばれます。初期設定では、選択され
た記事の下に隠れているスレッドを見せるようになっています。

@item gnus-mark-article-hook
@vindex gnus-mark-article-hook
@findex gnus-summary-mark-unread-as-read
@findex gnus-summary-mark-read-and-unread-as-read
@findex gnus-unread-mark
このフックは記事が選択されたときに常に呼ばれます。それは記事に既読の印を
付けるためにあります。初期値
は @code{gnus-summary-mark-read-and-unread-as-read} で、ほとんどすべての
読んだ記事の印を @code{gnus-read-mark} に変更します。この関数に影響され
ない記事は、可視、保留、期限切れ削除可能記事だけです。もし、未読に既読の
印を付けたいだけであれば、代わり
に @code{gnus-summary-mark-unread-as-read} を使うことができます。それは、
@code{gnus-low-score-mark} や @code{gnus-del-mark} (などなど) の印をその
まま残します。
@end table

@node Paging the Article
@section 記事のスクロール
@cindex article scrolling

@table @kbd
@item SPACE
@kindex SPACE (概略)
@findex gnus-summary-next-page
@kbd{SPACE} は記事を一ページ先にスクロールします。記事の最後にいる場合は
次の記事を選択します (@code{gnus-summary-next-page})。

@item DEL
@kindex DEL (概略)
@findex gnus-summary-prev-page
現在の記事を一ページ前にスクロールします (@code{gnus-summary-prev-page})。

@item RET
@kindex RET (概略)
@findex gnus-summary-scroll-up
現在の記事を一行先にスクロールします (@code{gnus-summary-scroll-up})。

@item M-RET
@kindex M-RET (概略)
@findex gnus-summary-scroll-down
現在の記事を一行後ろへスクロールします (@code{gnus-summary-scroll-down})。

@item A g
@itemx g
@kindex A g (概略)
@kindex g (概略)
@findex gnus-summary-show-article
@vindex gnus-summary-show-article-charset-alist
現在の記事を (再) 取得します。もし接頭引数が与えられると、現在の記事を取
得しますが、記事を扱う関数は実行しません。これは、サーバーからきたままの、
『生の』記事を与えます。

接頭引数を与えると、手動で文字集合の操作を行うことができます。
@kbd{C-u 0 g cn-gb-2312 RET} により、メッセージはあたか
も @code{cn-gb-2312} 文字集合で符号化されたかのように復号化されます。こ
れは、以下のような記述とともに @kbd{C-u 1 g} を行うのと同じです。

@lisp
(setq gnus-summary-show-article-charset-alist
      '((1 . cn-gb-2312)
        (2 . big5)))
@end lisp

@item A <
@itemx <
@kindex < (概略)
@kindex A < (概略)
@findex gnus-summary-beginning-of-article
記事の最初までスクロールします。
(@code{gnus-summary-beginning-of-article})。

@item A >
@itemx >
@kindex > (概略)
@kindex A > (概略)
@findex gnus-summary-end-of-article
記事の最後までスクロールします (@code{gnus-summary-end-of-article})。

@item A s
@itemx s
@kindex A s (概略)
@kindex s (概略)
@findex gnus-summary-isearch-article
記事バッファでインクリメンタルサーチ (isearch) を行いま
す (@code{gnus-summary-isearch-article})。

@item h
@kindex h (概略)
@findex gnus-summary-select-article-buffer
記事バッファを選択します (@code{gnus-summary-select-article-buffer})。
@end table

@node Reply Followup and Post
@section 返答、フォローアップ、投稿

@menu
* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::   
@end menu

@node Summary Mail Commands
@subsection 概略でのメールの命令
@cindex mail
@cindex composing mail

メールメッセージを作成するための命令:

@table @kbd
@item S r
@item r
@kindex S r (概略)
@kindex r (概略)
@findex gnus-summary-reply
@c @icon{gnus-summary-mail-reply}
@c @icon{gnus-summary-reply}
現在の記事を書いた人に返答のメールを送ります (@code{gnus-summary-reply})。

@item S R
@itemx R
@kindex R (概略)
@kindex S R (概略)
@findex gnus-summary-reply-with-original
@c @icon{gnus-summary-reply-with-original}
現在の記事を書いた人に、本記事を含んだ返答のメールを出しま
す (@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引
数の習慣を使います。

@item S w
@kindex S w (概略)
@findex gnus-summary-wide-reply
現在の記事を書いた人に対して、広い返答 (wide reply) をしま
す (@code{gnus-summary-wide-reply})。@dfn{広い返答} とはヘッダー
の @code{To}, @code{From}, (もしくは @code{Reply-to}) と @code{Cc}) のす
べての人に返答をすることです。

@item S W
@kindex S W (概略)
@findex gnus-summary-wide-reply-with-original
現在の記事に本記事を含んだ広い返答のメールを送りま
す (@code{gnus-summary-wide-reply-with-original})。この命令はプロセス/接
頭引数の習慣を使います。

@item S v
@kindex S v (概略)
@findex gnus-summary-very-wide-reply
現在の記事を書いた人に対して、非常に広い返答 (very wide reply) をしま
す (@code{gnus-summary-very-wide-reply})。@dfn{非常に広い返答} とは、プ
ロセス/接頭引数で指定されたすべての記事のヘッダーの @code{To},
@code{From}, (もしくは @code{Reply-to}) と @code{Cc}) のすべての人に返答
をすることです。この命令はプロセス/接頭引数の習慣を使います。

@item S V
@kindex S V (概略)
@findex gnus-summary-very-wide-reply-with-original
現在の記事に本記事を含んだ非常に広い返答のメールを送りま
す (@code{gnus-summary-very-wide-reply-with-original})。この命令はプロセ
ス/接頭引数の習慣を使います。

@item S B r
@kindex S B r (概略)
@findex gnus-summary-reply-broken-reply-to
現在の記事を書いた人に対して返答をしますが @code{Reply-To} フィールドは
無視します (@code{gnus-summary-reply-broken-reply-to})。

@item S B R
@kindex S B R (概略)
@findex gnus-summary-reply-broken-reply-to-with-original
現在の記事を書いた人に対して本記事を含んだ返答をします
が @code{Reply-To} フィールドは無視しま
す (@code{gnus-summary-reply-broken-reply-to-with-original})。

@item S o m
@itemx C-c C-f
@kindex S o m (概略)
@kindex C-c C-f (概略)
@findex gnus-summary-mail-forward
@c @icon{gnus-summary-mail-forward}
誰か他の人に現在の記事を転送します (@code{gnus-summary-mail-forward})。
接頭引数があると、転送記事の完全なヘッダーを取り込みます。

@item S m
@itemx m
@kindex m (概略)
@kindex S m (概略)
@findex gnus-summary-mail-other-window
@c @icon{gnus-summary-mail-originate}
メールを作成します (@code{gnus-summary-mail-other-window})。ディフォルト
では現在のグループの投稿様式 (posting style) を使います。もし接頭辞が与
えられたらそれは使いません。もし接頭辞が 1 だったら、どのグループの投稿
様式を使うかを尋ねます。

@item S i
@itemx i
@kindex i (概略)
@kindex S i (概略)
@findex gnus-summary-news-other-window
ニュースを作成します (@code{gnus-summary-news-other-window})。ディフォル
トでは現在のグループに投稿します。もし接頭辞が与えられたら現在のグループ
名は使われません。もし接頭辞が 1 だったら、どのグループに投稿するかを尋
ねます。

この関数は、たとえメールグループで使われたとしても、実際にはニュースの様
式を用意します。これは、メッセージを実際にはネットワーク経由で送らずに、
メールグループに "投稿" するのに便利です; それらは当のグループに単に直接
セーブされます。対応するバックエンドが投稿のためのメソッド (request-post
method) を持っていなければなりませんが。

@item S D b
@kindex S D b (概略)
@findex gnus-summary-resend-bounced-mail
@cindex bouncing mail
メールを送ったのに、何らかの理由 (アドレスの間違い、転送の不調) で戻って
きたときに、この命令を使って戻ってきたメールをもう一回送ることができま
す (@code{gnus-summary-resend-bonced-mail})。もう一度メールを送る前にヘッ
ダーを編集できるように、メールバッファにそのメールが現れるでしょう。この
命令に接頭引数を与えて、戻ってきたメールが誰かへの返答であった場合、
gnus はそのメールを取得して、それのヘッダーの精密調査ができるように画面
に表示します。ま、これはとてもよく失敗しますけど。

@item S D r
@kindex S D r (概略)
@findex gnus-summary-resend-message
上の命令と混同しないように、@code{gnus-summary-resend-message} は現在の
メッセージを送る先のアドレスの入力を促し、それからその場所にメールを送り
ます。メッセージのヘッダーは変更されません――しかし、
@code{Resent-To}, @code{Resent-From} 等のヘッダーが付け加えられます。こ
れは、(おそらく) あなた自身を @code{To} 欄に書いた本人にもメールを送って
しまうということです。これは混乱を招くでしょう。ですから、もちろん、本当
に 邪悪 な気分のときにだけこれを使うでしょう。

この命令は主に、あなたがいくつかのメールアカウント (account) を持ってい
て、自分自身の違ったアカウントにメールを転送したいときに用いられます。
(もしあなたが、@code{ルート} (root) であり、
@code{ポストマスター} (postmaster) でもあり、@code{ルート} に @code{ポス
トマスター} へのメールを受け取った場合は、それ
を @code{ポストマスター} にも再送したいと思うでしょ
う。Ordnung muss sein!)

この命令はプロセス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S O m
@kindex S O m (概略)
@findex gnus-summary-digest-mail-forward
現在の一連の記事 (@pxref{Decoding Articles}) の要約を作り、メールでその
結果を送ります (@code{gnus-summary-digest-mail-forward})。この命令はプロ
セス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S M-c
@kindex S M-c (概略)
@findex gnus-summary-mail-crosspost-complaint
@cindex crossposting
@cindex excessive crossposting
現在の記事の書き手に、過剰クロスポストへの苦情のメールを送りま
す (@code{gnus-summary-mail-crosspost-complaint})。

@findex gnus-crosspost-complaint
この命令は、現在 Usenet に横行している、クロスポストの世界的流行に対して
反撃を行う手段として提供されています。これは変
数 @code{gnus-crosspost-complaint} を序文にして、返答を作成します。この
命令はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) に従い、それぞれ
のメールを送る前に送信するかどうかの確認をします。
@end table

また @xref{Header Commands, ,ヘッダー命令, message-ja, The Message
Manual}, にさらなる情報があります。

@node Summary Post Commands
@subsection 概略の投稿命令
@cindex post
@cindex composing news

ニュースの記事を投稿するための命令:

@table @kbd
@item S p
@itemx a
@kindex a (概略)
@kindex S p (概略)
@findex gnus-summary-post-news
@c @icon{gnus-summary-post-news}
投稿するための記事を作成します (@code{gnus-summary-post-news})。ディフォ
ルトでは現在のグループに投稿します。もし接頭辞が与えられたら現在のグルー
プ名は使われません。もし接頭辞が 1 だったら、代わりに別のどのグループに
投稿するかを尋ねます。

@item S f
@itemx f
@kindex f (概略)
@kindex S f (概略)
@findex gnus-summary-followup
@c @icon{gnus-summary-followup}
現在の記事のフォローアップを投稿します (@code{gnus-summary-followup})。

@item S F
@itemx F
@kindex S F (概略)
@kindex F (概略)
@c @icon{gnus-summary-followup-with-original}
@findex gnus-summary-followup-with-original
本記事を取り込んで、現在の記事にフォローアップをしま
す (@code{gnus-summary-followup-with-original})。この命令はプロセス/接頭
引数の習慣を用います。

@item S n
@kindex S n (概略)
@findex gnus-summary-followup-to-mail
メールのメッセージを受け取っていたとしても、現在の記事のフォローアップを
ニュースに投稿しま
す (@code{gnus-summary-followup-to-mail})。この命令はプロセス/接頭引数の
習慣を用います。

@item S N
@kindex S N (概略)
@findex gnus-summary-followup-to-mail-with-original
メールのメッセージを受け取っていたとしても、本記事を引用して、現在の記事
のフォローアップをニュースに投稿しま
す (@code{gnus-summary-followup-to-mail-with-original}). この命令はプロ
セス/接頭引数の習慣を用います。

@item S o p
@kindex S o p (概略)
@findex gnus-summary-post-forward
現在の記事をニュースグループに転送しま
す (@code{gnus-summary-post-forward})。接頭引数が与えられたときは、転送
記事のヘッダーを完全に取り込みます。

@item S O p
@kindex S O p (概略)
@findex gnus-summary-digest-post-forward
@cindex digests
@cindex making digests
現在の一連の記事を要約して、その結果をニュースグループに送りま
す (@code{gnus-summary-digest-post-forward})。この命令はプロセス/接頭引
数の習慣を用います。

@item S u
@kindex S u (概略)
@findex gnus-uu-post-news
@c @icon{gnus-uu-post-news}
ファイルを Uuencode し、分割して、組にして投稿しま
す (@code{gnus-uu-post-news})。(@pxref{Uuencoding and Posting})。
@end table

また @xref{Header Commands, ,ヘッダー命令, message-ja, The Message
Manual}, にさらなる情報があります。

@c FIXME this is not implemented
@node Summary Message Commands
@subsection 概略メッセージ命令

@table @kbd
@item S y
@kindex S y (概略)
@findex gnus-summary-yank-message
現在の記事を既に存在する Message 作成バッファに貼り付けま
す (@code{gnus-summaryyank-message})。この命令は貼り付けたいメッセージバッ
ファの入力を促し、プロセス/接頭辞の習慣を理解しま
す (@pxref{Process/Prefix})。
@end table

@node Canceling and Superseding
@subsection 記事を取り消す
@cindex canceling articles
@cindex superseding articles

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなければ
なぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニュースの投稿は取り消す
ことができます。

@findex gnus-summary-cancel-article
@kindex C (概略)
@c @icon{gnus-summary-cancel-article}
取り消したい記事を見つけてください (取り消すことができるのは自分の記事だ
けです。変なことは試さないでください)。それから、
@kbd{C} か @kbd{S c} を押してくださ
い (@code{gnus-summary-cancel-article})。あなたの記事が取り消されま
す――世界中の機械があなたの記事を取り消します。この命令はプロセス/接頭
引数の習慣を用います (@pxref{Process/Prefix})。

しかし、注意してほしいのはすべてのサイト (site) が取り消しを扱っているわ
けではないことです。ですから、たいていのサイトが問題の記事を取り消しても、
あちこちであなたの記事は生き残るかもしれません。

Gnus は、取り消すときに『現在』の選択方法を使います。標準の投稿方法を使
いたいのであれば、文字接頭引数 @samp{a} を使ってくださ
い (@pxref{Symbolic Prefixes})。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、
@dfn{代替} (@dfn{superseding}) 記事を投稿して本記事を置き換えることがで
きます。

@findex gnus-summary-supersede-article
@kindex S (概略)
本記事のところへ移動して、@kbd{S s} を押してくださ
い (@code{gnus-summary-supersede-article})。普通の方法でそれを送る前に、
記事を好きなように編集することができます。代替に関しても、取り消しと同じ
ことが当てはまります。こちらの方がもっとよく当てはまるかもしれませ
ん: いくつかのサイトは代替を受け付けません。これらのサイトでは、あなたが
ほとんど同じ記事を二回投稿したようになります。

もしさっき記事を投稿したばかりですぐに変更したくなた場合、記事が最初にあ
なたのサイトに現れる前に取り消し/代替をするための巧妙な手段があります。
まず、投稿バッファ (@code{*sent ... *} のようになっています) に戻ります。
そこにはあなたがちょうど投稿した記事があり、すべてのヘッダーがそのままあ
ります。それらの中の @code{Message-ID} という語のところを変更することに
よって @code{Message-ID} ヘッダーを @code{Cancel} もしく
は @code{Supersedes} に変更してください。

ちょっと覚えておいてください: 'supersede' (代替) という語の中に 'c' は無
いということを。

@node Delayed Articles
@section 遅延記事
@cindex delayed sending
@cindex send delayed

ときとして、あなたはメッセージの送信を先延ばしにしたいと思うことはありま
せんか。例えば、あなたが大切なだれかの誕生日を思い出すために、ちょうどそ
の日に届くメッセージを用意したいと思ったとしましょう。
@code{gnus-delay} パッケージはこれにうってつけです。設定は簡単です:

@lisp
(gnus-delay-initialize)
@end lisp

@findex gnus-delay-article
普段はメッセージを送信するのに Message モードで @kbd{C-c C-c} コマンドを
使いますよね。先延ばしにするには、代わりに @kbd{C-c C-j}
(@code{gnus-delay-article}) を使って下さい。そうすると、どのくらい遅らせ
るかを尋ねてきます。可能な返事は次の通りです:

@itemize @bullet
@item
期間。整数と一つの文字で指定します。例えば @code{42d} は 42 日遅らせるこ
とを意味します。使うことができる文字は @code{m} (分)、@code{h} (時)、
@code{d} (日), @code{w} (週), @code{M} (月) および @code{Y} (年) です。

@item
日付。@code{YYYYY-MM-DD} のような形式で指定します。。メッセージの送信は
その日の特定の時刻 (ディフォルトは 8 時) まで遅らせられます。
@code{gnus-delay-default-hour} も参照して下さい。

@item
時刻。am/pm を含まない 24 時間制の、@code{hh:mm} の形式で与えます。送信
されるのは今日のその時刻ですが、すでにその時刻を過ぎてしまっていた場合は
翌日のその時刻になります。ですから、朝の 10 時に @code{11:15} を指定した
場合は 1時間15分後に送信されることになります。しかし @code{9:20} を指定
した場合は翌日の時刻を意味します。
@end itemize

@code{gnus-delay-article} の動作は、以下の数個の変数に影響されます:

@table @code
@item gnus-delay-default-hour
@vindex gnus-delay-default-hour
特定の日付を指定した場合に、メッセージがその日の何時に送信されるかを与え
ます。可能な値は 0 から 23 までの整数です。

@item gnus-delay-default-delay
@vindex gnus-delay-default-delay
ディフォルトの遅延を与える文字列です。前述のどんな形式でも可能です。

@item gnus-delay-group
@vindex gnus-delay-group
遅延記事は、ドラフトサーバーのこのグループに期限が来るまで保管されます。
たぶんあなたはこれを変更する必要は無いでしょう。ディフォルトの値
は @code{"delayed"} です。

@item gnus-delay-header
@vindex gnus-delay-header
それぞれの記事が送信される日時はヘッダーに記録されます。この変数はヘッダー
名の文字列です。たぶんあなたはこれを変更する必要は無いでしょう。ディフォ
ルトの値は @code{"X-Gnus-Delayed"} です。
@end table

送信の先延ばしはこんなふうに行なわれます:

@code{gnus-delay-article} コマンドで、あなたはどのくらい遅らせるかを指定
します。gnus はメッセージを送信する日時を計算し
て @code{X-Gnus-Delayed} ヘッダーに記録し、そのメッセージ
を @code{nndraft:delayed} グループに納めます。

あなたが新着ニュースを取得しようとするときはいつも、gnus は送信する期限
に達した記事をそのグループで探して、それらを送信します。これには関
数 @code{gnus-delay-send-queue} が使われます。ディフォルトではこの関数
は @code{gnus-get-new-news-hook} に追加されますが、もちろんあなたはこれ
を変更することができます。おそらくあなたは、ドラフトの送信にデーモンを使
いたいと思うのではないでしょうか? それには、デーモンに関
数 @code{gnus-delay-send-queue} を実行せよ、と言うだけで良いのです。

@table @code
@item gnus-delay-initialize
@findex gnus-delay-initialize
ディフォルトでは、この関数は Message モードにおける @kbd{C-c C-j} キーの
バインドと、
@code{gnus-delay-send-queue} の @code{gnus-get-new-news-hook} への追加を
行ないます。ですが、これは @code{no-keymap} と @code{no-check} の二つの
オプション引数を受け付けます。もし @code{no-keymap} が非nil だった
ら @kbd{C-c C-j} キーのバインドを行ないません。もし @code{no-check} が非
nil だったら @code{gnus-get-new-news-hook} は変更されません。

例えば @code{(gnus-delay-initialize nil t)} は、キーマップは変更する
が @code{gnus-get-new-news-hook} は変更しないことを意味します。あなたは
遅延記事の送信にデーモンを使いたいのでしょうね。でも、それを設定すること
を忘れないで下さいね。:-)
@end table

@node Marking Articles
@section 記事に印を付ける
@cindex article marking
@cindex article ticking
@cindex marks

記事に付けられる印はいくつかあります。

記事の @dfn{購読度} (おぉ、すんごい新語句だ!) を決定する印があります。英
字の印は一般的には @dfn{既読}を意味し、英字でない文字は一般的
に @dfn{未読}を意味します。

加えて、購読度に影響しない印もあります。

@menu
* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
@end menu

@ifinfo
これらの印を操作する過剰なくらいの命令があります:
@end ifinfo

@menu
* Setting Marks::               印の付け方と消し方
* Generic Mark Commands::       印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方
@end menu

@node Unread Articles
@subsection 未読記事

以下の印はいろいろな方法で記事に未読の (ような) 印を付けます。

@table @samp
@item !
@vindex gnus-ticked-mark
可視記事 (Ticked) として印をつけます (@code{gnus-ticked-mark})。

@dfn{可視記事}とは、常に可視状態である記事のことです。おもしろいと思う記
事があった場合や、単に読むのを先に延ばしたいときや、後で返答をしたいとき
に、普通は可視印を付けます。しかし、記事は期限切れ消去されることもありま
す (ニュースサーバーのソフトウェアがニュースサーバー上の記事を消去、
gnus 自体は可視記事を期限切れ消去しません) ので、永遠に記事を保存してお
きたい場合は、その記事を永続にする必要がありま
す (@pxref{Persistent Articles})。

@item ?
@vindex gnus-dormant-mark
保留として印を付けます (@code{gnus-dormant-mark})。

@dfn{保留記事}はフォローアップがあったときにだけ概略バッファに現れます。
フォローアップが無いときも表示させたいときは、命令 @kbd{/ D} を使うこと
ができます。それ以外は (見えるかどうかは別にして)、可視記事 (Ticked) と
似たようなものです。

@item SPACE
@vindex gnus-unread-mark
未読として印を付けます (@code{gnus-unread-mark})。

@dfn{未読記事}は今まで全く読まれていない記事のことです。
@end table

@node Read Articles
@subsection 既読記事
@cindex expirable mark

以下のすべての印は記事に既読の印を付けます。

@table @samp
@item r
@vindex gnus-del-mark
利用者が手動やそのようなもので命令 @kbd{d} によって既読の印を付けた記事
です (@code{gnus-del-mark})。

@item R
@vindex gnus-read-mark
実際に読まれた記事 (@code{gnus-read-mark})。

@item O
@vindex gnus-ancient-mark
前回のセッションで既読の印を付けて、今は@dfn{古く}なってしまった記事。

@item K
@vindex gnus-killed-mark
削除の印 (@code{gnus-killed-mark})。

@item X
@vindex gnus-kill-file-mark
削除ファイルによって削除の印がついた記
事 (@code{gnus-kill-file-mark})。

@item Y
@vindex gnus-low-score-mark
低すぎるスコアのために既読の印がついた記
事 (@code{gnus-low-score-mark})。

@item C
@vindex gnus-catchup-mark
キャッチアップによって既読の印がついた記
事 (@code{gnus-catchup-mark})。

@item G
@vindex gnus-canceled-mark
取り消された記事 (@code{gnus-canceled-mark})。

@item F
@vindex gnus-souped-mark
@sc{soup} されている記事 (@code{gnus-souped-mark})。@xref{SOUP}.

@item Q
@vindex gnus-sparse-mark
まばらに参照された記事 (@code{gnus-sparse-mark})。
@xref{Customizing Threading}.

@item M
@vindex gnus-duplicate-mark
重複抑制により既読の印のついた記事 (@code{gnus-duplicate-mark})。
@xref{Duplicate Suppression}.
@end table

これらのすべての印は、本当はただ記事が既読として印がついていることを意味
するだけです。適応スコアリングをしたときには違ったように解釈されますけれ
ど。

もう一つ、特別な印があります:

@table @samp
@item E
@vindex gnus-expirable-mark
期限切れ削除可能として印のついた記事 (@code{gnus-expirable-mark})。

記事を @dfn{期限切れ削除可能} として印を付ける (もしくは、自動的にそのよ
うに印を付ける) ことは、普通のグループではあまり意味がありません――利用
者はニューズ記事の期限による削除を制御していません。しかし、例えばメール
グループでは、@dfn{期限切れ削除可能} として印のついた記事は、いつで
も gnus によって削除されることがあります。
@end table

@node Other Marks
@subsection 他の印
@cindex process mark
@cindex bookmarks

記事が読まれたかどうかには関係しない印がいくつかあります。

@itemize @bullet

@item
現在の記事にしおりを挟むことができます。あなたは猫の尿の習慣に関する長い
論文を読んでいて、それを読み終わる前に夕食を食べるために家に帰らなければ
ならなかったとしましょう。そのときに、記事にしおりを挟むことができ、次に
その記事に出くわしたときに、gnus はそのしおりのところへ移動するでしょう。
@xref{Setting Marks}.

@item
@vindex gnus-replied-mark
返答をしたか、フォローアップをした (例えば、答えた) 記事はすべて二桁目
に @samp{A} の印がつきます (@code{gnus-replied-mark})。

@item
@vindex gnus-forwarded-mark
転送した記事はすべて二桁目に @samp{F} の印がつきま
す (@code{gnus-forwarded-mark})。

@item
@vindex gnus-cached-mark
記事キャッシュに貯められている記事は二桁目に @samp{*} の印がつきま
す (@code{gnus-replied-mark})。@xref{Article Caching}.

@item
@vindex gnus-saved-mark
(何らかの方法によって；必ずしも宗教的というわけではなく) 『保存された』
記事は二桁目に @samp{S} の印がつきます (@code{gnus-saved-mark})。

@vindex gnus-recent-mark
そのグループで ``最近'' (``recently'') 届いた記事は二桁目に @samp{N} の
の印がつきます (@code{gnus-recent-mark})。たいていのバックエンドはこの印
をサポートせず、その場合は単に表示されません。

@item
@vindex gnus-unseen-mark
まだ読まれたことがない記事は二桁目に @samp{.} の印がつきま
す (@code{gnus-unseen-mark})。

@item
@vindex gnus-not-empty-thread-mark
@vindex gnus-empty-thread-mark
もし @samp{%e} の仕様が使われると、スレッドがあるかどうかは、三桁目
に @code{gnus-not-empty-thread-mark} と @code{gnus-empty-thread-mark} の
それぞれによって印がつきます。

@item
@vindex gnus-process-mark
最後に @dfn{プロセス印} があります(@code{gnus-process-mark})。いろいろな
種類の命令がプロセス印があるとそれに対して実行されます。例えば、
@kbd{X u} (@code{gnus-uu-decode-uu}) はプロセス印の付いたすべての記事
を uudecode して、表示します。プロセス印の付いた記事は二桁目
に @samp{#} があります。
@end itemize

これらの『非購読度』の印は初期設定ではたいてい二桁目に現れるということに
気付いたかもしれません。ですから、キャッシュされていて、保存されていて、
返答をした記事にプロセス印が付いている場合、どのようになるのでしょう?

たいしたことはありません。優先順位は次のようになっています: プロセ
ス → キャッシュ → 返答済み → 保存。ですから、ある記事がキャッシュに入っ
ていて、返答されていた場合、キャッシュ印があるだけで、返答済み印はありま
せん。

@node Setting Marks
@subsection 印を付ける
@cindex setting marks

すべての印つけ命令は数値接頭引数を受け付けます。

@table @kbd
@item M c
@itemx M-u
@kindex M c (概略)
@kindex M-u (概略)
@findex gnus-summary-clear-mark-forward
@cindex mark as read
現在の記事から、すべての購読度印を消去しま
す (@code{gnus-summary-clear-mark-forward})。要するに、記事に未読の印を
付けます。

@item M t
@itemx !
@kindex ! (概略)
@kindex M t (概略)
@findex gnus-summary-tick-article-forward
現在の記事に可視記事印を付けま
す (@code{gnus-summary-tick-article-forward})。@xref{Article Caching}.

@item M ?
@itemx ?
@kindex ? (概略)
@kindex M ? (概略)
@findex gnus-summary-mark-as-dormant
現在の記事に保留記事印を付けま
す (@code{gnus-summary-mark-as-read-forward})。@xref{Article Caching}.

@item D
@kindex D (概略)
@findex gnus-summary-mark-as-read-backward
現在の記事に既読の印を付け、前の行にポイントを移動しま
す (@code{gnus-summary-mark-as-read-backward})。

@item M k
@itemx k
@kindex k (概略)
@kindex M k (概略)
@findex gnus-summary-kill-same-subject-and-select
現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未読記事
を選択します (@code{gnus-summary-kill-same-subject-and-select})。

@item M K
@itemx C-k
@kindex M K (概略)
@kindex C-k (概略)
@findex gnus-summary-kill-same-subject
現在の記事と同じ表題を持つすべての記事を既読として印を付けま
す (@code{gnus-summary-kill-same-subject})。

@item M C
@kindex M C (概略)
@findex gnus-summary-catchup
@c @icon{gnus-summary-catchup}
すべての未読記事に既読の印を付けます (@code{gnus-summary-catchup})。

@item M C-c
@kindex M C-c (概略)
@findex gnus-summary-catchup-all
グループのすべての記事に――可視記事や保留記事でさえも、既読の印を付けま
す (@code{gnus-summary-catchup-all})。

@item M H
@kindex M H (概略)
@findex gnus-summary-catchup-to-here
現在のグループの、現在位置とそれ以前の記事を既読として印を付けま
す (@code{gnus-summary-catchup-to-here})。

@item M h
@kindex M h (概略)
@findex gnus-summary-catchup-from-here
現在のグループの、現在位置とそれ以降の記事を既読として印を付けま
す (@code{gnus-summary-catchup-from-here})。

@item C-w
@kindex C-w (概略)
@findex gnus-summary-mark-region-as-read
ポイントとマークの間の記事に既読の印を付けま
す (@code{gnus-summary-mark-region-as-read})。

@item M V k
@kindex M V k (概略)
@findex gnus-summary-kill-below
初期設定のスコア (もしくは数値接頭引数) よりも低いスコアの記事を削除しま
す。

@item M e
@itemx E
@kindex M e (概略)
@kindex E (概略)
@findex gnus-summary-mark-as-expirable
現在の記事を期限切れ削除可能として印を付けま
す (@code{gnus-summary-mark-as-expirable})。

@item M b
@kindex M b (概略)
@findex gnus-summary-set-bookmark
現在の記事にしおりを設定します (@code{gnus-summary-set-bookmark})。

@item M B
@kindex M B (概略)
@findex gnus-summary-remove-bookmark
現在の記事のしおりを削除します (@code{gnus-summary-remobe-bookmark})。

@item M V c
@kindex M V c (概略)
@findex gnus-summary-clear-above
初期設定のスコア (もしくは数値接頭引数) よりも大きいスコアを持つ記事のす
べての印を消去します (@code{gnus-summary-clar-above})。

@item M V u
@kindex M V u (概略)
@findex gnus-summary-tick-above
初期設定のスコア (もしくは数値接頭引数) よりも大きいスコアを持つすべての
記事に可視印を付けます (@code{gnus-summary-tick-above})。

@item M V m
@kindex M V m (概略)
@findex gnus-summary-mark-above
印の入力を促し、初期設定のスコア (もしくは数値接頭引数) よりも大きなスコ
アを持つすべての記事にその印を付けます (@code{gnus-summary-mark-above})。
@end table

@vindex gnus-summary-goto-unread
変数 @code{gnus-summary-goto-unread} は印が付けられた後にどのような動作
がなされるかを決定します。もし @code{nil} でないと、ポイントは次/前の未
読記事に移動します。もし @code{nil} であると、ポイントは一行上か下に行く
だけです。特別な場合として、この変数が @code{never} であると、すべての印
を付ける命令と (@kbd{SPACE} のような) 他の命令は次の記事が未読であろうが
無かろうがその記事に移動します。初期値 @code{t} です。

@node Generic Marking Commands
@subsection Generic Marking Commands

記事に可視印を付ける命令 (@kbd{!}) に次の記事に移動してもらいたいという
人がいます。次の未読記事に移動してもらいたいと思う人もいます。また、他の
現在の記事に留まってもらいたい人もいるでしょう。そして、まだ前の (未
読) 記事に行ってほしい人がいるとは聞いたことはありませんが、そうしたいと
思う人も間違いなくいると思います。

この五つの動作を五つの違った印付け命令と掛け算すると、どの命令が何をすべ
きかの非常に複雑な変数の組をもつことになります。

この悲劇から逃れるために、gnus はこれらすべての違ったことをする命令を提
供します。これらは概略バッファの @kbd{M M} マップにあります。全てをみる
ためには @kbd{M M C-h} を入力してください---このマニュアルで一覧を出すに
は多過ぎます。

これらの命令を直接使うことはできますが、ほとんどの利用者は概略モードのキー
マップを交換する方を好むでしょう。例えば、@kbd{!} 命令に次の未読記事の代
わりに次の記事に移動してほしいとすると、このようなことができます:

@lisp
(add-hook 'gnus-summary-mode-hook 'my-alter-summary-map)
(defun my-alter-summary-map ()
  (local-set-key "!" 'gnus-summary-put-mark-as-ticked-next))
@end lisp

もしくは、

@lisp
(defun my-alter-summary-map ()
  (local-set-key "!" "MM!n"))
@end lisp

@node Setting Process Marks
@subsection プロセス印を付ける
@cindex setting process marks

@table @kbd
@item M P p
@itemx #
@kindex # (概略)
@kindex M P p (概略)
@findex gnus-pick-unmark-article-or-thread
スレッドか記事を未選択にしま
す (@code{gnus-pick-unmark-article-or-thread})。変
数 @code{gnus-thread-hide-subtree} が true であれば、このキーはスレッド
の最初の記事で使われたときはスレッドを未選択にします。そうでない場合は、
その記事だけを未選択にします。その行のスレッドか記事を未選択にするために
このキーに数値接頭引数を与える事ができます。

@item M P u
@itemx M-#
@kindex M P u (概略)
@kindex M-# (概略)
もし現在の記事にプロセス印があれば取り除きま
す (@code{gnus-summary-unmark-as-processable})。

@item M P U
@kindex M P U (概略)
@findex gnus-summary-unmark-all-processable
すべての記事からプロセス印を取り除きま
す (@code{gnus-summary-unmark-all-processable})。

@item M P i
@kindex M P i (概略)
@findex gnus-uu-invert-processable
プロセス印の付いている記事とそうでない記事を逆にしま
す (@code{gnus-uu-mark-by-regexp})。

@item M P R
@kindex M P R (概略)
@findex gnus-uu-mark-by-regexp
正規表現によって記事に印を付けます (@code{gnus-uu-mark-by-regexp})。

@item M P G
@kindex M P G (概略)
@findex gnus-uu-unmark-by-regexp
@code{Subject} が正規表現にマッチする記事から印を削除しま
す (@code{gnus-uu-unmark-by-regexp})。

@item M P r
@kindex M P r (概略)
@findex gnus-uu-mark-region
リージョンの記事に印を付けます (@code{gnus-uu-mark-region})。

@item M P g
@kindex M P g (概略)
@findex gnus-uu-unmark-region
リージョンの記事から印を削除します (@code{gnus-uu-unmark-region})。

@item M P t
@kindex M P t (概略)
@findex gnus-uu-mark-thread
現在の (副) スレッドのすべての記事に印を付けま
す (@code{gnus-uu-mark-thread})。

@item M P T
@kindex M P T (概略)
@findex gnus-uu-unmark-thread
現在の (副) スレッドのすべての記事から印を取り除きま
す (@code{gnus-uu-unamrk-thread})。

@item M P v
@kindex M P v (概略)
@findex gnus-uu-mark-over
接頭引数よりも大きなスコアを持つすべての記事に印を付けま
す (@code{gnus-uu-mark-over})。

@item M P s
@kindex M P s (概略)
@findex gnus-uu-mark-series
現在の一連の記事に印を付けます (@code{gnus-uu-mark-series})。

@item M P S
@kindex M P S (概略)
@findex gnus-uu-mark-sparse
既にいくつか印の付いた記事を持つ一連の記事群全てに印を付けま
す (@code{gnus-uu-mark-sparse})。

@item M P a
@kindex M P a (概略)
@findex gnus-uu-mark-all
一連の記事が出てくる順番にそれに属するすべての記事に印を付けま
す (@code{gnus-uu-mark-all})。

@item M P b
@kindex M P b (概略)
@findex gnus-uu-mark-buffer
バッファのすべての記事を現れている順番に印を付けま
す (@code{gnus-uu-mark-buffer})。

@item M P k
@kindex M P k (概略)
@findex gnus-summary-kill-process-mark
現在のプロセス印をスタックに積んで、すべての記事を無印にしま
す (@code{gnus-summary-kill-process-mark})。

@item M P y
@kindex M P y (概略)
@findex gnus-summary-yank-process-mark
スタックから前回のプロセス印を取り出して、それを復元しま
す (@code{gnus-summary-yank-process-mark})。

@item M P w
@kindex M P w (概略)
@findex gnus-summary-save-process-mark
現在のプロセス印をスタックに積みま
す (@code{gnus-summary-save-process-mark})。
@end table

そして、どうやって記事の本文 (body) の内容を基にプロセス印を付けるかは、
@pxref{Searching for Articles} の @kbd{&} 命令を参照して下さい。

@node Limiting
@section 制限をする
@cindex  limiting

概略バッファが現在グループにある記事の一部だけを表示するように制限できれ
ば便利なことがあります。多くの制限命令が持つ効果は概略バッファから少
し (もしくは多く) の記事を概略バッファから削除することです。

すべての制限命令はサーバーから既に取得された記事の一部分に作用します。こ
れらの命令はどれもサーバーに追加の記事を要求しません。

@table @kbd
@item / /
@itemx / s
@kindex / / (概略)
@findex gnus-summary-limit-to-subject
概略バッファをいくつかの表題と合致するものだけに制限しま
す (@code{gnus-summary-limit-to-subject})。もし接頭辞が与えられれば、合
致する記事を除外します。

@item / a
@kindex / a (概略)
@findex gnus-summary-limit-to-author
概略バッファを何人かの著者に合致するものだけに制限しま
す (@code{gnus-summary-limit-to-author})。もし接頭辞が与えられれば、合致
する記事を除外します。

@item / x
@kindex / x (概略)
@findex gnus-summary-limit-to-extra
``追加'' のヘッダーの一つに合致する記事に概略バッファを制限しま
す (@pxref{To From Newsgroups}) (@code{gnus-summary-limit-to-extra})。も
し接頭辞が与えられれば、合致する記事を除外します。

@item / u
@itemx x
@kindex / u (概略)
@kindex x (概略)
@findex gnus-summary-limit-to-unread
概略バッファを既読の印が付いていない記事に制限しま
す (@code{gnus-summary-limit-to-unread})。もし接頭引数が与えられれば、バッ
ファを厳密に未読記事のみに制限します。これは、可視と保留の記事は含まれな
いということです。

@item / m
@kindex / m (概略)
@findex gnus-summary-limit-to-marks
印を尋ねて、その印が付いている記事に制限しま
す (@code{gnus-summary-limit-to-marks})。

@item / t
@kindex / t (概略)
@findex gnus-summary-limit-to-age
数字を尋ねて、概略バッファをその数字の日より古い (もしくは同じ) 記事に制
限します (@code{gnus-summary-limit-to-age})。もし接頭引数が与えられれば、
その数字の日よりも新しい記事に制限します。

@item / n
@kindex / n (概略)
@findex gnus-summary-limit-to-articles
概略バッファを現在の記事に制限しま
す (@code{gnus-summary-limit-to-articles})。プロセス/接頭引数の習慣を使
います (@pxref{Process/Prefix})。

@item / w
@kindex / w (概略)
@findex gnus-summary-pop-limit
前の制限をスタックから取り出して、復元しま
す (@code{gnus-summary-pop-limit})。もし接頭引数を与えられれば、すべての
制限をスタックから取り出します。

@item / v
@kindex / v (概略)
@findex gnus-summary-limit-to-score
概略バッファをあるスコアと同じか、それより大きなスコアを持つ記事に制限し
ます (@code{gnus-summary-limit-to-score})。

@item / p
@kindex / p (概略)
@findex gnus-summary-limit-to-display-predicate
概略バッファを @code{display} グループパラメータの述語を満足させるように
制限します (@code{gnus-summary-limit-to-display-predicate})。この述語に
関する詳細は @pxref{Group Parameters} を参照して下さい。

@item / E
@itemx M S
@kindex M S (概略)
@kindex / E (概略)
@findex gnus-summary-limit-include-expunged
すべての消去された記事を表示しま
す (@code{gnus-summary-limit-include-expunged})。

@item / D
@kindex / D (概略)
@findex gnus-summary-limit-include-dormant
すべての保留記事を表示します (@code{gnus-summary-limit-include-dormant})。

@item / *
@kindex / * (概略)
@findex gnus-summary-limit-include-cached
すべてのキャッシュに入っている記事を表示しま
す (@code{gnus-summary-limit-include-cached})。

@item / d
@kindex / d (概略)
@findex gnus-summary-limit-exclude-dormant
すべての保留記事を隠します (@code{gnus-summary-limit-exclude-dormant})。

@item / M
@kindex / M (概略)
@findex gnus-summary-limit-exclude-marks
全ての印付き記事を除外します (@code{gnus-summary-limit-exclude-marks})。

@item / T
@kindex / T (概略)
@findex gnus-summary-limit-include-thread
現在のスレッドのすべての記事を表示しま
す (@code{gnus-summary-limit-include-thread})。

@item / c
@kindex / c (概略)
@findex gnus-summary-limit-exclude-childless-dormant
子記事の無いすべての保留記事を隠しま
す (@code{gnus-summary-limit-exclude-childless-dormant})。

@item / C
@kindex / C (概略)
@findex gnus-summary-limit-mark-excluded-as-read
すべての未読のみの印の記事を既読として印を付けま
す (@code{gnus-summary-limit-mark-excluded-as-read})。もし接頭引数が与え
られれば、可視と保留のみの印の記事も既読として印を付けます。

@item / N
@kindex / N (概略)
@findex gnus-summary-insert-new-articles
すべての新しい記事を概略バッファに挿入します。も
し @var{back-end}@code{-get-new-mail} が非-@code{nil} だったら、新しいメー
ルの到来を調べるということです。

@item / o
@kindex / o (概略)
@findex gnus-summary-insert-old-articles
すべての古い記事を概略バッファに挿入します。もし数字の接頭辞が与えられれ
ば、その数の記事を取り込みます。
@end table

@node Threading
@section スレッド
@cindex threading
@cindex article threading

Gnus は初期設定で記事をスレッドにします。@dfn{スレッドにする} とは、ある
記事への応答を応答した記事の直後に置く――階層的流儀で ということです。

スレッドは記事の @code{References} 欄を調べることによって行われます。完
全な世界では、これだけで良い木を作り上げるのに十分なのですが、不運なこと
に、@code{References} 欄はしばしば壊れているか、時には単にないということ
があります。不思議なニュースの増殖が問題を増やしますので、喜ばしい結果を
得るためには他の発見法を採用しなければなりません。過剰な対策法は存在して
いて、その恐るべき詳細は @pxref{Customizing Threading} に詳しく書いてあ
ります。

まず、概念の概観です:

@table @dfn
@item 根本 (root)
スレッドで一番頂点にある記事です；スレッドの最初の記事です。

@item スレッド (thread)
木のような記事の構成です。

@item 部分スレッド (sub-thread)
木のような構造の (より) 小さな部分です。

@item 無束縛スレッド (loose threads)
記事の期限切れ削除や、根本が既に前回のセッションで読まれたことにより概略
バッファに表示されない、等の理由により、スレッドはしばしば根本を失います。
そのようなときには、普通は多くの部分スレッドがあって、本当は一つのスレッ
ドに属しているのですが、根本にはつながっていない、ということになります。
こういうスレッドが無束縛スレッドと呼ばれています。

@item スレッド集め (thread gathering)
まばらスレッドを大きなスレッドに集めようとする試みです。

@item まばらスレッド (sparse threads)
無い記事が『推測された』スレッドで、概略バッファに空行で表示されます。
@end table

@menu
* Customizing Threading::       変更可能なスレッドに影響する変数
* Thread Commands::             概略バッファでのスレッドに基づいた命令
@end menu

@node Customizing Threading
@subsection スレッドをカスタマイズする
@cindex customizing threading

@menu
* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッ
                                ドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう... でもあ
                                なたは間違っていた!
@end menu

@node Loose Threads
@subsubsection 無束縛スレッド
@cindex <
@cindex >
@cindex loose threads

@table @code
@item gnus-summary-make-false-root
@vindex gnus-summary-make-false-root
もし @code{nil} でないと、gnus は全てのつながっていない部分木を一つの大
きな木にして、頂上にみせかけの根本を作ります。(ちょっと待ってください。
頂上に根元 (root) ですって? ええ、そうなのです。) つながっていない部分木
は本当の根本が期限切れ削除されたか、前回のセッションで根本を読んだり削除
したときにできます。

本当のスレッドが無いときは、gnus は何かでっち上げをする必要があります。
この変数は gnus が使うべきごまかしの方法を示しています。値としてとること
ができる四つの候補があります。

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{390}{
\put(0,0){\epsfig{figure=ps/summary-adopt,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=ps/summary-empty,width=7.5cm}}}
\put(0,400){\makebox(0,0)[tl]{\epsfig{figure=ps/summary-none,width=7.5cm}}}
\put(445,400){\makebox(0,0)[tr]{\epsfig{figure=ps/summary-dummy,width=7.5cm}}}
}
@end iflatex
@end iftex

@cindex adopting articles

@table @code
@item 養子 (adopt)
Gnus は最初の孤児を親にします。この親はすべての他の記事を養子にします。
この養子記事は、標準の角括弧 (@samp{[]}) の代わりに、先の尖った括
弧 (@samp{<>}) で印付けられます。これが初期設定の方法です。

@item みせかけ (dummy)
@vindex gnus-summary-dummy-line-format
Gnus は親のふりをするみせかけの概略行をつくります。みせかけの行はどの本
当の記事にも対応しませんので、それを選択することは、みせかけの記事の後の
最初の本当の記事を選択をするだけになります。みせかけの根本の様式を指定
するために、@code{gnus-summary-dummy-line-format} が使われます。これはたっ
た一つだけのフォーマットの仕様を受け付けます: @samp{S} で、これは記事の
表題です。@xref{Formatting Variables}.

@item 空 (empty)
Gnus は実際にはどの記事も親にはせず、単に最初の孤児を除いてすべての孤児
の表題欄を空のままにします。
(実際は、@code{gnus-summary-same-subject} を表題として使いま
す (@pxref{Summary Buffer Format})。)

@item none
全くどの記事も親にしません。スレッドを集めて、一つの記事の後に他の記事を
表示するだけです。

@item nil
無束縛スレッドを集めません。
@end table

@item gnus-summary-gather-subject-limit
@vindex gnus-summary-gather-subject-limit
無束縛スレッドは記事の表題を比較することによって集められます。もしこの変
数が @code{nil} であると、gnus は無束縛スレッドを一つの大きな超スレッド
に集める前に、無束縛スレッドの表題が完全に一致することを要求します。これ
は、長い表題の行を切り落としてしまう間抜けなニュースリーダーが存在する現
在では、あまりに厳しい要求かも知れません。もしそう思うのなら、この変数を
例えば 20 に設定して、表題の最初の 20 文字だけが一致することを要求するよ
うにすることができます。この変数を本当に低い数字に設定すると、gnus が目
に入る全てを一つのスレッドに集めるのを見ることができるでしょう。そして、
それはあまり有用ではありません。

@cindex fuzzy article gathering
この変数を特別な値 @code{fuzzy} に設定すれば、gnus は表題にあいまいな文
字列比較アルゴリズムを使います (@pxref{Fuzzy Matching})。

@item gnus-simplify-subject-fuzzy-regexp
@vindex gnus-simplify-subject-fuzzy-regexp
これは正規表現か、あいまい表題指定が使われているときに表題から合致したも
のが取り除かれる、正規表現のリストであることができます。

@item gnus-simplify-ignored-prefixes
@vindex gnus-simplify-igonored-prefixes
もし @code{gnus-summary-gather-subject-limit} を 10 くらいに低く設定した
ならば、この変数を何か意味のあるものに設定することを考えるでしょう:

@c Written by Michael Ernst <mernst@cs.rice.edu>
@lisp
(setq gnus-simplify-ignored-prefixes
      (concat
       "\\`\\[?\\("
       (mapconcat
        'identity
        '("looking"
          "wanted" "followup" "summary\\( of\\)?"
          "help" "query" "problem" "question"
          "answer" "reference" "announce"
          "How can I" "How to" "Comparison of"
          ;; ...
          )
        "\\|")
       "\\)\\s *\\("
       (mapconcat 'identity
                  '("for" "for reference" "with" "about")
                  "\\|")
       "\\)?\\]?:?[ \t]*"))
@end lisp

この正規表現に合致するすべての語は、二つの表題を比較する前に取り除かれま
す。

@item gnus-simplify-subject-functions
@vindex gnus-simplify-subject-functions
@code{nil} でないと、この変数
は @code{gnus-summary-gather-subject-limit} を上書きします。この変数は文
字列 @code{Subject} を反復して簡単な形にたどり着くために適用する関数のリ
ストである必要があります。

このリストに入れて役に立つような関数は次のようなものです:

@table @code
@item gnus-simplify-subject-re
@findex gnus-simplify-subject-re
前の方にある @samp{Re:} を取り除きます。

@item gnus-simplify-subject-fuzzy
@findex gnus-simplify-subject-fuzzy
あいまいに簡単にします。

@item gnus-simplify-whitespace
@findex gnus-simplify-whitespace
余分な空白 (whitespace) を取り除きます。

@item gnus-simplify-all-whitespace
@findex gnus-simplify-all-whitespace
すべての空白 (whitespace) を取り除きます。
@end table

もちろん、あなた自身の関数を書くこともできます。

@item gnus-summary-gather-exclude-subject
@vindex gnus-summary-gather-exclude-subject
無束縛スレッド集めは表題のみに行われますので、特
に @samp{} や @samp{(none)}のような良くある表題のときは、多くの間違いを
起こす可能性があります。この状況を少しよくするために、どの表題が集める過
程から除かれるかを決める正規表
現 @code{gnus-summary-gather-exclude-subject} を使うことができます。ディ
フォルトは @samp{^ *$\\|^(none)$} です。

@item gnus-summary-thread-gathering-function
@vindex gnus-summmary-thread-gathering-function
Gnus は @code{Subject} 欄を見ることによってスレッドを集めます。これは、
結果的に全く関係の無い記事が同じ『スレッド』に含まれることがあるというこ
とで、これは混乱の元です。代替手段は、合致するものを見つけるため
に @code{References} 欄にある @code{Message-ID} をすべて探すことです。こ
れは関係の無い記事が集められたスレッドに含まれることは全く無いことを保証
しますが、こわれたニュースリーダーで投稿した記事は適切に集められないとい
うことでもあります。選択権はあなたにあります――疫病かコレラか。

@table @code
@item gnus-gather-threads-by-subject
@findex gnus-gather-threads-by-subject
この関数はディフォルトの収集関数で、排他的に @code{Subject} を見ます。

@item gnus-gather-threads-by-references
この関数は排他的に @code{References} 欄を見ます。
@end table

@code{References} によって集めることを試してみたいのであれば、次のように
することができます:

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp
@end table

@node Filling In Threads
@subsubsection スレッドを埋める

@table @code
@item gnus-fetch-old-headers
@vindex gnus-fetch-old-headers
もし @code{nil} でないと、gnus は古いスレッドをもっと古いヘッダー――既
読印の付いている記事のヘッダーを取得することで大きくしようとします。もし
できるだけ少ない概略行を表示したいけれど、できるだけたくさんの非密スレッ
ドに接続しておきたいときは、この変数を @code{some} か数字に設定すること
ができます。もし数字に設定したときは、それより多い追加のヘッダーは取得さ
れません。どちらの場合でも、古いヘッダーの取得が動作するのは、使っている
バックエンド(back end) が overview ファイルを使っているかどうかです――
これは普通は @code{nntp}, @code{nnspool}, @code{nnml} およ
び @code{nnmaildir}です。スレッドのルートがサーバーによって期限切れ削除
されたときは、gnus はどうしようもないことを覚えておいてください。

この変数は @code{invisible} に設定することもできます。これは視覚的な効果
は何もありませんが、命令 @kbd{A T} をよく使うのであれば役に立つでしょ
う (@pxref{Finding the Parent})。

@item gnus-build-sparse-threads
@vindex gnus-build-sparse-threads
古いヘッダーを取得すると遅くなることがあります。同じような低賃金の効果を
得るために、この変数を @code{some} に設定することができます。そうすると、
gnus は全ての記事の完全な @code{References} 欄を見て、同じスレッドに属す
る記事をつなごうとします。これは gnus が記事がスレッドから失われていると
推測したところのスレッド表示に@dfn{ずれ}を残すでしょう。(これらのずれは
普通の概略行のように現れます。もしずれを選択したときは、gnus はその当の
記事を取得しようとします。) この変数が @code{t} であると、gnus は全ての
『ずれ』をスレッドを補完するのに役に立つかを考慮せずに表示します。最後に、
この変数が @code{more} であると、gnus はどこにもつながっていない枝葉のま
ばらな節を切り落としません。この変数はディフォルトでは @code{nil} です。

@item gnus-read-all-available-headers
@vindex gnus-read-all-available-headers
これはどちらかと言えばあまり役に立たない変数です。ニュースではないグルー
プにおいて概略バッファがとても大きくなり、しかも親記事を辿ることができな
い場合に使うことを想定しています。それは主に @code{nnultimate} グループ
のような、ウェブに基づいたグループです。

これを使わない場合はディフォルトの @code{nil} のままにしておくのが無難で
す。使いたい場合はグループ名に合致する正規表現か、すべてのグループ名に合
致する @code{t} にして下さい。
@end table

@node More Threading
@subsubsection もっとスレッドを

@table @code
@item gnus-show-threads
@vindex gnus-show-threads
この変数が @code{nil} であると、スレッドは作られず、ここにある残りのすべ
ての変数は全く効果が無くなります。スレッド作りを止めるとグループの選択が
少し速くなりますが、記事を読むのがもっと遅く、不便になることは確実です。

@item gnus-thread-hide-subtree
@vindex gnus-thread-hide-subtree
これが @code{nil} でないと、すべてのスレッドは概略バッファが生成されたと
きに隠れます。

これは述語指示子であることもできます (@pxref{Predicate Specifiers})。利
用できる述語
は @code{gnus-article-unread-p} と @code{gnus-article-unseen-p} です。

これは例です:

@lisp
(setq gnus-thread-hide-subtree
      '(or gnus-article-unread-p
           gnus-article-unseen-p))
@end lisp

(これはかなりばかげた例です。なぜならすべてのまだ読まれたことが無い記事
は未読でもあるからなのですが、主旨は汲み取って下さい。)

@item gnus-thread-expunge-below
@vindex gnus-thread-expunge-below
この数字より少ない総合的スコア (@code{gnus-thread-score-function}) を持
つすべてのスレッドは消去されます。この変数はディフォルトで
は @code{nil} で、これはどのスレッドも消去されないということです。

@item gnus-thread-hide-killed
@vindex gnus-thread-hide-killed
もしスレッドを削除して、この変数が @code{nil} でないと、部分木は隠されま
す。

@item gnus-thread-ignore-subject
@vindex gnus-thread-ignore-subject
時々、誰かがスレッドの真中で表題を変更することがあります。もしこの変数
が @code{nil} でないと、これがディフォルトですが、表題の変更は無視されま
す。もし @code{nil} だと、表題の変更をすると別のスレッドになります。

@item gnus-thread-indent-level
@vindex gnus-thread-indent-level
この数字は部分スレッドがどれくらい字下げ (indent) されるべきかを決めます。
ディフォルトは 4 です。

@item gnus-sort-gathered-threads-function
@vindex gnus-sort-gathered-threads-function
ときどき、特にメーリングリストで、手元にメールが到着する順番は必ずしもメー
リングリストに到着した順番と同じでは無いことがあります。従って、副スレッ
ドを初期設定の @code{gnus-thread-sort-by-number} で並び換えると、応答の
方がそれが応答している記事より先に現れることがあります。グループパラメー
タや適切なフック (例えば @code{gnus-summary-generate-hook}) でこの変数を
代わりの値 (例えば、@code{gnus-thread-sort-by-date}) に設定することで、
そのような場合に、より論理的な副スレッドの順番を生成することができます。
@end table

@node Low-Level Threading
@subsubsection 低レベルにおけるスレッド作成

@table @code
@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
すべてのヘッダーを解析する前に実行されるフックです。ディフォルトの値
は @code{(gnus-set-summary-default-charset)} です。これは変
数 @code{gnus-newsgroup-default-charset-alist} で指定されている値から概
略バッファの @code{default-mime-charset} を設定します。

@item gnus-alter-header-function
@vindex gnus-alter-header-function
これが @code{nil} でないと、ヘッダー構造の交換を可能にするようにこの関数
が呼ばれます。関数は一つの引数、記事ヘッダーのベクトル、とともに呼ばれ、
それが何らかの方法で交換されます。例えば、(接頭語やその他のものを付け加
えることによる) 体系的な方法で @code{Message-ID} を交換するメールから
ニュースへのゲートウェイがある場合、@code{Message-ID} がもっと意味のある
ものにするために、この変数を設定して元に戻すことができます。これは一つの
例です:

@lisp
(setq gnus-alter-header-function 'my-alter-message-id)

(defun my-alter-message-id (header)
  (let ((id (mail-header-id header)))
    (when (string-match
           "\\(<[^<>@@]*\\)\\.?cygnus\\..*@@\\([^<>@@]*>\\)" id)
      (mail-header-set-id
       (concat (match-string 1 id) "@@" (match-string 2 id))
       header))))
@end lisp
@end table

@node Thread Commands
@subsection スレッドの命令
@cindex thread commands

@table @kbd
@item T k
@itemx C-M-k
@kindex T k (概略)
@kindex C-M-k (概略)
@findex gnus-summary-kill-thread
現在の (部分) スレッドに既読の印を付けま
す (@code{gnus-summary-kill-thread})。もし接頭引数が正であると、代わりに
すべての印を取り除きます。接頭引数が負であると、代わりに記事を可視にしま
す。

@item T l
@itemx C-M-l
@kindex T l (概略)
@kindex C-M-l (概略)
@findex gnus-summary-lower-thread
現在の (部分) スレッドのスコアを下げま
す (@code{gnus-summary-lower-thread})。

@item T i
@kindex T i (概略)
@kindex gnus-summary-raise-thread
現在の (部分) スレッドのスコアを上げま
す (@code{gnus-summary-raise-thread})。

@item T #
@kindex T # (概略)
@findex gnus-uu-mark-thread
プロセス印を現在の (部分) スレッドに付けま
す (@code{gnus-uu-mark-thread})。

@item T M-#
@kindex T M-# (概略)
@findex gnus-uu-unmark-thread
現在の (部分) スレッドからプロセス印を取り除きま
す (@code{gnus-uu-unmark-thread})。

@item T T
@kindex T T (概略)
@findex gnus-summary-toggle-threads
スレッド表示を切り替えます (@code{gnus-summary-toggle-threads})。

@item T s
@kindex T s (概略)
@findex gnus-summary-show-thread
もしあれば、現在の記事の下に隠れているスレッドを表示しま
す (@code{gnus-summary-show-thread})。

@item T h
@kindex T h (概略)
@findex gnus-summary-hide-thread
現在の (部分) スレッドを隠します (@code{gnus-summary-hide-thread})。

@item T S
@kindex T S (概略)
@findex gnus-summary-show-all-threads
すべての隠されているスレッドを表示しま
す (@code{gnus-summary-show-all-threads})。

@item T H
@kindex T H (概略)
@findex gnus-summary-hide-all-threads
すべてのスレッドを隠します (@code{gnus-summary-hide-all-threads})。

@item T t
@kindex T t (概略)
@findex gnus-summary-rethread-current
現在の記事のスレッドをもう一度作り直しま
す (@code{gnus-summary-rethread-current})。これは概略バッファがスレッド
表示されていないときでも動作します。

@item T ^
@kindex T ^ (概略)
@findex gnus-summary-reparent-thread
現在の記事を印付き (もしくは前の) 記事の子記事にしま
す (@code{gnus-summary-reparent-thread})。
@end table

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付けま
す。

@table @kbd
@item T n
@kindex T n (概略)
@itemx C-M-f
@kindex C-M-f (概略)
@itemx M-down
@kindex M-down (概略)
@findex gnus-summary-next-thread
次のスレッドに移動します (@code{gnus-summary-next-thread})。

@item T p
@kindex T p (概略)
@itemx C-M-b
@kindex C-M-b (概略)
@itemx M-up
@kindex M-up (概略)
@findex gnus-summary-prev-thread
前のスレッドに移動します (@code{gnus-summary-prev-thread})。

@item T d
@kindex T d (概略)
@findex gnus-summary-down-thread
スレッドを降下します (@code{gnus-summary-down-thread})。

@item T u
@kindex T u (概略)
@findex gnus-summary-up-thread
スレッドを上昇します (@code{gnus-summary-up-thread})。

@item T o
@kindex T o (概略)
@findex gnus-summary-top-thread
スレッドの頂上に移動します (@code{gnus-summary-top-thread})。
@end table

@vindex gnus-thread-operation-ignore-subject
スレッドを作成するときに表題を無視すると、自然にスレッドにはいくつかの違っ
た表題があることになります。それか
ら `T k' (@code{gnus-summary-kill-thread}) のような命令を発するときに、
全体のスレッドを削除するのではなく、現在の記事と同じ表題を持つ部分だけを
削除したいときがあるかもしれません。もしこの発想が良いと思うのであれば、
@code{gnus-thread-operation-ignore-subject} をいじくることができます。こ
れが @code{nil} でないと (これがディフォルトですが)、スレッドの命令を実
行しているときに表題は無視されます。この変数が @code{fuzzy} であると、あ
いまいに等しい表題を持つ記事だけが含まれます (@pxref{Fuzzy Matching})。

@node Sorting the Summary Buffer
@section 並び替え

@findex gnus-thread-sort-by-total-score
@findex gnus-thread-sort-by-date
@findex gnus-thread-sort-by-score
@findex gnus-thread-sort-by-subject
@findex gnus-thread-sort-by-author
@findex gnus-thread-sort-by-number
@findex gnus-thread-sort-by-random
@vindex gnus-thread-sort-functions
@findex gnus-thread-sort-by-most-recent-thread
もしスレッドの概略表示を使っているのであれば、
@code{gnus-thread-sort-functions} を設定することでスレッドを並び替えるこ
とができます。それは、単独の関数、関数のリスト、関数と @code{(関数でない
もの)} の要素であることができます。ディフォルトでは、並び替えは記事番号
によってなされます。既に作られている並び替え述語関数
は @code{gnus-thread-sort-by-number}, @code{gnus-thread-sort-by-author},
@code{gnus-thread-sort-by-subject}, @code{gnus-thread-sort-by-date},
@code{gnus-thread-sort-by-score},
@code{gnus-thread-sort-by-most-recent-number},
@code{gnus-thread-sort-by-most-recent-date},
@code{gnus-thread-sort-by-random} およ
び @code{gnus-thread-sort-by-total-score} です。

各関数は二つのスレッドをとり、最初のスレッドが他のスレッドより先に並び替
えられるべきであれば、@code{nil} でない値をかえします。普通、並び替えは
本当はそれぞれのスレッドの根本を見るだけによりなされることに気を付けてく
ださい。もし二つ以上の関数を使う場合、優先的並び替えキーはリストの最後の
関数です。おそらくいつも @code{gnus-thread-sort-by-number} を並び替え関
数のリスト――最初が好ましい に入れておくべきでしょう。これは他の並び替
え基準に関して等しいスレッドは記事が上がっていく順番に表示されることを保
証します。

スコアの逆順、表題、そして最後に番号、の順に並び替えたいのであれば、次の
ようにできます:

@lisp
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-number
        gnus-thread-sort-by-subject
        (not gnus-thread-sort-by-total-score)))
@end lisp

最高スコアのスレッドが概略バッファの最初に表示されます。スレッドが同じス
コアの場合は、英字順に並びかえられます。スコアと表題が同じスレッドは番号
で並び替えられ、(普通は) 記事が到着した順番になります。

スコア、到着の逆順に並び替えたいのであれば、次のようにできます:

@lisp
(setq gnus-thread-sort-functions
      '((lambda (t1 t2)
          (not (gnus-thread-sort-by-number t1 t2)))
        gnus-thread-sort-by-score))
@end lisp

@vindex gnus-thread-score-function
変数 @code{gnus-thread-score-function} (ディフォルトは @code{+}) に入っ
ている関数はスレッドの総合のスコアを計算するために用いられます。役に立つ
関数は、@code{max}, @code{min}, もしくは二乗、もしくはあなたの好奇心をく
すぐるような何かでしょう。

@findex gnus-article-sort-functions
@findex gnus-article-sort-by-date
@findex gnus-article-sort-by-score
@findex gnus-article-sort-by-subject
@findex gnus-article-sort-by-author
@findex gnus-article-sort-by-random
@findex gnus-article-sort-by-number
何か奇妙な理由などでスレッド表示を使っていないのなら、変
数 @code{gnus-article-sort-functions} をいじくる必要があります。これ
は @code{gnus-thread-sort-functions} と非常に似ていますが、記事の比較に
は少々違った関数を使います。使用可能な並び替え述語関数
は @code{gnus-article-sort-by-number},
@code{gnus-article-sort-by-author},
@code{gnus-article-sort-by-subject}, @code{gnus-article-sort-by-date},
@code{gnus-article-sort-by-random} およ
び @code{gnus-article-sort-by-score} です。

スレッドを使っていない表題の概略表示を並び替えたいのであれば、次のような
ことをすることができます:

@lisp
(setq gnus-article-sort-functions
      '(gnus-article-sort-by-number
        gnus-article-sort-by-subject))
@end lisp

@node Asynchronous Fetching
@section 非同期記事取得
@cindex asynchronous article fetching
@cindex article pre-fetch
@cindex pre-fetch

もしニュースを遠くの @sc{nntp} サーバーから取得しているのであれば、ネッ
トワークの待ち時間が記事を読むことは骨の折れることにしてしまうかもしれま
せん。@kbd{n} を押して次の記事が現れるまで、しばらく待たなければなりませ
ん。どうして前の記事を読んでいる間に gnus が先に行って記事を取得しないの
でしょう? 本当に、そうした方が良いのではないのでしょうか。

まず、いくつかの警告です。非同期記事取得、特に gnus がそれを行っている方
法にはいくつかの落とし穴があります。

例えば、あなたは短い記事 1 を読んでいて、記事 2 はとても長くあなたはそれ
を読むことには興味が無いとしましょう。Gnus はこのことはわからないので、
先に行って記事 2 を取得します。あなたは記事 3 を読むことにしますが、
gnus は記事 2 を取得している最中なので、接続は封鎖されています。

この状況を避けるために、gnus はサーバーに二つの (それは 2 と数えてくださ
い) 接続を張ることができます。これはあまりして良いことではないと考える人
もいるでしょうが、私には実際の代替手段が見つからないのです。余分な接続を
するためには何らかの時間がかかりますので、gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先-取得を使わないときよりも、あなたのマシンと @sc{nntp} サーバー間
にもっと負荷がかかるということになるでしょう。サーバー自身ももっと負荷が
かかるようになります――余分な記事の要求と、余分な接続で。

はい、これで本当はこのようなことをすべきで無い事が分かったでしょう... 本
当にそうしたいと思わない限りは。

@vindex gnus-asynchronous
これが方法です: @code{gnus-asynchronous} を @code{t} に設定してください。
残りのことは自動的に起こります。

@vindex gnus-use-article-prefetch
@code{gnus-use-article-prefetch} を設定することにより、どれくらいの記事
が先に取得されるべきかを操作することができます。これはディフォルトで
は 30 で、グループの記事を読んでいるときに、バックエンドが次の 30 記事を
先-取得するということです。この変数が @code{t} であると、バックエンドは
制限無く取得できるすべての記事を先-取得しようとします。これ
が @code{nil} であると、先-取得は行われません。

@vindex gnus-async-prefetch-article-p
@findex gnus-async-read-p
おそらく、先-取得をしたくない記事がいくつかあるでしょう――例えば、既読
記事。変数 @code{gnus-async-prefetch-article-p} は記事が先に取得されるべ
きかどうかを制御します。この関数は問題の記事が先-取得されるべきであれ
ば @code{nil} でない値をかえすべきです。ディフォルト
は @code{gnus-async-read-p} で、それは既読記事には @code{nil} をかえしま
す。この関数は記事のデータ構造を唯一の引数として呼ばれます。

例えば、もし 100 行よりも短い未読記事のみを先に取得したいのであれば、次
のようにできます:

@lisp
(defun my-async-short-unread-p (data)
  "Return non-nil for short, unread articles."
  (and (gnus-data-unread-p data)
       (< (mail-header-lines (gnus-data-header data))
          100)))

(setq gnus-async-prefetch-article-p 'my-async-short-unread-p)
@end lisp

これらの関数は何度も何度も呼ばれますので、gnus を遅くしすぎないように、
短く甘美であるのが好ましいです。おそらく、このようなものをバイトコンパイ
ル (byte-compile) するのは良い着想でしょう。

@vindex gnus-prefetched-article-deletion-strategy
記事は非同期バッファから遅かれ早かれ削除されなければなりません。
@code{gnus-prefetched-article-deletion-strategy} はいつ記事を削除するか
を指定しています。これは以下の要素を含むようなリストです:

@table @code
@item read
記事が読まれたときに削除します。

@item exit
グループを抜けたときに記事を削除します。
@end table

ディフォルトの値は @code{(read exit)} です。

@c @vindex gnus-use-header-prefetch
@c @code{gnus-use-header-prefetch} が @code{nil} でないと、次のグループから
@c 記事を先に取得します。

@node Article Caching
@section 記事のキャッシュ
@cindex article caching
@cindex caching

もし@emph{非常に}遅い @sc{nntp} 接続であるならば、記事キャッシュをするこ
とを考えるかもしれません。そうすると、それぞれの記事はあなたのホームディ
レクトリの下にローカルに溜めらます。既に推測されているかも知れませんが、
これは @emph{巨大な}ディスクスペースを食い、iノードも非常に速く食いつぶ
す可能性があるため、それはあなたの頭を泳がせる事になるかもしれません。
ウォッカの中で。

でも注意深く使われれば、それは記事を保存する簡単な方法になり得ます。

@vindex gnus-use-long-file-name
@vindex gnus-cache-directory
@vindex gnus-use-cache
キャッシュを実行するためには、@code{gnus-use-cache} を @code{t} に設定し
ます。ディフォルトでは、すべての可視または保留として印の付いている記事は
ローカルのキャッシュに複写されます。このキャッシュが平らな構造か階層的で
あるかは、いつもどおり、変数 @code{gnus-use-long-file-name} で制御されま
す。

可視か保留記事を再選択した場合は、サーバーの代わりにキャッシュから取得さ
れます。キャッシュにある記事は期限切れ削除されませんので、記事が属してい
るところに残したままで記事を保存する方法として使う事ができるかもしれませ
ん。保存したい記事をすべて保留の印を付けて、後は心配は要りません。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょうか。

@vindex gnus-cache-remove-articles
@vindex gnus-cache-enter-articles
キャッシュ へ入る/から削除される は変数 @code{gnus-cache-enter-articles} と @code{gnus-cache-remove-articles} に
よって制御されます。これらは両方ともシンボルのリストです。前者はディフォ
ルトでは @code{(ticked dormant)} で、可視と保留記事はキャッシュに入れら
れるという事です。後者はディフォルトでは @code{(read)} で、既読の印が付
いた記事はキャッシュから削除されるという事です。おそらくこれらの二つのリ
ストは @code{ticked}, @code{dormant}, @code{unread} およ
び @code{read} からなるでしょう。

@findex gnus-jog-cache
それで、どうやって大量の記事取得と貯蓄実現されるのでしょうか。命
令 @code{gnus-jog-cache} は全ての購読グループに対して、すべての未読記事
を要求し、スコアを付け、キャッシュに保存します。この命令を実際に、実際に
実際に実際に、使うのは、1) @sc{nntp} サーバーとの接続が本当に、本当に、
本当に遅く 2) 本当に、本当に、本当に巨大なディスクを持っているときだけに
するべきです。これは真面目にいっています。ダウンロードされる記事の数を少
なくする一つの方法は、欲しくない記事のスコアを低くし、既読の印を付ける事
です。そうした場合、それらはこの命令ではダウンロードされません。

@vindex gnus-uncacheable-groups
@vindex gnus-cacheable-groups
いくつかのグループではキャッシュをしたくないというのは良くある事です。例
えば、@code{nnml} メールディレクトリーがホームディレクトリーの下にあれば、
それをあなたのホームディレクトリーの下の別の場所にキャッシュするのは意味
の無い事です。あなたが二倍の容量を使う事が良いと感じない限りは。

キャッシュを制限するために、@code{gnus-cacheable-groups} を をキャッシュ
するグループの連想リスト、例えば @samp{^nntp} とするか、正規表
現 @code{gnus-uncacheable-groups} を例えば、@samp{^nnml} に設定して下さ
い。両方の変数の初期値は @code{nil} です。もしグループが両方の正規表現に
合致すると、そのグループはキャッシュされません。

@findex gnus-cache-generate-nov-databases
@findex gnus-cache-generate-active
@vindex gnus-cache-active-file
キャッシュはどの記事が含まれているかの情報をアクティブファイ
ル (@code{gnus-cache-active-file}) に溜めます。このファイル (もしくはキャッ
シュの他の部分) が何らかの理由でぐちゃぐちゃになってしまった場合、
gnus は物事を正しくするために二つの関数をお勧めします。
@kbd{M-x gnus-cache-generate-nov-databases} はすべての @sc{nov} ファイル
を (再) 作成し、@kbd{gnus-cache-generate-active} はアクティブファイル
を (再) 作成します。

@findex gnus-cache-move-cache
@code{gnus-cache-move-cache} はすべての @code{gnus-cache-directory} をど
こか別の場所に移動します。あなたはどこに移動させるかを尋ねられます。それっ
てかっこいいでしょ?

@node Persistent Articles
@section 永続記事
@cindex persistent articles
記事のキャッシュと近い関係にあるものに、@dfn{永続記事}があります。実際、
それはキャッシュの別の見方で、私の意見ではその方がもっと役に立ちます。

例えば、ニュースグループを読んでいて、そのまま永遠に保存して秘蔵したい、
いくつかの価値ある宝石に出会ったとしましょう。普通はそれをファイルに保存
します (多くの保存命令の一つを使って)。それの問題は、単にあの、嫌なだけ
です。理想的には、記事はグループであなたが見つけた場所に永遠に残っている
べきでしょう。ニュースサーバーにおける期限削除には影響されないで。

これが@dfn{永続記事}です――記事は削除されません。それは普通のキャッシュ
命令を使って実装されていますが、永続記事の管理をするために二つの明示的な
命令を使います:

@table @kbd
@item *
@kindex * (概略)
@findex gnus-cache-enter-article
現在の記事を永続にします (@code{gnus-cache-enter-article})。

@item M-*
@kindex M-* (概略)
@findex gnus-cache-remove-article
現在の記事を永続記事から取り除きます (@code{gnus-cache-remove-articles})。
これは普通は記事を削除します。
@end table

この命令は両方ともプロセス/接頭引数の習慣を理解します。

もし永続記事にだけ興味があるのでしたら、可視記事 (やその他のもの) がキャッ
シュに入るのを避けるために、@code{gnus-use-cache} を @code{passive} に設
定するのが良いでしょう:

@lisp
(setq gnus-use-cache 'passive)
@end lisp

@node Article Backlog
@section 記事のバックログ
@cindex backlog
@cindex article backlog
もし遅い接続しかない場合で、キャッシュを使うという発想はあまり魅力的では
ないとき (実際そうなのですが)、@dfn{バックログ} に切り替える事によって
状況を何とかすることができます。これは既に読んだ記事を再取得しなくて良い
ように、gnus が既に読んだ記事を一時保存しておくところです。これはもちろ
ん、あなたに最近読んだ記事を再び選択する癖があるときだけに役立ちます。も
し絶対にそれをしないのであれば、バックログをすることは gnus を少し遅くし、
メモリーの使用量をいくらか増やします。

@vindex gnus-keep-backlog
もし @code{gnus-keep-backlog} を数字 @var{n} に設定すると、gnus は最大
で @var{n} の古い記事を後の再取得のためにバッファに溜めておきます。この
変数が @code{nil} ではなく、数字でもない場合、gnus は@emph{全て}の既読記
事をたくわえます。これはあなたの Emacs が、暴発してあなたのマシンが落ち
るまで制限なく膨れ上がるということです。私はあなた方全てが元気でいられる
ようにここに書き加えました。

この変数はディフォルトでは @code{nil} です。

@node Saving Articles
@section 記事の保存
@cindex saving articles

Gnus はたくさんの方法で記事を保存する事ができます。以下のものは非常に率
直な方法 (例えば、記事が保存する前にほとんど何もなされない) で記事を保存
するための説明です。違った手段 (uudecodeする、shar ファイルを展開す
る) については@code{gnus-uu} を使うのが良いでしょ
う (@pxref{Decoding Articles})。

ここに載っているコマンドは対象がファイルです。グループに保存したい場合
は @kbd{B c} (@code{gnus-summary-copy-article}) コマンドを参照して下さ
い (@pxref{Mail Group Commands})。

@vindex gnus-save-all-headers
@code{gnus-save-all-headers} が @code{nil} でないと、gnus は記事を保存す
る前に望ましくないヘッダーを消去しません。

@vindex gnus-saved-headers
もし上の変数が @code{nil} であると、正規表
現 @code{gnus-saved-headers} に合致するすべてのヘッダーは残され、残りの
ものは保存する前に削除されます。

@table @kbd
@item O o
@itemx o
@kindex O o (概略)
@kindex o (概略)
@findex gnus-summary-save-article
@c @icon{gnus-summary-save-article}
ディフォルトの記事保存を用いて現在の記事を保存しま
す (@code{gnus-summary-save-article})。

@item O m
@kindex O m (概略)
@findex gnus-summary-save-article-mail
現在の記事をメールの様式で保存しま
す (@code{gnus-summary-save-article-mail})。

@item O r
@kindex O r (概略)
@findex gnus-summary-save-article-rmail
現在の記事を rmail の様式で保存しま
す (@code{gnus-summary-save-article-rmail})。

@item O f
@kindex O f (概略)
@findex gnus-summary-save-article-file
@c @icon{gnus-summary-save-article-file}
現在の記事を普通のファイル (plain file) 様式で保存しま
す (@code{gnus-summary-save-article-file})。

@item O F
@kindex O F (概略)
@findex gnus-summary-write-article-file
現在の記事を普通のファイル様式で保存し、以前のファイルの内容を上書きしま
す (@code{gnus-summary-write-article-file})。

@item O b
@kindex O b (概略)
@findex gnus-summary-save-article-body-file
現在の記事の本文 (body) を普通のファイル様式で保存しま
す (@code{gnus-summary-save-article-body-file})。

@item O h
@kindex O h (概略)
@findex gnus-summary-save-article-folder
現在の記事を mh のフォルダーの様式で保存しま
す (@code{gnus-summary-save-article-folder})。

@item O v
@kindex O v (概略)
@findex gnus-summary-save-article-vm
現在の記事を VM フォルダーに保存しま
す (@code{gnus-summary-save-article-vm})。

@item O p
@itemx |
@kindex O p (概略)
@kindex | (概略)
@findex gnus-summary-pipe-output
現在の記事をパイプに保存します。うーんと、あのぉ、私が言おうとしている事
は――現在の記事をプロセスにパイプするということで
す (@code{gnus-summary-pipe-output})。

@item O P
@kindex O P (概略)
@findex gnus-summary-muttprint
@vindex gnus-summary-muttprint-program
現在の記事を muttprint に保存します。これは、外部プログラム Muttprint
(@uref{http://muttprint.sourceforge.net/} 参照) を使って記事を印刷します。
プログラム名と使用するオプションは、変
数 @code{gnus-summary-muttprint-program} で指定されます。
(@code{gnus-summary-muttprint})。
@end table

@vindex gnus-prompt-before-saving
すべてのこれらの命令はプロセス/接頭引数の習慣を使いま
す (@pxref{Process/Prefix})。もしこれらの関数を使ってたくさんの記事を保
存した場合、それぞれのすべての記事に対してファイル名の入力を要求される事
に飽き飽きするでしょう。入力促進動作は変
数 @code{gnus-prompt-before-saving} によって制御されます。これはディフォ
ルトでは @code{always} で、あなたが知っていて嫌がっている、過剰な促進動
作をします。代わりにこの変数を @code{t} に設定すると、あなたが保存するそ
れぞれの一連の記事に対して一回だけ促されます。本当に gnus にすべての思考
をさせたいのであれば、この変数を @code{nil} にすることさえできます。そし
て、記事を保存するためのファイルを促される事はありません。Gnus は単純に
すべての記事をディフォルトのファイルに保存します。

@vindex gnus-default-article-saver
Gnus があなたの望むとおりになるように、変
数 @code{gnus-default-article-saver} をカスタマイズする事ができます。下
の六つの既製関数を使う事ができますし、自分自身の関数を作る事もできます。

@table @code
@item gnus-summary-save-in-rmail
@findex gnus-summary-save-in-rmail
@vindex gnus-rmail-save-name
@findex gnus-plain-save-name
これはディフォルトの様式、@dfn{babyl} です。変
数 @code{gnus-ramil-save-name} に入っている関数を、記事を保存するための
ファイル名を取得するために使用します。ディフォルト
は @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-mail
@findex gnus-summary-save-in-mail
@vindex gnus-mail-save-name
Unix メール (mbox) ファイルに保存します。変
数 @code{gnus-mail-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルト
は @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-file
@findex gnus-summary-save-in-file
@vindex gnus-file-save-name
@findex gnus-numeric-save-name
記事を通常のファイルの後に追加します。変数 @code{gnus-file-save-name} に
入っている関数を、記事を保存するためのファイル名を取得するために使用しま
す。ディフォルトは @code{gnus-numeric-save-name} です。

@item gnus-summary-write-to-file
@findex gnus-summary-write-to-file
記事をストレートに通常のファイルに保存します。そのファイルが存在していた
ら上書きされます。変数 @code{gnus-file-save-name} に入っている関数を、記
事を保存するためのファイル名を取得するために使用します。ディフォルト
は @code{gnus-numeric-save-name} です。

@item gnus-summary-save-body-in-file
@findex gnus-summary-save-body-in-file
記事の本体を通常のファイルの後に追加します。変
数 @code{gnus-file-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルト
は @code{gnus-numeric-save-name} です。

@item gnus-summary-save-in-folder
@findex gnus-summary-save-in-folder
@findex gnus-folder-save-name
@findex gnus-Folder-save-name
@vindex gnus-folder-save-name
@cindex rcvstore
@cindex MH folders
MH ライブラリーの @code{rcvstore} を用いる事によって記事を MH フォルダー
に保存します。変数 @code{gnus-folder-save-name} に入っている関数を、記事
を保存するファイル名を取得するために使用します。ディフォルト
は @code{gnus-folder-save-name} ですが、@code{gnus-Folder-save-name} も
使う事ができて、こちらは先頭が大文字、残りが小文字になった名前をつくりま
す。

@item gnus-summary-save-in-vm
@findex gnus-summary-save-in-vm
記事を VM フォルダーに保存します。この設定を使うためには VM メールリーダー
が必要です。
@end table

@vindex gnus-article-save-directory
これらの全ての関数は最後の一つを除いて、環境変数 @code{SAVEDIR} によって
初期化される @code{gnus-article-save-directory} に記事を保存します。これ
はディフォルトでは @file{~/News/} です。

上にあるように、記事を保存するためのファイルの適切な名前を見つけるために、
関数は違った関数を用います。以下は名前を生成するために使用可能な関数のリ
ストです:

@table @code
@item gnus-Numeric-save-name
@findex gnus-Numeric-save-name
@file{~/News/Alt.andera-dworkin/45} のようなファイル名。

@item gnus-numeric-save-name
@findex gnus-numeric-save-name
@file{~/News/alt.andera-dworkin/45} のようなファイル名。

@item gnus-Plain-save-name
@findex gnus-Plain-save-name
@file{~/News/Alt.andera-dworkin} のようなファイル名。

@item gnus-plain-save-name
@findex gnus-plain-save-name
@file{~/News/alt.andera-dworkin} のようなファイル名。

@item gnus-sender-save-name
@findex gnus-sender-save-name
@file{~/News/larsi} のようなファイル名。
@end table

@vindex gnus-split-methods
連想リスト @code{gnus-split-methods} に正規表現を放り込む事によって、
gnus に記事を保存する場所を提案する事ができます。例えば、gnus に関連した
記事をファイル @file{gnus-stuff} に、VM に関連した記事
を @code{vm-stuff} 保存したければ、この変数を以下のようにする事ができま
す:

@lisp
(("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
 ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
 (my-choosing-function "../other-dir/my-stuff")
 ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))
@end lisp

これはそれぞれの要素が、二つの要素――@dfn{合致} と @dfn{ファイル} を持
つリストであるリストであるという事がわかります。合致は文字列 (この場合は
記事のヘッダーに合致する正規表現として使われます) および、シンボル (グルー
プ名を引数として、関数として呼ばれます) および、リスト (これは評
価 (@code{eval}) されます) であることができます。もしこれらの動作の一つ
でも @code{nil} でない結果を返すと、@dfn{ファイル}がディフォルトの促進と
して使われます。加えて、呼ばれた関数か式が文字列か文字列のリストを返した
ときは、演算の結果自体が使われます。

基本的には、現在の記事を保存するのに使われる可能性のあるファイル名のリス
トを手に入れる事になります。(すべての『合致』が使われます。) それから本
当に名前として使いたいものを促され、この変数を適用する事により得られた結
果からファイル名補完をして入力します。

この変数はディフォルトでは @code{((gnus-article-archive-name))} で、
gnus が保存する記事の @code{Archive-name} 行を調べて、それをファイル名の
提案として使うという事です。

これはファイル名を少しきれいにする関数の例です。
@samp{nnml:mail.whatever} のようなメールグループがたくさんあるのであれば、
保存するためのファイル名を作る前にこれらのグループ名の最初を切り落とした
いかもしれません。次の物はちょうどそれをします:

@lisp
(defun my-save-name (group)
  (when (string-match "^nnml:mail." group)
    (substring group (match-end 0))))

(setq gnus-split-methods
      '((gnus-article-archive-name)
        (my-save-name)))
@end lisp

@vindex gnus-use-long-file-name
最後に @code{gnus-use-long-file-name} という変数があります。これ
が @code{nil} であると、すべての上記の関数はグループ名のすべてのピリオ
ド (@samp{.}) をスラッシュ (@samp{/}) で置き換えます――これは関数はすべ
てのファイルを一番上のディレクトリーに置くのではなく、階層的なディレクト
リーを作るという事です (@file{~/News/alt.andrea-dworkin} の代わり
に @file{~/News/alt/andrea-dworkin}。) この変数はたいていのシステムにお
いてディフォルトで @code{t} です。しかし、歴史的な理由か
ら Xenix と usg-unix-v マシンではディフォルトで @code{nil} です。

この関数は削除とスコアのファイル名に影響します。この変数がリストで、リス
トに要素 @code{not-score} があると、長いファイル名はスコアファイルには使
われず、リストに要素 @code{not-save} があると、長いファイル名は保存には
使われず、要素 @code{not-kill} があると、長いファイル名は削除ファイルに
は使われません。

もし記事をスプールのような階層に保存したいのであれば、次のようにできます。

@lisp
(setq gnus-use-long-file-name '(not-save)) ; to get a hierarchy
(setq gnus-default-article-saver
      'gnus-summary-save-in-file) ; no encoding
@end lisp

それから @kbd{o} によって記事を保存するだけです。それからこの階層を短命
な @code{nneething} グループによって読む事ができます――グループバッファ
で @kbd{G D} とし、一番上のディレクトリーを引数 (@file{~/News/}) として
渡します。

@node Decoding Articles
@section 記事の復号化
@cindex decoding articles

ときどき利用者は何らかの方法で符号化された記事 (もしくは記事群) を投稿し
ます。Gnus はあなたのためにそれらを復号化する事ができます。

@menu
* Uuencoded Articles::          記事を uuencode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せな復号化のための変数
* Viewing Files::               復号化の結果を見たい?
@end menu

@cindex series
@cindex article series
これらすべての関数はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) を、
『一つの記事』を『一つの群』と解釈する拡張をして、どの記事に操作をするか
を見つけるために使います。Gnus は自分自身でどの記事がその群に属している
かを判断し、すべての記事を復号化して、その結果のファイルを 展開/閲覧/保
存 することができます。

Gnus は以下の簡単な規則に則ってどの記事が群に属するのかを推測します: 表
題は行の最後の二つの数字を除いて (ほとんど) 同じである必要があります。
(空白は大体無視されますが。)

例えば: @samp{cat.gif (2/3)} というような表題を選ぶと、gnus は正規表
現 @samp{^cat.gif ([0-9]+/[0-9]+).*$} に合致するすべての記事を見つけよう
とします。

@samp{cat.gif (2/3) Part 6 of a series} のような標準でない表題はどの自動
閲覧命令によっても適切に認識されないため、手で記事に @kbd{#} の印を付け
なければなりません。

@node Uuencoded Articles
@subsection uuencode された記事
@cindex uudecode
@cindex uuencoded articles

@table @kbd
@item X u
@kindex X u (概略)
@findex gnus-uu-decode-uu
@c @icon{gnus-uu-decode-uu}
現在の群を uudecode します (@code{gnus-uu-decode-uu})。

@item X U
@kindex X U (概略)
@findex gnus-uu-decode-uu-and-save
現在の群を uudecode して保存します (@code{gnus-uu-decode-uu-and-save})。

@item X v u
@kindex X v u (概略)
@findex gnus-uu-decode-uu-view
現在の群を uudecode して、表示します (@code{gnus-uu-decode-uu-view})。

@item X v U
@kindex X v U (概略)
@findex gnus-uu-decode-uu-and-save-view
現在の記事を uudecode して、表示して保存しま
す (@code{gnus-uu-decode-uu-and-save-view})。
@end table

これらすべてはプロセス印によって印付けられた記事の存在に対して反応すると
いうことを覚えておいてください。例えば、もしニュースグループ全体を復号化
して保存したいのであれば、普通
は @kbd{M P a} (@code{gnus-uu-mark-all}) とし、それか
ら @kbd{X U} (@code{gnus-uu-decode-uu-and-save}) とします。

この全ては、白日の下に明白にキーを打っていた @sc{gnus 4.1} のときと
は @code{gnus-uu} の動作が全く違っています。この版の @code{gnus-uu} は普
通は何かの方法 (@pxref{Setting Process Marks}) で記事に印を付けて、それ
から @kbd{X u} を押す事を前提としています。

@vindex gnus-uu-notify-files
注意: @code{gnus-uu-notify-files} に合致する名前、
@samp{[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)} にハードコードされる、
を持つ記事を復号化しようとしたときは、@code{gnus-uu} は問題の記事をちょ
うど閲覧した事を知らせるために、自動的に @samp{comp.unix.wizards} に記事
を投稿します。この機能を使わないようにする事はできません。

@node Shell Archives
@subsection シェルアーカイブ
@cindex unshar
@cindex shell archives
@cindex shared articles

シェルアーカイブ (『shar ファイル』) はソースを配布するための人気のある
方法でしたが、今日ではそんなに使われていません。とにかくこれらを扱うため
の命令があります:

@table @kbd
@item X s
@kindex X s (概略)
@findex gnus-uu-decode-unshar
現在の群を解凍します (@code{gnus-uu-decode-unshar})。

@item X S
@kindex X S (概略)
@findex gnus-uu-decode-unshar-and-save
現在の群を解凍し保存します (@code{gnus-uu-decode-unshar-and-save})。

@item X v s
@kindex X v s (概略)
@findex gnus-uu-decode-unshar-view
現在の群を解凍し表示します (@code{gnus-uu-decode-unshar-view})。

@item X v S
@kindex X v S (概略)
@findex gnus-uu-decode-unshar-and-save-view
現在の群を解凍し、表示して保存しま
す (@code{gnus-uu-decode-unshar-and-save-view})。
@end table

@node PostScript Files
@subsection ポストスクリプトファイル
@cindex PostScript

@table @kbd
@item X p
@kindex X p (概略)
@findex gnus-uu-decode-postscript
現在のポストスクリプト群を展開します (@code{gnus-uu-decode-postscript})。

@item X P
@kindex X P (概略)
@findex gnus-uu-decode-postscript-and-save
現在のポストスクリプト群を展開して保存しま
す (@code{gnus-uu-decode-postscript-and-save})。

@item X v p
@kindex X v p (概略)
@findex gnus-uu-decode-postscript-view
現在のポストスクリプト群を表示しま
す (@code{gnus-uu-decode-postscript-view})。

@item X v P
@kindex X v P (概略)
@findex gnus-uu-decode-ostscript-and-save-view
現在のポストスクリプト群を表示し保存しま
す (@code{gnus-uu-decode-postscript-and-save-view})。
@end table

@node Other Files
@subsection 他のファイル

@table @kbd
@item X o
@kindex X o (概略)
@findex gnus-uu-decode-save
現在の群を保存します (@code{gnus-uu-decode-save})。

@item X b
@kindex X b (概略)
@findex gnus-uu-decode-binhex
現在の記事を binhex 解凍します (@code{gnus-uu-decode-binhex})。これは本
当は動作しません。
@end table

@node Decoding Variables
@subsection 復号化のための変数

形容詞です。動詞ではありません。

@menu
* Rule Variables::              ファイルがどのように表示されるかを決める
                                変数
* Other Decode Variables::      他の復号化の変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数
@end menu

@node Rule Variables
@subsubsection 規則変数
@cindex rule variables

Gnus はファイルを閲覧するのを決定するのに@dfn{規則変数}を用います。これ
らの変数はすべて以下のような様式です。

@lisp
      (list '(regexp1 command2)
            '(regexp2 command2)
            ...)
@end lisp

@table @code
@item gnus-uu-user-view-rules
@vindex gnus-uu-user-view-rules
@cindex sox
この変数はファイルを閲覧するときに最初に調べられます。例えば、も
し @samp{.au} 音ファイルを変換するために @code{sox} を使いたいときは、次
のようにできます:

@lisp
(setq gnus-uu-user-view-rules
      (list '("\\\\.au$\" "sox %s -t .aiff > /dev/audio")))
@end lisp

@item gnus-uu-user-view-rules-end
@vindex gnus-uu-user-view-rules-end
この変数は gnus が利用者とディフォルトの閲覧規則から合致するものを見つけ
られなかったときに調べられます。

@item gnus-uu-user-archive-rules
@vindex gnus-uu-user-archive-rules
この変数はアーカイブを展開するときにどの命令が使われるべきかを決めるため
に使う事ができます。
@end table

@node Other Decode Variables
@subsubsection 他の復号化の変数

@table @code
@vindex gnus-uu-grabbed-file-functions

@item gnus-uu-grabbed-file-functions
このリストのすべての関数はそれぞれのファイルが上手く復号化された直後に呼
ばれます――ですから、すぐにファイルを移動や閲覧したりすることができ、何
かをする前にすべてのファイルが復号化されるのを待つ必要はありません。この
リストに入れる事のできる既製関数は:

@table @code
@item gnus-uu-grab-view
@findex gnus-uu-grab-view
ファイルを閲覧します。

@item gnus-uu-grab-move
@findex gnus-uu-grab-move
ファイルを移動します (もし保存関数を使っているのであれば)。
@end table

@item gnus-uu-be-dangerous
@vindex gnus-uu-be-dangerous
復号化の最中に変な状況が起こったときに何をするかを指定します。も
し @code{nil} であると、できるだけ保守的になります。もし @code{t} である
と、動作しないものは無視して、現存するファイルを上書きします。その他の場
合は、それぞれのときに尋ねます。

@item gnus-uu-ignore-files-by-name
@vindex gnus-uu-ignore-files-by-name
この正規表現に合致する名前のファイルは閲覧されません。

@item gnus-uu-ignore-files-by-type
@vindex gnus-uu-ignore-files-by-type
この変数に合致する @sc{mime} の型を持つファイルは閲覧されません。Gnus は
ファイル名に基づいて型を推測している事に注意してください。
@code{gnus-uu} は (まだ) @sc{mime} パッケージではありませんので、これは
少し変です。

@item gnus-uu-tmp-dir
@vindex gnus-uu-tmp-dir
@code{gnus-uu} がその仕事をする場所です。

@item gnus-uu-do-not-unpack-archives
@vindex gnus-uu-do-not-unpack-archives
@code{nil} でないのは、@code{gnus-uu} は表示するためのファイルを探すため
にアーカイブの中までは入っていかないという事です。

@item gnus-uu-view-and-save
@vindex gnus-uu-view-and-save
@code{nil} でないのは、利用者はファイルを閲覧した後に常に保存するかどう
かを尋ねられるという事です。

@item gnus-uu-ignore-default-view-rules
@vindex gnus-uu-ignore-default-view-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトの閲覧規則を無視する
という事です。

@item gnus-uu-ignore-default-archive-rules
@vindex gnus-uu-ignore-default-archive-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトのアーカイブ展開命令
を無視するという事です。

@item gnus-uu-kill-carriage-return
@vindex gnus-uu-kill-carriage-return
@code{nil} でないのは、@code{gnus-uu} は記事からすべてのキャリッジリター
ン (carriage return) を取り去るという事です。

@item gnus-uu-unmark-articles-not-decoded
@vindex gnus-uu-unmark-articles-not-decoded
@code{nil} でないのは、@code{gnus-uu} は復号化に失敗した記事に未読の印を
付けるという事です。

@item gnus-uu-correct-stripped-uucode
@vindex gnus-uu-correct-stripped-uucode
@code{nil} でないというのは、@code{gnus-uu} は続く空白が削除されてしまっ
ている uuencode されたファイルを修復しようと @emph{試す} という事です。

@item gnus-uu-pre-uudecode-hook
@vindex gnus-uu-pre-uudecode-hook
@code{uudecode} にメッセージを送る前に実行されるフックです。

@item gnus-uu-view-with-metamail
@vindex gnus-uu-view-with-metamail
@cindex metamail
@code{nil} でないのは、@code{gnus-uu} は規則変数で定義された閲覧命令を無
視して、ファイル名に基づいた @sc{mime} 内容の型に取り替えるという事です。
その結果は閲覧のために @code{metamail} にかけられます。

@item gnus-uu-save-in-digest
@vindex gnus-uu-save-in-digest
@code{nil} でないのは、@code{gnus-uu} が復号化をしないで保存をするように
言われたときに、要約を保存するという事です。この変数が @code{nil} である
と、@code{gnus-uu} は 何も飾りをしないで全てをファイルに保存します。要約
は RFC1153 準じています――意味のある量を指定して、番号を発行する簡単な
方法が見つからなかったので、単純にそれらは切り落としています。
@end table

@node Uuencoding and Posting
@subsubsection uuencode と投稿

@table @code
@item gnus-uu-post-include-before-composing
@vindex gnus-uu-post-include-before-composing
@code{nil} でないのは、@code{gnus-uu} が記事を作成する前に符号化するファ
イルを尋ねるという事です。この変数が @code{t} であると、@kbd{C-c C-i} に
よって符号化されたファイルを取り込むか、記事を投稿するときに取り込むか、
どちらかをする事ができます。

@item gnus-uu-post-length
@vindex gnus-uu-post-length
記事の最大の長さです。符号化されたファイルは全体のファイルを投稿するのに
必要な量のファイルに分割されます。

@item gnus-uu-post-threaded
@vindex gnus-uu-post-threaded
@code{nil} でないのは、@code{gnus-uu} が符号化されたファイルをスレッドで
投稿するという事です。これはあまり賢い方法ではないかも知れません。という
のは、今まで私が見た中で uuencode された記事を集めるのに、スレッドを追っ
ていく事のできる他の復号装置が存在しないからです。(えーと、私はそれをす
る一つのパッケージを見た事があります――@code{gnus-uu} です。しかしなぜ
か、それが数のうちに入るとは思えないのです...) ディフォルト
は @code{nil} です。

@item gnus-uu-post-separate-description
@vindex gnus-uu-post-separate-description
@code{nil} でないのは、記述は別の記事で投稿されるという事です。最初の記
事は普通は (0/x) のように番号が付けられます。もしこの変数
が @code{nil} であると、利用者の書いた記述は最初のファイルの始めに取り込
まれ、(1/x) の番号が付けられます。ディフォルトは @code{t} です。
@end table

@node Viewing Files
@subsection ファイルの閲覧
@cindex viewing files
@cindex pseudo-articles

復号化した後でファイルが何らかのアーカイブである場合、gnus はアーカイブ
を展開しようと試み、アーカイブの中に閲覧できるファイルがあるかを調べます。
例えば、gzip された tar ファイル @file{pics.tar.gz} があって、ファイ
ル @file{pic1.jpg} と @file{pic2.gif} を含んでいる場合、gnus は主ファイ
ルを解凍して tar を展開し、それから二つの絵を閲覧します。この展開の過程
は再帰的なので、アーカイブにアーカイブのアーカイブがあると、それはすべて
展開されます。

最後に、gnus は普通はそれぞれの抽出された記事ごとに@dfn{疑似記事}を概略
バッファに挿入します。これらの『記事』に移動した場合は、実行する命令 (普
通はgnus が提案をします) を入力するように促され、それから命令が実行され
ます。

@vindex gnus-view-pseudo-asynchronously
@code{gnus-view-pseudo-asynchronously} が @code{nil} であると、Emacs は
先へ進む前に閲覧が終わるまで待ちます。

@vindex gnus-view-pseudos
@code{gnus-view-pseudos} が @code{automatic} であると、gnus は概略バッファ
に疑似記事を挿入しませんが、それらをすぐに閲覧します。この変数
が @code{not-confirm} であると、利用者は閲覧が済む前に確認さえも求められ
ません。

@vindex gnus-view-pseudos-separately
@code{gnus-view-pseudos-separately} が @code{nil} でないと、一つの疑似記
事が閲覧されるそれぞれのファイルに対して作成されます。@code{nil} である
と、同じ閲覧命令を使うすべての命令がその命令の引数のリストとして渡されま
す。

@vindex gnus-insert-pseudo-articles
@code{gnus-insert-pseudo-articles} が @code{nil} でないと、復号化のとき
に疑似記事を挿入します。ディフォルトでは @code{t}です。

それで、そのような感じです。@emph{実質サーバー} から
の @emph{実質グループ} の @emph{疑似記事} 読んでいます。そして考えま
す: どうして全てが現実ではなくなってしまったのだろうか? どうしてここに来
てしまったのだろうか?

@node Article Treatment
@section 記事の扱い

この巨大な説明文書を読んできて、人々が書いた事を読む、といったようなニュー
ズリーダーの本当の目的を完全に忘れてしまったかも知れません。記事を読む事
です。残念な事に、人々は書く事は非常に苦手としていますので、記事を読みや
すくするための関数と変数が山のようにあります。

@menu
* Article Highlighting::        記事を果物サラダのように見えるようにした
                                い
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた
                                関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID や アドレスなどをクリッ
                                クする
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             X-Face, Picons, Smileys を表示する
* Article Signature::           署名って何?
* Article Miscellania::         他のいろいろなもの
@end menu

@node Article Highlighting
@subsection 記事のハイライト
@cindex highlighting

記事バッファを果物サラダのようにしたいだけでなく、華やかな果物サラダのよ
うに見えるようにしたいでしょう。

@table @kbd
@item W H a
@kindex W H a (概略)
@findex gnus-article-highlight
@findex gnus-article-maybe-highlight
現在の記事をもっとハイライト (highlight) します。この関数は、ヘッダー、
引用文、署名をハイライトし、本体 (body) と頭 (head) にボタンを加えます。

@item W H h
@kindex W H h (概略)
@findex gnus-article-highlight-headers
@vindex gnus-header-face-alist
ヘッダーをハイライトします (@code{gnus-article-highlight-headers})。ハイ
ライトは変数 @code{gnus-header-face-alist} にしたがってなされ、それはそ
れぞれの要素が @code{(@var{正規表現} @var{名前} @var{内容})} という様式
のリストです。
@var{正規表現}はヘッダーに合致する正規表現、@var{名前}はヘッダーの名前を
ハイライトするのに使われるフェイス (face) (@pxref{Faces and Fonts})、
@var{内容}はヘッダーの値をハイライトするフェイスです。最初に合致したもの
が使われます。@var{正規表現}は @samp{^} が付けられるべきではない事に注意
してください――gnus がそれを付け加えます。

@item W H c
@kindex W H c (概略)
@findex gnus-article-highlight-citation
引用された文をハイライトします (@code{gnus-article-highlight-citation})。

引用ハイライトをカスタマイズするいくつかの変数は:

@table @code
@vindex gnus-cite-parse-max-size

@item gnus-cite-parse-max-size
記事の大きさがこの変数 (ディフォルトでは 25000) より大きい記事は、引用ハ
イライトは行われません。

@item gnus-cite-max-prefix
@vindex gnus-cite-max-prefix
引用接頭語の最大の長さです (ディフォルトでは 20 です)。

@item gnus-cite-face-list
@vindex gnus-cite-face-list
引用をハイライトするために使われるフェイスのリストです (@pxref{Faces and
Fonts})。同じメッセージの中に複数の記事からの引用があると、gnus はそれぞ
れの記事からの引用をそれ用のフェイスで表示しようとします。これにより、誰
が何を書いたかが分かりやすくなるでしょう。

@item gnus-supercite-regexp
@vindex gnus-supercite-regexp
普通の Supercite 属性行に合致する正規表現です。

@item gnus-supercite-secondary-regexp
@vindex gnus-supercite-secondary-regexp
引き裂かれた Supercite 属性行に合致する正規表現です。

@item gnus-cite-minimum-match-count
@vindex gnus-cite-minimum-match-count
それが引用であると決定する前に調べなければならない最小の同一接頭語です。

@item gnus-cite-attribution-prefix
@vindex gnus-cite-attribution-prefix
属性行の始まりに合致する正規表現です。

@item gnus-cite-attribution-suffix
@vindex gnus-cite-attribution-suffix
属性行の最後に合致する正規表現です。

@item gnus-cite-attribution-face
@vindex gnus-cite-attribution-face
属性行に使われるフェイスです。その属性に属する文のためのフェイスと融合さ
れます。
@end table

@item W H s
@kindex W H s (概略)
@vindex gnus-signature-separator
@vindex gnus-signature-face
@findex gnus-article-highlight-signature
署名 (signature) をハイライトしま
す (@code{gnus-article-highlight-signature})。
@code{gnus-signature-separator} (@pxref{Article Signature}) の後の全ての
ものは署名と考えられ、@code{gnus-signature-face} でハイライトされます。
それはディフォルトでは @code{italic} です。記事を自動的にハイライトする
方法については @xref{Customizing Articles} を参照して下さい。
@end table

@node Article Fontisizing
@subsection 記事のフォント変更
@cindex emphasis
@cindex article emphasis

@cindex gnus-article-emphasize
@kindex W e (概略)
人々はよくニュースの記事で @samp{_これ_} や @samp{*これ*} また
は @samp{/これ/} のようなものを使って単語を強調します。Gnus は 記事を命
令 @kbd{W e} (@code{gnus-article-emphasize}) にかける事によって素敵に見
えるようにできます。

@vindex gnus-emphasis-alist
強調がどのように演算されるかは変数 @code{gnus-emphasis-alist} によって制
御されます。これは最初の要素が合致するべき正規表現である連想リストです。
二番目の要素はどの正規表現のグループが強調語全体を見つけるために使われる
かを示す数字です。三番目はどの正規表現のグループが表示されハイライトされ
るかを決める数字です。
(この二つのグループの間の記事は隠されます。) 四番目はハイライトのフェイ
スです。

@lisp
(setq gnus-emphasis-alist
      '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
        ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))
@end lisp

@cindex slash
@cindex asterisk
@cindex underline
@cindex /
@cindex *

@vindex gnus-emphasis-underline
@vindex gnus-emphasis-bold
@vindex gnus-emphasis-italic
@vindex gnus-emphasis-underline-bold
@vindex gnus-emphasis-underline-italic
@vindex gnus-emphasis-bold-italic
@vindex gnus-emphasis-underline-bold-italic
初期設定では七つの規則があり、それらは以下のフェイスを用いま
す: @code{gnus-emphasis-bold}, @code{gnus-emphasis-italic}, @code{gnus-emphasis-underline}, @code{gnus-emphasis-bold-italic}, @code{gnus-emphasis-underline-italic}, @code{gnus-emphasis-underline-bold}, @code{gnus-emphasis-underline-bold-italic}.

これらのフェイスを変更したいのであれば、
@kbd{M-x customize} か @code{copy-face} を使う事ができます。例えば、
@code{gnus-emphasis-italic} に代わりに赤のフェイスを使うようにしたいとき
は、次のようにできます:

@lisp
(copy-face 'red 'gnus-emphasis-italic)
@end lisp

@vindex gnus-group-highlight-words-alist
任意の語を強調表示させたいときは、
@code{gnus-group-highlight-words-alist} 変数を使うことができます。これ
は @code{gnus-emphasis-alist} と同じ構文を使います。
@code{highlight-words} グループパラメータを使うこともできます。

記事を自動的にフォンと変更させるためには @xref{Customizing Articles} を
参照して下さい。

@node Article Hiding
@subsection 記事を隠す
@cindex article hiding

もしくは、それぞれの記事の特定のものを隠したいかもしれません。たいていの
記事には普通はありすぎるくらい作りかえるものがあります。

@table @kbd
@item W W a
@kindex W W a (概略)
@findex gnus-article-hide
記事バッファでたくさんの隠匿をします (@kbd{gnus-article-hide})。特に、こ
の関数はヘッダー、PGP、引用文と署名を隠します。

@item W W h
@kindex W W h (概略)
@findex gnus-article-hide-headers
ヘッダーを隠します (@code{gnus-article-hide-headers})。
@xref{Hiding Headers}.

@item W W b
@kindex W W b (概略)
@findex gnus-article-hide-boring-headers
あまり興味のもてないヘッダーを隠しま
す (@code{gnus-article-hide-boring-headers})。@xref{Hiding Headers}.

@item W W s
@kindex W W s (概略)
@findex gnus-article-hide-signature
署名を隠します (@code{gnus-article-hide-signature})。
@xref{Article Signature}.

@item W W l
@kindex W W l (概略)
@findex gnus-article-hide-list-identifiers
@vindex gnus-list-identifiers
@code{gnus-list-identifiers} で指定されているメーリングリストの標識を削
除します。これらはいくつかのメーリングリストのサーバーが全て
の @code{Subject} ヘッダーの最初につける文字列です---例えば、
@samp{[zebra 4711]}。文字列の初めにある @samp{Re: } は、削除を行なう前に
跳び越されます。@code{gnus-list-identifiers} に @code{\\(..\\)} を含めて
はいけません。

@table @code
@item gnus-list-identifiers
@vindex gnus-list-identifiers
表題から削除されるべき標識のリストに合致する正規表現です。これは正規表現
のリストであることもできます。
@end table

@item W W p
@kindex W W p (概略)
@findex gnus-article-hide-pgp
@vindex gnus-article-hide-pgp-hook
@sc{pgp} 署名を隠します (@code{gnus-article-hide-pgp})。@sc{pgp} 署名が
隠された後にフック @code{gnus-article-hide-pgp-hook} が実行されます。
例えば、署名を持つ記事を自動的に認証するには:

@lisp
;;; Hide pgp cruft if any.

(setq gnus-treat-strip-pgp t)

;;; After hiding pgp, verify the message;
;;; only happens if pgp signature is found.

(add-hook 'gnus-article-hide-pgp-hook
          (lambda ()
            (save-excursion
              (set-buffer gnus-original-article-buffer)
              (mc-verify))))
@end lisp

@item W W P
@kindex W W P (概略)
@findex gnus-article-hide-pem
@sc{pem} (privacy enhanced messages (プライバシー拡張メッセージ)) 部分を
隠します (@code{gnus-article-hide-pem})。

@item W W B
@kindex W W B (概略)
@findex gnus-article-strip-banner
@cindex banner
@cindex OneList
@cindex stripping advertisements
@cindex advertisements
@code{banner} グループパラメータで指定されたバナーを取り除きま
す (@code{gnus-article-strip-banner})。これは主に、いくつかのメーリング
リストや司会者付きのグループが全ての記事に追加する、欝陶しいバナーと/も
しくは署名を隠すために使用されます。この関数を使う方法
は @code{banner} グループパラメータ (@pxref{Group Parameters}) をバナー
を取り除きたいグループに追加します。パラメータは、消去されるテキストに合
致する正規表現として解釈される文字列か、(最後の) 署名が消去されるという
意味であるシンボル @code{signature} また
は @code{gnus-article-banner-alist} の正規表現に対応したシンボルであるこ
とができます。

@item W W c
@kindex W W c (概略)
@findex gnus-article-hide-citation
引用を隠します (@code{gnus-article-hide-citation})。隠蔽をカスタマイズす
るいくつかの変数は:

@table @code
@item gnus-cited-opend-text-button-line-format
@itemx gnus-cited-closed-text-button-line-format
@vindex gnus-cited-closed-text-button-line-format
@vindex gnus-cited-opend-text-button-line-format

Gnus はどこの引用文が隠されているかを示すためにボタンを付け加え、文章の
隠蔽を切り替えられるようにします。この変数の様式はこれらのフォーマットの
ような変数によって指定されます (@pxref{Formatting Variables})。次の指定
は有効です:

@table @samp
@item b
隠された文の最初のポイントです。
@item e
隠された文の最後のポイントです。
@item l
隠されたリージョンの文字の数です。
@item n
隠された文の行の数です。
@end table

@item gnus-cited-lines-visible
@vindex gnus-cited-lines-visible
引用文の最初からの表示される行数です。
@end table

@item W W C
@kindex W W C (概略)
@findex gnus-article-hide-citation-in-followups
根本でない記事の引用文を隠しま
す (@code{gnus-article-hide-citation-in-followups})。これは対話的命令と
してはあまり役に立たないかもしれませんが、自動的に起こる手軽な関数である
でしょう (@pxref{Customizing Articles})。

@item W W C-c
@kindex W W C-c (概略)
@findex gnus-article-hide-citation-maybe

以下の二つの変数に基づいて引用を隠しま
す (@code{gnus-article-hide-citation-maybe}):

@table @code
@item gnus-cite-hide-percentage
@vindex gnus-cite-hide-percentage
もし引用文がこの変数 (初期値は 50) より大きい割合であれば、引用文を隠し
ます。

@item gnus-cite-hide-absolute
@vindex gnus-cite-hide-absolute
隠される引用文は少なくともこの長さ (初期値 10) でなければなりません。
@end table
@end table

これらの全ての『隠蔽』命令は切り替え命令ですが、これらの命令に負の接頭引
数を与えると、それらは前に隠されていたものを表示します。正の接頭引数を与
えれば、それらは常に隠します。

引用カスタマイズのための他の変数の情報のため
に @pxref{Article Highlighting} も参照してください。

自動的に記事の要素を隠すための方法は @xref{Customizing Articles} を参照
して下さい。

@node Article Washing
@subsection 記事洗濯
@cindex washing
@cindex article washing

私たちはこれをもっともな理由の下で『記事洗濯』(article washing) と呼んで
います。すなわち、キー @kbd{A} は使われているので、代わりに
キー @kbd{W} を使う必要があるのです。

私たちは @dfn{洗濯} を『何かの何かを何か別のものに変換する』と定義してい
ますが、普通はもっと良く見える何かに落ち着きます。それにもっときれいです、
たぶん。

gnus が記事を表示する既定のやり方を変えたいとき
は @xref{Customizing Articles} を参照して下さい。

@table @kbd
@item C-u g
これは記事洗濯ではなくて、その逆です。これをタイプすると、ディスクやサー
バーにあるがままの記事が見えます。

@item W l
@kindex W l (概略)
@findex gnus-summary-stop-page-breaking
ページの区切りを現在の記事から取り除きま
す (@code{gnus-summary-stop-page-breaking})。ページの区切りに付いて
は @xref{Misc Article} を参照して下さい。

@item W r
@kindex W r (概略)
@findex gnus-summary-caesar-message
@c @icon{gnus-summary-caesar-message}
記事バッファでカエサル変換 (Caesar rotate) (rot13) をしま
す (@code{gnus-summary-caesar-message})。カエサル変換か rot13 を用いて読
む事のできる、判読不可能な記事です (典型的には、攻撃的な冗談などです。)

普通は ``rot13'' と呼ばれています。それはアルファベットの位置が 13 個回
転するからです。例えば、@samp{B} (2 番目の文字) → @samp{O} (15 番目の文
字)。これは時々『カエサル変換』と呼ばれる事もあります。というのは、カエ
サルがこの形式の、えーと、ちょっと簡単な暗号化を採用したという噂があるか
らです。

@item W t
@item t
@kindex W t (概略)
@kindex t (概略)
@findex gnus-summary-toggle-header
記事バッファにすべてのヘッダーを表示するかどうかを切り替えま
す (@code{gnus-summary-toggle-header})。

@item W v
@kindex W v (概略)
@findex gnus-summary-verbose-headers
記事バッファにすべてのヘッダーを永遠に表示するかどうかを切り替えま
す (@code{gnus-summary-verbose-headers})。

@item W m
@kindex W m (概略)
@findex gnus-summary-toggle-mime
表示する前に記事に @sc{mime} 処理を実行するかどうかを切り換えま
す (@code{gnus-summary-toggle-mime})。

@item W o
@kindex W o (概略)
@findex gnus-article-treat-overstrike
オーバーストライクを処理します (@code{gnus-article-treat-overstrike})。

@item W d
@kindex W d (概略)
@findex gnus-article-treat-dumbquotes
@vindex gnus-article-dumbquotes-map
@cindex Smartquotes
@cindex M****s*** sm*rtq**t*s
@cindex Latin 1
@code{gnus-article-dumbquotes-map} に応じて、マ■■■ソ■
■ sm*rtq**t*s を処理します この関数は文字が sm*rtq**t* かどうかを推測し
ますので、対話的にのみ使用されるべきであることに注意してください。

Sm*rtq**t*s はもっと多くの引用文字を提供するために、マ■■■ソ■■が勝手
に文字マップを拡張したものです。もし、アポストロフィ (') や引用記号など
があるべきところに @code{\222} や @code{\264} のようなものが見えてしまっ
たら、洗濯してみて下さい。

@item W k
@kindex W k (概略)
@findex gnus-article-outlook-deuglify-article
@cindex Outlook Express
壊れた Outlook (Express) の記事を deuglify して再表示しま
す (@code{gnus-article-outlook-deuglify-article})。

@item W w
@kindex W w (概略)
@findex gnus-article-fill-cited-article
語の折り返しをします (@code{gnus-article-fill-cited-articles})。

折り返しをするときに、幅を指定するために命令に数値接頭引数を与える事がで
きます。

@item W Q
@kindex W Q (概略)
@findex gnus-article-fill-long-lines
長い行を折り返します (@code{gnus-article-fill-mode-lines})。

@item W C
@kindex W C (概略)
@findex gnus-article-capitalize-sentences
それぞれの分の最初の語を大文字にしま
す (@code{gnus-article-capitalize-sentences})。

@item W c
@kindex W c (概略)
@findex gnus-article-remove-cr
CRLF の組 (すなわち、行の最後の @samp{^M}) を LF に変換します (これ
は DOS の行末の世話をします)、そしてそれから残りの CR を LF に変換しま
す (これは MAC の行末の世話をします) (@code{gnus-article-remove-cr})。

@c @item W q
@c @kindex W q (Summary)
@c @findex gnus-article-de-quoted-unreadable
@c Treat quoted-printable (@code{gnus-article-de-quoted-unreadable}).
@c Quoted-Printable is one common @sc{mime} encoding employed when sending
@c non-ASCII (i. e., 8-bit) articles.  It typically makes strings like
@c @samp{d,Aij,A` vu} look like @samp{d=E9j=E0 vu}, which doesn't look very
@c readable to me.  Note that the this is usually done automatically by
@c Gnus if the message in question has a @code{Content-Transfer-Encoding}
@c header that says that this encoding has been done.
@c If a prefix is given, a charset will be asked for.

@c @item W 6
@c @kindex W 6 (Summary)
@c @findex gnus-article-de-base64-unreadable
@c Treat base64 (@code{gnus-article-de-base64-unreadable}).
@c Base64 is one common @sc{mime} encoding employed when sending non-ASCII
@c (i. e., 8-bit) articles.  Note that this is usually done
@c automatically by Gnus if the message in question has a
@c @code{Content-Transfer-Encoding} header that says that this encoding has
@c been done.
@c If a prefix is given, a charset will be asked for.

@item W Z
@kindex W Z (概略)
@findex gnus-article-decode-HZ
HZ または HZP を処理します。HZ (または HZP) は中国語の記事を伝送するとき
に使われる一般的な符号です。これは @samp{~@{<:Ky2;S@{#,NpJ)l6HK!#~@}} の
ような典型的な文字列を作ります。

@item W u
@kindex W u (Summary)
@findex gnus-article-unsplit-urls
URL に含まれる改行を削除します。いくつかのメイラーは、行を短くするために
出ていくメールに改行を挿入しますが、これは長い URL を複数の行に分割して
しまいます。改行を削除することによって、それらの URL を復旧させま
す (@code{gnus-article-unsplit-urls})。

@item W h
@kindex W h (概略)
@findex gnus-article-wash-html
@sc{html} を処理します。当該メッセージが @sc{html} であることを示
す @code{Content-Type} ヘッダーを持っていたならば、それは gnus によって
自動的に行なわれることに注意して下さい。

接頭辞が与えられると、何の文字集合 (charset) として扱うかを尋ねられます。

@vindex gnus-article-wash-function
ディフォルトでは @sc{html} の変換に @code{mm-inline-text-html-renderer}
(@pxref{Customization, , , emacs-mime}) で設定された関数を使いますが、こ
れは変数 @code{gnus-article-wash-function} で制御されます。使うことがで
きる、あらかじめ用意された関数は以下の通りです。

@table @code
@item w3
Emacs/W3 を使います。

@item w3m
emacs-w3m を使います (詳しくは @uref{http://emacs-w3m.namazu.org/} を参
照して下さい)。

@item links
Links を使いま
す (@uref{http://artax.karlin.mff.cuni.cz/~mikulas/links/} を参照)。

@item lynx
Lynx を使います (@uref{http://lynx.browser.org/} を参照)。

@item html2text
html2text (シンプルな @sc{html} コンバーター、gnus に含まれている) を使
います。
@end table

@item W b
@kindex W b (概略)
@findex gnus-article-add-buttons
クリックできるボタンを記事に加えます (@code{gnus-article-add-buttons})。
@xref{Article Buttons}.

@item W B
@kindex W B (概略)
@findex gnus-article-add-buttons-to-head
クリックできるボタンを記事のヘッダーに加えま
す (@code{gnus-article-add-buttons-to-head})。

@item W p
@kindex W p (概略)
@findex gnus-article-verify-x-pgp-sig
署名付きコントロールメッセージの認証を行ないま
す (@code{gnus-article-verify-x-pgp-sig})。
@code{newgroup} や @code{checkgroups} といったコントロールメッセージは、
通常そのニュースグループ階層のメインテイナーによって署名されています。認
証を行なうためには、メインテイナーの公開鍵をあなたのキーリングに追加しな
ければなりません。@footnote{多くのニュースグループ階層のメインテイナー
の PGP の鍵は @uref{ftp://ftp.isc.org/pub/pgpcontrol/README.html} から入
手することができます。}

@c @item W s
@c @kindex W s (Summary)
@c @findex gnus-summary-force-verify-and-decrypt
@c Verify a signed (PGP, @sc{pgp/mime} or @sc{s/mime}) message
@c (@code{gnus-summary-force-verify-and-decrypt}). @xref{Security}.

@item W W H
@kindex W W H (概略)
@findex gnus-article-strip-headers-in-body
記事の本体の先頭から @code{X-No-Archive} ヘッダーのようなヘッダーを取り
除きます (@code{gnus-article-strip-headers-in-body})。

@item W E l
@kindex W E l (概略)
@findex gnus-article-strip-leading-blank-lines
記事の始めからのすべての空白行を取り除きま
す (@code{gnus-article-strip-leading-blank-lines})。

@item W E m
@kindex W E m (概略)
@findex gnus-article-strip-multiple-blank-lines
すべての空白行を空行で置き換え、すべての複数の空行を一つの空行で置き換え
ます (@code{gnus-article-strip-multiple-blank-lines})。

@item W E t
@kindex W E t (概略)
@findex gnus-article-remove-trailing-blank-lines
記事の最後のすべての空白行を取り除きま
す (@code{gnus-article-remove-trailing-blank-lines})。

@item W E a
@kindex W E a (概略)
@findex gnus-article-strip-blank-lines
上の三つの命令をすべて行います (@code{gnus-article-strip-blank-lines})。

@item W E A
@kindex W E A (概略)
@findex gnus-article-strip-all-blank-lines
すべての空白行を取り除きます (@code{gnus-article-strip-all-blank-lines})。

@item W E s
@kindex W E s (概略)
@findex gnus-article-strip-leading-space
記事の本体のすべての行の始めからのすべての空白を取り除きま
す (@code{gnus-article-strip-leading-space})。

@item W E e
@kindex W E e (概略)
@findex gnus-article-strip-trailing-space
記事の本文の全ての行の最後から空白を消去しま
す (@code{gnus-article-strip-trailing-space})。
@end table

記事の洗濯を自動的にするための方法は @xref{Customizing Articles} を参照
して下さい。

@node Article Header
@subsection 記事ヘッダー

これらのコマンドは記事ヘッダーをいろいろ変形させます。

@table @kbd
@item W G u
@kindex W G u (概略)
@findex gnus-article-treat-unfold-headers
折り返されたヘッダー行を一行にしま
す (@code{gnus-article-treat-unfold-headers})。

@item W G n
@kindex W G n (概略)
@findex gnus-article-treat-fold-newsgroups
@code{Newsgroups} と @code{Followup-To} ヘッダーを折り返しま
す (@code{gnus-article-treat-fold-newsgroups})。

@item W G f
@kindex W G f (概略)
@findex gnus-article-treat-fold-headers
すべてのメッセージヘッダーを折り返しま
す (@code{gnus-article-treat-fold-headers})。

@item W E w
@kindex W E w (概略)
@findex gnus-article-remove-leading-whitespace
すべてのヘッダーから余計な空白を取り除きま
す (@code{gnus-article-remove-leading-whitespace})。
@end table

@node Article Buttons
@subsection 記事のボタン
@cindex buttons

よく記事の中に他のものへの参照が入れられる事があります。そして、gnus が
それに関する事を、それらの参照の上で @kbd{RET} を打つか、マウスの真中の
ボタンを使う事によって、最小限の努力で取得する事ができれば素敵でしょう。

Gnus はディフォルトで特定の標準の参照に@dfn{ボタン}を付けます: ちゃんと
した URL、メールアドレス、Message-ID です。これは二つの変数によって制御
されていて、その一つは記事の本体を扱い、もう一つは記事のヘッダーを扱いま
す。

@table @code
@item gnus-button-alist
@vindex gnus-button-alist
それぞれの入力要素が次のような様式の連想リストです:

@lisp
(REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@table @var
@item regexp
この正規表現 (regexp) に合致するすべての文は外部参照であるとみなされます。
これは埋め込まれた URL に合致する典型的な正規表現で
す @samp{<URL:\\([^\n\r>]*\\)>}。これはまた正規表現の値を持つ変数であっ
てもよく、有用な変数として @code{gnus-button-url-regexp} があります。

@item button-par
Gnus は合致したもののどの部分がハイライトされるのかを知らなければなりま
せん。これは正規表現のどの副表現がハイライトされるかを指定する番号です。
全てをハイライトしたいのなら、ここで 0 を使ってください。

@item use-p
この式は @code{評価} され、結果が @code{nil} でなければ、これは合致であ
るとみなされます。これは間違った合致を避けるために特別な選別をしたいとき
に役に立ちます。

@item function
この関数 (function) はこのボタンをクリックしたときに呼ばれます。

@item data-par
@var{button-par} のように、これは部分表現の番号ですが、これは合致のどの
部分が @var{function} にデータとして送られるかを指定します。
@end table

ですから、URL をボタンにする完全な入力要素は

@lisp
("<URL:\\([^\n\r>]*\\)>" 0 t gnus-button-url 1)
@end lisp

@item gnus-header-button-alist
@vindex gnus-header-button-alist
それが記事のヘッダーだけに適用され、それぞれの入力要素がどのヘッダーにボ
タン化を適用するかを示す追加の要素がある事を除き、これは他の連想リストと
同じようなものです:

@lisp
(HEADER REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@var{header} は正規表現です。

@item gnus-button-url-regexp
@vindex gnus-button-url-regexp
埋め込まれた URL に合致する正規表現です。それは上の変数のディフォルトの
値で使われます。

@item gnus-article-button-face
@vindex gnus-article-button-face
ボタンに使われるフェイスです。

@item gnus-article-mouse-face
@vindex gnus-article-mouse-face
マウスのカーソルがボタンの上にあるときに使われるフェイスです。
@end table

記事を自動的にボタン化する方法は @xref{Customizing Articles} を参照して
下さい。

@node Article Date
@subsection 記事の日付

日付は聞いた事の無い何か辺鄙な時間帯 (timezone) で作成されている事が良く
あるので、記事が送られたときに何時であったかを知る事ができるのは非常に良
い事でしょう。

@table @kbd
@item W T u
@kindex W T u (概略)
@findex gnus-article-date-ut
UT (別名 GMT, ZULU) で日付を表示します (@code{gnus-article-date-ut})。

@item W T i
@kindex W T i (概略)
@findex gnus-article-date-iso-8601
@cindex ISO 8601
日付を国際的な形式、ISO 8601 で表示しま
す (@code{gnus-article-date-iso8601})。

@item W T l
@kindex W T l (概略)
@findex gnus-article-date-local
日付を利用者の地域の時間帯で表示します (@code{gnus-article-date-local})。

@item W T p
@kindex W T p (概略)
@findex gnus-article-date-english
日付を英語で発音できる形式で表示しま
す (@code{gnus-article-date-english})。

@item W T s
@kindex W T s (概略)
@vindex gnus-article-time-format
@findex gnus-article-date-user
@findex format-time-string
日付を利用者定義の様式を使って表示します (@code{gnus-article-date-user})。
その様式は変数 @code{gnus-article-time-format} で指定され、
@code{format-time-string} に渡される文字列です。様式指定をする事ができる
一覧は変数の説明文を見てください。

@item W T e
@kindex W T e (概略)
@findex gnus-article-date-lapsed
@findex gnus-start-date-timer
@findex gnus-stop-date-timer
記事が投稿されてから今までどれくらいの時間が経過したかを表示しま
す (@code{gnus-article-date-lapsed})。こんなふうに。

@example
X-Sent: 6 weeks, 4 days, 1 hour, 3 minutes, 8 seconds ago
@end example

@code{gnus-article-date-lapsed-new-header} の値でこのヘッダーを既存
の Date の下に追加するか、置き替えるかを指定します。

gnus でメールを読むことの有利な点は、単純なバグを素晴らしい不条理に置き
換えることです。

この行が連続して更新されるようにしたいのであれば、

@lisp
(gnus-start-date-timer)
@end lisp

をあなたの @file{.gnus.el} ファイルに入れるか、何かのフックで実行するよ
うにする事ができます。タイマーを止めたいのであれば、命
令 @code{gnus-stop-date-timer} を使う事ができます。

@item W T o
@kindex W T o (概略)
@findex gnus-article-date-original
本来の日付を表示します (@code{gnus-article-date-original})。これはあなた
が普通は他の変換関数を使っていて、それが完全に間違った事をしているのでは
ないかと心配しているときに役に立ちます。例えば、記事が 1854年に投稿され
たとなっているとしましょう。しかし、そのような事は @emph{完全に }不可能
です。私が信用できませんか? *くすくす(笑)*
@end table

自動的に好む書式で日付を表示する方法は @xref{Customizing Articles} を参
照して下さい。

@node Article Display
@subsection Article Display
@cindex picons
@cindex x-face
@cindex smileys

これらのコマンドは、いろんな取るに足らないギミック (gimmicks) の表示を、
それらをサポートしている Emacs の記事バッファに追加します。

@code{X-Face} ヘッダーは小さな白黒画像で、メッセージヘッダーから供給され
ます (@pxref{X-Face})。

一方 Picon はあなた自身のシステムに依存し、gnus はヘッダーにマッチするあ
なたの持ち物を探してみます (@pxref{Picons})。

スマイリーは、人々がメッセージに散らかしたがる小さな @samp{:-)} シンボル
です。

これらすべての機能はトグルです。もしすでにそれらが存在していたならば、そ
れらは削除されます。

@table @kbd
@item W D x
@kindex W D x (概略)
@findex gnus-article-display-x-face
@code{X-Face} を @code{From} ヘッダーに表示しま
す (@code{gnus-article-display-x-face})。

@item W D s
@kindex W D s (概略)
@findex gnus-treat-smiley
スマイリーを表示します (@code{gnus-treat-smiley})。

@item W D f
@kindex W D f (概略)
@findex gnus-treat-from-picon
@code{From} ヘッダーを Picon 化します (@code{gnus-treat-from-picon})。

@item W D m
@kindex W D m (概略)
@findex gnus-treat-mail-picon
すべてのメールヘッダー (すなわち @code{Cc}、@code{To}) を Picon 化しま
す (@code{gnus-treat-mail-picon})。

@item W D n
@kindex W D n (概略)
@findex gnus-treat-newsgroups-picon
すべてのニュースヘッダー (すなわ
ち @code{Newsgroups} と @code{Followup-To}) を Picon 化しま
す (@code{gnus-treat-newsgroups-picon})。

@item W D D
@kindex W D D (概略)
@findex gnus-article-remove-images
記事バッファからすべての画像を削除しま
す (@code{gnus-article-remove-images})。
@end table

@node Article Signature
@subsection 記事の署名
@cindex signatures
@cindex article signature

@vindex gnus-signature-separator
それぞれの記事は二つの部分に分けられます――見出し (header) と本
体 (body) です。本体は署名部分と文章部分に分けられます。どれが署名とみな
されるかを決める変数は @code{gnus-signature-separator} です。これは普通
は son-of-RFC 1036 で指示されている標準の @samp{^-- $} です。しかし、多
くの人が標準でない署名分離を用いますので、この変数は一つ一つ試される、正
規表現のリストであることもできます。(探索は本体の最後から始めへとなされ
ます。) よくありそうな値は:

@lisp
(setq gnus-signature-separator
      '("^-- $"         ; 標準
        "^-- *$"        ; 普通の壊し方
        "^-------*$"    ; 多くの人は長ーーい横棒の
                        ; 行を使います。あぁ!
        "^ *--------*$" ; 二倍のあぁぁ!
        "^________*$"   ; 下線も人気があります
        "^========*$")) ; 邪道!
@end lisp

あなたが寛容であればあるほど、間違った結果を得る事になるでしょう。

@vindex gnus-signature-limit
@code{gnus-signature-limit} は記事を表示するときにどれが署名とみなされる
かへの制限を提供します。

@enumerate
@item
これが整数であれば、署名はこの整数より (文字で) 長くなっていてはいけませ
ん。
@item
これが浮動小数点数であれば、署名はその数字より (行で) 長くなっていてはい
けません。
@item
これが関数であれば、その関数は引数なしで呼ばれ、それが @code{nil} を返せ
ば、バッファには署名がありません。
@item
これが文字列であれば、それは正規表現として使われます。もしそれが合致すれ
ば、その当の文字列は署名ではありません。
@end enumerate

この変数は要素が上に挙げられた型のリストである事もできます。これは例です:

@lisp
(setq gnus-signature-limit
      '(200.0 "^---*Forwarded article"))
@end lisp

これは署名分離物の後に 200 を超える行か、署名分離物の後の文章が正規表
現 @samp{^---*Forwarded article} に合致すれば、結局それは署名ではないと
いう事です。

@node Article Miscellania
@subsection 記事いろいろ

@table @kbd
@item A t
@kindex A t (概略)
@findex gnus-article-babel
記事をある言語から別のものへ変換しま
す (@code{gnus-article-babel})。
@end table

@c node `MIME Commands' and node `Charsets' is stripped, which is
@c pGnus specific.

@node Article Commands
@section 記事命令

@table @kbd
@item A P
@cindex PostScript
@cindex printing
@kindex A P (概略)
@vindex gnus-ps-print-article
@findex gnus-summary-print-article
記事バッファのポストスクリプト (PostScript) イメージを作成して印刷しま
す (@code{gnus-summary-print-article})。@code{gnus-ps-print-hook} がバッ
ファを印刷する直前に実行されるでしょう。他に、Muttprint を使って印刷する
こともできます (@pxref{Saving Articles})。
@end table

@node Summary Sorting
@section 概略の並び替え
@cindex summary sorting

私はどうしてあなたがそうしたいのかはわからないのですが、それでもあなたは
たくさんの方法で概略バッファを並び替える事ができます。

@table @kbd
@item C-c C-s C-n
@kindex C-c C-s C-n (概略)
@findex gnus-summary-sort-by-number
記事番号によって並び替えます (@code{gnus-summary-sort-by-number})。

@item C-c C-s C-a
@kindex C-c C-s C-a (概略)
@findex gnus-summary-sort-by-author
著者によって並び替えます (@code{gnus-summary-sort-by-author})。

@item C-c C-s C-s
@kindex C-c C-s C-s (概略)
@findex gnus-summary-sort-by-subject
表題によって並び替えます (@code{gnus-summary-sort-by-subject})。

@item C-c C-s C-d
@kindex C-c C-s C-d (概略)
@findex gnus-summary-sort-by-date
日付によって並び替えます (@code{gnus-summary-sort-by-date})。

@item C-c C-s C-l
@kindex C-c C-s C-l (概略)
@findex gnus-summary-sort-by-lines
行によって並び替えます (@code{gnus-summary-sort-by-lines})。

@item C-c C-s C-c
@kindex C-c C-s C-c (概略)
@findex gnus-summary-sort-by-chars
記事の長さで並び替えます (@code{gnus-summary-sort-by-chars})。

@item C-c C-s C-i
@kindex C-c C-s C-i (概略)
@findex gnus-summary-sort-by-score
スコアによって並び替えます (@code{gnus-summary-sort-by-score})。

@item C-c C-s C-r
@kindex C-c C-s C-r (Summary)
@findex gnus-summary-sort-by-random
ランダムに並び替えます (@code{gnus-summary-sort-by-random})。

@item C-c C-s C-o
@kindex C-c C-s C-o (概略)
@findex gnus-summary-sort-by-original
ディフォルトの方法で並び替えます (@code{gnus-summary-sort-by-original})。
@end table

これらの関数はスレッドを使っているときと使っていないときの両方で動作しま
す。後者の場合は、すべての概略行が一行一行並び替えられます。前者の場合は、
根本と根本を基本として並び替えられ、それはあなたが求めている事とは異
なっているかもしれません。スレッドを使う事を切り替えるには @kbd{T T} を
打ってください (@pxref{Thread Commands})。

@node Finding the Parent
@section 親記事を探す
@cindex parent articles
@cindex referring articles

@table @kbd
@item ^
@kindex ^ (概略)
@findex gnus-summary-refer-parent-article
現在の記事の親記事を読みたくて、それが概略バッファに表示されていないくて
も、おそらくそれは可能でしょう。というのは、現在のグループ
が @sc{nntp} で取得されていて、親がまだ期限消去されていない上、現在の記
事の @code{References} がぶち壊されていなければ、ただ、
@kbd{^} か @kbd{A r} を押せば良いだけで
す (@code{gnus-summary-refer-parent-article})。もし全てが上手く行けば、
親記事を取得できるでしょう。もし親記事が既に概略バッファに表示されている
のであれば、ポイントがその記事に移動するでしょう。

正の数値接頭引数を与えられれば、祖先まで多くの記事を戻って取得します。負
の数字接頭引数が与えられれば、その祖先の記事だけを取得します。ですから、
@kbd{3 ^} とすれば、gnus は現在の記事の親と、祖父母と、曾祖父母を取得し
ます。@kbd{-3 ^} とすれば、gnus は現在の記事の曾祖父母だけを取得します。

@item A R (概略)
@findex gnus-summary-refer-references
@kindex A R (概略)
記事の @code{References} 欄にある全ての記事を取得しま
す (@code{gnus-summary-refer-references})。

@item A T (概略)
@findex gnus-summary-refer-thread
@kindex A T (概略)
現在の記事が出てきているスレッドの、完全なスレッドを表示しま
す (@code{gnus-summary-refer-thread})。この命令は動作するために現在のグ
ループのすべてのヘッダーを取得しなければなりませんので、普通は少し時間が
かかります。もし、これをしばしば行うのであれば、
@code{gnus-fetch-old-headers} を @code{invisible} に設定することを考えた
ほうが良いでしょう (@pxref{Filling In Threads})。これは普通は視覚的な効
果はありませんが、この命令の動作をかなり速くするでしょう。もちろん、グルー
プに入るのは少し遅くなります。

@vindex gnus-refer-thread-limit
変数 @code{gnus-refer-thread-limit} はこの命令を実行するときにどのくらい
古い (すなわち、現在の記事で最初に表示されたよりも前の記事) ヘッダーを取
得するかを指定します。ディフォルトは 200 です。もし @code{t} であれば、
取得可能なすべてのヘッダーを取得します。この変数は命令 @code{A T} に数値
接頭引数を与える事により上書きする事ができます。

@item M-^ (概略)
@findex gnus-summary-refer-article
@kindex M-^ (概略)
@cindex Message-ID
@cindex fetching by Message-ID
どのグループに属しているかに関わらず、任意の記事を @sc{nntp} サーバーに
尋ねる事ができます。
@kbd{M-^} (@code{gnus-summary-refer-article}) は @code{Message-ID}、それ
はあの長く、なかなか読む事のできな
い @samp{<38o6up$6f2@@hymir.ifi.uio.no>} のような参照をあなたに尋ねます。
あなたはすべてを正確に打ち込まなければなりません。残念ながら、あいまいな
検索はできないのです。
@end table

ニュースでない選択方法から @code{Message-ID} で取得するときには現在の選
択方法が使われますが、この命令に接頭引数を与える事でこれを上書きする事が
できます。

@vindex gnus-refer-article-method
もしあなたの読んでいるグループが @code{Message-ID} での取得があまり良く
できないようなグループ (@code{nnspool} など) である場合、
@code{gnus-refer-article-method} を @sc{nntp} に設定する事ができます。お
そらく、あなたが会話している @sc{nntp} サーバーがあなたの読んでいるスプー
ルを更新していると非常に良いでしょう。しかし、それはどうしても必要なわけ
ではありません。

それは選択方法のリストであることもでき、特別なシンボル @code{current} で
あることもできます。後者は、現在の選択方法を使うという意味です。リストの
場合は、gnus は合うものを発見するまでリストの全ての方法を試します。

これは現在の方法を試して、それが失敗した場合には Google に訊く設定の例で
す:

@lisp
(setq gnus-refer-article-method
      '(current
        (nnweb "refer" (nnweb-type google))))
@end lisp

ほとんどのメールバックエンドは @code{Message-ID} での取得が可能ですが、
あまり優雅な方法でやっているわけではありません。@code{nnmbox},
@code{nnbabyl} および @code{nnmaildir} はどのグループからの記事も位置を
得ることができますが、@code{nnml}, @code{nnfolder} およ
び @code{nnimap} は現在のグループに投稿した記事の位置しか得る事ができま
せん。(その他のものは時間がかかりすぎます。) @code{nnmh} では全く不可能
です。

@node Alternative Approaches
@section 代替手段

違った人は違った方法を使ってニュースを読もうとします。これは gnus でもそ
うであるので、我々は概略バッファーのためのマイナーモード (minor mode) に
少しの選択肢を与えてあります。

@menu
* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動-復号化する
@end menu

@node Pick and Read
@subsection 選んで読む
@cindex pick and read

いくつかのニュースリーダー (@code{nn} や、あのぉ、VM/CMS で
の @code{Netnews} など) は二相の読むための界面を使います。利用者はまず概
略バッファで読みたい記事に印を付けます。それから、記事バッファだけを表示
して記事を読みます。

@vindex gnus-pick-mode
@kindex M-x gnus-pick-mode
Gnus はこれをするための概略バッファマイナーモードを提供します――
@code{gnus-pick-mode} です。これは基本的には簡単に印を付けられるように少
しのプロセス印命令が一打鍵命令になり、概略バッファへ切り替えるための追加
命令を一つ提供します。

これが pick mode を使ったときに使用可能なキーです:

@table @kbd
@item .
@kindex . (選択)
@findex gnus-pick-article-or-thread
現在の行の記事かスレッドを選択しま
す (@code{gnus-pickd-article-or-thread})。もし変
数 @code{gnus-thread-hide-subtree} が true であれば、このキーはスレッド
の最初の記事で使われたときはスレッド全体を選択します。そうでなければ、そ
れはその記事だけを選択します。もし数値接頭引数を与えられればそのスレッド
か記事へと生んでいき、それを選択します。(行数は普通は概略選択行の最初に
表示されています。)

@item SPACE
@kindex SPACE (選択)
@findex gnus-pick-next-page
概略バッファを一ページ次にスクロールします (@code{gnus-pick-next-page})。
もしバッファの最後であれば、選択記事を読み始めます。

@item u
@kindex u (選択)
@findex gnus-pick-unmark-article-or-thread
スレッドか記事を未選択にしま
す (@code{gnus-pick-unmark-article-or-thread})。変
数 @code{gnus-thread-hide-subtree} が true であれば、このキーはスレッド
の最初で使われればスレッドを未選択にします。そうでない場合はそれは記事だ
けを未選択にします。その行にあるスレッドか記事を未選択にするためにこのキー
に数値接頭引数を与える事ができます。

@item RET
@kindex RET (選択)
@findex gnus-pick-start-reading
@vindex gnus-pick-display-summary
選択された記事を読み始めます (@code{gnus-pick-start-reading})。接頭引数
を与えられれば、まずすべての未選択記事に既読の印を付けます。
@code{gnus-pick-display-summary} が @code{nil} でないと、概略バッファは
読んでいる間も表示されます。
@end table

全ての普通の概略モード命令は選択モード (pick-mode)でも使用可能ですが、
@kbd{u} は例外です。しかし、同じ関
数 @code{gnus-summary-tick-article-forward} に割り当てられてい
る @kbd{!} を使う事ができます。

これが良い考えだと思うのであれば、次のようにする事ができます:

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@vindex gnus-pick-mode-hook
@code{gnus-pick-minor-mode-hook} は pick マイナーモードバッファで実行さ
れます。

@vindex gnus-summary-pick-line-format
pick モードでの概略行の様式は標準の様式とは少し違います。それぞれの行の
最初に行数が表示されます。Pick モードの行の様式は変
数 @code{gnus-summary-pick-line-format} で制御されま
す (@pxref{Formatting Variables})。これ
は @code{gnus-summary-line-format} と同じ様式指定を受け付けま
す (@pxref{Summary Buffer Lines})。

@node Binary Groups
@subsection バイナリーグループ
@cindex binary groups

@findex gnus-binary-mode
@kindex M-x gnus-binary-mode
もし多くの時間をバイナリーグループ (binary group) で過ごしているのなら、
いつも @kbd{X u}, @kbd{n}, @kbd{RET} を叩くのが嫌になっているでしょう。
@kbd{M-x gnus-binary-mode} は記事を普通の方法で表示する代わりに、普通
の gnus の記事選択関数を記事群を uudecode しその結果を表示するように変更
する、概略バッファのためのマイナーモードです。

@kindex g (バイナリー)
@findex gnus-binary-show-article
実際は、このモードにしたときに、現実の記事を見るための唯一の命令
が @kbd{g} です (@code{gnus-binary-show-article})。

@vindex gnus-binary-mode-hook
@code{gnus-binary-mode-hook} がバイナリーマイナーモードバッファで呼ばれ
ます。

@node Tree Display
@section 木表示
@cindex trees

@vindex gnus-use-trees
もし普通の gnus の概略表示を好きでないならば、
@code{gnus-use-trees} を @code{t} に設定してみると良いかもしれません。こ
れは (ディフォルトで) 追加の @dfn{木バッファ} (tree buffer) を作成します。
木バッファではすべての概略モード命令を実行する事ができます。

もちろん、木表示をカスタマイズする変数が少しあります:

@table @code
@item gnus-tree-mode-hook
@vindex gnus-tree-mode-hook
すべての木モードバッファで実行されるフックです。

@item gnus-tree-mode-line-format
@vindex gnus-tree-mode-line-format
木モードバッファでのモード行のためのフォーマット文字列です (@pxref{Mode
Line Formatting})。ディフォルトは @samp{Gnus: %%b %S %Z} です。使用可能
な指定は @pxref{Summary Buffer Mode Line} を参照してください。

@item gnus-selected-tree-face
@vindex gnus-selected-tree-face
木バッファで選択された記事をハイライトするために使われるフェイスです。ディ
フォルトでは @code{modeline} です。

@item gnus-tree-line-format
@vindex gnus-tree-line-format
木の節のためのフォーマット文字列です。でもこの名前は少し誤った名称で
す――それは行ではなく、ただ節を定義するだけです。ディフォルトの値
は @samp{%(%[%3,3n%]%)} で、それは投稿者の名前の最初の三文字を表示します。
すべての節が同じ長さであるのは重要ですので、@samp{%4,4n} のような指定
を @emph{使わなければならない} のです。

有効な指定は:

@table @samp
@item n
投稿者の名前。
@item f
@code{From} 欄。
@item N
記事の番号。
@item [
開き括弧。
@item ]
閉じ括弧。
@item s
表題。
@end table

@xref{Formatting Variables}。

表示に関連した変数は:

@table @code
@item gnus-tree-brackets
@vindex gnus-tree-brackets
これは『本当の』記事と『まばら記事』に違いを付けるために使われます。様式
は @code{((@var{本当の開} . @var{本当の閉}) (@var{まばら開} . @var{まばら閉}) (@var{偽の開} . @var{偽の閉}))} と
なっていて、ディフォルト
は @code{((?[ . ?]) (?( . ?)) (?@{ . ?@}) (?< . ?>))} です。

@item gnus-tree-parent-child-edges
@vindex gnus-tree-parent-child-edges
これは親の節を子に接続するために使われる文字を含んだリストです。ディフォ
ルトは @code{(?- ?\\ ?|)} です。
@end table

@item gnus-tree-minimize-window
@vindex gnus-tree-minimize-winodw
もしこの変数が @code{nil} でないと、他の gnus ウィンドウがもっと場所を取
れるように gnus は木バッファをできるだけ小さくします。もしこの変数が数字
であると、木バッファはその数字より大きくなる事はありません。ディフォルト
は @code{t} です。フレームでいくつかのウィンドウが横に並んで表示されてい
て、木バッファがそのうちの一つである場合、木ウィンドウを最小化することは
その隣に表示されているすべてのウィンドウの大きさを変更する事に注意してく
ださい。

以下のフックを追加して、いつでも木ウィンドウを最小化しても良いでしょう。

@lisp
(add-hook 'gnus-configure-windows-hook
          'gnus-tree-perhaps-minimize)
@end lisp

@item gnus-generate-tree-function
@vindex gnus-generate-tree-function
@findex gnus-generate-horizontal-tree
@findex gnus-generate-vertical-tree
実際にスレッドの木を作成する関数です。二つの既定義の使用可能な関数
は: @code{gnus-generate-horizontal-tree} と @code{gnus-generate-vertical-tree} (こ
れがディフォルトです) です。
@end table

水平木バッファ (horizontal tree buffer) の例です:

@example
@{***@}-(***)-[odd]-[Gun]
     |      \[Jan]
     |      \[odd]-[Eri]
     |      \(***)-[Eri]
     |            \[odd]-[Paa]
     \[Bjo]
     \[Gun]
     \[Gun]-[Jor]
@end example

同じスレッドが垂直木バッファ (vertical tree buffer) で表示されたものです:

@example
@{***@}
  |--------------------------\-----\-----\
(***)                         [Bjo] [Gun] [Gun]
  |--\-----\-----\                          |
[odd] [Jan] [odd] (***)                   [Jor]
  |           |     |--\
[Gun]       [Eri] [Eri] [odd]
                          |
                        [Paa]
@end example

もし水平木を使っているのなら、概略バッファで木を隣り合わせで表示できれば
嬉しいでしょう。次のようなものをファイル @file{.gnus.el} に加える事がで
きます:

@lisp
(setq gnus-use-trees t
      gnus-generate-tree-function 'gnus-generate-horizontal-tree
      gnus-tree-minimize-window nil)
(gnus-add-configuration
 '(article
   (vertical 1.0
             (horizontal 0.25
                         (summary 0.75 point)
                         (tree 1.0))
             (article 1.0))))
@end lisp

@xref{Window Layout}。

@node Mail Group Commands
@section メールグループ命令
@cindex mail group commands

いくつかの命令はメールグループのみで意味を持ちます。これらの命令が現在の
グループで有効でないなら、それらは大騒ぎをしてあなたに知らせるでしょう。

すべてのこれらの命令は (期限削除と編集命令は除く) プロセス/接頭引数の習
慣を使います (@pxref{Process/Prefix})。

@table @kbd
@item B e
@kindex B e (概略)
@findex gnus-summary-expire-articles
現在のグループのすべての期限削除可能な記事について、期限削除の処
理 (@code{gnus-summary-expire-articles}) を行ないます。これは、そのグルー
プにしばらく存在していた期限切れ削除可能なすべての記事を消去するというこ
とです。(@pxref{Expiring Mail})。

@item B C-M-e
@kindex B C-M-e (概略)
@findex gnus-summary-expire-articles-now
グループのすべての期限削除可能な記事を削除しま
す (@code{gnus-summay-expire-articles-now})。これは現在のグループの該当
する @strong{全て}の期限削除記事は永遠に空の大きな @file{/dev/null} へ消
え去るという事です。

@item B DEL
@kindex B DEL (概略)
@findex gnus-summary-delete-article
@c @icon{gnus-summary-mail-delete}
メール記事を削除します。これは『あなたのディスクから今から永遠に削除して、
二度と戻らない』の『削除』です。注意して使ってくださ
い (@code{gnus-summary-delete-article})。

@item B m
@kindex B m (概略)
@cindex move mail
@findex gnus-summary-move-article
@vindex gnus-preserve-marks
あるメールグループから別のところへ記事を移動しま
す (@code{gnus-summary-move-article})。@code{gnus-preserve-marks} の値
が nil ではないならば (これが初期値ですが)、マークは保存されます。

@item B c
@kindex B c (概略)
@cindex copy mail
@findex gnus-summary-copy-article
@c @icon{gnus-summary-mail-copy}
あるグループ (メールグループや他のもの) からメールグループに記事を複製し
ます (@code{gnus-summary-copy-article})。@code{gnus-preserve-marks} の値
が nil ではないならば (これが初期値ですが)、マークは保存されます。

@item B B
@kindex B B (概略)
@cindex crosspost mail
@findex gnus-summary-crosspost-article
現在の記事を他のグループにクロスポストしま
す (@code{gnus-summary-crosspost-article})。これは他のグループ記事の新し
い複製を作成し、記事の Xref 欄も適切に更新されます。

@item B i
@kindex B i (概略)
@findex gnus-summary-import-article
任意のファイルを現在のメールグループに取り込みま
す (@code{gnus-summary-import-article})。あなたはファイル名と、
@code{From} 欄と @code{Subject} 欄の入力を促されます。

@item B I
@kindex B I (概略)
@findex gnus-summary-create-article
空の記事を現在のメールグループに作りま
す (@code{gnus-summary-create-article})。@code{From} ヘッダー
と @code{Subject} ヘッダーの内容を尋ねられます。

@item B r
@kindex B r (概略)
@findex gnus-summary-respool-article
メール記事をスプールし直します (@code{gnus-summary-move-article})。
@code{gnus-summary-respool-default-method} が再スプールするときのディフォ
ルトの選択方法として使用されます。この変数はディフォルトで @code{nil} で、
これは現在のグループの選択方法が代わりに使われるという事です。
@code{gnus-preserve-marks} の値が nil ではないならば (これが初期値です
が)、マークは保存されます。

@item B w
@itemx e
@kindex B w (概略)
@kindex e (概略)
@findex gnus-summary-edit-article
@kindex C-c C-c (記事)
@findex gnus-summary-edit-article-done
現在の記事を編集します (@code{gnus-summary-edit-article})。編集を終了し
て変更を永遠にするため
に @kbd{C-c C-c} (@code{gnus-summary-edit-article-done}) を打ちます。も
し命令 @kbd{C-c C-c} に数値接頭引数を与えると、gnus は記事を再ハイライト
しません。

@item B q
@kindex B q (概略)
@findex gnus-summary-respool-query
もし記事を再スプールしたいときは、再スプールをする前にどのグループに記事
が移るかに興味があるでしょう。この命令でそれがわかりま
す (@code{gnus-summary-respool-query})。

@item B t
@kindex B t (概略)
@findex gnus-summary-respool-trace
同様に、この命令は再溜め込みをするときに使われた全ての特級分割方式を、も
しそれがあれば表示します (@code{gnus-summary-respool-trace})。

@item B p
@kindex B p (概略)
@findex gnus-summary-article-posted-p
一部の人はあなたの投稿へのフォローアップをするときに、『親切な』複製を送
る傾向があります。これらは普通はそこに @code{Newsgroups} 欄が付いている
のですが、いつもそうであるとは限りません。この命
令 (@code{gnus-summary-article-posted-p}) は現在の記事をあなたのニュース
サーバーから (というよりは、むし
ろ @code{gnus-refer-article-method} や @code{gnus-select-method} か
ら) 取得しようとし、記事を発見できたかどうかを報告します。それが記事を発
見しなかったとしても、それはとにかく投稿されているかもしれません――メー
ルの伝達はニュースの伝達よりもずっと速く、ニュースの複製がまだ到着してい
ないだけかもしれないのです。

@c @item K E
@c @kindex K E (Summary)
@c @findex gnus-article-encrypt-body
@c @vindex gnus-article-encrypt-protocol
@c Encrypt the body of an article (@code{gnus-article-encrypt-body}).
@c The body is encrypted with the encryption protocol specified by the
@c variable @code{gnus-article-encrypt-protocol}.
@end table

@vindex gnus-move-split-methods
@cindex moving articles
もし、規則的に記事を移動 (もしくは複製) するのであれば、gnus に記事をど
こに入れれば良いか提案させたいと思うでしょう。
@code{gnus-move-split-methods} は @code{gnus-split-methods} と同じ構文を
使う変数です (@pxref{Saving Articles})。あなたが妥当だと思うような提案を
するようにその変数をカスタマイズする事ができます。
(@code{gnus-split-methods} がファイル名を使うのに対し
て @code{gnus-move-split-methods} はグループ名を使うことに注意して下さ
い。)

@lisp
(setq gnus-move-split-methods
      '(("^From:.*Lars Magne" "nnml:junk")
        ("^Subject:.*gnus" "nnfolder:important")
        (".*" "nnml:misc")))
@end lisp

@node Various Summary Stuff
@section いろいろな概略の物件

@menu
* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::  
* Really Various Summary Commands::  あのやっかいな他に適合しない命令
@end menu

@table @code
@vindex gnus-summary-mode-hook
@item gnus-summary-mode-hook
概略モードバッファを作成するときにこのフックが呼ばれます。

@vindex gnus-summary-generate-hook
@item gnus-summary-generate-hook
これはスレッド作成と概略バッファ作成の前に実行する最後のものとして呼ばれ
ます。これはニュースグループの持っているデータに基づいてスレッドの変数を
カスタマイズするために非常に便利です。このフックはほとんどの概略バッファ
変数が設定された後に呼ばれます。

@vindex gnus-summary-prepare-hook
@item gnus-summary-prepare-hook
それは概略バッファが作成された後に呼ばれます。例えば、それは何か他の邪悪
な方法で行をハイライトしたり、バッファの見え方を修正したりするのに使った
りするかも知れません。

@vindex gnus-summary-prepared-hooi
@item gnus-summary-prepared-hook
概略バッファが作成された後で一番最後に呼ばれるフックです。

@vindex gnus-summary-ignore-duplicates
@item gnus-summary-ignore-duplicates
Gnus が同じ @code{Message-ID} を持つ二つの記事を発見したときは、何か思い
切った事をしなければなりません。別の記事が同じ @code{Message-ID} を持つ
事は許されていませんが、それは何らかの出所からメールを読んでいるときに起
こるかもしれません。Gnus はこの変数によって何が起こるかをカスタマイズで
きるようになっています。もしそれが @code{nil} (これがディフォルトで
す) であれば、gnus は @code{Message-ID} を付け替えて (表示のためだけ
に) 記事を他の記事と同じように表示します。この変数が @code{t} であると、
それは記事を表示しません---最初から存在しなかったかのように。

@vindex gnus-alter-articles-to-read-function
@item gnus-alter-articles-to-read-function
この変数に設定した関数で、選択する記事のリストを変更することができます。
関数は二つの引数 (グループ名と選択する記事のリスト) を受け付けます。

例えば以下の関数は、キャッシュ記事のリストをあるグループのリストだけに追
加します。

@lisp
(defun my-add-cached-articles (group articles)
  (if (string= group "some.group")
      (append gnus-newsgroup-cached articles)
    articles))
@end lisp

@vindex gnus-newsgroup-variables
@item gnus-newsgroup-variables
ニュースグループ (その概略バッファの) のローカル変数、または変数とそれら
のディフォルト値 (ディフォルト値が nil でない場合) の cons セルのリスト
で、その概略バッファが活きている間はグローバル変数になります。これらの変
数は、別のバッファでそれら (グループパラメータ) の効果が変更されていても、
(そのグループの) グループパラメータの変数を設定するために使うことができ
ます。例です:

@lisp
(setq gnus-newsgroup-variables
     '(message-use-followup-to
       (gnus-visible-headers .
         "^From:\\|^Newsgroups:\\|^Subject:\\|^Date:\\|^To:")))
@end lisp
@end table

@node Summary Group Information
@subsection 概略グループ情報

@table @kbd
@item H f
@kindex H f (概略)
@findex gnus-summary-fetch-faq
@vindex gnus-grou-faq-directory
現在のグループの FAQ (frequently asked questions (頻繁にされる質問) のリ
スト) を取得しようとします (@code{gnus-summary-fetch-faq})。Gnus は普通
は遠隔マシンのディレクトリである @code{gnus-group-faq-directory} か
ら FAQ を取得しようとします。この変数はディレクトリーのリストである事も
できます。その場合は、この命令に接頭引数を与える事でいろいろなサイ
ト (site) から選ぶ事ができます。おそらく @code{ange-ftp} もしく
は @code{efs} がファイルの取得に使われるでしょう。

@item H d
@kindex H d (概略)
@findex gnus-summary-describe-group
現在のグループに関する短い記述を与えま
す (@code{gnus-summary-describe-group})。接頭引数が与えられると、サーバー
から強制的に記述の再読み込みをします。

@item H h
@kindex H h (概略)
@findex gnus-summary-describe-briefly
最重要概略打鍵の非常に短い記述を与えま
す (@code{gnus-summary-describe-briefly})。

@item H i
@kindex H i (概略)
@findex gnus-info-find-node
Gnus の info の節 (node) に移動します (@code{gnus-info-find-node})。
@end table

@node Searching for Articles
@subsection 記事を探す

@table @kbd
@item M-s
@kindex M-s (概略)
@findex gnus-summary-search-article-forward
直後にある全ての (生の) 記事を正規表現で検索しま
す (@code{gnus-summary-search-article-forward})。

@item M-r
@kindex M-r (概略)
@findex gnus-summary-search-article-backward
前にある全ての (生の) 記事を正規表現で検索しま
す (@code{gnus-summary-search-article-backward})。

@item &
@kindex & (概略)
@findex gnus-summary-execute-command
この命令はあなたにヘッダー部分とその部分に合致する正規表現、合致した場合
に実行される命令の入力を促進します (@code{gnus-summary-execute-command})。
もしヘッダーが空文字列ならば、記事全体を探します。もし接頭引数を与えられ
れば、代わりに後ろ向きに探します。

例えば @kbd{& RET 文字列 #} は、ヘッダーか本文に @samp{文字列} を持つす
べての記事にプロセス印を付けます。

@item M-&
@kindex M-& (概略)
@findex gnus-summary-universal-argument
プロセス印によって印付けられた全ての記事の操作を実行しま
す (@code{gnus-summary-universal-argument})。
@end table

@node Summary Generation Commands
@subsection 概略生成命令

@table @kbd
@item Y g
@kindex Y g (概略)
@findex gnus-summary-prepare
現在の概略バッファを再作成します (@code{gnus-summary-prepare})。

@item Y c
@kindex Y c (概略)
@findex gnus-summary-insert-cached-articles
全ての (現在のグループに) キャッシュされた記事 を概略バッファに挿入しま
す (@code{gnus-summary-insert-cached-articles})。
@end table

@node Really Various Summary Commands
@subsection 本当にいろいろな概略命令

@table @kbd
@item A D
@itemx C-d
@kindex C-d (概略)
@kindex A D (概略)
@findex gnus-summary-enter-digest-group
もし現在のグループが他の記事の集まりであるならば (例えば、摘要 (digest))、
そのような記事でできているグループに入るためにこの命令を使うかもしれませ
ん(@code{gnus-summary-enter-digest-group})。Gnus はこの命令に接頭引数を
与えない限り、どのような型の記事が現在表示されているかを推測しようとし、
それは強制的に『摘要』という解釈になります。基本的に、他の様式からなる他
のメッセージの集合であったときは、@kbd{C-d} とすることによりもっと便利な
方法でそれらのメッセージを読む事ができるようになります。

@item C-M-d
@kindex C-M-d (概略)
@findex gnus-summary-read-document
この命令は上のものに非常に似ていますが、いくつかの文書を一つの大ーきいグ
ループに集めます (@code{gnus-summary-read-read-document})。それはいくつ
かの @code{nndoc} グループをそれぞれの文書のために 開き、それからこれら
の @code{nndoc} グループの上に @code{nnvirtual} グループを開く事によって
この事を可能にしています。この命令はプロセス/接頭引数の習慣を理解しま
す (@pxref{Process/Prefix})。

@item C-t
@kindex C-t (概略)
@findex gnus-summary-togle-truncation
概略行の切断を切り替えます (@code{gnus-summary-toggle-truncation})。これ
はおそらく概略バッファの行中央表示関数を混乱させますので、記事を読んでい
る間に切断を切っているのは良い考えではないでしょう。

@item =
@kindex = (概略)
@findex gnus-summary-expand-window
概略バッファのウィンドウを拡大しま
す (@code{gnus-summary-expand-window})。接頭引数を与えられれば、
@code{記事} ウィンドウを拡大します。

@item C-M-e
@kindex C-M-e (概略)
@findex gnus-summary-edit-parameters
現在のグループのグループの媒介変数 (parameter) (@pxref{Group
Parameters}) を編集します (@code{gnus-summary-edit-parameters})。

@item C-M-a
@kindex C-M-a (概略)
@findex gnus-summary-customize-parameters
現在のグループのグループパラメータ (@pxref{Group Parameters}) をカスタマ
イズします (@code{gnus-summary-customize-parameters})。
@end table

@node Exiting the Summary Buffer
@section 概略バッファを抜ける
@cindex summary exit
@cindex exiting groups

普通は概略バッファから抜けると、グループの全ての情報を更新してグループバッ
ファに戻ります。

@table @kbd
@item Z Z
@itemx q
@kindex Z Z (概略)
@findex q (概略)
@findex gnus-summary-exit
@vindex gnus-summary-exit-hook
@vindex gnus-summary-prepare-exit-hook
@c @icon{gnus-summary-exit}
現在のグループを出て、グループの全ての情報を更新しま
す (@code{gnus-summary-exit})。抜け出るためのたいていの事をする前
に @code{gnus-summary-prepare-exit-hook} が呼ばれ、それはディフォルト
で @code{gnus-summary-expire-articles} を呼びます。抜け出る過程を追えた
後に @code{gnus-summary-exit-hook} が呼ばれます。(未読の) グループが残っ
ていないときにグループモードに戻るとき
に @code{gnus-group-no-more-groups-hook} が実行されます。

@item Z E
@itemx Q
@kindex Z E (概略)
@findex Q (概略)
@findex gnus-summary-exit-no-update
グループのどの情報も更新せずに現在のグループを抜け出ま
す (@code{gnus-summary-exit-no-update})。

@item Z c
@itemx c
@kindex Z c (概略)
@kindex c (概略)
@findex gnus-summary-catchup-and-exit
@c @icon{gnus-summary-catchup-and-exit}
グループの全ての保留でない記事 (unticked article) に既読の印を付けて、そ
れから抜けます (@code{gnus-summary-catchup-and-exit})。

@item Z C
@kindex Z C (概略)
@findex gnus-summary-catchup-all-and-exit
保留記事も含めて、全ての記事に既読の印を付けて、それから抜けま
す (@code{gnus-summary-catchup-all-and-exit})。

@item Z n
@kindex Z n (概略)
@findex gnus-summary-catchup-and-goto-next-group
全ての記事に既読の印を付けて次のグループへ移動しま
す (@code{gnus-summary-catchup-and-goto-next-group})。

@item Z R
@kindex Z R (概略)
@findex gnus-summary-reselect-current-group
現在のグループを出て、それから入り直しま
す (@code{gnus-summary-reselect-current-group})。もし接頭引数を与えられ
れば、既読と未読の両方の全ての記事を選択します。

@item Z G
@itemx M-g
@kindex Z G (概略)
@kindex M-g (概略)
@findex gnus-summary-rescan-group
@c @icon{gnus-summary-mail-get}
グループを抜け、グループの新しい記事を調べ、グループを選択しま
す (@code{gnus-summary-rescan-group})。もし接頭引数を与えられれば、既読
と未読の両方の全ての記事を選択します。

@item Z N
@kindex Z N (概略)
@findex gnus-summary-next-group
グループを抜けて、次のグループへ移動しま
す (@code{gnus-summary-next-group})。

@item Z P
@kindex Z P (概略)
@findex gnus-summary-prev-group
グループを抜けて、前のグループへ移動しま
す (@code{gnus-summary-prev-group})。

@item Z s
@kindex Z s (概略)
@findex gnus-summary-save-newsrc
現在の既読/印付き記事の数をドリブルバッファ (dribble buffer) に保存し、
それからドリブルバッファを保存します (@code{gnus-summary-save-newsrc})。
もし接頭引数を与えられれば、ファイル @file{.newsrc} も保存します。この命
令を使うと、更新なしで抜け出る事 (@kbd{Q} 命令) は意味が無くなります。
@end table

@vindex gnus-exit-group-hook
現在のグループを、グループの全ての情報を更新して抜けるとき
に @code{gnus-exit-group-hook} が呼ばれます。
@kbd{Q} 命令 (@code{gnus-summary-exit-no-update}) では、このフックを呼び
ません。

@findex gnus-summary-wake-up-the-dead
@findex gnus-dead-summary-mode
@vindex gnus-kill-summary-on-exit
あなたにグループを抜けて、それから考えを変える癖があるのであれば、
@code{gnus-kill-summary-on-exit} を @code{nil} に設定するのが良いかもし
れません。もしそうすれば、gnus はそれから抜け出るときに概略バッファを削
除しません。(何という驚き!) その代わりに、それはバッファの名前
を @samp{*Dead Summary ... *} のようなものに変更し、
@code{gnus-dead-summary-mode} と呼ばれるマイナーモードを導入します。今や、
そのバッファに切り替えれば、全てのキーが関
数 @code{gnus-summary-wake-up-the-dead} に割り当てられていることに気付く
でしょう。死んだ概略バッファ (dead summary buffer) でどれかのキーを叩く
事と、生きた普通の概略バッファになるでしょう。

死んだ概略バッファは同時に一つしか存在する事はできません。

@vindex gnus-use-cross-reference
概略バッファを抜け出ると、現在のグループのデータは更新されます (どの記事
を読んで、どの記事に返答したか、などなど。) もし変
数 @code{gnus-use-cross-reference} が @code{t} であると (それがディフォ
ルトです)、そのグループに相互参照された (cross referenced) 記事は既読の
印が付き、それが相互投稿 (cross post) された他の購読しているグループでも
既読の印が付きます。この変数が @code{nil} でも @code{t} でなければ、記事
は購読と未購読の両方のグループで既読の印が付きま
す (@pxref{Crosspost Handling})。

@node Crosspost Handling
@section 相互投稿の扱い

@cindex velveeta
@cindex spamming
相互投稿 (cross post) された記事に既読の印を付ける事は、同じ記事を二回以
上読まないですむという事を保証します。もちろん、だれかがそれをいくつかの
グループに別々に投稿しない限りは。同じ記事をいくつかのグループに投稿する
事 (相互投稿でなくて) は @dfn{spamming} と呼ばれ、あなたはそのような憎む
べき犯罪を行うものにに対して、法律によって不快な記事を送ることが義務づけ
られています。spam を選別するために、NoCeM 取扱を試したいと思うかもしれ
ません (@pxref{NoCeM})。

覚えてください: 相互投稿は構いませんが、同じ記事を別々にいくつかのグルー
プに投稿するのは許されません。大量の相互投稿 (@dfn{velveeta}) はどうして
も避けられるべきで、過剰相互投稿に対して不満を言うために命
令 @code{gnus-summary-mail-crosspost-complaint} を使うことさえできます。

@cindex cross-posting
@cindex Xref
@cindex @sc{nov}
相互投稿を gnus が正しく扱えないようになる原因の一つは、@sc{nov} 行
に @code{Xref} 欄を含まない、@sc{xover} (これは非常に良いです、というの
はそれは速度をとても速くするからです) の使用可能な @sc{nntp} サーバーを
使っていることです。これは害悪なのですが、あぁ、悲しいかな、非常に良くあ
る事です。Gnus はあなたが読んだ全ての記事に @code{Xref} 行を登録する事で、
正しい事をしよう としますが、記事を削除するか、読まないで既読の印を付け
ると、gnus はこれらの記事に @code{Xref} の行をのぞきまわる機会を得る事が
無く、相互参照機構を用いる事ができません。

@cindex LIST overview.fmt
@cindex overview.fmt
あなたの @sc{nntp} サーバーがその概観ファイ
ル (overview file) に @code{Xref} 欄を含んでいるかを調べるには、
@samp{telnet your.nntp.server nntp} として、@code{inn} サーバー
で @samp{More READER} とし、それから @samp{LIST overview.fmt} とする事を
試してください。これは動作しないでしょうが、もし動作して、取得した最後の
行が @samp{Xref:full} でないならば、ニュースの管理者が概観ファイルに
@code{Xref} 欄を含むようにするまで、ニュース管理者に叫び、泣き付く事を続
けるべきでしょう。

@vindex gnus-nov-is-evil
Gnus にいつでも正しい @code{Xref} を取得するようにさせたいのであれば、
@code{gnus-nov-is-evil} を @code{t} にする必要があり、それは非常に速度を
遅くします。

ま、人生はそのようなものです。

代替手段に付いては @pxref{Duplicate Suppression} を参照してください。

@node Duplicate Suppression
@section 重複の抑制

ディフォルトでは gnus は相互投稿機構を利用する事によって、同じ記事
を二回以上読まないようにしようとします (@pxref{Crosspost Handling})。し
かし、その単純で効果的な方法は、いろいろな理由により、満足する結果をもた
らさないかも知れません。

@enumerate
@item
@sc{nntp} サーバーは @code{Xref} 欄の生成に失敗するかも知れません。これ
は悪い事で、あまり起こりません。

@item
@sc{nntp} サーバーは @file{.overview} データベースに @code{Xref} 欄を含
めるのに失敗するかも知れません。これは悪い事で、非常に良くある事です、あぁ
悲しい。

@item
同じグループ (もしくはいくつかの関連したグループ) を違った @sc{nntp} サー
バーから読んでいるかもしれません。

@item
グループに投稿された記事と重複するメールを受け取ったかもしれません。
@end enumerate

@code{Xref} の扱いに失敗する状況は他にもありますが、これら四つがとても良
くある状況です。

もし、本当にもしも @code{Xref} の扱いに失敗したら、@dfn{重複抑制}に切り
替える事を考えるかもしれません。そうすれば、gnus はあなたが読んだ全ての
記事かそうでなければ、既読の印が付いた全ての記事の @code{Message-ID} を
記憶し、それから、魔法のように、その後のそれらと出会った全ての場合に、既
読の印を付けます――@emph{全て}のグループで。この機構を使うのは非常に非
効率的ですが、過度に非効率なわけではありません。もちろん同じ記事を一回以
上読むほうが好ましいです。

重複抑制はあまり繊細なものではありません。どちらかというと、大槌のような
ものです。それは非常に単純な方法で動作しています――もし記事に既読の印を
付ければ、それはこの Message-ID を キャッシュに加えます。次にこ
の Message-ID にであったときは、@samp{M} 印によって記事に既読の印を付け
ます。それはその記事がどのグループにあるかは気にしません。

@table @code
@item gnus-suppress-duplicates
@vindex gnus-suppress-duplicates
@code{nil} でなければ、重複抑制をします。

@item gnus-save-duplicate-list
@vindex gnus-save-duplicate-list
@code{nil} でなければ、重複のリストをファイルに保存します。これは起動と
終了の時間を長くしますので、初期状態では @code{nil} です。しかし、これは
単一の gnus の実行期で読まれた重複記事だけが抑制されるという事です。

@item gnus-duplicate-list-length
@vindex gnus-duplicate-list-length
この変数はどのくらい多くの @code{Message-ID} を重複抑制リストに保ってお
くかも決定します。ディフォルトは 10000 です。

@item gnus-duplicate-file
@vindex gnus-duplicate-file
重複抑制のリストを蓄積しておくファイルの名前です。ディフォルト
は @file{~/News/suppression} です。
@end table

何度も gnus を終了して起動する傾向があるのであれば、おそら
く @code{gnus-save-duplicate-list} を @code{t} にするのは良い考えでしょ
う。もし gnus を続けて何週間も走らせておくのであれば、それ
を @code{nil} にするかもしれません。一方で、リストを保存する事は起動と終
了をずっと遅くしますので、よく gnus を終了して起動するのであれば、
@code{gnus-save-duplicate-list} を @code{nil} に設定するべきであるという
事になります。うーむ。私はあなたがどうするかに任せたい、と思います。

@ignore
@node Security
@section Security

Gnus is able to verify signed messages or decrypt encrypted messages.
The formats that are supported are PGP, @sc{pgp/mime} and @sc{s/mime},
however you need some external programs to get things to work:

@enumerate
@item
To handle PGP messages, you have to install mailcrypt or gpg.el as
well as a OpenPGP implementation (such as GnuPG).

@item
To handle @sc{s/mime} message, you need to install OpenSSL.  OpenSSL 0.9.6
or newer is recommended.

@end enumerate

More information on how to set things up can be found in the message
manual (@pxref{Security, ,Security, message, Message Manual}).

@table @code
@item mm-verify-option
@vindex mm-verify-option
Option of verifying signed parts.  @code{never}, not verify;
@code{always}, always verify; @code{known}, only verify known
protocols. Otherwise, ask user.

@item mm-decrypt-option
@vindex mm-decrypt-option
Option of decrypting encrypted parts.  @code{never}, no decryption;
@code{always}, always decrypt; @code{known}, only decrypt known
protocols. Otherwise, ask user.
@end table
@end ignore

@node Mailing List
@section メーリングリスト

@kindex A M (概略)
@findex gnus-mailing-list-insinuate
Gnus は RFC 2369 で既定された各種のメーリングリストで使われるフィールド
を理解します。これを有効にするには `to-list' グループパラメー
タ (@pxref{Group Parameters}) を追加して、概略バッファ
で @kbd{A M} (@code{gnus-mailing-list-insinuate}) を使うか

@lisp
(add-hook 'gnus-summary-mode-hook 'turn-on-gnus-mailing-list-mode)
@end lisp

を唱えれば良いでしょう。これによって概略バッファでの以下の命令が使えるよ
うになります。

@table @kbd
@item C-c C-n h
@kindex C-c C-n h (概略)
@findex gnus-mailing-list-help
List-Help フィールドがあったら、メーリングリストのヘルプを取り寄せるため
のメッセージを送信します。

@item C-c C-n s
@kindex C-c C-n s (概略)
@findex gnus-mailing-list-subscribe
List-Subscribe フィールドがあったら、メーリングリストの講読を始めるため
のメッセージを送信します。

@item C-c C-n u
@kindex C-c C-n u (概略)
@findex gnus-mailing-list-unsubscribe
List-Unsubscribe フィールドがあったら、メーリングリストの講読をやめるた
めのメッセージを送信します。

@item C-c C-n p
@kindex C-c C-n p (概略)
@findex gnus-mailing-list-post
List-Post フィールドがあったら、メーリングリストに投稿します。

@item C-c C-n o
@kindex C-c C-n o (概略)
@findex gnus-mailing-list-owner
List-Owner フィールドがあったら、メーリングリストの管理者宛てにメッセー
ジを送信します。

@item C-c C-n a
@kindex C-c C-n a (概略)
@findex gnus-mailing-list-owner
List-Archive フィールドがあったら、メーリングリストのアーカイブを閲覧し
ます。
@end table

@node Article Buffer
@chapter 記事バッファ
@cindex article buffer

記事は一つしかない記事バッファに表示されます。全ての概略バッファ
は (gnus に共有しないように指示しない限り) 同じ記事バッファを共有します。

@menu
* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  @sc{mime} 記事として見せる
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファで使えるキー操作
* Misc Article::                その他
@end menu

@node Hiding Headers
@section 余分なヘッダーを隠す
@cindex hiding headers
@cindex deleting headers

各記事の頭の部分はヘッダー(@dfn{head})と呼ばれます (残りの部分はボ
ディ (@dfn{body})です。すでにお気づきでしょうが)。

@vindex gnus-show-all-headers
ヘッダーにはたくさんの便利な情報が含まれています。記事を書いた人の名前、
それが書かれた日付、記事の表題などです。これはとても良いんですが、ヘッダー
には大部分の人には見たくもない情報――記事があなたのところに着くまでどん
なシステムを経由してきたか、@code{Message-ID}, @code{References} などな
ど…もうやんなっちゃうくらい――もたくさん含まれています。たぶんあなたは
これらの行はいくつか取り除いてしまいたいと思うでしょう。もしこれらの行を
全て記事バッファ内に残しておきたければ、@code{gnus-show-all-headers} を
@code{t} に設定してください。

Gnus はヘッダーを選り分けるために二つの変数を用意しています。

@table @code
@item gnus-visible-headers
@vindex gnus-visible-headers
この変数が @code{nil} 以外であれば、どのヘッダーを記事バッファに残したい
かを指定する正規表現であるとみなされます。この変数にマッチしないヘッダー
は全て隠されます。

例えば、記事を書いた人の名前と表題のみを見たければ、こう指定します。

@lisp
(setq gnus-visible-headers "^From:\\|^Subject:")
@end lisp

この変数は、表示させたいヘッダーにマッチする正規表現をリストで指
定することもできます。

@item gnus-ignored-headers
@vindex gnus-ignored-headers
この変数は @code{gnus-visible-headers} の反対です。この変数が設定されて
いれば (かつ @code{gnus-visible-headers} が @code{nil} であれば)、これは
隠したいヘッダー行全てにマッチする正規表現であるとみなされます。この変数
にマッチしない全てのヘッダー行は表示されます。

例えば、単に @code{References} 欄と @code{Xref} 欄のみを消し去りたければ、
以下のようにします:

@lisp
(setq gnus-ignored-headers "^References:\\|^Xref:")
@end lisp

この変数は消したいヘッダーにマッチする正規表現のリストでも構いま
せん。

なお、@code{gnus-visible-headers} が @code{nil} 以外の場合は、こ
の変数には効果が無いことに注意してください。
@end table

@vindex gnus-sorted-header-list
Gnus はヘッダーの並べ替え(sort)も行います (これはディフォルトで行われま
す)。この並べ替えは @code{gnus-sorted-header-list} 変数を設定することで
制御することができます。これはヘッダーをどういう順序で表示するかを指定す
る正規表現のリストです。

例えば、記事の著者名を最初に、次に表題を表示したければ、こんな風
になるでしょう。

@lisp
(setq gnus-sorted-header-list '("^From:" "^Subject:"))
@end lisp

表示するようになっているヘッダーでこの変数に指定されていないもの
は、この変数に指定されている全てのヘッダーの後に、適当な順序で表
示されるでしょう。

@findex gnus-article-hide-boring-headers
@vindex gnus-boring-article-headers
@code{gnus-article-hide-boring-headers} を@code{head} に設定することによっ
て、もっとつまらないヘッダーを隠すことができます。この関数が何をするか
は @code{gnus-boring-article-headers} 変数に依存します。この変数はリスト
ですが、このリストには実際のヘッダーの名前が入るのではありません。代わり
に gnus がチェックして視界から消し去るためのさまざまな「つまらない条件」
@dfn{boring conditions} のリストを指定します。

この条件には以下のようなものがあります。

@table @code
@item empty
空のヘッダーを全て消去します。
@item followup-to
@code{Followup-To} 欄が @code{Newsgroups} 欄と同一である場合には消去しま
す。
@item reply-to
@code{Reply-To} 欄が @code{From} 欄と同じアドレスを示している場合には消
去します。
@item newsgroups
@code{Newsgroups} 欄が現在のグループ名しか含んでいない場合には消去します。
@item to-address
@code{To} 欄が現在のグループの @code{to-address} パラメータと同じものし
か含んでいない場合には消去します。
@item date
その記事が過去三日以内のものであれば、@code{Date} 欄を消去します。
@item long-to
@code{To} 欄があまりにも長い場合には消去します。
@item many-to
@code{To} 欄が一つよりも多ければ、それらを全て消去します。
@end table

これらの三つの要素を入れたければ、こんな風になります:

@lisp
(setq gnus-boring-article-headers
      '(empty followup-to reply-to))
@end lisp

これはこの変数のディフォルト値でもあります。

@node Using MIME
@section MIME を使う
@cindex @sc{mime}

パントマイム (mime) とは、意味も無く空中で手を振るものとして広く
知られており、その間観客はあくびをしながらぼんやりとしてます。

一方、@sc{mime} とは、意味も無く記事を符号化する標準であり、その
ために全てのニュースリーダが恐怖で死んでしまうものです。

@sc{mime} はその記事がどんな文字集合を使用しているか、その文字をどう符号
化しているかを指定することができ、さらには絵やその他のみだらなものを無邪
気な格好の記事に埋め込むことさえ可能にします。

@vindex gnus-show-mime
@vindex gnus-article-display-method-for-mime
@findex gnus-article-display-mime-message
Gnus は @code{gnus-article-display-method-for-mime} に記事を押し付けるこ
とで @sc{mime} を扱います。この初期値
は @code{gnus-article-display-mime-message} です。この関数
は @sc{semi} MIME-View プログラムを呼び出して実際の処理を行います。
@sc{semi} MIME-View に関する詳しい情報は、マニュアルを参照してくださ
い (まだないけど (;_;))。

@sc{mime} を常に使用したければ、
@code{gnus-show-mime} を @code{t} に設定してください。
@code{gnus-show-mime} を設定していると、運が悪いと記事バッファには故障し
たような画面が見えることもあるでしょう。これは避けようがありません。

GNUS や Gnus では、このたちの悪い問題で驚かされないようにするには、概略
バッファにおいて切り替え機能を使うというのが最善かも知れません (例えば、
@samp{alt.sing-a-long} グループに入ると、あなたの気づかないうち
に @sc{mime} は記事中のサウンドファイルを復号して、何やら怪しげな長い長
い歌があなたのスピーカーから大音響で流れ出し、あなたはボリュームボタンを
見つけられず、というのはそんなものはもともとついてないからで、みんなはあ
なたの方を睨みはじめ、あなたはプログラムを止めようとするけどできなくて、
ボリュームを制御するプログラムも見つけられなくて、そして部屋中の全員は突
然あなたのことを軽蔑の眼差しで見るようになってしまい、あなたはちょっと面
白くない思いをする、とか)。

現実の出来事と実在の人物に類似しているかもしれませんが、これは全てホント
のことです。げほげほ。

まあ、そういう訳で、gnus では @code{metamail-buffer} を使うのを止めた訳
です。そういう訳で、今では常に @code{gnus-show-mime} を @code{nil} 以外
にしておき、周りに人がいない時を見計らって記事バッファに現われるボタンを
押しましょう。

@c Also see @pxref{MIME Commands}.

@node Customizing Articles
@section 記事のカスタマイズ
@cindex article customization

記事がどのように存在しているかをカスタマイズするためのたくさんの関数です。
これらの関数を対話的に呼ぶこともできますし、記事を選択したときに自動的
に選択することもできます。

自動的に呼ばれるようにするためには、対応する ``treatment'' 変数を設定し
ます。例えば、ヘッダーを隠すためには、@code{gnus-treat-hide-headers} を
設定します。以下は設定できる変数の一覧ですが、まずこれらの変数の取り得る
値を議論します。

注意: いくつかの値は、有効な値ですが、ほとんど意味を無しません。意味のあ
る値は下の一覧を調べてください。

@enumerate
@item
@code{nil}: この扱いをしません。

@item
@code{t}: この扱いを全ての本文の部分で行います。

@item
@code{head}: ヘッダーでその扱いをします。

@item
@code{last}: この扱いを最後の部分で行います。

@item
整数: この扱いをこの番号より短い全ての本文の部分で行います。

@item
文字列のリスト: このリストのなかの正規表現に合致する名前のグループで読ま
れた記事の全ての本文の部分でこの扱いを行います。

@item
最初の要素が文字列でないリストです:

リストは再帰的に評価されます。リストの最初の要素は述語です。以下の述語が
認識されます: @code{or}, @code{and}, @code{not}, @code{typep}. これが例
です:

@lisp
(or last
    (typep "text/x-vcard"))
@end lisp

@end enumerate

@c FIXTGNUS Is this true?
ここで @dfn{一部分} という語が使われていることに気付いたと思います。これ
はメッセージには @sc{mime} マルチパート記事があり、いくつかの部分に分割
されているかもしれないという事実を反映しています。マルチパートでない記事
は一つの部分のみであるとみなされます。

@vindex gnus-article-treat-types
この扱いは全てのマルチパートの部分に適用されるのでようか? はい、そうした
ければそうなります。ですが、初期設定では、@samp{text/plain} 部分が扱いを
受けます。これは @code{gnus-article-treat-types} 変数で制御され、これは
各部分の型に合致する正規表現のリストです。制御変数の値が、上で説明されて
いるように述語のリストであるときは、この変数は無視されます。

以下の扱いのオプションが使用可能です。これをカスタマイズするための最も簡
単な方法は @code{gnus-article-treat} カスタマイズグループを調査すること
です。丸括弧の中の値は提案されている意味のある値です。他のものも可能です
が、ほとんどの人はおそらくここに一覧表示されているもので十分でしょう。

@table @code
@item gnus-treat-buttonize (t, integer)
@item gnus-treat-buttonize-head (head)

@xref{Article Buttons}.

@item gnus-treat-capitalize-sentences (t, integer)
@item gnus-treat-overstrike (t, integer)
@item gnus-treat-strip-cr (t, integer)
@item gnus-treat-strip-headers-in-body (t, integer)
@item gnus-treat-strip-leading-blank-lines (t, integer)
@item gnus-treat-strip-multiple-blank-lines (t, integer)
@item gnus-treat-strip-pem (t, last, integer)
@item gnus-treat-strip-pgp (t, last, integer)
@item gnus-treat-strip-trailing-blank-lines (t, last, integer)
@item gnus-treat-unsplit-urls (t, integer)
@item gnus-treat-decode-article-as-default-mime-charset (t, integer)

@xref{Article Washing}.

@item gnus-treat-date-english (head)
@item gnus-treat-date-iso8601 (head)
@item gnus-treat-date-lapsed (head)
@item gnus-treat-date-local (head)
@item gnus-treat-date-original (head)
@item gnus-treat-date-user-defined (head)
@item gnus-treat-date-ut (head)

@xref{Article Date}.

@item gnus-treat-from-picon (head)
@item gnus-treat-mail-picon (head)
@item gnus-treat-newsgroups-picon (head)

@xref{Picons}.

@item gnus-treat-display-smileys (t, integer)

@item gnus-treat-body-boundary (head)

@vindex gnus-body-boundary-delimiter
ヘッダーと本文の間に境界線を追加します。境界線に
は @code{gnus-body-boundary-delimiter} に設定された文字列が使われます。

@xref{Smileys}.

@item gnus-treat-display-xface (head)

@xref{X-Face}.

@item gnus-treat-emphasize (t, head, integer)
@item gnus-treat-fill-article (t, integer)
@item gnus-treat-fill-long-lines (t, integer)
@item gnus-treat-hide-boring-headers (head)
@item gnus-treat-hide-citation (t, integer)
@item gnus-treat-hide-citation-maybe (t, integer)
@item gnus-treat-hide-headers (head)
@item gnus-treat-hide-signature (t, last)

@xref{Article Hiding}.

@item gnus-treat-highlight-citation (t, integer)
@item gnus-treat-highlight-headers (head)
@item gnus-treat-highlight-signature (t, last, integer)

@xref{Article Highlighting}.

@item gnus-treat-play-sounds
@item gnus-treat-translate
@item gnus-treat-x-pgp-sig (head)

@item gnus-treat-unfold-headers (head)
@item gnus-treat-fold-headers (head)
@item gnus-treat-fold-newsgroups (head)
@item gnus-treat-leading-whitespace (head)

@xref{Article Header}.
@end table

@vindex gnus-part-display-hook
もちろん、@code{gnus-part-display-hook} から呼ばれる自分自身の関数を書く
こともできます。関数はその部分に範囲が狭められた状態で呼ばれ、ほとんどな
んでも好きなことをできます。バッファに保存しておかなければならない情報は
ありません---何でも変えることができます。しかし、ヘッダーを消してはいけ
ません。

@node Article Keymap
@section 記事のキー操作

概略バッファにおけるキー操作のほとんどは記事バッファでも使用でき
ます。これらは概略バッファでそのキーを押したかのように動作します。
つまり、実は記事を読んでいる間、概略バッファを表示させておく必要
もないということです。全ての操作は記事バッファから行うことができ
るのです。

それらに加えていくつかのキー操作が利用できます。

@table @kbd
@item SPACE
@kindex SPACE (記事)
@findex gnus-article-next-page
一頁前にめくります (@code{gnus-article-next-page})。

@item DEL
@kindex DEL (記事)
@findex gnus-article-prev-page
一頁後ろに戻します (@code{gnus-article-prev-page})。

@item C-c ^
@kindex C-c ^ (記事)
@findex gnus-article-refer-article
カーソル位置が @code{Message-ID} の近辺にあるときに @kbd{C-c ^} を押
すと、gnus はサーバーからその記事を取ってこようとしま
す (@code{gnus-article-refer-article})。

@item C-c C-m
@kindex C-c C-m (記事)
@findex gnus-article-mail
カーソル位置の近くにあるアドレスに返信を送りま
す (@code{gnus-article-mail})。接頭引数を与えると、そのメールに引用しま
す。

@item s
@kindex s (記事)
@findex gnus-article-show-summary
バッファを再構成して、概略バッファを見えるようにしま
す (@code{gnus-article-show-summary})。

@item ?
@kindex ? (記事)
@findex gnus-article-describe-briefly
利用できるキー操作のごく簡単な説明を出しま
す (@code{gnus-article-describe-briefly})。

@item TAB
@kindex TAB (記事)
@findex gnus-article-next-button
次のボタンがあればそこに移動しま
す (@code{gnus-article-next-button})。これはボタン機能をオンにしていると
きのみ意味を持ちます。

@item M-TAB
@kindex M-TAB (記事)
@findex gnus-article-prev-button
一つ前のボタンがあればそこに移動します (@code{gnus-article-prev-button})。

@item R
@kindex R (記事)
@findex gnus-article-reply-with-original
現在の記事に本記事を含んだ返答のメールを送りま
す (@code{gnus-article-reply-with-original})。接頭辞を与えると広い返
答 (wide reply) になります。もし領域が活性化されていたならば、その領域に
あるテキストだけを yank します。

@item F
@kindex F (記事)
@findex gnus-article-followup-with-original
現在の記事に本記事を含んでフォローアップをしま
す (@code{gnus-article-followup-with-original})。接頭辞を与えると広い返
答 (wide reply) になります。もし領域が活性化されていたならば、その領域に
あるテキストだけを yank します。
@end table

@node Misc Article
@section 記事のその他

@table @code
@item gnus-single-article-buffer
@vindex gnus-single-article-buffer
@code{nil} 以外であれば、全てのグループに対して同じ記事バッファを使用し
ます (これはディフォルトです)。@code{nil} であれば、各グループ毎の固有の
記事バッファを持つようになります。

@c FIXMETGNUS Default value is nil for T-gnus.
@vindex gnus-article-decode-hook
@item gnus-article-decode-hook
@cindex MIME
@sc{mime} 記事を復号化するときに使用されるフックです。

@vindex gnus-article-prepare-hook
@item gnus-article-prepare-hook
このフックは記事が記事バッファに書き込まれた直後に呼び出されます。これは
主に、何か記事の内容に依存する処理をする関数のために用意されています。つ
まり記事バッファの内容を変更するような目的で使うべきではないでしょう。

@item gnus-article-mode-hook
@vindex gnus-article-mode-hook
記事モードバッファで呼び出されるフックです。

@item gnus-article-mode-syntax-table
@vindex gnus-article-mode-syntax-table
記事バッファで用いられるシンタックステーブルです。これ
は @code{text-mode-syntax-table} をもとに初期化されます。

@vindex gnus-article-mode-line-format
@item gnus-article-mode-line-format
この変数は @code{gnus-summary-mode-line-format} と同じ行に従った様式文字
列です (@pxref{Mode Line Formatting})。これは以下の二つの拡張を除いて、
その変数と同じ様式指定を受付けます。

@table @samp
@item w
記事の「洗濯状態」@dfn{wash status}。これは記事に対して行われたであろう
洗濯操作を示す一文字からなる短い文字列になります。文字とそれらの意味は:

@table @samp
@item c
記事バッファにおいて、引用された文が隠されているかもしれない場合に表示さ
れます。

@item h
記事バッファにおいて、ヘッダーが隠されている場合に表示されます。

@c @item p
@c Displayed when article is digitally signed or encrypted, and Gnus has
@c hidden the security headers.  (N.B. does not tell anything about
@c security status, i.e. good or bad signature.)

@item s
記事バッファにおいて、署名が隠されている場合に表示されます。

@item o
記事バッファに重ね打ち文字がある場合に表示されます。

@item e
記事バッファに強調された文字列がある場合に表示されます。
@end table

@c FIXMETGNUS Does this work?
@item m
記事の @sc{mime} 部分の数です。
@end table

@vindex gnus-break-pages

@item gnus-break-pages
改頁 @dfn{page breaking} を行うかどうかを制御します。この変数
が @code{nil} 以外であれば、記事中に頁区切り文字が現れた場所ごとに頁分割
します。この変数が @code{nil} であれば頁分けは行われません。

@item gnus-page-delimiter
@vindex gnus-page-delimiter
これが上で触れた区切り文字です。ディフォルトでは @samp{^L} (フォーム
フィード、改頁) です。
@end table

@node Composing Messages
@chapter メッセージの作成
@cindex composing messages
@cindex messages
@cindex mail
@cindex sending mail
@cindex reply
@cindex followup
@cindex post
@c @cindex using gpg
@c @cindex using s/mime
@c @cindex using smime

@kindex C-c C-c (投稿)
投稿のための命令をすると、あなたはメッセージバッファに移動します。
そこでは、記事を好きなように編集する事ができます。
その後で @kbd{C-c C-c} を押す事によって、記事を送信します。
@xref{Top, , Overview, message, Message Manual}。記事はあなたの設定に基
づいて送信されます (@pxref{Posting Server})。

@menu
* Mail::                        メールと返答
* Posting Server::              どのサーバーを通してニュースを投稿または
                                メールを送信するべきか?
* Mail and Post::               同時にメールを出し返答する
* Archived Messages::           送ったメッセージを gnus が貯めておくとこ
                                ろ
* Posting Styles::              あなたが誰であるかを指定するより簡単な方
                                法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を好きでないときに
                                何が起こる?
@c * Signing and encrypting::      How to compose secure messages.
@end menu

投稿するべきでなかった記事を削除するための情報は @pxref{Canceling and
Superseding} を参照してください。

@node Mail
@section メール

出て行くメールをカスタマイズする変数です:

@table @code
@item gnus-uu-digest-headers
@vindex gnus-uu-digest-headers
要約メッセージ (digested message) に含まれるヘッダーに合致する正規表現の
リストです。ヘッダーは合致した順に取り込まれます。

@item gnus-add-to-list
@vindex gnus-add-to-list
@code{nil} でなければ、@kbd{a} をしたときに、@code{to-list} グループパラ
メータをそれのないメールグループに付け加えます。

@item gnus-confirm-mail-reply-to-news
@vindex gnus-confirm-mail-reply-to-news
非-@code{nil}だったら、ニュース記事に返信するときに gnus は確認を求めま
す。メールで返信する気は無いのに時たまぞんざいに R を押してしまう癖があ
るならば、この変数はそんなあなたのためにあります。
@end table

@node Posting Server
@section 投稿するサーバー

最新の (もちろん、非常に知的な) 記事を送り出すために、あの魔法のよう
な @kbd{C-c C-c} キーを押した時、それはどこにいくのでしょう?

尋ねてくれてありがとう。あなたを恨みます。

それは非常に複雑になり得ます。

@vindex gnus-post-method

ニュースを投稿するとき、通常 Message は @code{message-send-news} を呼び
出します (@pxref{News Variables, , News Variables, message-ja, Message
Manual})。普通は、gnus は講読用と同じ選択方法を使って投稿します (このこ
とは、あなたがたくさんのグループを異なったサーバーで講読している場合に、
たぶん都合が良いのです)。しかし、あなたが講読しているそのサーバーが投稿
を許可せず、読むことのみを許可しているのならば、おそらくあなたの (非常に
知的でとんでもなく興味深い) 記事を投稿するために、他のサーバーを使いたい
と思うでしょう。@code{gnus-post-method} を他の方法に設定する事ができます。

@lisp
(setq gnus-post-method '(nnspool ""))
@end lisp

さて、この設定をした後でサーバーがあなたの記事を拒否したり、サーバーが落
ちていたりしたら、どうしたらよいのでしょう? この変数を上書きするために、
命令 @kbd{C-c C-c} に零でない接頭引数を与える事で、投稿に『現在の』サー
バーを使わせる事、すなわちディフォルトの動作に戻す事ができます。

もし、零接頭引数をその命令に与えたなら (すなわち、@kbd{C-u 0 C-c C-c})、
gnus は投稿にどの方法を使うかをあなたに尋ねます。

@code{gnus-post-method} を選択方法のリストにする事もできます。その場合は、
gnus は常に投稿にどの方法を使うかをあなたに尋ねます。

最後に、あなたがいつでも基本の選択方法を使って投稿したいのならば、この変
数を @code{native} にして下さい。

メールを送信するときに、Message は @code{message-send-mail-function} を
呼び出します。ディフォルトの関
数 @code{message-send-mail-with-sendmail} は記事を順番待ちに入
れ (queuing) たり送信するために、バイナリーで @code{sendmail} にパイプし
ます。ローカルシステムが @code{sendmail} でメールを送信するように設定さ
れていなくても、あなたが遠隔 @sc{smtp} サーバーに接続する権利を持ってい
るならば、
@code{message-send-mail-function} を @code{smtpmail-send-it} に設定する
ことができます。@code{smtpmail} パッケージを使うために正しい設定がなされ
ているかどうか確認して下さい。例です:

@lisp
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-default-smtp-server "YOUR SMTP HOST")
@end lisp

これと似たものに @code{message-smtpmail-send-it} があります。
ISP が POP-before-SMTP の認証を要求している場合に有用です。関
数 @code{mail-source-touch-pop} の説明文を見てください。

他の可能な @code{message-send-mail-function} の選択肢
は @code{message-send-mail-with-mh},
@code{message-send-mail-with-qmail} および @code{feedmail-send-it} を含
みます。

@node Mail and Post
@section メールと投稿

これはメールを出す事と投稿する事の両方に関連する変数のリストです:

@table @code
@item gnus-mailing-list-groups
@findex gnus-mailing-list-groups
@cindex mailing lists

もしあなたのニュースサーバーが本当にメーリングリストから @sc{nntp} サー
バーへのゲートウェイを提供しているのであれば、それらのグループは問題なく
読めるでしょう。しかし簡単にはそれらに投稿/フォローアップすることはでき
ません。一つの解決法は グループパラメー
タ (@pxref{Group Parameters}) に @code{to-address} を加える事です。簡単
にできるのは、@code{gnus-mailing-list-groups} を、本当にメーリングリスト
であるようなグループに合致する正規表現に設定することです。その後は、すく
なくとも、メーリングリストへのフォローアップはたいていのときに動作します。
これらのグループに投稿する事は (@kbd{a}) それでも苦痛を引き起こすでしょ
うけど。
@end table

あなたは自分が送るメッセージの綴りを調べたいと思うかも知れません。もしく
は、もし手で綴り調べをしたくないのであれば、自動綴り調べ
を @code{ispell} パッケージを使う事によって付け加える事ができます:

@cindex ispell
@findex ispell-message
@lisp
(add-hook 'message-send-hook 'ispell-message)
@end lisp

もしあなたが @code{ispell} の辞書をグループに応じて切り替えたいならば、
以下のようにすれば良いでしょう。

@lisp
(add-hook 'gnus-select-group-hook
          (lambda ()
            (cond
             ((string-match
               "^de\\." (gnus-group-real-name gnus-newsgroup-name))
              (ispell-change-dictionary "deutsch"))
             (t
              (ispell-change-dictionary "english")))))
@end lisp

あなたの必要に応じて変更して下さい。

@node Archived Messages
@section メッセージの保管
@cindex archived messages
@cindex sent messages

Gnus はあなたが送ったメールとニュースを貯めておくためのいくつかの違った
方法を提供します。ディフォルトの方法はメッセージを保存するため
に @dfn{事実上の書庫サーバー}(archive virtual server) を使います。これを
完全に禁止したいのであれば、
変数 @code{gnus-message-archive-group} は @code{nil} になるべきで、これ
がディフォルトです。

あなたが読んで興味を持ったメッセージをグループに保存するに
は @kbd{B c} (@code{gnus-summary-copy-article}) コマンドを参照して下さ
い (@pxref{Mail Group Commands})。

@vindex gnus-message-archive-method
@code{gnus-message-archive-method} は送ったメッセージを蓄積するためにど
の事実上のサーバーを gnus が使うべきかを指定します。ディフォルトは:

@lisp
(nnfolder "archive"
          (nnfolder-directory   "~/Mail/archive")
          (nnfolder-active-file "~/Mail/archive/active")
          (nnfolder-get-new-mail nil)
          (nnfolder-inhibit-expiry t))
@end lisp

しかし、どのメール選択方法でも使う事ができま
す (@code{nnml}, @code{nnmbox} などなど)。しかし @code{nnfolder} はこの
ような事をするのにとても好ましい選択方法です。ディフォルトのディレクトリー
選択を好きでないならば、次のようにできます:

@lisp
(setq gnus-message-archive-method
      '(nnfolder "archive"
                 (nnfolder-inhibit-expiry t)
                 (nnfolder-active-file "~/News/sent-mail/active")
                 (nnfolder-directory "~/News/sent-mail/")))
@end lisp

@vindex gnus-message-archive-group
@cindex Gcc
Gnus は外へ出て行く全てのメッセージに、一つかそれ以上のそのサーバーのグ
ループへ向かう @code{Gcc} 欄を挿入します。どのグループを使うかは変
数 @code{gnus-message-archive-group} によって決まります。

この変数は次のような事をするために使われます:

@itemize @bullet
@item
文字列
メッセージはそのグループに保存されます。

あなたはグループ名に選択方法を含めることができますが、そうするとそのメッ
セージは @code{gnus-message-archive-method} で指定した選択方法ではなくて、
代わりにグループ名の選択方法で保存されることに注意しましょう。上に示した
ように @code{gnus-message-archive-method} は、ディフォルト値を持つもので
あると考えて下さい。ですか
ら @code{gnus-message-archive-group} を @code{"foo"} にしておけば、外へ
出て行くメッセージは @samp{nnfolder+archive:foo} に保存されますが、もし
あなたが @code{"nnml:foo"} という値を使うと、@samp{nnml:foo} に保存され
ます。
@samp{nnml:foo}.
@item
文字列のリスト
メッセージはそれらの全てのグループに保存されます。
@item
正規表現、関数、様式の連想リスト
キーが『合致』すると、結果が使われます。
@item
@code{nil}
メッセージの保存は行われません。これがディフォルトです。
@end itemize

試してみましょう:

@samp{MisK} と呼ばれる一つのグループに保存するならば:
@lisp
(setq gnus-message-archive-group "MisK")
@end lisp

二つのグループ、@samp{MisK} と @samp{safe} に保存するならば:
@lisp
(setq gnus-message-archive-group '("MisK" "safe"))
@end lisp

どのグループにいるかによって違ったグループに保存するなら:
@lisp
(setq gnus-message-archive-group
      '(("^alt" "sent-to-alt")
        ("mail" "sent-to-mail")
        (".*" "sent-to-misc")))
@end lisp

もっと複雑なもの:
@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          "misc-mail")))
@end lisp

全てのニュースメッセージを一つのファイルに保存して、メールメッセージを一
月につき一つのファイルに保存するには:

@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          (concat "mail." (format-time-string
                           "%Y-%m" (current-time))))))
@end lisp

@c (XEmacs 19.13 には @code{format-time-string} はありませんので、そ
@c の @code{gnus-message-archive-group} のために違った値を使わなければなり
@c ません。)

今や、メッセージを送ると、それは適切なグループに保存されます。(もし特定
のメッセージに対して保存をしたくないのであれば、挿入された @code{Gcc} 欄
を取り除いてください。) 保管グループは次に gnus を起動したときか、次にグ
ループバッファで @kbd{F} を押したときにグループバッファに現れます。他の
グループと同じようにそのグループに入って、記事を読む事ができます。そのグ
ループが本当に大きくなって嫌になったら、なにか良いものにその名前を変更す
る事ができます (グループバッファで @kbd{G r} を使う事によって) ――
@samp{misc-mail-september-1995} や他のもに。新しいメッセージは古い (今は
空になった) グループに溜められます。

以上が送ったメッセージを保管するディフォルトの方法です。Gnus はディフォ
ルトの方法を好きではない人には違ったやり方を勧めています。そのような場合
は、@code{gnus-message-archive-group} を @code{nil} に設定するべきです。
これは保管をしないようにします。

@table @code
@item gnus-outgoing-message-group
@vindex gnus-outgoing-message-group
全ての外にいくメッセージはこのグループに入れられます。もし全ての外に行く
メールと記事をグループ @samp{nnml:archive} に保管したいのであれば、この
変数をその値に設定する事ができます。この変数はグループ名のリストである事
もできます。

もしそれぞれのメッセージをどのグループに入れるかをもっと制御したいのであ
れば、この変数を現在のニュースグループ名を調べて、適切なグループ名 (もし
くは名前のリスト) を返す関数に設定する事ができます。

この変数は @code{gnus-message-archive-group} の代わりに使う事ができます
が、後者の方が好ましい方法です。

@item gnus-gcc-mark-as-read
@vindex gnus-gcc-mark-as-read
もし非@code{nil}なら、@code{Gcc} の記事に既読の印を付けます。

@c @item gnus-gcc-externalize-attachments
@c @vindex gnus-gcc-externalize-attachments
@c If @code{nil}, attach files as normal parts in Gcc copies; if a regexp
@c and matches the Gcc group name, attach files as external parts; if it is
@c @code{all}, attach local files as external parts; if it is other
@c non-@code{nil}, the behavior is the same as @code{all}, but it may be
@c changed in the future.
@end table

@node Posting Styles
@section 投稿様式
@cindex posting styles
@cindex styles

それらはすべて変数で、それは私の頭を泳がせます。

それで、なぜどのグループに投稿するかによって違っ
た @code{Organization} と署名を望むのでしょうか? そして、あなたは家庭の
マシンと職場のマシンの両方から投稿して、違った @code{From} 行やその他の
ものを望むのですか?

@vindex gnus-posting-styles
そのような事をする方法の一つは変更される必要のある変数を変更する賢いフッ
クを書く事です。それは少し退屈なので、利用者にこれらの事を手軽な連想リス
トで指定するというすばらしい着想にたどり着いた人がいました。これは変
数 @code{gnus-posting-styles} の例です:

@lisp
((".*"
   (signature "Peace and happiness")
   (organization "What me?"))
 ("^comp"
  (signature "Death to everybody"))
 ("comp.emacs.i-love-it"
  (organization "Emacs is it")))
@end lisp

この例から推測されるように、この連想リストはいくつか
の @dfn{様式} (style) からなっています。それぞれの様式は最初の要素が何ら
かの形で ``合致'' したときに適用されます。連想リスト全体は最初から最後ま
で反復して実行され、それぞれの合致が適用されます。これは、後の様式の属性
が前に合致した様式の属性を上書きすると言う事です。ですから、
@samp{comp.programming.literate} は、署
名 @samp{Death to everybody} と @code{Organization} ヘッ
ダー @samp{What me?} を持ちます。

それぞれの様式の最初の要素は @code{合致} (match) と呼ばれます。もしそれ
が文字列であれば、gnus はそれをグループ名に正規表元現として合致操作を行
います。@code{(header 合致 正規表現)} という様式であれば、gnus は元の記
事の中から名前が合致するヘッダーを探し、それを正規表元と比較します。合致
と正規表現は文字列です。もしそれが関数のシンボルであれば、その関数が引数
無しで呼ばれます。それが変数のシンボルであれば、その変数が参照されます。
それがリストであれば、そのリストが @code{評価} されます。どの場合でも、
これが @code{nil}でない値を帰せば、様式は @code{合致した} と言います。

それぞれの様式は任意の量の @dfn{属性} を持つ事ができます。それぞれの属性
は @code{(@var{name} @var{value})} の対により成り立っています。属性名
は、@code{signature}, @code{signature-file}, @code{x-face-file},
@code{address} (@code{user-mail-address} を上書きする), @code{name}
(@code{user-full-name} を上書きする) または @code{body} のどれかである事
ができます。属性名は文字列またはシンボルである事もできます。その場合は、
これはヘッダー名として使われ、その値が記事のヘッダーに挿入されます。もし
属性名が @code{nil} だったらそのヘッダー名は削除されます。もし属性名
が @code{eval} だったらその様式が評価され、結果は捨てられます。

属性値は文字列 (そのまま使われます)、引数の無い関数 (返り値が使われます)、
変数 (その値が使われます) またはリスト (それは @code{評価} されて、返り
値が使われます) である事ができます。関数はセットアップされたメッセージバッ
ファで呼ばれ (@code{eval} され) ます。現在の記事のヘッダーは変
数 @code{message-reply-headers} から得られます。これは number subject
from date id references chars lines xref extra の各ヘッダーから成るベク
トルです。

@vindex message-reply-headers

もし、作成しようとしているメッセージがニュース記事かメールメッセージであ
るかを調べたいときは、二つの関
数 @code{message-news-p} と @code{message-mail-p} を使うことによって知る
事ができます。

@findex message-mail-p
@findex message-news-p

そして、これは例です:

@lisp
(setq gnus-posting-styles
      '((".*"
         (signature-file "~/.signature")
         (name "User Name")
         ("X-Home-Page" (getenv "WWW_HOME"))
         (organization "People's Front Against MWM"))
        ("^rec.humor"
         (signature my-funny-signature-randomizer))
        ((equal (system-name) "gnarly")  ;; 様式
         (signature my-quote-randomizer))
        (message-news-p        ;; 関数シンボル
         (signature my-news-signature))
        (window-system         ;; 変数シンボル
         ("X-Window-System" (format "%s" window-system)))
        ;; Lars さんに返事をするときは
        ;; Organization ヘッダーを付けよう。
        ((header "to" "larsi.*org")
         (Organization "Somewhere, Inc."))
        ((posting-from-work-p) ;; ユーザーが定義した関数
         (signature-file "~/.work-signature")
         (address "user@@bar.foo")
         (body "You are fired.\n\nSincerely, your boss.")
         (organization "Important Work, Inc"))
        ("nnml:.*"
         (From (save-excursion
                 (set-buffer gnus-article-buffer)
                 (message-fetch-field "to"))))
        ("^nn.+:"
         (signature-file "~/.mail-signature"))))
@end lisp

@samp{nnml:.*} の規則は、あなたが出すすべての返事の @code{To} アドレス
を @code{From} アドレスとして使うことを意味します。これは、あなたがたく
さんのメーリングリストに参加している場合に便利でしょう。

@node Drafts
@section 下書き
@cindex drafts

もしメッセージ (メールもしくはニュース) を書いているときに、突然オーブン
にステーキが入っている事を思い出したなら (もしくは、あなたがとーってもす
ごい菜食主義者で、茎をフードプロセッサーにいれているなら)、書いているメッ
セージを保存する方法があれば良いと思うでしょう。そうすれば、いつか別の日
に編集を続ける事ができ、それが完成したと思ったときに送る事ができます。

えぇ、心配しないでください。Gnus のメールと投稿命令を使う何らかのメッセー
ジを書き始めたときに、手に入れるバッファは自動的に特別な @dfn{draft} グ
ループに関連付けられます。普通の方法でバッファを保存すれば (たとえば、
@kbd{C-x C-s})、その記事はそこに保存されます。(自動保存ファイルも下書き
グループ (draft group) に行きます。)

@cindex nndraft
@vindex nndraft-directory
下書きグループは @samp{nndraft:drafts} と呼ばれる特別なグループ です (も
しあなたが全てを知らなければならないのであれば、それは @code{nndraft} グ
ループとして実装されています)。変数 @code{nndraft-directory} はそのファ
イルを @code{nndraft} がどこに保管するべきかを指定します。このグループが
特別であるというのは、その中の記事を永可視にしたり既読の印を付けたりでき
ないからです――グループの全ての記事は永久に未読です。

もしグループが存在しないなら、それは作成され、購読されます。グループバッ
ファからそれを消し去る唯一の方法は、それを未購読にすることです。

@c @findex gnus-dissociate-buffer-from-draft
@c @kindex C-c M-d (Mail)
@c @kindex C-c M-d (Post)
@c @findex gnus-associate-buffer-with-draft
@c @kindex C-c C-d (Mail)
@c @kindex C-c C-d (Post)
@c If you're writing some super-secret message that you later want to
@c encode with PGP before sending, you may wish to turn the auto-saving
@c (and association with the draft group) off.  You never know who might be
@c interested in reading all your extremely valuable and terribly horrible
@c and interesting secrets.  The @kbd{C-c M-d}
@c (@code{gnus-dissociate-buffer-from-draft}) command does that for you.
@c If you change your mind and want to turn the auto-saving back on again,
@c @kbd{C-c C-d} (@code{gnus-associate-buffer-with-draft} does that.
@c
@c @vindex gnus-use-draft
@c To leave association with the draft group off by default, set
@c @code{gnus-use-draft} to @code{nil}.  It is @code{t} by default.

@findex gnus-draft-edit-message
@kindex D e (下書き)
記事の編集を続けたいときは、下書きグループに入っ
て @kbd{D e} (@code{gnus-draft-edit-message}) を押すだけです。あなたが残
した状態のバッファに移動します。

拒否された記事もこの下書きグループに入れられま
す (@pxref{Rejected Articles})。

@findex gnus-draft-send-all-messages
@findex gnus-draft-send-message
それ以上編集しないで投稿 (もしくはメール) したい拒否されたメッセージがた
くさんあるのであれば、命令 @kbd{D s} を使う事ができます。この命令はプロ
セス/接頭引数の習慣を理解します (@pxref{Process/Prefix})。命
令 @kbd{D S} (@code{gnus-draft-send-all-messages}) はバッファの全てのメッ
セージを送り出します。

送りたくないメッセージがいくつかあるのであれば、命
令 @kbd{D t} (@code{gnus-draft-toggle-sending}) を使ってメッセージを配送
不可の印を付ける事ができます。これは切り替え命令です。

@node Rejected Articles
@section 拒否された記事
@cindex rejected articles

時々ニュースサーバーは記事を拒否します。おそらくサーバーはあなたの顔を好
きではないのでしょう。おそらくそれは惨めに感じたからでしょう。おそら
く @emph{悪魔 (demon) がいるのでしょう}。おそらく引用文を入れすぎたので
しょう。おそらくディスクが一杯だったのでしょう。おそらくサーバーが落ちて
いたのでしょう。

これらの状況は、もちろん、完全に gnus の扱える範囲外です。(Gnus は、もち
ろん、あなたの外見を愛しており、いつも機嫌が良く、中を飛び回る天使がいて、
どれくらい引用文が含まれていようと気にせず、一杯になったり、落っこちたり
しません。) ですから、gnus はこれらの記事を後でサーバーの気分がよくなる
まで保存します。

拒否された記事は自動的に特別な下書きグループ (@pxref{Drafts}) に入れられ
ます。サーバーが戻ってきたなら、普通はそのグループに入って全ての記事を送
ります。

@ignore
@node Signing and encrypting
@section Signing and encrypting
@cindex using gpg
@cindex using s/mime
@cindex using smime

Gnus can digitally sign and encrypt your messages, using vanilla PGP
format or @sc{pgp/mime} or @sc{s/mime}.  For decoding such messages,
see the @code{mm-verify-option} and @code{mm-decrypt-option} options
(@pxref{Security}).

For PGP, Gnus supports two external libraries, @sc{gpg.el} and
@sc{Mailcrypt}, you need to install at least one of them.  The
@sc{s/mime} support in Gnus requires the external program OpenSSL.

Often, you would like to sign replies to people who send you signed
messages.  Even more often, you might want to encrypt messages which
are in reply to encrypted messages.  Gnus offers
@code{gnus-message-replysign} to enable the former, and
@code{gnus-message-replyencrypt} for the latter.  In addition, setting
@code{gnus-message-replysignencrypted} (on by default) will sign
automatically encrypted messages.

Instructing MML to perform security operations on a @sc{mime} part is
done using the @kbd{C-c C-m s} key map for signing and the @kbd{C-c
C-m c} key map for encryption, as follows.

@table @kbd

@item C-c C-m s s
@kindex C-c C-m s s
@findex mml-secure-message-sign-smime

Digitally sign current message using @sc{s/mime}.

@item C-c C-m s o
@kindex C-c C-m s o
@findex mml-secure-message-sign-pgp

Digitally sign current message using PGP.

@item C-c C-m s p
@kindex C-c C-m s p
@findex mml-secure-message-sign-pgp

Digitally sign current message using @sc{pgp/mime}.

@item C-c C-m c s
@kindex C-c C-m c s
@findex mml-secure-message-encrypt-smime

Digitally encrypt current message using @sc{s/mime}.

@item C-c C-m c o
@kindex C-c C-m c o
@findex mml-secure-message-encrypt-pgp

Digitally encrypt current message using PGP.

@item C-c C-m c p
@kindex C-c C-m c p
@findex mml-secure-message-encrypt-pgpmime

Digitally encrypt current message using @sc{pgp/mime}.

@item C-c C-m C-n
@kindex C-c C-m C-n
@findex mml-unsecure-message
Remove security related MML tags from message.

@end table

Also @xref{Security, ,Security, message, Message Manual}.

@end ignore
@node Select Methods
@chapter 選択方法
@cindex foreign groups
@cindex select methods

@dfn{外部グループ} (foreign group) とは、普通 (もしくはディフォルト) の
方法で読まれないグループの事です。例えば、それは違った @sc{nntp} サーバー
のグループであったり、事実上のグループであったり、個人的なメールグループ
であったりするでしょう。

外部グループ (もしくは、本当に全てグルー
プ) は @dfn{名前} と @dfn{選択方法} で指定されます。後者を先に例に出すと、
選択方法は最初の要素がどのバックエンドを使うか (たとえば、@code{nntp}, @code{nnspool}, @code{nnml}) で、
二つめの要素が @dfn{サーバー名} である連想リストです。選択方法には、その
当のバックエンドにとって特別の意味を持つ値である追加の要素があるかも知れ
ません。

選択方法は @dfn{事実上のサーバー} を定義すると言うことができるかもしれま
せん---ですから私たちはちょうどそれをしまし
た (@pxref{Server Buffer})。

グループの @dfn{名前} はバックエンドがグループを認識する名前です。

たとえば、@sc{nntp} サーバーのグループ @samp{soc.motss} は名
前 @samp{soc.motss} と選択方法 @code{(nntp "some.where.edu")} を持ちます。
@code{nntp} バックエンドはこのグループを @samp{soc.motss} として知ってい
るだけですが、gnus はこのグループ
を @samp{nntp+some.where.edu:soc.motss}と呼びます。

もちろん、違った方法は全てそれ特有のものがあります。

@menu
* Server Buffer::               事実上のサーバーを作って編集する
* Getting News::                USENET ニュースを gnus で読む
* Getting Mail::                個人的なメールを gnus で読む
* Browsing the Web::            過剰なウェブの資源からメッセージを取得す
                                る
* IMAP::                        gnus を @sc{imap} のクライアントとして使う
* Other Sources::               ディレクトリー、ファイル、SOUP パケット
                                を読む
* Combined Groups::             複数のグループを一つのグループに結合する
* Gnus Unplugged::              ニュースとメールをオフラインで読む
@end menu

@node Server Buffer
@section サーバーバッファ

伝統的に、@dfn{サーバー} はそれに接続して、それから情報を要求するマシン
かソフトウェアです。gnus は本当のどんなサーバーにも直接には接続せず、バッ
クエンドか他のものを通してすべての処理を行ないます。しかし、それは実際の
媒体と gnus の間に単に一つかそれ以上の階層を置くことであって、それぞれの
バックエンドがまさに疑似的なサーバーに相当すると言っても良いでしょう。

例えば @code{nntp} バックエンドは、異なるいくつかの実在する @sc{nntp} サー
バー、あるいは同じ実在する @sc{nntp} サーバーの異なるポートに接続するた
めに用いられます。あなたは、どのバックエンドを使うか、そしてどんなパラメー
タを設定するかを選択方法 (@dfn{select method}) で指定します。

選択方法の指定は、ときに極めて面倒なものになります。そうだなあ、例えば、
@sc{nov} ヘッダーを取り寄せようとすると固まってしまい、選択の作業が故障
がちな @sc{nntp} サーバー @samp{news.funet.fi} のポート 13 を読みたい場
合とか。うおっほん。とにかくですね、このサーバーを使うそれぞれのグループ
についてそういうことを設定しなければならないとしたら、大変な作業になって
しまうでしょう。そこで gnus は、そういう作業をサーバーバッファで行なうた
めに、選択方法に名前を付ける手段を設けているのです。

サーバーバッファに入るためには、グループバッファ
で @kbd{^} (@code{gnus-group-enter-server-mode}) コマンドを使って下さい。

@menu
* Server Buffer Format::        このバッファの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使う事ができる
* Unavailable Servers::         接続しようと試みたサーバーのいくつかが落
                                ちているかもしれない
@end menu

@vindex gnus-server-mode-hook
サーバーバッファを作成するときに @code{gnus-server-mode-hook} が実行され
ます。

@node Server Buffer Format
@subsection サーバーバッファの表示様式
@cindex server buffer format

@vindex gnus-server-line-format
サーバーバッファの行の外見を、変数 @code{gnus-server-line-format} 変数を
変更する事によって変える事ができます。これは @code{format} のような変数
で、すこし単純な拡張がなされています:

@table @samp
@item h
どのようにニュースが取得されるか---バックエンドの名前。

@item n
サーバーの名前。

@item w
どこからニュースが取得されるべきか---アドレス。

@item s
サーバーの接続の 開いた/閉じた/拒否された 状態。
@end table

@vindex gnus-server-mode-line-format
モード行も変数 @code{gnus-server-mode-line-format} を使う事によってカス
タマイズする事ができます (@pxref{Mode Line Formatting})。以下の指定は理
解されます:

@table @samp
@item S
サーバー名。

@item M
サーバー方法。
@end table

@pxref{Formatting Variables} も参照してください。

@node Server Commands
@subsection サーバー命令
@cindex server commands

@table @kbd
@item a
@kindex a (サーバー)
@findex gnus-server-add-server
新しいサーバーを追加します (@code{gnus-server-add-server})。

@item e
@kindex e (サーバー)
@findex gnus-server-edit-server
サーバーを編集します (@code{gnus-server-edit-server})。

@item SPACE
@kindex SPACE (サーバー)
@findex gnus-server-read-server
現在のサーバーをざっと眺めます (@code{gnus-server-read-server})。

@item q
@kindex q (サーバー)
@findex gnus-server-exit
グループバッファに戻ります (@code{gnus-server-exit})。

@item k
@kindex k (サーバー)
@findex gnus-server-kill-server
現在のサーバーを切ります (kill) (@code{gnus-server-kill-server})。

@item y
@kindex y (サーバー)
@findex gnus-server-yank-server
先ほど切られた (killed) サーバーを貼り付けます (yank)
(@code{gnus-server-yank-server})。

@item c
@kindex c (サーバー)
@findex gnus-server-copy-server
現在のサーバーを複写します (@code{gnus-server-copy-server})。

@item l
@kindex l (サーバー)
@findex gnus-server-list-servers
全てのサーバーの一覧を挙げます (@code{gnus-server-list-servers})。

@item s
@kindex s (サーバー)
@findex gnus-server-scan-server
サーバーにその資源から新しい記事を調べるように要求しま
す (@code{gnus-server-scan-server})。これは主にメールサーバーに対して意
味を持ちます。

@item g
@kindex g (サーバー)
@findex gnus-server-regenerate-server
サーバーが全てのデータ構造を再作成するように求めま
す (@code{gnus-server-regenerate-server})。これは同期からはずれてしまっ
たメールバックエンドがあるときに役に立ちます。
@end table

@node Example Methods
@subsection 方法の例

ほとんどの選択方法は非常に簡単で、自分自身をよく説明しています:

@lisp
(nntp "news.funet.fi")
@end lisp

直接スプールから読むのはもっと簡単です:

@lisp
(nnspool "")
@end lisp

見たとおり、選択方法の最初の要素はバックエンドの名前で、二番目
は @dfn{アドレス} (address)、もしくはそう呼びたいのであれば、
@dfn{名前} です。

これらの二つの要素の後には、任意の数
の @code{(@var{変数} @var{様式})} の対を入れる事ができます。

最初の例に戻りましょう---そのマシンのポート 15 から読みたかったと思って
ください。これがその時に、なるべき選択方法です:

@lisp
(nntp "news.funet.fi" (nntp-port-number 15))
@end lisp

どの変数が関連するかを見つけるために、それぞれのバックエンドの説明文書を
読むべきでしょうが、これは @code{nnmh} の例です。

@code{nnml} はスプールのような構造で読むメールバックエンドです。例えば、
接触を図りたい二つの構造があるとしましょう: 一つはあなたの私的なメールス
プールで、他方は公的なものです。これは私的なメールのために使用可能な指定
です:

@lisp
(nnmh "private" (nnmh-directory "~/private/mail/"))
@end lisp

(そうするとこのサーバーは @samp{private} と呼ばれますが、あなたは既に推
測していたかもしれません。)

これは公的スプールのための方法です:

@lisp
(nnmh "public"
      (nnmh-directory "/usr/information/spool/")
      (nnmh-get-new-mail nil))
@end lisp

@cindex proxy
@cindex firewall

防壁 (firewall) の中にいて、防壁マシンからの @sc{nntp} サーバーへの接続
しかないのであれば、gnus に防壁マシンに @code{rlogin} して、そこか
ら @sc{nntp} サーバーに telnet をするように指示する事ができます。
これをする事は少しばからしいですが、事実上のサーバーの定義はおそらくこの
ようなものになるべきです:

@lisp
(nntp "firewall"
      (nntp-open-connection-function nntp-open-via-rlogin-and-telnet)
      (nntp-via-address "the.firewall.machine")
      (nntp-address "the.real.nntp.host")
      (nntp-end-of-line "\n"))
@end lisp

もし、すばらしい @code{ssh} プログラムを、モデム線からの圧縮された接続を
提供するために使いたいのであれば、上記の例に以下の設定を加えることができ
ます。

@lisp
      (nntp-via-rlogin-command "ssh")
@end lisp

@code{nntp-via-rlogin-command-switches} も参照して下さい。

もしあなたが防壁の中にいたとしても、"runsocks" のようなラッパーコマンド
を通して外の世界を直接アクセスできるのならば、以下のように socks を通し
てニュースサーバーと telnet 接続することができます:

@lisp
(nntp "outside"
      (nntp-pre-command "runsocks")
      (nntp-open-connection-function nntp-open-via-telnet)
      (nntp-address "the.news.server")
      (nntp-end-of-line "\n"))
@end lisp

これはもちろん、自動認証を提供するために @code{ssh-agent} を適切に設定し
なければなりません。圧縮された接続を得るためには、@code{ssh}のファイ
ル @file{config} で @samp{Compression} オプションがある必要があります。

@node Creating a Virtual Server
@subsection 事実上のサーバーを作成する

もしあなたが永続記事を使ってたくさんの記事をキャッシュに保存しているので
あれば、キャッシュを読むための事実上のサーバーを作りたいと思うかもしれま
せん。

最初に、新しいサーバーを付け加える必要があります。命令 @kbd{a} がそれを
します。おそらくキャッシュを読むためには @code{nnspool} を使うのが一番良
いでしょう。@code{nnml} や @code{nnmh} も使う事ができますけど。

@kbd{a nnspool RET cache RET} と打ってください。

すると @samp{cache} と呼ばれる， @code{nnspool} の事実上のサーバー
ができるはずです。次はそれを編集して、正しい定義を与えるだけです。サーバーを
編集するために @kbd{e} を打ってください。以下のものを含むバッファに入る
でしょう。

@lisp
(nnspool "cache")
@end lisp

それを次のものに変更してください:

@lisp
(nnspool "cache"
         (nnspool-spool-directory "~/News/cache/")
         (nnspool-nov-directory "~/News/cache/")
         (nnspool-active-file "~/News/cache/active"))
@end lisp

サーバーバッファに戻るために @kbd{C-c C-c} と打ってください。今やこの事
実上のサーバーで @kbd{RET} を押すと、閲覧バッファに入るべきで、表示され
ているどのグループにでも入る事ができるはずです。

@node Server Variables
@subsection サーバー変数

変数を定義する一つのやっかいな点は (バックエンドと Emacs 一般の両方で)、
変数の定義がロードされている間に、いくつかの変数は他の変数で初期化さ
れるという事です。もし "基となる" 変数がロードされた後に変更しても、"導
き出された" 変数は変更されません。

これは普通はディレクトリーやファイルの変数に影響します。例えば、
@code{nnml-directory} はディフォルトで @file{~/Mail} ですが、全て
の @code{nnml} ディレクトリー変数はその変数によって初期化されるので、
@code{nnml-active-file} は @file{~/Mail/active} になります。もし新しい事
実上の @code{nnml} サーバーを定義した場合、@code{nnml-directory} を設定
するだけでは充分では@emph{ありません}---あなたは望んだ状態になるように、
全てのファイル変数を明示的に設定しなければなりません。それぞれのバックエ
ンドに対する完全な変数のリストを見るためには、このマニュアルの後に続くそ
れぞれのバックエンドの部分を読んでください。でも、@code{nnml} の定義の例
はここにあります:

@lisp
(nnml "public"
      (nnml-directory "~/my-mail/")
      (nnml-active-file "~/my-mail/active")
      (nnml-newsgroups-file "~/my-mail/newsgroups"))
@end lisp

@node Servers and Methods
@subsection サーバーと方法

普通に選択方法を使うところであればどこでも (例えば、外部サーバーを概観しているときの
グループ選択方法である @code{gnus-secondary-select-method} ) 、代わりに
事実上のサーバー名を使う事ができます。このことによりたくさんキーボー
ドを叩かなくてすむ可能性があります。そして、全てにわたって、その方が良い
です。

@node Unavailable Servers
@subsection 使用不可能なサーバー

もしサーバーに接続不可能であるならば、gnus はサーバーを @code{拒否} とし
て印を付けます。これはその後のそのサーバーとの接続をはかるどのような試み
も無視されるという事です。Gnus は接続が開けないことが本当であるかどうか
を少しも確かめず、``It can't be opend,'' (接続を開く事ができません) と告
げます。

それは行儀が悪いと思う事があるかもしれませんが、それはたいていのときには
良い方法です。例えば、サーバー @samp{nephelococcdyia.com} に 10 個購読し
ているグループがあるとしましょう。サーバーはどこか非常に遠くにあり、マシ
ンはとても遅いので、それが今日はあなたとの接続を拒否するかどうかを調べる
だけで一分かかります。もし gnus がそれを 10 回試すようになっていたなら、
あなたは非常にうるさく思うでしょう。ですから、gnus はそれを試そうとはし
ません。一度 ``connection refused'' (接続は拒否されました) を受け取ると、
それはサーバーが ``down'' (落ちている) であるとみなします。

それで、一時的にそのマシンの機嫌が悪いだけだったら何が起こるのでしょう?
マシンが復活したかどうかをどうすれば調べる事ができるのでしょう?

サーバーバッファに飛び移って (@pxref{Server Buffer})、以下の命令でつつく
だけでできます:

@table @kbd
@item O
@kindex O (サーバー)
@findex gnus-server-open-server
現在の行のサーバーとの接続を確立しようとしま
す (@code{gnus-server-open-server})。

@item C
@kindex C (サーバー)
@findex gnus-server-close-server
サーバーの接続 (もしあれば) を閉じます (@code{gnus-server-close-server})。

@item D
@kindex D (サーバー)
@findex gnus-server-deny-server
現在のサーバーに接続不可能の印を付けま
す (@code{gnus-server-open-all-server})。

@item M-c
@kindex M-c (サーバー)
@findex gnus-server-close-to-all-servers
バッファにある全てのサーバーとの接続を閉じま
す (@code{gnus-server-close-all-servers})。

@item R
@kindex R (サーバー)
@findex gnus-server-remove-denials
Gnus がどれかのサーバーから接続拒否を受けたかどうかの全ての印を消去しま
す (@code{gnus-server-remove-denials})。

@item L
@kindex L (Server)
@findex gnus-server-offline-server
サーバーの状態をオフラインにします (@code{gnus-server-offline-server})。
@end table

@node Getting News
@section ニュースの取得
@cindex reading news
@cindex news back ends

ニュースリーダーは普通はニュースを読む事に使われます。Gnus は現在はニュー
ズを取得するために二つだけの方法を提供しています---@sc{nntp} サーバーか、
ローカルスプールから読む事ができます。

@menu
* NNTP::                        @sc{nntp} サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む
@end menu

@node NNTP
@subsection NNTP
@cindex nntp

@sc{nntp} サーバーの外部グループを購読するのは比較的簡単です。単
に @code{nntp} を方法として指定し、@sc{nntp} サーバーのアドレ
ス (address) を、うーん、アドレスとして指定するだけです。

もし @sc{nntp} サーバーが標準でないポート (port) に位置しているときは、
選択方法の三番目の要素をこのポートの数字に設定する事で正しいポートに接続
する事ができるでしょう。そのためにグループ情報を編集しなければなりませ
ん (@pxref{Foreign Groups})。

外部グループの名前は基本グループと同じでも構いません。実際、あなたの
思うままに同じグループを可能な限りの違ったサーバーから購読する事ができま
す。名前の衝突は起こりません。

以下の変数は事実上の @code{nntp} サーバーを作るために使われます:

@table @code
@item nntp-server-opened-hook
@vindex gnus-server-opend-hook
@cindex @sc{mode reader}
@cindex authinfo
@cindex authentification
@cindex nntp authentification
@findex nntp-send-authinfo
@findex nntp-send-mode-reader
は接続ができた後に実行されます。それは @sc{nntp} サーバーに接触した後に
それに命令を送るために使われる事ができます。ディフォルトでは関
数 @code{nntp-send-mode-reader} により命令 @code{MODE READER} がサーバー
に送られます。その関数は常にこのフックにあるべきです。

@item nntp-authinfo-function
@vindex nntp-authinfo-function
@findex nntp-send-authoinfo
@vindex nntp-authinfo-file
この関数は @sc{nntp} サーバーに @samp{AUTHINFO} を送るために使われます。
ディフォルトの関数は @code{nntp-send-authinfo} で、
@file{~/.authinfo} (もしくは変数 @code{nntp-authinfo-file} に設定したど
のようなものでも) を使用可能な記載を調べるために探します。もし一つも見つ
からなかったら、あなたにログイン名とパスワードの入力を促進します。ファイ
ル @file{~/.authinfo} の様式は (ほとんど) @code{ftp} のファイ
ル @file{~/.netrc} と同じで、それは @code{ftp} のマニュアルページに定義
されていますが、ここのものは顕著な事実です:

@enumerate
@item
ファイルは一つ以上の行を含み、それぞれは一つのサーバーを定義します。

@item
それぞれの行は任意の数の 区切り印/値 の対を含む事ができます。

有効な区切り印は @samp{machine}, @samp{login}, @samp{password},
@samp{default} です。加えて、gnus は @file{.netrc}/@code{ftp} の構文の原
型には現れない二つの新しい区切り印、名付け
て @samp{port} と @samp{force} を導入します。
(これが @file{.authinfo} ファイルの様式が @file{.netrc} ファイルの様式か
ら逸れる唯一の方法です。) @samp{port} はサーバーのどのポートを認証に用い
るかを示し、@samp{force} は以下で説明します。

@end enumerate

これがそのファイルの例です:

@example
machine news.uio.no login larsi password geheimnis
machine nntp.ifi.uio.no login larsi force yes
@end example

区切り印/値 の対はどのような順番ででも現れる事ができます。例えば、
@samp{machine} は最初に現れる必要はありません。

この例では、ログイン名とパスワードの両方が前者のサーバーには与えられてい
るのに対して、後者はログイン名だけを挙げていて、利用者はパスワードの入力
を促進されます。後者は @samp{force} タグも持っていて、それは接続時
に @var{nntp} サーバーに認証情報 (authinfo) が送られるという事です。ディ
フォルト (すばわち、@samp{force} タグが無いとき) では @var{nntp} サーバー
が認証情報を尋ねない限りそれを @var{nntp} サーバーに送りません。

@samp{machine} 行に合致しない全てのサーバーに適用され
る @samp{default} 行を追加する事もできます。

@example
default force yes
@end example

これは以前に書かれていない全てのサーバーに命令 @samp{AUTHINFO} を強制的
に送ります。

ファイル @file{~/.authinfo} を世界中が読めるような設定に放置しないように
注意してください。

@item nntp-server-action-alist
@vindex nntp-server-action-alist
これはサーバーの型に合致する正規表現と、合致が起こったときに取られる動作
の連想リストです。例えば、gnus に innd に接続したときに毎回ビープ音を鳴
らさせたい (beep) のであれば、次のようにする事ができます:

@lisp
(setq nntp-server-action-list
      '(("innd" (ding))))
@end lisp

まぁ、そのような事はしたくないでしょうけど。

ディフォルトの値は

@lisp
'(("nntpd 1\\.5\\.11t"
   (remove-hook 'nntp-server-opened-hook
                'nntp-send-mode-reader)))
@end lisp

で、これは nntpd 1.5.11t には命令 @code{MODE READER} を送らない事を確実
にします。なぜなら、その命令はそのサーバーを固まらせると私は聞いているか
らです。

@item nntp-maximum-request
@vindex nntp-maximum-request
もし @sc{nntp} サーバーが @sc{nov} ヘッダーの機能を提供していないのであ
れば、このバックエンドは命令 @code{head} をいくつも送って、ヘッダーを集
めます。この動作を速くするために、バックエンドは返答を待たずにこの命令を
たくさん送り、それから全ての返答を読みます。これは変
数 @code{nntp-maximum-request} によって制御され、ディフォルトで 400 です。
もしネットワークが故障がちであるなら、この変数を 1 に設定するべきでしょ
う。

@item nntp-connection-timeout
@vindex nntp-connection-timeout
定期的に接続する外部 @code{nntp} グループがたくさんあるなら、適切に応答
しない @code{nntp} サーバーがあったり、あるサーバーは常識的な時間内では
返答できないくらい負荷がかかっている、などの問題があるでしょう。これは困っ
た問題になることがありますが、@code{nntp-connection-timeout} を設定する
事によりある程度解消する事ができます。これは接続をあきらめるまえに、
@code{nntp} バックエンドが何秒待つかを示す整数です。もしこれ
が @code{nil} であると、これが初期設定ですが、時間切れ切断はなされません。

@c @item nntp-command-timeout
@c @vindex nntp-command-timeout
@c @cindex PPP connections
@c @cindex dynamic IP addresses
@c If you're running Gnus on a machine that has a dynamically assigned
@c address, Gnus may become confused.  If the address of your machine
@c changes after connecting to the @sc{nntp} server, Gnus will simply sit
@c waiting forever for replies from the server.  To help with this
@c unfortunate problem, you can set this command to a number.  Gnus will
@c then, if it sits waiting for a reply from the server longer than that
@c number of seconds, shut down the connection, start a new one, and resend
@c the command.  This should hopefully be transparent to the user.  A
@c likely number is 30 seconds.
@c
@c @item nntp-retry-on-break
@c @vindex nntp-retry-on-break
@c If this variable is non-@code{nil}, you can also @kbd{C-g} if Gnus
@c hangs.  This will have much the same effect as the command timeout
@c described above.

@item nntp-server-hook
@vindex nntp-server-hook
このフックは @sc{nntp} サーバーに接続する最後の一歩として実行されます。

@item nntp-buggy-select
@vindex nntp-buggy-select
あなたの選択の一連の作業が故障がちであるときにこれを @code{nil} でない値
に設定してください。

@item nntp-nov-is-evil
@vindex nntp-nov-is-evil
@sc{nntp} サーバーが @sc{nov} 機能を提供していなければこの変数
を @code{t} に設定する事ができますが、@code{nntp} は普通は @sc{nov} が使
われるかどうかを自動的に調べます。

@item nntp-xover-commands
@vindex nntp-xover-commands
@cindex nov
@cindex XOVER
サーバーから @sc{nov} 行を取得するための命令として使われる文字列のリスト
です。この変数のディフォルトの値は @code{("XOVER" "XOVERVIEW")} です。

@item nntp-nov-gap
@vindex nntp-nov-gap
@code{nntp} は普通はサーバーに @sc{nov} 行のための一つの大きな要求を送り
ます。サーバーは一つの巨大な、行のリストで応答します。しかし、もしグルー
プの 2-5000 の記事を読んで、1 と 5001 を読みたいだけなら、@code{nntp} は
必要無い 4999 の @sc{nov} 行を取得する事になります。この変数
は @code{XOVER} 要求がどれくらい大きな二つの連続した記事群の間のへだた
り (gap) まで分割されないで送られるかを決定します。ネットワークが速い場
合は、この変数を本当に小さな数字に設定するとおそらく取得が遅くなるという
事に注意してください。この変数が @code{nil} であると、@code{nntp} は要求
を分割しません。ディフォルトは 5 です。

@item nntp-prepare-server-hook
@vindex nntp-prepare-server-hook
@sc{nntp} サーバーに接続を試みる前に実行されるフックです。

@item nntp-warn-about-losing-connection
@vindex nntp-warn-about-losing-connection
この変数が @code{nil} でないと、サーバーが接続を閉じたときに少し雑音がた
てられます。

@item nntp-record-commands
@vindex nntp-record-commands
もし @code{nil} でないと、@code{nntp} は @sc{nntp} サーバーに送った全て
の命令を (時刻と共に) @samp{*nntp-log*} バッファに記録します。これは動作
していないと思われる gnus/@sc{nntp} 接続をディバッグしているときに役に立
ちます。

@item nntp-open-connection-function
@vindex nntp-open-connection-function
どのように nntp サーバーと接続するかをカスタマイズすることができます。パ
ラメータ @code{nntp-open-connection-function} を設定すると、gnus は接続
を確立するためにその関数を使います。そのために五つの関数があらかじめ用意
されています。それらは二種類に分類することができ、直接接続するための関数
群 (三つ) と間接的に接続するためのもの (二つ) があります。

@item nntp-prepare-post-hook
@vindex nntp-prepare-post-hook
記事をポストする直前に実行されるフックです。もし記事
に @code{Message-ID} ヘッダーが無くてニュースサーバーが推奨 ID を提供し
てくれるならば、このフックが実行される前にそれが記事に加えられます。これ
は、もしあなたが gnus が @code{Message-ID} ヘッダーを付けないようにして
いても、@code{Cancel-Lock} ヘッダーを作るために利用することができます。
それにはこうすれば良いでしょう:

@lisp
(add-hook 'nntp-prepare-post-hook 'canlock-insert-header)
@end lisp

すべてのサーバーが推奨 ID をサポートしているわけではないことに注意して下
さい。これは例えば INN 2.3.0 以上で動作します。

@item nntp-list-options
@vindex nntp-list-options
LIST コマンドのオプションに使って、(サーバーの) リスト出力を設定したニュー
スグループだけに制限するための、ニュースグループ名のリストです。それぞれ
のニュースグループ名には @dfn{fj.*} や @dfn{japan.*} のような、シェル形
式のワイルドカードを使うことができます。もし幸運にもサーバーがそのような
オプションを受け付けてくれれば、gnus を速く動作させることができるかもし
れません。これは、以下のようにサーバー変数として使うことができます。

@lisp
(setq gnus-select-method
      '(nntp "news.somewhere.edu"
             (nntp-list-options ("fj.*" "japan.*"))))
@end lisp

@item nntp-options-subscribe
@vindex nntp-options-subscribe
合致したら無条件で講読するニュースグループ名の正規表現です。正規表現の文
字列では @dfn{$} の代わりに @dfn{ } を使って下さい。サーバーが LIST コマ
ンドのオプションにシェル形式のワイルドカードを受け付けてくれない場合でも、
@code{nntp-list-options} と同様の効果があるでしょう。これは、以下のよう
にサーバー変数として使うことができます。

@lisp
(setq gnus-select-method
      '(nntp "news.somewhere.edu"
             (nntp-options-subscribe "^fj\\.\\|^japan\\.")))
@end lisp

@item nntp-options-not-subscribe
@vindex nntp-options-not-subscribe
合致しなかったら無条件で講読するニュースグループ名の正規表現です。正規表
現の文字列では @dfn{$} の代わりに @dfn{ } を使って下さい。サーバー
が LIST コマンドのオプションにシェル形式のワイルドカードを受け付けてくれ
ない場合でも、@code{nntp-list-options} と同様の効果があるでしょう。これ
は、以下のようにサーバー変数として使うことができます。

@lisp
(setq gnus-select-method
      '(nntp "news.somewhere.edu"
             (nntp-options-not-subscribe "\\.binaries\\.")))
@end lisp
@end table

@menu
* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数
@end menu

@node Direct Functions
@subsubsection 直接接続するための関数
@cindex direct connection functions

これらの関数は、あなたのマシンと @sc{nntp}サーバーを接続するために直接呼
ばれます。また、それらの動作はそれらが共通に参照する変数に影響されま
す (@pxref{Common Variables})。

@table @code
@findex nntp-open-network-stream
@item nntp-open-network-stream
これはディフォルトで、単純に遠隔システムのポートなどに接続します。

@findex nntp-open-ssl-stream
@item nntp-open-ssl-stream
@dfn{安全な} チャンネルを使ってサーバーに接続します。これを使うためには、
OpenSSL (@uref{http://www.openssl.org}) か SSLeay
(@uref{ftp://ftp.psy.uq.oz.au/pub/Crypto/SSL} と @file{ssl.el} (例え
ば W3 の配布から) が必要) がインストールされていなければなりません。それ
からサーバーを次のように定義します:

@lisp
;; 編集し終わったら `C-c C-c' をタイプして下さい。
;;
;; ポート 563 が "snews" として /etc/services で定義済みであっても
;; openssl s_client -port でその名前は使えません。
;;
(nntp "snews.bar.com"
      (nntp-open-connection-function nntp-open-ssl-stream)
      (nntp-port-number 563)
      (nntp-address "snews.bar.com"))
@end lisp

@findex nntp-open-telnet-stream
@item nntp-open-telnet-stream
単に @samp{telnet} して @sc{nntp} サーバーに接続します。あなたは、ディフォ
ルトの @code{nntp-open-network-stream} がそれをするのにもかかわらず、な
ぜこの関数があるのか不思議に思うかもしれません。その理由 (の一つ) は、も
しあなたが防壁の中にいたとしても @code{runsocks} のようなコマンドラッパー
のおかげで外の世界を直接アクセスできるならば、あなたはそれをこのように使
うことができるのです:

@lisp
(nntp "socksified"
      (nntp-pre-command "runsocks")
      (nntp-open-connection-function nntp-open-telnet-stream)
      (nntp-address "the.news.server"))
@end lisp

Emacs のセッション全体をラップして、ディフォルトのメソッドを使うというの
は、良い案ではありません。
@end table

@node Indirect Functions
@subsubsection 間接的に接続するための関数
@cindex indirect connection functions

これらの関数は、実際に @sc{nntp} サーバーに接続する前に中間のホストに接
続するために間接的に呼ばれます。すべてのこれらの関数と関連する変数
は "via" 接続の仲間に属しているとも言えるので、それを明確にするためにす
べて "via" という接頭辞が付けられます。また、それらの動作はそれらが共通
に参照する変数に影響されます (@pxref{Common Variables})。

@table @code
@item nntp-open-via-rlogin-and-telnet
@findex nntp-open-via-rlogin-and-telnet
遠隔システムに @samp{rlogin} して、そこから本当
の @sc{nntp} サーバーに @samp{telnet} します。これは、例えばあなたが始め
に防壁マシンに接続しなければならない場合に便利です。

@code{nntp-open-via-rlogin-and-telnet}-用の変数:

@table @code
@item nntp-via-rlogin-command
@vindex nntp-via-rlogin-command
中間のホストにログインするために使われるコマンドです。ディフォルト
は @samp{rsh} ですが、@samp{ssh} が人気のある代替手段です。

@item nntp-via-rlogin-command-switches
@vindex nntp-via-rlogin-command-switches
@code{nntp-via-rlogin-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @code{nil} です。も
し @samp{ssh} を @code{nntp-via-rlogin-command} の値として使うならば、デー
タ接続を圧縮するために @samp{("-C")} を使うことができます。あるいは、も
し中間のホストで telnet コマンドが疑似端末を必要とするならば、これ
を @samp{("-t")} または @samp{("-C" "-t")} にして下さい。
@end table

@item nntp-open-via-telnet-and-telnet
@findex nntp-open-via-telnet-and-telnet
本質的には同じことなのですが、中間のホストに接続するため
に @samp{rlogin} の代わりに @samp{telnet} を使います。

@code{nntp-open-via-telnet-and-telnet}-用の変数:

@table @code
@item nntp-via-telnet-command
@vindex nntp-via-telnet-command
中間のホストに @code{telnet} するために使われるコマンドです。ディフォル
トは @samp{telnet} です。

@item nntp-via-telnet-switches
@vindex nntp-via-telnet-switches
@code{nntp-via-telnet-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @samp{("-8")} です。

@item nntp-via-user-password
@vindex nntp-via-user-password
中間のホストにログインするときに使われるパスワードです。

@item nntp-via-envuser
@vindex nntp-via-envuser
もし非@code{nil}なら、中間の @code{telnet} のセッション (クライアントと
サーバーの両方) で @code{ENVIRON} オプションをサポートし、ログイン名の入
力を要求しません。これは例えば Solaris の @code{telnet} で動作します。

@item nntp-via-shell-prompt
@vindex nntp-via-shell-prompt
中間のホストでのシェルのプロンプトに合致する正規表現です。ディフォルト
は @samp{bash\\|\$ *\r?$\\|> *\r?} です。
@end table
@end table

これらは上記の関数が参照する付加的な変数です:

@table @code
@item nntp-via-user-name
@vindex nntp-via-user-name
中間のホストに接続するときに使う利用者名です。

@item nntp-via-address
@vindex nntp-via-address
接続する中間のホストのアドレスです。
@end table

@node Common Variables
@subsubsection 共通の変数

以下の変数は、すべての、またはいくつかのあらかじめ用意されている関数の動
作に影響を及ぼします。設定されていなければ、すべての関数が影響されます。

@table @code
@item nntp-pre-command
@vindex nntp-pre-command
素の接続用の関
数 (@code{nntp-open-network-stream} と @code{nntp-open-ssl-stream} だけ
だと思う) ではないものを通して接続するときに使うコマンドラッパーです。例
えばあなたは @samp{SOCKS} ラッパーを割り当てるでしょう。

@item nntp-address
@vindex nntp-address
@sc{nntp} サーバーのアドレスです。

@item nntp-port-number
@vindex nntp-port-number
接続する @sc{nntp} サーバーのポート番号です。ディフォルト
は @samp{nntp} です。@sc{ssl} を介した @sc{nntp} を使うには、ポートの名
前ではなくて整数 (つまり @samp{snews} ではなくて @samp{563}) を指定して
下さい。外部の SSL ツールはポートの名前では動作しないからです。

@item nntp-end-of-line
@vindex nntp-end-of-line
@sc{nntp} サーバーとお話をしているときに行の終わりの印として使われる文字
列です。これはディフォルトで @samp{\r\n} ですが、素ではない接続用の関数
を使っているときは @samp{\n} であるべきです。

@item nntp-telnet-command
@vindex nntp-telnet-command
@samp{telnet} を通して @sc{nntp} サーバーと接続するときに使うコマンドで
す。これは中間のホストと接続するためのものでは ＊ありません＊。これは単
に本当の @sc{nntp} サーバーと接続するためのものです。ディフォルト
は @samp{telnet} です。

@item nntp-telnet-switches
@vindex nntp-telnet-switches
@code{nntp-telnet-command} に渡すスイッチのリストです。ディフォルト
は @samp{("-8")} です。
@end table

@node News Spool
@subsection ニューススプール
@cindex nnspool
@cindex new spool

ローカルスプールから外部グループを購読する事は非常に簡単で、役に立ちます。
たとえば、非常に大きな記事があるグループ---例え
ば @samp{alt.binaries.pictures.furniture} を読む速度が速くなります。

とにかく、@code{nnspool} を方法として、@code{""} (もしくは何でも) をアド
レスとして指定するだけです。

もしローカルスプールにつなぐ事が可能なら、おそらくそれを基本選択方法とし
て使うべきでしょう (@pxref{Finding the News})。それは普通
は @code{nntp} 選択方法より速いですが、そうでないかもしれません。それは
状況に依存します。何があなたのサイトで一番良いかを見つけるために、いろい
ろと試してみなければなりません。

@table @code
@item nnspool-inews-program
@vindex nnspool-inews-program
記事を投稿するために使われるプログラムです。

@item nnspool-inews-switches
@vindex nnspool-inews-switches
記事を投稿するときに inews プログラムに与えられるパラメータです。

@item nnspool-spool-directory
@code{nnspool} が記事を探すところです。これは普通
は @file{/usr/spool/news/} です。

@item nnspool-nov-directory
@vindex nnspool-nov-directory
@code{nnspool} が @sc{nov} ファイルを探すところです。これは普通
は @file{/usr/spool/news/over.view/} です。

@item nnspool-lib-dir
@vindex nnspool-lib-dir
ニュースのライブラリーディレクトリーの場所です (ディフォルト
で @file{/usr/lib/news/} です)。

@item nnspool-active-file
@vindex nnspool-active-file
アクティブファイルへのパスです。

@item nnspool-newsgroups-file
@vindex nnspool-newsgroups-file
グループ記述ファイルへのパスです。

@item nnspool-history-file
@vindex nnspool-history-file
ニュース履歴ファイルへのパスです。

@item nnspool-active-times-file
@vindex nnspool-active-times-file
現状日付ファイルへのパスです。

@item nnspool-nov-is-evil
@vindex nnspool-nov-is-evil
@code{nil} でないと、@code{nnspool} はそれが見つけたどんな @sc{nov} ファ
イルも使おうとはしません。

@item nnspool-sift-nov-with-sed
@vindex nnspool-sift-nov-with-sed
@cindex sed
@code{nil} でないと、これがディフォルトですが、概観ファイル (overview)
から関連する部分を得るために @code{sed} を使います。もし @code{nil} だと、
@code{nnspool} はファイル全体をバッファに読み込んで、そこで実行します。
@end table

@node Getting Mail
@section メール取得
@cindex reading mail
@cindex mail

ニュースリーダーでメールを読む---それは明白に超自然的な事ではないのです
か? いや、もちろんできます。

@menu
* Mail in a Newsreader::        ニュースリーダでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              どのようにメールグループを作成するか
* Mail Sources::                Gnus にどこからメールを取ってくるかを知
                                らせる
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを、身の毛のよだ
                                つような分割をすることができる
* Group Mail Splitting::        メール分割を駆動するためにグループカスタ
                                マイズを使う
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               欲しくないメールを取り除く
* Washing Mail::                取得したメールから嫌なものを取り除く
* Duplicates::                  重複したメールを扱う
* Not Reading Mail::            他のファイルを読むためにメールバックエ
                                ンドを使う
* Choosing a Mail Back End::    Gnus は色々なメール様式を読む事ができる
@end menu

@node Mail in a Newsreader
@subsection ニュースリーダでメール

あなたが伝統的なメールリーダから gnus に乗り換えることを決断したならば、
あなたはいろいろなカルチャーショックを受けることでしょう。

gnus は伝統的なメールリーダのようなふるまいをしません。あなたが望むな
らそのようにもできますが、それは骨折り損のくたびれ儲けです。

gnus はふつう同じ手法ですべてのグループを扱います。あなたはあるグルー
プを選んで新しい/未読の記事を読む、そして読んだ記事は既読としてマーク
される。あなたが目にするのは (あなたが意図的に尋ねなければ) それだけで
す。これってとてもニュースリーダ的でしょ。

あなたは記事を消すために特別な操作はしません。

このことは既読の記事はすべて消されてしまうことを意味するのかって? そりゃ
あんまりですよね!

そうではありません。古い記事はいろんな仕組みによって @dfn{expire} され
るのです。ニュース記事はニュースの管理人 (が管理しているサーバ) によっ
て expire の処理が制御され、メールの expire の処理はあなたが制御します。
メールの expire については @pxref{Expiring Mail} を参照して下さい。

しばらくメールとニュースの両方を使ってみれば、記事の取り扱いについて配
送の機構が行なうことはわずかであることに気が付きます。

多くの人たちは複数のメーリングリストを講読しています。それら
は @sc{smtp} で配送される、メール、です。それらの記事をとても注意深く読
んでいるにもかかわらず、何週間も返事が無いことがあるでしょう。私たちはそ
ういう記事をセーブする必要はありません。なぜならば、もう一度読む必要が生
じても、それらはどこかに保存されているからです。

ある人たちは小人数に利用されているローカルニュースグループを講読してい
ます。それらは @sc{nntp} で配送される、ニュース、です。私たちは自分の仕
事に役立てるために、それらの膨大な記事の断片を読んだり返事をしなければ
なりません。そしてそれらは保存されていないかもしれませんから、興味のあ
る記事を個人メールと同じように保存しなければならないでしょう。

配送の仕組みの違いはどうでもよいことで、大事なのはいかに主題に興味を持っ
ているかと、もう一度読みたいときにいかに簡単に呼び出せるかなのです。

gnus はメールをニュースグループのように ``グループ'' に並べ変えて、各々
のグループ (メールかニュース) を別個に扱うための豊富な機能を提供します。

ある人たちは gnus (えっへん) のやりかたに満足できなくて、gnus がメール
リーダになることを欲します。gnus をもっとメールリーダ的なものにするた
めに鞭打つことは可能ではあるのですが、前にも言ったように簡単ではありま
せん。いわゆるメールリーダが好みならば @sc{vm} を使いましょう。これは
優秀な、厳密な意味でのメールリーダです。

脅かすわけではないのですが、はっきりさせておきたいのは、あなたに記事に
ついての新しいやり方を修得して欲しいということです。あなたが gnus のや
り方を受け入れてくれた暁には、きっとあなたは gnus が好きになること請け
合いです。

(少くとも、私が gnus に入れた、Emacs のサブリミナル脳味噌洗濯関数を売っ
てくれた人はそれを保証しています。あなたも同化します。あなたは gnus を愛
します。あなたは gnus でのメールの方法を愛します。絶対に。)

@node Getting Started Reading Mail
@subsection メールを読む事を始める

Gnus を使って新しいメールを読む事は非常に簡単です。あなたのメールバック
エンドのあなたの選択を @code{gnus-secondary-select-methods} に放り込むだ
けで、あとのことは自動的に起こります。

例えば、@code{nnml} (これは "一メール一ファイル" バックエンドです) を使
いたいなら、次のものをあなたの @file{.gnus} ファイルに入れる事ができます。

@lisp
(setq gnus-secondary-select-methods '((nnml "")))
@end lisp

今や、次に gnus を起動したときには、このバックエンドは新しい記事を求め、
それはあなたのスプールファイルから全てのメッセージをディレクトリー、ディ
フォルトでは @code{~/Mail/} に移動します。作成された新しいグルー
プ (@samp{mail.misc}) が購読され、他のグループと同じように読む事ができま
す。

あなたはおそらくメールをいくつかのグループに分割したいでしょうけど:

@lisp
(setq nnmail-split-methods
      '(("junk" "^From:.*Lars Ingebrigtsen")
        ("crazy" "^Subject:.*die\\^Organization:.*flabby")
        ("other" "")))
@end lisp

これは結果として三つの新しい @code{nnml} メールグループを作りま
す: @samp{nnml:junk}, @samp{nnml:crazy}, @samp{nnml:other} です。最初
の二つのグループに合わないメールは全て最後のグループに入れられます。

これは gnus でメールを読むために充分であるはずです。マニュアルのこの部分
の他の項を熟読したいと思うかもしれませんが。特
に @pxref{Choosing a Mail Back End} と @pxref{Expiring Mail} を。

@node Splitting Mail
@subsection メールの分割
@cindex splitting mail
@cindex mail splitting

@vindex nnmail-split-methods
変数 @code{nnmail-split-methods} は入ってくるメールをどのようにグループ
分けするかを指定します。

@lisp
(setq nnmail-split-methods
  '(("mail.junk" "^From:.*Lars Ingebrigtsen")
    ("mail.crazy" "^Subject:.*die\\|^Organization:.*flabby")
    ("mail.other" "")))
@end lisp

この変数はリストのリストで、これらのリストの最初のそれぞれの要素がメール
グループの名前で (ところで、それらは @samp{mail} で始まる必要はありませ
ん)、二つめの要素がそれぞれのメールのヘッダーからそれがどのグループに属
するかを決定する正規表現です。最初の文字列は、@code{replace-match} によっ
て、合致した文章からの副表現を挿入するために使われるような、
@code{samp\\1} の様式を含むかもしれません。たとえば:

@lisp
("list.\\1" "From:.* \\(.*\\)-list@@majordomo.com")
@end lisp

二番目の要素は関数である事もできます。その場合は、それは法則の最初の要素
を引数として、ヘッダーに範囲を狭めて (narrowed to headers) 呼ばれます。
それは、メールがそのグループに属すると考えるのであれば、@code{nil} でな
い値を帰す必要があります。

これらの最後は常に総合的なものであるべきで、他の正規表現に合致しないメー
ルに合致するために、この正規表現は @emph{いつも} @samp{}であるべきです。
(これらの法則は連想リストの初めから終わりまで順番に実行されます。相互投
稿 (crosspost) を使用可能にしていない限り、最初の合致した法則が "勝ちま
す"。相互投稿を使用可能にしている場合、全ての合致した法則が "勝ちます"。)

もしあなた自身でこれをいじくりまわしたいときは、あなたの選んだ関数をこの
変数に設定する事ができます。この関数は入って来たメールメッセージのヘッダー
に範囲を狭められたバッファで引数なしで呼ばれます。この関数は、それがこの
メールメッセージを運ぶべきである、と考えるグループ名のリストを返すべきで
す。

全てのメールバックエンドは、入って来た貧乏で純粋なヘッダーを乱暴に扱って
も良い事に注意してください。それらはすべて @code{Lines} ヘッダーを追加し
ます。いくつかは @code{X-Gnus-Group} ヘッダーを加えます。たいていのもの
は Unix の mbox の @code{From<SPACE>} 行を何か別の名前に変えます。

@vindex nnmail-crosspost
メールバックエンドはすべて相互投稿の機能を提供しています。いくつかの正規
表現が合致すると、メールは全てのグループに ``相互投稿'' されます。
@code{nnmail-crosspost} はこの機能を使うかどうかを指定します。どの記事も
総合の (@samp{}) グループに相互投稿されない事に注意してください。

@vindex nnmail-crosspost-link-function
@cindex crosspost
@cindex links
@code{nnmh} と @code{nnml} は相互投稿された記事にハードリンク (hardlink)
を作る事によって相互投稿を行います。しかし、全てのファイルシステムがハー
ドリンクの機能を提供しているわけではありません。もしあなたがその場合に当
てはまるのであれば、
@code{nnmail-crosspost-link-function} を @code{copy-file} に設定してくだ
さい。(この変数はディフォルトで @code{add-name-to-file} です。)

@kindex M-x nnmail-split-history
@kindex nnmail-split-history
前のメール分割がメッセージをどこに入れたかを見たい場合は、命令 @kbd{M-x
nnmail-split-history} を使う事ができます。これからスプールし直そうとする
メッセージがどこに入るかを見たい場合は、
@code{gnus-summary-respool-trace} と関連する命
令 (@pxref{Mail Group Commands}) を使う事ができます。

@vindex nnmail-split-header-length-limit
@code{nnmail-split-header-length-limit} の制限より長いヘッダー行は、分割
関数の処理対象から除外されます。

@vindex nnmail-mail-splitting-charset
@vindex nnmail-mail-splitting-decodes
(訳注: オリジナルの Gnus とは仕様が微妙に異なることに注意して下さい) ディ
フォルトでは分割コードは @sc{mime} エンコードされたヘッダーをデコードす
るので、非-ASCII 文字列にマッチさせることができます。変
数 @code{nnmail-mail-splitting-charset} が @sc{mime} 文字集
合 (mime-charset) であったらそれ、@sc{mime} 文字集合ではない
非-@code{nil} な値だったらそのときの @code{default-mime-charset} の値で、
(@sc{mime} エンコードされたものではない) 非-ASCII ビットパターンもデコー
ドします。この動作は @code{nnmail-mail-splitting-decodes} を nil にする
ことによって完全に止めることができ、生のヘッダーのデータを元に記事にマッ
チさせたい場合には有効でしょう。

Gnus はあなたに自分自身に跳ね返ってくるような可能性のある全ての機会を提
供します。例えば、あなたの上司からくる全てのメールを含んだグループを作っ
たとしましょう。それから、偶発的にそのグループの購読取り止めが起こったと
します。Gnus はそれでも上司からの全てのメールを未購読のグループに入れま
すので、上司が ''月曜日までにその報告書を準備しないと首だ!'' というメー
ルをあなたに送っても、あなたはそれを見る事はなく、火曜日になって本当は翌
月の家賃を払うために空のボトルを集めるべきであっても、まだ有給で雇われて
いると信じているかもしれません。

@node Mail Sources
@subsection Mail Sources

いろんなところからメールを取得することができます---メールスプール、
POP メールサーバー、procmail ディレクトリー、maildir などが例としてあり
ます。

@menu
* Mail Source Specifiers::      メールの元がどこかを指定する
* Mail Source Customization::   世の中に影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使用する
@end menu

@node Mail Source Specifiers
@subsubsection メールソース指示子
@cindex POP
@cindex mail server
@cindex procmail
@cindex mail spool
@cindex mail source

@dfn{メールソース指示子} に @code{メールソース} (@pxref{Fetching Mail})
を設定することで、gnus にメールを取得する方法を教えることができます。

これは例です:

@lisp
(pop :server "pop3.mailserver.com" :user "myname")
@end lisp

御覧の通り、メールソース指示子はリストで、最初の要素は @dfn{メールソース
の型}、その次は任意の数の @dfn{キーワード} となります。明示的に指定され
ていないキーワードは初期値になります。

以下のメールソースの型を使用可能です:

@table @code
@item file
単独のファイルからメールを取得します。普通はメールスプールです。

キーワード:

@table @code
@item :path
ファイルのパスです。初期値は @code{MAIL} 環境変数の値
か @code{rmail-spool-directory} の値 (普通
は @file{usr-mail/spool/user-name} のようなもの) です。
@end table

ファイルメールソースの例:

@lisp
(file :path "/usr/spool/mail/user-name")
@end lisp

もしくは、初期パスを使うと:

@lisp
(file)
@end lisp

メールスプールファイルがローカルマシンに無い場合は、POP や @sc{imap} な
どでメールを取得するのが最善です。ここでは ange-ftp のファイル名は使用で
きません---メールを移動しているときにメールスプールをロックする方法があ
りません。

適切なサーバーを設置することが不可能なら、変わりに  ssh を使うことができ
ます。

@lisp
(setq mail-sources
      '((file :prescript "ssh host bin/getmail >%t")))
@end lisp

@samp{getmail} スクリプトは以下のようなものになります:

@example
#!/bin/sh
#  getmail - move mail from spool to stdout
#  flu@@iki.fi

MOVEMAIL=/usr/lib/emacs/20.3/i386-redhat-linux/movemail
TMP=$HOME/Mail/tmp
rm -f $TMP; $MOVEMAIL $MAIL $TMP >/dev/null && cat $TMP
@end example

目的に合うように使用したい @samp{movemail} に合わせてスクリプトを書き換
えてください。

@item directory
ディレクトリー中の複数のファイルからメールを取得します。これは普通
は procmail に新しいメールをいくつかのファイルに分割させているときに使用
されます。すなわちファイル @file{foo.bar.spool} にあるメールは、グルー
プ @code{foo.bar} に置かれます (サフィックス @code{.spool} は変更可能で
す)。@code{nnmail-scan-directory-mail-source-once} を @code{nil} 以外に
すると、gnus は新しいメールソースを一回だけ調べるようになります。これは、
指定したレベルのメールグループだけを調べたいときに、とりわけ便利です。

@code{nnmail-resplit-incoming} という変数もあり、これを非-@code{nil} に
すると通常の分割処理がディレクトリー中のすべてのファイルに対して行なわれ
ます。

キーワード:

@table @code
@item :path
ファイルのあるディレクトリーのパスです。これには初期値はありません。

@item :suffix
この接尾語で終わるファイルだけが使用されます。初期値は @samp{.spool} で
す。

@item :predicate
この述語が @code{nil} でない値を返すファイルのみです。初期値
は @code{identity} です。これは追加の選別器として使用されます---正しい接
尾語 @emph{と} この述語を満足するファイルだけが考慮されます。

@item :prescript
@itemx :postscript
メールの取得の前/後に実行されるスクリプトです。
@end table

ディレクトリーメールソースの例です:

@lisp
(directory :path "/home/user-name/procmail-dir/"
           :suffix ".prcml")
@end lisp

@item pop
POP サーバーからメールを取得します。

キーワード:

@table @code
@item :server
POP サーバーの名前です。初期値は @code{MAILHOST} 環境変数から取得されま
す。

@item :port
POP サーバーのポート番号です。これは数値 (例えば @samp{:port 1234}) か文
字列 (例えば @samp{:port "pop3"}) です。もし文字列なら Unix システムにお
ける @file{/etc/services} に載っているサービス名でなければなりません。初
期値は @samp{pop3} です。システムによっては @samp{"pop-3"} としなければ
ならないかもしれません。

@item :user
POP サーバーに与える利用者名です。初期値はログイン名です。

@item :password
POP サーバーに与えるパスワードです。指定されない場合は、利用者は入力を促
進されます。

@item :program
POP サーバーからメールを取得するために使用されるプログラムです。これ
は @code{format} のような文字列であるべきです。例です:

@example
fetchmail %u@@%s -P %p %t
@end example

有効な書式使用指示文字は:

@table @samp
@item t
メールが移動されるファイルの名前です。これは常にこの文字列に含まれていな
ければなりません。

@item s
サーバーの名前です。

@item P
サーバーのポート番号です。

@item u
使用する利用者名です。

@item p
使用するパスワードです。
@end table

これらの仕様で使われる値は対応するキーワードに与えた値から取られます。

@item :prescript
メールを取得する前に実行されるスクリプトです。構文は @code{:program} キー
ワードと同じです。これは実行される関数であることもできます。

@item :postscript
メールを取得した後に実行されるスクリプトです。構文は @code{:program} キー
ワードと同じです。これは実行される関数であることもできます。

@item :function
POP サーバーからメールを取得するために使う関数です。その関数は一つのパラ
メータとともに呼ばれます---メールがそこへ移動されるべきファイルです。

@item :authentication
これは @code{password} かシンボル @code{apop} で、どの認証方式を使うかを
決めるもののどちらかです。初期設定は @code{password} です。

@item :connection
サーバーに接続するときに使うストリームで、@code{ssl}, @code{tls} または
それ以外を指定できます。ディフォルトは @code{nil} で、安全ではない接続を
用います。SSL/TLS では外部プログラムとライブラリが必要であることに注意し
て下さい:

@itemize @bullet
@item
@dfn{ssl:} SSL を使います。OpenSSL (@samp{openssl} プログラム) か SSLeay
(@samp{s_client}) と外部ライブラリ @samp{ssl.el} が必要です。
@item
@dfn{starttls:} STARTTLS (SSL に類似) を使います。外部ライブラ
リ @samp{starttls.el} と @samp{starttls} プログラムが必要です。
@samp{starttls}.
@end itemize

@item :leave
非-@code{nil} でメールをサーバーに残し、メッセージの取得に UIDL を使いま
す。ディフォルトは @code{nil} です。
@end table

@code{:program} と @code{:function} キーワードが指定されていないと、
@code{pop3-movemail} が使用されます。

これはいくつかの例です。初期利用者名で、初期 POP サーバーから取得し、初
期取得方法を使用します:

@lisp
(pop)
@end lisp

指名されたサーバーから指名された利用者とパスワードで取得します:

@lisp
(pop :server "my.pop.server"
     :user "user-name" :password "secret")
@end lisp

メールの移動に @samp{movemail} を使います:

@lisp
(pop :program "movemail po:%u %t %p")
@end lisp

@item maildir
Maildir からメールを取得します。これは現在 qmail と postfix でのみでサポー
トされている mailbox 形式で、特別のディレクトリーのそれぞれのファイルが
正確に 1 メールとなっています。

キーワード:

@table @code
@item :path
メールが保存されるディレクトリーのパスです。初期値は環境変
数 @code{MAILDIR} から取得した値か、または @samp{~/Maildir/} です。
@item :subdirs
Maildir のサブディレクトリです。初期値は @samp{("new" "cur")} です。

@c Gnus で取得する前に、ときどき pop3 デーモンでメールを探すなら、以下の最
@c 初の例のように、maildir の中の @code{cur} ディレクトリーからもメールを取
@c 得する必要があります。

リモートマシンからメールを取り寄せることも出来ます。
(というのも、maildir はロックの問題を気にせずに済むから。)
@end table

Maildir メールソースの例をふたつ:

@lisp
(maildir :path "/home/user-name/Maildir/"
         :subdirs ("cur" "new"))
@end lisp

@lisp
(maildir :path "/user@@remotehost.org:~/Maildir/"
         :subdirs ("new"))
@end lisp

@item imap
@sc{imap} サーバーからメールを取得します。何らかの理由で @sc{imap} を意
図されたようなネットワーク上でメールを読むプロトコルとして扱いたくないと
きは、gnus では POP サーバーと同様に扱うことができ、与えられ
た @sc{imap} メールボックスから記事を取得します。詳しくは @xref{IMAP} を
参照して下さい。

Kerberos, GSSAPI, SSL/TLS および STARTTLS のための外部プログラムとライブ
ラリが必要であることに留意して下さい。@xref{IMAP}

キーワード:

@table @code
@item :server
@sc{imap} サーバーの名前。初期値は環境変数 @code{MAILHOST} から得ます。

@item :port
@sc{imap} サーバーのポート番号。普通は初期値は @samp{143} で、SSL/TLS 接
続には @samp{993} です。

@item :user
@sc{imap} サーバーに渡す利用者名です。初期値はログイン名です。

@item :password
@sc{imap} サーバーに渡すパスワードです。指定されていないときは、利用者は
入力を促されます。

@item :stream
サーバーに接続するときに使うストリーム。@code{imap-stream-alist} にある
シンボルの中のひとつを設定します。現状では @samp{gssapi},
@samp{kerberos4}, @samp{starttls}, @samp{ssl}, @samp{shell} または初期値
の @samp{network} になります。

@item :authentication
サーバーでの認証にどの認証法を使うか。これ
は @code{imap-authenticator-alist} のシンボルの一つを設定します。現状で
は @samp{gssapi}, @samp{kerberos4}, @samp{digest-md5}, @samp{cram-md5},
@samp{anonymous} または初期値の @samp{login} になります。

@item :program
:stream に `shell' が設定されているときは、この値が変
数 `imap-shell-program' に割り当てられます。これは @code{format} ふうの
文字列 (または文字列のリスト) でなければなりません。例を示しましょう。

@example
ssh %s imapd
@end example

有効な format 指示子は以下の通りです。

@table @samp
@item s
サーバーの名前。

@item l
`imap-default-user' で設定されたユーザ名。

@item p
サーバーのポート番号。
@end table

これらの指定に使われる値は、対応するキーワードに与えた値から取ってきます。

@item :mailbox
メールを取得するメールボックスの名前。初期値は @samp{INBOX} で、これは普
通は入ってくるメールを受け取るメールボックスです。

@item :predicate
取得する記事を決定するために使われる述語。初期値の、@samp{UNSEEN
UNDELETED} はおそらくたいていの人には最良の選択でしょうが、ときど
き @sc{imap} クライアントでメールボックスを覗き、いくつかの記事に既
読 (もしくは、SEEN) の印を付けるなら、@samp{1:*} に設定したいかもしれま
せん。そうすれば、メールボックスの全ての記事は印の如何に関わらず取得され
ます。述語の完全な一覧は、RFC2060 の 6.4.4 節を読んでください。

@item :fetchflag
サーバーで、取得した記事に印を付ける方法。初期値の @samp{\Deleted} はそ
れらに消去の印を付けますが、他に @samp{\Seen} では単に既読の印を付けます。
これらは最もありそうな二つの選択ですが、他の印も RFC2060 の 2.3.2 節で定
義されています。

@item :dontexpunge
@code{nil} でなかったら、記事を取得した後で、それらに消去の印が付いてい
ても削除しません。
@end table

@sc{imap} メールソースの例:

@lisp
(imap :server "mail.mycorp.com"
      :stream kerberos4
      :fetchflag "\\Seen")
@end lisp

@item webmail
@uref{www.hotmail.com}, @uref{webmail.netscape.com},
@uref{www.netaddress.com}, @uref{www.yahoo.com} などのウェブメールサーバー
からメールを取得します。

注: ウェブメールはクッキーに大きく依存します。url "4.0pre.46" を使う場合
は "one-line-cookie" パッチを当てる必要があります。

警告: メールが失われるかもしれません。無保証です。

キーワード:

@table @code
@item :subtype
ウェブメールサーバーの型です。初期値は @code{hotmail} です。他の候補
は @code{netscape}, @code{netaddress}, @code{my-deja} です。

@item :user
ウェブメールサーバーの利用者名です。初期値はログイン名です。

@item :password
ウェブメールサーバーのパスワードです。指定しない場合は、利用者に入力を促
します。

@item :dontexpunge
@code{nil} でなかったら、未読の記事だけを取得して、それらをごみ箱のフォ
ルダーに移動しません。
@end table

ウェブメールのソースの例です:

@lisp
(webmail :subtype 'hotmail
         :user "user-name"
         :password "secret")
@end lisp
@end table

@table @dfn
@item Common Keywords
共通キーワードはどんな型のメールソースにも使うことができます。

キーワード:

@table @code
@item :plugged

@code{nil} でなかったら、gnus が @dfn{unplugged} であってもメールを取得
します。もしあなたがディレクトリをメールソースに使っているならば、この例
のように指定することができます:

@lisp
(setq mail-sources
      '((directory :path "/home/pavel/.Spool/"
                   :suffix ""
                   :plugged t)))
@end lisp

あなたが @dfn{unplugged} であっても gnus はメールを取得します。これは、
ローカルのメールとニュースを使う場合に便利です。
@end table
@end table

@subsubsection Function Interface

上記のいくつかのキーワードは、実行するための Lisp 関数を指定します。関数
が実行されている間だけ、それぞれのキーワード @code{:foo} の値として Lisp
 変数 @code{foo} が使われます。例えば、以下のメールソースの設定例につい
て考えてみて下さい。

@lisp
(setq mail-sources '((pop :user "jrl"
                          :server "pophost" :function fetchfunc)))
@end lisp

関数 @code{fetchfunc} が実行されているとき、@code{user} というシンボルの
値は @code{"jrl"} になり、@code{server} というシンボルの値
は @code{"pophost"} になります。
@code{port}, @code{password}, @code{program}, @code{prescript}, @code{postscript}, @code{function} お
よび @code{authentication} の値もまた、それらの既定値になります。

それぞれの型のメールソースのためのキーワードのリストについては、上記を参
照して下さい。

@node Mail Source Customization
@subsubsection メールソースのカスタマイズ

以下はメールの取得方法に影響する変数の一覧です。普通はこれらはどれも設定
する必要はないでしょう。

@table @code
@item mail-source-crash-box
@vindex mail-source-crash-box
メールを操作している間に保存されている場所です。初期値
は @file{~/.emacs-mail-crash-box} です。

@item mail-source-delete-incoming
@vindex mail-source-delete-incoming
@code{nil} でなければ、入って来たファイルは、それを処理した後に消去され
ます。

@item mail-source-directory
@vindex mail-source-directory
ファイルが (もしあれば) 保存されるディレクトリーです。初期値
は @file{~/Mail/} です。現時点では、これが使われる唯一のものは前の変数
が @code{nil} であった場合、入ってきたファイルが保存される場所の指定です。

@item mail-source-incoming-file-prefix
@vindex mail-source-incoming-file-prefix
入ってきたメールを保存するファイルのプレフィックスです。初期値
は @file{Incoming} で、この場合ファイル
は @file{Incoming30630D_} や @file{Incoming298602ZD} のようになります。
@code{mail-source-delete-incoming} が @code{nil} の場合だけですが。

@item mail-source-default-file-modes
@vindex mail-source-default-file-modes
全ての新しいメールファイルはこのファイルモードになります。初期値
は 384 です。

@item mail-source-movemail-program
@vindex mail-source-movemail-program
非-nil だったら新着メールの取り込むためのプログラムの名前。nil だった
ら @var{exec-directory} にある @code{movemail}。
@end table

@node Fetching Mail
@subsubsection メールの取得

@vindex mail-sources
@vindex nnmail-spool-file
実際に gnus にどこから新しいメールを取得するかを教えるには、
@code{mail-sources} をメールソース指示子のリストに設定することで
す (@pxref{Mail Source Specifiers})。

この変数 (と旧式の @code{nnmail-spool-file}) が @code{nil} であれば、メー
ルバックエンドは決して自分自身ではメールを取得しようとしません。

ローカルのスプールと POP メールサーバーの両方からメールを取得したいなら、
このようにすることができます:

@lisp
(setq mail-sources
      '((file)
        (pop :server "pop3.mail.server"
             :password "secret")))
@end lisp

もしくは、これらのキーワードの初期値を使いたくなければ:

@lisp
(setq mail-sources
      '((file :path "/var/spool/mail/user-name")
        (pop :server "pop3.mail.server"
             :user "user-name"
             :port "pop3"
             :password "secret")))
@end lisp

メールバックエンドを使うときは、gnus は全てのメールを inbox から吸い上げ
て、ホームディレクトリーに放り投げます。あなたがメールバックエンドを使っ
ていない場合は、gnus は一通もメールを移動しません---最初に魔法の呼び出し
をたくさんしなければなりません。まず五角形を描き、蝋燭に火を付け、山羊を
生け贄として捧げ終えた後で、gnus があなたのメールを移動しても本当にあま
り驚いてはいけません。

@node Mail Back End Variables
@subsection メールバックエンド変数

これらの変数は (たいていの場合) 全ての違ったメールバックエンドに関連しま
す。

@table @code
@vindex nnmail-read-incoming-hook
@item nnmail-read-incoming-hook
メールバックエンドは新しいメールを読み込んだ後にこのフックを呼びます。も
しそうしたいと思うなら、このフックをメール監視プログラムに知らせるために
使う事ができます。

@vindex nnmail-split-hook
@item nnmail-split-hook
@findex article-decode-encoded-words
@findex RFC1522 decoding
@findex RFC2047 decoding
それぞれのメッセージがそのヘッダーに基づいて分割がなされる直前にそれが保
存されているバッファで実行されるフックです。このフックはそれが適合すると
考えるように自由にバッファの内容を編集する事ができます---バッファは分割
が終わった後で消去され、バッファで行われた変更はどのファイルにも現れませ
ん。@code{gnus-article-decode-rfc1522} がこのフックに加える事が適切な関
数の一つです。

@vindex nnmail-pre-get-new-mail-hook
@vindex nnmail-post-get-new-mail-hook
@item nnmail-pre-get-new-mail-hook
@itemx nnmail-post-get-new-mail-hook
これらは入ってくるメールを扱うときに実行される役に立つ二つのフックで
す---@code{nnmail-pre-get-new-mail-hook} (これは新しいメールを扱う直前に
呼ばれます) と @code{nnmail-post-get-new-mail-hook} (これはメールの扱い
が終わったときに呼ばれます) です。次のものは、この二つのフックを使って新
しいメールファイルに与えられる初期ファイルモードを変更する例です:

@lisp
(add-hook 'nnmail-pre-get-new-mail-hook
          (lambda () (set-default-file-modes 511)))

(add-hook 'nnmail-post-get-new-mail-hook
          (lambda () (set-default-file-modes 551)))
@end lisp

@item nnmail-use-long-file-names
@vindex nnmail-use-long-file-names
@code{nil} でないなら、メールバックエンドは長いファイル名とディレクトリー
名を使います。@samp{mail.misc} のようなグループ名は @file{mail.misc} と
いうディレクトリー (@code{nnml} バックエンドが使われているとみなすと) か
ファイル (@code{nnfolder} バックエンドが使われているとみなすと) という結
果になります。もしそれが @code{nil} であるなら、同じグループ
は @file{mail/misc} という結果になります。

@item nnmail-delete-file-function
@vindex nnmail-delete-file-function
@findex delete-file
ファイルを消去するために呼ばれる関数です。初期値
は @code{delete-file} です。

@item nnmail-cache-accepted-message-ids
@vindex nnmail-cache-accepted-message-ids
@code{nil} でないと、バックエンドに入って来た記事 (例えば、@code{Gcc} に
よって) の @code{Message-ID} をメール重複発見ファイルに入れます。ディフォ
ルトは @code{nil} です。

@item nnmail-cache-ignore-groups
@vindex nnmail-cache-ignore-groups
正規表現か正規表現のリストです。正規表現にグループ名がマッチする
と @code{Message-ID} キャッシュに記録されません。

例えば特級分割 (@pxref{Fancy Mail Splitting}) を関
数 @code{nnmail-split-fancy-with-parent} とともに使っている場合に役立つ
でしょう。
@end table

@node Fancy Mail Splitting
@subsection 特級メール分割
@cindex mail splitting
@cindex fancy mail splitting

@vindex nnmail-split-fancy
@findex nnmail-split-fancy
比較的単純な標準のメール分割指定の方法ではあなたの望む事ができない場合、
@code{nnmail-split-methods} を @code{nnmail-split-fancy} に設定する事が
できます。それから変数 @code{nnmail-split-fancy} で遊ぶ事ができます。

まずこの変数の値の例を見てみましょう:

@lisp
;; メールデーモン (mailer deamon) は普通のグループには相互投稿されませ
;; ん。警告は本当のエラーとは違ったグループに入れられます。
(| ("from" mail (| ("subject" "warn.*" "mail.warning")
                   "mail.misc"))
   ;; エラーでないメッセージは全ての関連したグループに相互投稿されます
   ;; が、(ding) リストと他の (ding) 関連のメールのためのグループには
   ;; 相互投稿しません。
   (& (| (any "ding@@ifi\\.uio\\.no" "ding.list" "ding.list")
         ("subject "ding" "ding.misc"))
      ;; 他のメーリングリスト...
      (any "procmail@@informatik\\.rwth-aachen\\.de" "procmail.list")
      (any "SmartList@@informatik\\.rwth-aachen\\.de" "SmartList.list")
      ;; 以下のどちらのメーリングリストも同じ接頭辞なので、bugs-
      ;; だけに投稿されたものが mypkg.list に相互投稿されないよ
      ;; うにしています。しかし本当に相互投稿された記事を相互投稿
      ;; することは許しています。
      (any "bugs-mypackage@@somewhere" "mypkg.bugs")
      (any "mypackage@@somewhere\" - "bugs-mypackage" "mypkg.list")
      ;; 人々...
      (any "larsi@@ifi\\.uio\\.no" "people.Lars_Magne_Ingebrigtsen"))
   ;; 合致しなかったメールは全てを捕まえるグループへ行きます。
   "misc.misc")
@end lisp

この変数は @dfn{分割} の様式になっています。分割は (あるいは) それぞれの
分割が他の分割を含む再帰的構造です。これは使用可能な五つの分割構文です:

@enumerate

@item
@samp{group}: もし分割が文字列であると、それはグループ名としてみなされま
す。普通の正規表現の合致がなされます。例は下の方を見て下さい。

@item
@code{(@var{field} @var{value} @code{[-} @var{restrict} @code{[@dots{}]}@code{]} @var{split})}:
もし分割がリストで、最初の要素が文字列であり、ヘッダー @var{field} (正規
表現) が @var{value} (これも正規表現) を含んでいる場合、メッセージ
を @var{split} で指定されたところに蓄積します。@var{restrict} (また他の
正規表現) が @var{field} の後で、合致した @var{value} の最後の前のいくつ
かの文字列に合致したら、@var{split} は無視されます。@var{restrict} の閉
包のどれもが合致しなければ @var{split} が実行されます。

@item
@code{(| @var{split}@dots{})}: 分割がリストで、最初の要素
が @code{|} (垂直棒) であると、それぞれの @var{split} をそのうちの一つが
合致するまで実行します。@var{split} はメールメッセージが一つ以上のグルー
プに蓄積されたときに ``合致した'' とします。

@item
@code{(& @var{split}@dots{})}: 分割がリストで、最初の要素が @code{&} で
あると、リストの全ての @var{split} (複数) を実行します。

@item
@code{junk}: もし分割がシンボル @code{junk} であると、そのメッセージを保
存しません (すなわち、消去してしまいます)。非常に注意して使って下さい。

@item
@code{(: @var{function} @var{arg1} @var{arg2} @dots{})}: もし分割がリス
トで、最初の要素が @code{:} であると、二番目の要素が @var{args} を引数と
して関数として呼ばれます。関数は @var{split} を返すべきです。

@cindex body split
例えば以下の関数は、記事のボディに基づいた分割に使えるでしょう:

@lisp
(defun split-on-body ()
  (save-excursion
    (set-buffer " *nnmail incoming*")
    (goto-char (point-min))
    (when (re-search-forward "Some.*string" nil t)
      "string.group")))
@end lisp

@code{:} が使われるとき、バッファ @samp{" *nnmail incoming*"} はメッセー
ジの部分に狭められます。

@item
@code{(! @var{func} @var{split})}: 分割がリストで、最初の要素
が @code{!} であると @var{split} が実行され、
@var{func} は @var{split} の結果を引数として呼ばれます。@var{func} は分
割を返すべきです。

@item
@code{nil}: もし分割が @code{nil} であれば、それは無視されます。

@end enumerate

これらの分割で、@var{fileld} は完全なフィールド名に合致しなければなりま
せん。@var{value} は基礎モード (fundamental mode) 構文テーブル (syntax
table) に従って完全に合致しなければなりません。正規表現でフィールド名か
語の部分に合致させるために @code{.*} を使う事ができます。言い換えれば、
全ての @var{value} は @samp{\<} と @samp{\>} の対で囲まれます。

@vindex nnmail-split-abbrev-alist
@var{field} と @var{value} は lisp シンボル (symbol) である事もでき、そ
の場合はそれらは @code{nnmail-split-abbrev-alist} で指定されているように
展開されます。これはセルの @code{car} がキーを含んでいて、@code{cdr} が
関連付けられた値を持っているコンスセル (cons cell) の連想リストです。

@vindex nnmail-split-fancy-syntax-table
@code{nnmail-split-fancy-syntax-table} がこれらの全ての分割が実行されて
いるときに有効な構文テーブルです。

ヘッダーのいくつかの情報に基づいて、gnus に動的にグループを作らせたいの
であれば (例えば、グループ名で @code{replace-match} のような代用をする)、
次のような事ができます。

@example
(any "debian-\\b\\(\\w+\\)@@lists.debian.org" "mail.debian.\\1")
@end example

この例では、@samp{debian-foo@@lists.debian.org} に送られたメール
は @samp{mail.debian.foo} という風になります。

もし文字列が要素 @samp{\&} を含んでいると、代わりに前で合致した文字列が
使われます。同様に、要素 @samp{\\1} から @samp{\\9} まではグループ付
け 1 から 9 までで合致した文字列で代替されます。

@findex nnmail-split-fancy-with-parent
関数 @code{nnmail-split-fancy-with-parent} は、フォローアップ記事を親記
事と同じグループに振り分けるために使います。メールの振り分けを一生懸命設
定してみても完璧にはできないことがありますね。 例えば、上司から個人宛て
のメールが届いたとします。自分が携っているプロジェクトとは別の話です。け
れど「他のメールと区別できるようにこれこれこういう言葉を表題に書いてくだ
さい」と上司に向かって指図するわけにはいきませんから、結局自分の手を煩わ
してひとつひとつメールを正しいグループに振り分けるはめになります。そんな
ときにこの関数を使うと、この面倒な作業を 1 スレッドにつき 1 回きりで済ま
すことができます。

この機能を利用するためには、まず変
数 @code{nnmail-treat-duplicates} と @code{nnmail-cache-accepted-message-ids} の
値を非-nil に設定する必要があります。それができた
ら @code{nnmail-split-fancy-with-parent} を使ってみてください。コロンを
使ってこんな風に書きます:
@lisp
(setq nnmail-treat-duplicates 'warn     ; または 'delete
      nnmail-cache-accepted-message-ids t
      nnmail-split-fancy
      '(| (: nnmail-split-fancy-with-parent)
          ;; 残りの振り分け方はここに書く
        ))
@end lisp

この機能は実際、次の様に働いています: 変数
@code{nnmail-treat-duplicates} の値が非-nil の場合、Gnus は見つけた全記
事のメッセージ ID を 変数 @code{nnmail-message-id-cache-file} が指定する
ファイルに記録します。このとき、それぞれの記事が存在するグループの名前を
併記します (ただしメールの場合だけ、さもなければグループ名は調べません)。
さて、いよいよメールの振り分けが始まると、関数
@code{nnmail-split-fancy-with-parent} は、対象となる各記事の References
(と In-Reply-To) ヘッダを調べ、@code{nnmail-message-id-cache-file} に指
定されているファイルにそれらのメッセージ ID があるかどうか調べます。親記
事が見つかると、そのグループ名が正規表
現 @code{nnmail-split-fancy-with-parent-ignore-groups} にマッチしなけれ
ば、この関数は対応するグループ名を返すわけです。ここで、変
数 @code{nnmail-message-id-cache-length} の値を既定値よりも幾らか大きな
値に設定することをお勧めします。そうすると、今調べられたメッセージ ID 達
は今しばらくキャッシュの中に存続できます (5000 に設定するとキャッシュファ
イルの大きさはだいたい 300 キロバイトぐらいになるみたいです)。
@vindex nnmail-cache-accepted-message-ids
さらに、変数 @code{nnmail-cache-accepted-message-ids} の値を
非-@code{nil} に設定すれば、gnus は移動された記事のメッセージ ID をも記
録するので、フォローアップ記事は親記事の移動先と同じグループに入るように
なります。

あるグループをキャッシュに記録したくない場合は、変
数 @code{nnmail-cache-ignore-groups} も参照して下さい。例えば、外に出す
すべてのメッセージが `outgoing' グループで書かれているならば、
@code{nnmail-cache-ignore-groups} をそのグループ名にマッチするように設定
するのが良いです。さもないとあなたのすべてのメッセージに対する返事が、最
後は `outgoing' グループに入ってしまうでしょう。

@node Group Mail Splitting
@subsection グループメール分割
@cindex mail splitting
@cindex group mail splitting

@findex gnus-group-split
たーくさんのメーリングリストを購読しているけれど、手でメール分割規則を維
持したくないときは、グループメール分割というものがあなたのためにあります。
グループパラメータかグループカスタマイズ
で @var{to-list}, @var{to-address} の両方もしくはどちらかを設定し
て @code{nnmail-split-methods} を @code{gnus-group-split} に設定するだけ
です。分割関数は全てのグループでこれらのパラメータを走査し、それに従って
分割します。すなわち、メールグループのパラメー
タ @var{to-list} か @var{to-address} で指定されたアドレスから投稿された
ものか、そのアドレスへ投稿されたメッセージがそのグループに保存されます。

ときには、メーリングリストには複数のアドレスがあり、メール分割にそれら全
てを認識させたいと思うときがあるかもしれません: @var{extra-aliases} グルー
プパラメータを追加のアドレスのリストに設定するだけで終りです。正規表現を
使いたければ、@var{split-regexp} を設定してください。

これらの全てのグループのパラメータは、@code{nnmail-split-fancy} 分割を作
成するために使用され、それは @var{field} が @samp{any} で、
@var{value} が @var{to-list}, @var{to-address}, @var{extra-aliases} の全
て、@var{split-regexp} の全ての合致に合致する単独の正規表現、
@var{split} がグループの名前になります。@var{restrict} も使用できます:
@var{split-exclude} パラメータを正規表現のリストに設定するだけです。

これらの全てのパラメータを使って正しい分割が生成されないときや、何か違っ
たものが必要なときは、パラメー
タ @var{split-spec} を @code{nnmail-split-fancy} 分割に設定することがで
きます。この場合は、他の前に書いた全てのパラメータ
は @code{gnus-group-split} に無視されます。特に、
@var{split-spec} は @code{nil} に設定することができ、その場合はグループ
は @code{gnus-group-split} に無視されます。

@vindex gnus-group-split-default-catch-all-group
@code{gnus-group-split} はそれぞれのグループに一つの分割を含む単一
の @code{&} 特級分割を定義することで合致する全てのグループに相互投稿をし
ます。メッセージがどの分割にも合致しなければ、どれかのグループ
で @var{split-spec} が @code{catch-all} に設定されていない場合
は @code{gnus-group-split-default-catch-all-group} で指定されているグルー
プに保存されます。@var{split-spec} が @code{catch-all} に設定されている
グループがある場合は、そのグループが全てを捕獲するグループとして使用され
ます。この変数はしばしば単にグループを指定するために使われますが、任意の
複雑な特級分割をも設定する (結局、グループ名は特級分割なのです) ので、個
人のメールフォルダーのどのメーリングリストにも当てはまらないメールを分割
するのに便利でしょう。なおこの特級分割は、@code{|} 分割リストの最後の要
素 - グループパラメータから抽出された規則を持つ @code{&} 分割を含む - と
して追加されることに注意してください。

そろそろ例を出すべきでしょう。以下のグループパラメータが定義されていると
します:

@example
nnml:mail.bar:
((to-address . "bar@@femail.com")
 (split-regexp . ".*@@femail\\.com"))
nnml:mail.foo:
((to-list . "foo@@nowhere.gov")
 (extra-aliases "foo@@localhost" "foo-redist@@home")
 (split-exclude "bugs-foo" "rambling-foo")
 (admin-address . "foo-request@@nowhere.gov"))
nnml:mail.others:
((split-spec . catch-all))
@end example

@code{nnmail-split-methods} を @code{gnus-group-split} に設定すると、
@code{nnmail-split-fancy} が選択されて、変
数 @code{nnmail-split-fancy} が以下のように設定されているかのように振舞
います:

@lisp
(| (& (any "\\(bar@@femail\\.com\\|.*@@femail\\.com\\)" "mail.bar")
      (any "\\(foo@@nowhere\\.gov\\|foo@@localhost\\|foo-redist@@home\\)"
           - "bugs-foo" - "rambling-foo" "mail.foo"))
   "mail.others")
@end lisp

@findex gnus-group-split-fancy
全てのメールグループでグループ分割を使用したくはないときは、
@code{nnmail-split-fancy} 分割を次のように使用することでいくつかのグルー
プだけに使うことができます。

@lisp
(: gnus-group-split-fancy GROUPS NO-CROSSPOST CATCH-ALL)
@end lisp

@var{groups} は出力の分割を生成するためにパラメータが走査されるグループ
名のリストか正規表現です。@var{no-crosspost} は相互投稿を使用禁止にるた
めに使うことができます。その場合、単一の @code{|} 分割が出力されます。
@var{catch-all} は @var{gnus-group-split-default-catch-all-group} のよう
に、最後の手段として使われる特級分割です。@var{catch-all} が @code{nil} で
あるか、@var{split-regexp} がどれかの選択されたグループ空文字列に合致す
ると、全捕獲分割は行われません。そうでない場合、グループ
に @var{split-spec} が @code{catch-all} に設定されているものがあると、こ
のグループが @var{catch-all} 引数を上書きします。

@findex gnus-group-split-setup
不運なことに、全てのグルプとパラメータを走査することは非常に遅いです。特
に全てのメッセージに対してなされることを考えると。けれども、絶望しない
で! 関数 @code{gnus-group-split-setup} が @code{gnus-group-split} をより
ずっと効率的な方法で使うことができます。それ
は @code{nnmail-split-methods} を @code{nnmail-split-fancy} に設定し、
@code{nnmail-split-fancy} を @code{gnus-group-split-fancy} で生成された
分割に設定します。こうしてどんなに分割するメッセージがたくさんあっても、
グループパラメータは一度だけ走査されます。

@findex gnus-group-split-update
しかし、グループパラメータを変更すると、@code{nnmail-split-fancy} を手で
更新しなければなりません。@code{gnus-group-split-update} を実行すること
でそれを行えます。自動的に更新される方が好みなら、
@code{gnus-group-split-setup} にそれを実行するように教えるだけです。例え
ば、@file{.gnus} に以下のものを追加してください:

@lisp
(gnus-group-split-setup AUTO-UPDATE CATCH-ALL)
@end lisp

@var{auto-update} が @code{nil} で無いと、
@code{gnus-group-split-update} が @code{nnmail-pre-get-new-mail-hook} に
追加され、二度と @code{nnmail-split-fancy} の更新を心配する必要はありま
せん。@var{catch-all} を省略しない場合は (それはオプション
で @code{nil} と等
価)、@code{gnus-group-split-default-catch-all-group} はその値に設定され
ます。

@vindex gnus-group-split-updated-hook
@code{nnmail-split-fancy} が @code{gnus-group-split-update} で設定された
後に、変更したいときのために、この関数
は @code{gnus-group-split-update-hook} を終了する直前に実行します。

@node Incorporating Old Mail
@subsection 古いメールを取り込む
@cindex incorporating old mail
@cindex import old mail

たいていの人は色々なファイルフォーマットで蓄積されたたくさんの古いメール
があるでしょう。もし gnus に粋な gnus メールバックエンドの一つを使うよう
に設定したのであれば、おそらく古いメールをメールグループに取り込みたいと
思うでしょう。

それをする事はとても簡単です。

例を挙げましょう: @code{nnml} (@pxref{Mail Spool}) を使ってメールを読ん
でいて、@code{nnmail-split-methods} を満足できる値に設定しています。古
い Unix mbox ファイルが重要だけれど古いメールで満たされています。あなた
はそれを @code{nnml} グループに移動したいと思っています。

方法です:

@enumerate
@item
グループバッファに行きます。

@item
`G f' と打って、mbox ファイルから @code{nndoc} グループを作成するように
促進されたときに mbox ファイルへのパスを与えます (@pxref{Foreign
Groups})。

@item
`SPACE' を打って、新しく作られたグループに入ります。

@item
`M P b' を打って、グループバッファの全ての記事に実行印を付けま
す (@pxref{Setting Process Marks})。

@item
`B r' を打って全てのプロセス印の付いた再スプールし、促進されたとき
に @samp{nnml} と答えます (@pxref{Mail Group Commands})。
@end enumerate

mbox ファイルの全てのメールメッセージも今やあなたの @code{nnml} グループ
に広がっています。それらに入って、変な故障もなく物事が上手く行っているか
どうかを調べてください。もし大丈夫なようであれば、mbox ファイルを消す事
を考えるかもしれませんが、私は全てのメールがあるべきところに納まっている
のを完全に確認するまでは、そうはしません。

@node Expiring Mail
@subsection メールの期限切れ消去
@cindex article expiry

伝統的なメールリーダーは、何か、既読の印を付けると記事を削除する傾向があ
ります。Gnus はメールを読む事に対して、基本的に全く違った方法を取ります。

Gnus は基本的にメールを比較的特別な方法で受け取られたニュースであるとみ
なします。それは実際にメールを変更したり、メールメッセージを消す権力があ
るとは考えません。メールグループに入って、記事に ``既読'' の印を付けたり、
他の流儀で切ったりしても、メール記事はまだシステムに存在しています。繰り
返します: gnus はあなたの古い、既読メールを消去しません。もちろん、あな
たがそうしろと尋ねない限りの話ですが。

Gnus に望ましくないメールを削除させるためには、記事を @dfn{期限切れ消去
可能} (expirable) として印を付けなければなりません。しかしながら、これは
記事が即座に消え去るという事ではありません。一般的に、メール記事は次のよ
うな場合にシステムによって削除されます 1) 期限切れ消去可能の印を付けられ
る 2) 一週間以上経った記事である。もし記事を期限切れ消去可能にしなければ、
それは地獄が凍りつくまでシステムに残りつづけます。これはもう一度強調付き
で繰り返されるに足るものです: ``もし'' あなたが記事
を ``期限切れ消去可能'' であると ``しない'' なら、gnus は ``決して'' そ
れらの ``記事'' を消去しません。

@vindex gnus-auto-expirable-newsgroups
手で記事に期限切れ消去可能の印を付けなければならないわけではありません。
正規表現 @code{gnus-auto-expirable-newsgroups} に合致するグループは全て
の既読記事に自動的に期限切れ消去可能の印が付けられます。全ての期限切れ消
去可能の印の付いた記事は概略バッファの最初の桁に @samp{E} が表示されます。

ディフォルトでは自動期限切れ消去可能を使用すると、gnus はあなたが読んだ
全ての記事を、それが既読であったか未読であったかに関わらず、期限切れ消去
可能として印を付けます。既読の印の付いた記事が自動的に期限切れ消去可能と
して印付けられるのを避けるために、以下のようなものを @file{.gnus} ファイ
ルに書く事ができます:

@vindex gnus-mark-article-hook
@lisp
(remove-hook 'gnus-mark-article-hook
             'gnus-summary-mark-read-and-unread-as-read)
(add-hook 'gnus-mark-article-hook 'gnus-summary-mark-unread-as-read)
@end lisp

自動期限切れ消去可能グループを作る事は、全ての既読記事が期限切れ消去され
る事ではない事に気を付けてください---期限切れ消去可能として印の付いた記
事だけが期限切れ消去されます。命令 @kbd{d}が自動的に記事を期限切れ消去可
能にするのでは無いという事にも気を付けてください---半自動の、自動期限切
れ消去可能グループで記事を既読に印付けることだけが記事を期限切れ消去可能
にします。

@lisp
(setq gnus-auto-expirable-newsgroups
      "mail.nosense-list\\|mail.nice-list")
@end lisp

自動期限切れ消去を実行する他の方法は、グループのグループパラメータとして、
要素 @code{auto-expirable} を持つ事です。

もし適応スコア付け (@pxref{Adaptive Scoring}) と自動期限切れ消去を使用し
ているなら、問題が起こるでしょう。自動期限切れ消去と適応スコア付けはあま
り良く相互作用しません。

@vindex nnmail-expiry-wait
変数 @code{nnmail-expiry-wait} は期限切れ消去可能記事がどれくらいの期間
生存しているかのディフォルトの時間設定を提供します。Gnus はメッセージが
送られたときではなく、それが @emph{到着} してからの日を計算します。ディ
フォルトは 7 日間です。

Gnus は記事がどのグループに属しているかに基づいて、それがどのくらい生存
するかを成功に設定する関数も提供しています。グルー
プ @samp{mail.private} は期限を 1ヶ月に、グループ @samp{mail.junk} では
期限を 1 日に、その他のものには期限を 6 日間にするには:

@vindex nnmail-expiry-wait-function
@lisp
(setq nnmail-expiry-wait-function
      (lambda (group)
       (cond ((string= group "mail.private")
               31)
             ((string= group "mail.junk")
               1)
             ((string= group "important")
              'never)
             (t
               6))))
@end lisp

この関数に与えられるグループ名は ``装飾無し'' のグループ名です---
@samp{nnml:} やその他の似たようなものは付きません。

変数 @code{nnmail-expiry-wait} と関
数 @code{nnmail-expiry-wait-function} は数字 (整数である必要はありませ
ん) かシンボル @code{immediate} か @code{never} のどちらかである事ができ
ます。

期限切れ期間を選択的に変更するためにグループパラメー
タ @code{expiry-wait} を使う事もできます (@pxref{Group Parameters})。

@vindex nnmail-expiry-target
記事の期限切れ消去の普通の動作はそれらを消去することです。しかし、場合に
よってはそれらを消去するよりも別のグループに移動した方が有意義かもしれま
せん。変数 @code{nnmail-expiry-target} (とグループパラメー
タ @code{expiry-target}) はこれを制御します。この変数の値はすべてのグルー
プに対するディフォルトになりますが、特定のグループごとにグループパラメー
タを使って指定すれば上書きすることができます。ディフォルトの値
は @code{delete} ですが、文字列 (記事を移動する先のグループ名) または移
動先のグループ名か @code{delete} を返す関数 (記事に範囲を狭めたバッファ
で、その記事が存在しているグループ名が引数として与えられます) にすること
ができます。

グループ名を指定する場合の例:
@lisp
(setq nnmail-expiry-target "nnml:expired")
@end lisp

@findex nnmail-fancy-expiry-target
@vindex nnmail-fancy-expiry-targets
gnus には変数 @code{nnmail-fancy-expiry-targets} に従ってメールを期限切
れ消去するための関数 @code{nnmail-fancy-expiry-target} があります。これ
は例です:

@lisp
 (setq nnmail-expiry-target 'nnmail-fancy-expiry-target
       nnmail-fancy-expiry-targets
       '((to-from "boss" "nnfolder:Work")
         ("subject" "IMPORTANT" "nnfolder:IMPORTANT.%Y.%b")
         ("from" ".*" "nnfolder:Archive-%Y")))
@end lisp

この設定によって、題名に @code{IMPORTANT} を持ち、
@code{YYYY} 年 @code{MMM} 月に発信されたいかなるメールも、グルー
プ @code{nnfolder:IMPORTANT.YYYY.MMM} に期限切れ消去 (訳注: 実際の動作は
保存) されます。もし From または To ヘッダーが文字列 @code{boss} を含ん
でいたら @code{nnfolder:Work} に期限切れ消去されます。それ以外のすべての
メールは @code{nnfolder:Archive-YYYY} に期限切れ消去されます。

@vindex nnmail-keep-last-article
@code{nnmail-keep-last-article} が @code{nil} でないと、gnus はメールニュー
スグループの最後の記事を決して期限切れ消去しません。これは procmail の利
用者の人生を楽にするためです。

@vindex gnus-total-expirable-newsgroups
ところで: そこにある、gnus が決して期限切れ消去可能でない記事を期限切れ
消去する事はない、というのは嘘です。@code{total-expire} をグループパラメー
タに入れると、記事は期限切れ消去の印が付きませんが、全ての記事は期限切れ
消去過程に入れられます。非常に注意して使ってください。さらにもっと危険な
ものは変数 @code{gnus-total-expirable-newsgroups} です。この正規表現に合
致する全てのグループは全ての既読記事が期限切れ消去可能の過程に突っ込まれ
ます。これは、当のグループの @emph{全て} の古いメール記事は少し後で削除
されるという事です。非常に注意して使って、あなたが使用した正規表現が間違っ
たグループに合致して、あなたの全ての重要なメールが消えてしまったと言って、
私のところに泣き付いて来ないでください。@emph{男}になりなさい! もしくは、
@emph{女} になりなさい! あなたが気持ちよいと感じる全てのものと! ですから
そこに!

たいていの人はほとんどのメールグループを total-expirable (全体期限切れ消
去可能) にしますが。

@vindex gnus-inhibit-user-auto-expire
@code{gnus-inhibit-user-auto-expire} が @code{nil} でなければ、グループ
が自動時限消去が使用されるようになっていても、利用者の印付け命令は記事に
時限消去可能の印を付けません。

@node Washing Mail
@subsection メール洗濯
@cindex mail washing
@cindex list server brain damage
@cindex incoming mail treatment

メイラー (mailer) やリストサーバー (list server) は本当に本当に馬鹿げた
事をすることで悪名高いです。``わぁ、RFC822 は我々のサーバーを通っていく
メッセージの全ての行の最後に @code{wE aRe ElIte!!!!!1!!} を加える事を明
示的に禁止はしていないぞ。さぁ、やってみよう!!!!1'' えぇ、そのとおりです
が、RFC822 は能力の低い人によって読まれるようには書かれていません。明白
な事はそこでは議論されていません。ですから。そういうことです。

問題点: ドイツ版 Microsoft Exchange は返答の表題に @samp{Re: } の代わり
に @samp{AW: } を付け加えます。私はこれに動揺して狼狽しているふりをする
こともできましたが、そうする気力がありませんでした。それは笑うべき事です。

Gnus は記事を表示するときにそれを洗濯するために過度の関数を提供していま
すが、メールをディスクに保存する前に選別をすることができた方が良いでしょ
う。その目的のために、三つのフックとそのフックに入れる事のできる色々な関
数があります。

@table @code
@item nnmail-prepare-incoming-hook
@vindex nnmail-prepare-incoming-hook
このフックはメールに何かをする前に呼ばれ、基本的な、メールを掃いてきれい
にする所作のためにあります。それは全ての新しい、入ってきたメールを含んで
いるバッファで呼ばれます。使う事のできる関数は:

@table @code
@item nnheader-ms-strip-cr
@findex nnheader-ms-strip-cr
それぞれの行から、最後にあるキャリッジリターン (carriage return) を取り
除きます。これは MS のマシン上で動作している Emacs のディフォルトです。
@end table

@item nnmail-prepare-incoming-header-hook
@vindex nnmail-prepare-incoming-header-hook
このフックはそれぞれのヘッダーに範囲を狭められて (narrowed) 呼ばれます。
ヘッダーをきれいにするときに使う事ができます。使う事のできる関数は:

@table @code
@item nnmail-remove-leading-whitespace
@findex nnmail-remove-leading-whitespace
ヘッダーにそれが良く見えるように ``有用な'' リストサーバーが前の方に付け
加えた空白を無くします。あぁぁ。

(この関数はすべてのメッセージのボディ中にあるヘッダー (ボディ中のメッセー
ジが持っているヘッダー行のようなもの) に対しても動作するので、使用に際し
ては潜在的な危険を孕んでいます。したがってバグを修正するよりは、文書で特
徴を示すのが、もちろん正しい解決の道です。)

@item nnmail-remove-list-identifiers
@findex nnmail-remove-list-identifiers
いくつかのリストサーバーは同一識別子を付け加えます---例えば、
@samp{(idm)}---を全ての @code{Subject} ヘッダーの最初に付けます。それは、
石器時代のメールヘッダーを使っている人には良い事だと思います。この関数は
正規表現 @code{nnmail-list-identifiers} に合致する文字列を取り除きます。
それは正規表現のリストである事もできます。
@code{nnmail-list-identifiers} に @code{\\(..\\)} を含めてはいけません。

例えば、@samp{(idm)} と @samp{nagnagnag} 同一識別子を取り除きたいのなら:

@lisp
(setq nnmail-list-identifiers
      '("(idm)" "nagnagnag"))
@end lisp

これは @code{gnus-list-identifiers} で非破壊的に行うこともできます。
@xref{Article Hiding}。

@item nnmail-remove-tabs
@findex nnmail-remove-tabs
全ての @samp{TAB} 文字を @samp{SPACE} 文字に変換します。

@item nnmail-fix-eudora-headers
@findex nnmail-fix-eudra-headers
@cindex Eudora
Eudora は壊れた @code{References} ヘッダーを作成しますが、
@code{In-Reply-To} ヘッダーにはちゃんとしたものを入れます。この関数
は @code{References} ヘッダーを取り除きます。
@end table

@item nnmail-prepare-incoming-message-hook
@vindex nnmail-prepare-incoming-message-hook
このフックはそれぞれのメッセージに範囲を狭められて呼ばれます。使う事ので
きる関数は:

@table @code
@item article-de-quoted-unreadable
@findex article-de-quoted-unreadable
Quoted Readable 符号化を復号化します。
@end table
@end table

@node Duplicates
@subsection 重複

@vindex nnmail-treat-duplicates
@vindex nnmail-message-id-cache-length
@vindex nnmail-message-id-cache-file
@cindex duplicate mails
いくつかのメーリングリストのメンバーなら、時々同じメールを二つ受け取る事
があります。これはとてもうるさく感じることもありますので、
@code{nnmail} はそれが発見するかもしれない重複を調べて扱います。これをす
るために、古い @code{Message-ID} を保存しま
す---@code{nnmail-messagge-id-cache-file} に。これはディフォルトで
は @file{~/.nnmail-cache} です。それに保存される最大数
の @code{Message-ID} は変数 @code{nnmail-message-id-cache-length} に制御
され、それはディフォルトで 1000 です。(ですから、
1000 @code{Message-ID} が溜められます。) これが恐ろしいと思ったなら、
@code{nnmail-treat-duplicates} を @code{warn} (ディフォルトではそのよう
になっていますが) に設定する事ができ、そうすれば、@code{nnmail} は重複メー
ルを消去しません。その代わりに、メールの先頭にこれは違ったメッセージの重
複であるという警告を挿入します。

この変数は関数である事もできます。その場合は、関数
は @code{Message-ID} を引数として、当のメッセージに範囲を狭められたバッ
ファから呼ばれます。この関数は @code{nil}, @code{warn}, @code{delete} の
どれかを返さなければなりません。

変数を @code{nil} に設定する事によって、この機能を完全に使わないようにす
る事ができます。

もし全ての重複メールを特別な @dfn{duplicate} グループに入れたいのであれ
ば、普通のメール分割方法を使ってそれをすることができます:

@lisp
(setq nnmail-split-fancy
      '(| ;; 重複メッセージは分離されたグループへ行きます。
        ("gnus-warning" "duplicat\\(e\\|ion\\) of message" "duplicate")
        ;; デーモンやポストマスターや似たようなものからの
        ;; メッセージは他のところへ。
        (any mail "mail.misc")
        ;; 他の法則。
        [ ... ] ))
@end lisp

もしくは次のようなもの:
@lisp
(setq nnmail-split-methods
      '(("duplicates" "^Gnus-Warning:.*duplicate")
        ;; 他の法則。
        [...]))
@end lisp

すばらしい機能があります: もし受け手がメールを gnus で読んでいる事を知っ
ていて、@code{nnmail-treat-duplicates} が @code{delete} に設定してあると、
あなたの知っている、その人が既に受け取ったメールの @code{Message-ID} を
使って、考える限りたくさんの侮辱を送る事ができます。その楽しさを考えてみ
てください! その人はそれらを決してみる事はありません! わぉ!

@node Not Reading Mail
@subsection メールを読むのではない

メールバックエンドを使い始めると、それらにはあなたがそれらでメールを読み
たいと思っていると仮定するといううるさい癖があります。これはもっともでな
い事ではないかもしれませんが、あなたの望む事ではないかもしれません。

もし @code{mail-sources} と @code{nnmail-spool-file} を @code{nil} に設
定すると、どのバックエンドも入ってくるメールを読もうと試みる事はなく、望
む事の手助けになるでしょう。

@vindex nnbabyl-get-new-mail
@vindex nnmbox-get-new-mail
@vindex nnml-get-new-mail
@vindex nnmh-get-new-mail
@vindex nnfolder-get-new-mail
例えば、@code{nnml} でメールを読む事に非常に満足していて、古
い @sc{rmail} ファイルが @code{nnbabyl} で隠されているのをさっと見たいだ
けなら、これは余分でしょう。すべてのバックエンドは バックエンド-
@code{get-new-mail} という変数を持っています。もし @code{nnbabyl} のメー
ル読み込みを使用不可にしたいのであれば、グループの事実上のサーバー
を @code{nnbabyl-get-new-mail} を @code{nil} に設定するように編集します。

全てのメールバックエンドは入ってくるメールを読み込むときに、保存されるべ
き記事に範囲を狭めて @code{nn}*@code{-prepare-save-mail-hook} を呼びます。

@node Choosing a Mail Back End
@subsection メールバックエンドを選ぶ

Gnus はメールグループを動作するようにするとメールスプールを読み込みます。
メールファイルはまずあなたのホームディレクトリーに複写されます。その後に
何が起こるかはメールをどの様式で溜めたいかによって変わります。

標準の gnus では六つの違ったメールバックエンドがあり、個別にさらなるバッ
クエンドを使用可能です。ほとんどの人が使うメールバックエンドは (それがた
ぶん最速だから) @code{nnml} です (@pxref{Mail Spool})。あなたは以下に五
つのバックエンドしかないことに気が付くでしょう; @code{nnmaildir} の文献
はまだこのマニュアルに完全に編入されていないのです。それまで
は @uref{http://multivac.cwru.edu./nnmaildir/} で見つけることができます。

@menu
* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Rmail Babyl::                 Emacs のプログラムは rmail の babyl フォー
                                マットを使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Mail Folders::                それぞれのグループに対して一つのファイル
                                を持つ
* Comparing Mail Back Ends::    得失の深い洞察
@end menu

@node Unix Mail Box
@subsubsection Unix メールボックス
@cindex nnmbox
@cindex unix mail box

@vindex nnmbox-active-file
@vindex nnmbox-mbox-file
@dfn{nnmbox} バックエンドはメールを蓄蔵するために標準の Un*x mbox ファイ
ルを用います。@code{nnmbox} はそれぞれのメール記事にそれがどのグループに
属しているかを示す追加のヘッダーを加えます。

事実上のサーバーの設定:

@table @code
@item nnmbox-mbox-file
@vindex nnmbox-mbox-file
利用者のホームディレクトリーのメールボックスの名前。既定値
は @file{~/mbox} です。

@item nnmbox-activate-file
@vindex nnmbox-active-file
メールボックスのアクティブファイルの名前。既定値
は @file{~/.mbox-active} です。

@item nnmbox-get-new-mail
@vindex nnmbox-get-new-mail
@code{nil} でなければ、@code{nnmbox} は入って来たメールを読み込んでグルー
プに分割します。既定値は @code{t} です。
@end table

@node Rmail Babyl
@subsubsection Rmail Babyl
@cindex nnbabyl
@cindex rmail mbox

@vindex nnbabyl-active-file
@vindex nnbabyl-mbox-file
@dfn{nnbabyl} バックエンドはメールを蓄蔵するために babyl メールボック
ス (別名 @dfn{rmail mbox}) を使います。@code{nnbabyl} はそれぞれの記事に
それがどのグループに属しているかを示す追加のヘッダーを加えます。

事実上のサーバーの設定:

@table @code
@item nnbabyl-mbox-file
@vindex nnbabyl-mbox-file
rmail mbox ファイルの名前。既定値は @file{~/RMAIL} です。

@item nnbabyl-active-file
@vindex nnbabyl-active-file
rmail box のためのアクティブファイルの名前。既定値
は @file{~/.rmail-active} です。

@item nnbabyl-get-new-mail
@vindex nnbabyl-get-new-mail
@code{nil} でなければ、@code{nnbabyl} は入ってくるメールを読み込みます。
既定値は @code{t} です。
@end table

@node Mail Spool
@subsubsection メールスプール
@cindex nnml
@cindex mail @sc{nov} spool

@dfn{nnml} スプールメール様式は他の知られた様式とは互換性がありません。
それは少し注意して使われるべきです。

@vindex nnml-directory
もしこのバックエンドを使うと、gnus は入ってくるメールを、それぞれのメー
ルを 1 ファイルとしてファイルに分割し、記事を変
数 @code{nnml-directory} で指定されたディレクトリーの下の対応するディレ
クトリーに入れます。ディフォルトの値は @file{~/Mail/} です。

前もってディレクトリーを作っておく必要はありません。それの面倒は gnus が
見てくれます。

もしあなたのアカウントに蓄積できるファイルの数に厳密な制限があるなら、こ
のバックエンドを使うべきではありません。それぞれのメールはそれ自身のファ
イルを得ますので、数週間でたくさんの iノードを占有する可能性は十分にあり
ます。別にこれが問題でなく、親切なシステム管理者が、気が狂ったよう
に ``誰が私の iノードを食いつぶしているんだ? 誰だ? 誰!?'' と叫びながら歩
き回る事が問題でないなら、これがおそらく使う事のできる一番速い様式である
ということは知っておくべきでしょう。新しいメールを読むためだけに大き
な mbox ファイルを重い足取りで探す必要はありません。

@code{nnml} は記事分割に関してはおそらく一番遅いバックエンドでしょう。そ
れは多くのファイルを作らなければならず、それは入ってくるメールのため
の @sc{nov} データベースも作成しなければなりません。これのために、メール
を読む事に関してはたぶん最速のバックエンドになります。

@cindex self contained nnml servers
@cindex marks
印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
@code{nnml} サーバーは @code{tar} などを使ってバックアップしたり、後であ
なたが付けた印がすべて保たれた状態で gnus に戻す (本来の @code{nnml} サー
バーによって追加する) ことができる特質を持つようになります。グループの印
はそれぞれの @code{nnml} グループのディレクトリ内の、通
常 @code{.marks} ファイル (@code{nnml-marks-file-name} を参照) に格納さ
れます。また、個々の @code{nnml} グループについてもバックアップすること
が可能で、(バックアップを nnml ディレクイトリに戻した後で) @kbd{G m} キー
を使ってそのグループを元に戻します。

もし何らかの理由によって @file{.marks} ファイルがおかしくなっていると思っ
たときは、単にそれら全部を消してしまうことができます。gnus は次回起動す
るときに、それらを正しく再作成するでしょう。

事実上のサーバーの設定:

@table @code
@item nnml-directory
@vindex nnml-directory
全ての @code{nnml} ディレクトリーはこのディレクトリーの下に置かれます。
既定値は `message-directory' の値 (その既定値は @file{~/Mail}) です。

@item nnml-active-file
@vindex nnml-active-file
@code{nnml} サーバーのためのアクティブファイル。既定値
は @file{~/Mail/active"} です。

@item nnml-newsgroups-file
@vindex nnml-newgroups-file
@code{nnml} グループ記述ファイル。@xref{Newsgroups File Format}。既定値
は @file{~/Mail/newsgroups"} です。

@item nnml-get-new-mail
@vindex nnml-get-new-mail
@code{nil} でなければ、@code{nnml} は入って来たメール読み込みます。既定
値は @code{t} です。

@item nnml-nov-is-evil
@vindex nnml-nov-is-evil
@code{nil} でなければ、このバックエンドはどの @sc{nov} ファイルも無視し
ます。既定値は @code{nil} です。

@item nnml-nov-file-name
@vindex nnml-nov-file-name
@sc{nov} ファイルの名前。ディフォルトは @file{.overview} です。

@item nnml-prepare-save-mail-hook
@vindex nnml-prepare-save-mail-hook
保存する前に記事に範囲を狭めて実行するフックです。

@item nnml-marks-is-evil
@vindex nnml-marks-is-evil
非@code{nil} であると、このバックエンドはいかなる @sc{印} ファイルも無視
します。ディフォルトは @code{nil} です。

@item nnml-marks-file-name
@vindex nnml-marks-file-name
@dfn{印} ファイルの名前です。ディフォルトは @file{.marks} です。

@item nnml-use-compressed-files
@vindex nnml-use-compressed-files
非-@code{nil} だったら @code{nnml} は圧縮されたメッセージファイルを使う
ことを考慮に入れます。
@end table

@findex nnml-generate-nov-databases
@code{nnml} グループと @sc{nov} ファイルが完全に良い状態でなくなってしまっ
たなら、@kbd{M-x nnml-generate-nov-databases} と打つ事によって、完全に更
新する事ができます。この命令は、それぞれ全てのファイルを見る事によっ
て @code{nnml} 階層全体をトロール魚網でさらいますので、それが終わるまで
には時間がかかるかもしれません。この機能へのより良いインターフェースはサー
バーバッファで見つかるでしょう (@pxref{Server Commands})。

@node MH Spool
@subsubsection MH スプール
@cindex nnmh
@cindex mh-e mail spool

@code{nnmh} は、@sc{nov} データベースを作らないこととアクティブファイル
や印ファイルを保持しない事を除いて、@code{nnml} と似ています。そのこと
は @code{nnmh} を @code{nnml} より @emph{かなり} 遅いバックエンドにして
いますが、それは procmail のスクリプトを書くためにずっとやりやすくなって
もいます。

事実上のサーバーの設定:

@table @code
@item nnmh-directory
@vindex nnmh-directory
全ての @code{nnmh} ディレクトリーはこのディレクトリーの下に置かれます。
既定値は @code{message-directory} の値 (その既定値は @file{~/Mail}) です。

@item nnmh-get-new-mail
@vindex nnmh-get-new-mail
@code{nil} でなければ、@code{nnmh} は入ってくるメールを読み込みます。既
定値は @code{t} です。

@item nnmh-be-safe
@vindex nnmh-be-safe
@code{nil} でなければ、@code{nnmh} はフォルダーにある記事が実際に gnus
が考えているものと同じであるかを調べるという馬鹿げた事をやります。それは
日付と目に入る全ての情報を調べますので、これを @code{t} に設定する事は深
刻な速度低下が起こるという事です。もし @code{nnmh} 記事を読むの
に gnus 以外のものを使っていないのであれば、この変数を @code{t} に設定す
る必要はありません。既定値は @code{nil} です。
@end table

@node Mail Folders
@subsubsection メールフォルダー
@cindex nnfolder
@cindex mbox folders
@cindex mail folders

@code{nnfolder} はそれぞれのメールグループを違ったファイルに蓄蔵するバッ
クエンドです。それぞれのファイルは標準の Un*x mbox 様式です。
@code{nnfolder} は記事番号と到着日を記録しておくための追加のヘッダーを加
えます。

@cindex self contained nnfolder servers
@cindex marks
印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
@code{nnfolder} サーバーは @code{tar} などを使ってバックアップしたり、後
であなたが付けた印がすべて保たれた状態で gnus に戻す (本来
の @code{nnfolder} サーバーによって追加する) ことができる特質を持つよう
になります。グループの印は @code{nnfolder} ディレクトリ内の、mbox ファイ
ルに通常 @code{.mrk} (@code{nnfolder-marks-file-name} を参照) が付加され
た名前のファイルに格納されます。また、個々の @code{nnfolder} グループに
ついてもバックアップすることが可能で、(バックアップを nnfolder ディレク
イトリに戻した後で) @kbd{G m} キーを使ってそのグループを元に戻します。

事実上のサーバーの設定:

@table @code
@item nnfolder-directory
@vindex nnfolder-directory
全ての @code{nnfolder} メールボックスはこのディレクトリーの下に置かれま
す。既定値は @code{message-directory} の値 (その既定値
は @file{~/Mail}) です。

@item nnfolder-active-file
@vindex nnfolder-active-file
アクティブファイルの名前。既定値は @file{~/Mail/active} です。

@item nnfolder-newgroups-file
@vindex nnfolder-newsgroups-file
グループ記述ファイルの名前。@xref{Newsgroups File Format}。既定値
は @file{~/Mail/newsgroups"} です。

@item nnfolder-get-new-mail
@vindex nnfolder-get-new-mail
@code{nil} でなければ、@code{nnfolder} は入ってくるメールを読み込みます。
既定値は @code{t} です。

@item nnfolder-save-buffer-hook
@vindex nnfolder-save-buffer-hook
@cindex backup files
フォルダーを保存する前に実行されるフックです。@code{nnfolder} バッファに
対してさえも Emacs は通常のバックアップの変名をする事に注意して下さい。
この機能を無効にしたいのであれば、ファイル @file{.emacs} で次のような事
をする事ができます:

@lisp
(defun turn off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'nnfolder-save-buffer-hook 'turn-off-backup)
@end lisp

@item nnfolder-delete-mail-hook
@vindex nnfolder-delete-mail-hook
これから消去されるメッセージに範囲を狭められて実行されるフックです。この
関数は別のところにメッセージをコピーしたり、消去するまえに何らかの情報を
取り出すために使ったりすることができます。

@item nnfolder-nov-is-evil
@vindex nnfolder-nov-is-evil
もし非@code{nil}なら、このバックエンドは @sc{nov} ファイルを無視します。
既定値は @code{nil} です。

@item nnfolder-nov-file-suffix
@vindex nnfolder-nov-file-suffix
@sc{nov} ファイルの拡張子です。ディフォルトは @file{.nov} です。

@item nnfolder-nov-directory
@vindex nnfolder-nov-directory
@sc{nov} ファイルが格納されるディレクトリです。nil だった
ら @code{nnfolder-directory} が使われます。

@item nnfolder-marks-is-evil
@vindex nnfolder-marks-is-evil
非@code{nil} であると、このバックエンドはいかなる @sc{印} ファイルをも
無視します。ディフォルトは @code{nil} です。

@item nnfolder-marks-file-suffix
@vindex nnfolder-marks-file-suffix
@sc{印} ファイルの拡張子です。ディフォルトは @file{.mrk} です。

@item nnfolder-marks-directory
@vindex nnfolder-marks-directory
@sc{印} ファイルが格納されるディレクトリです。nil だった
ら @code{nnfolder-directory} が使われます。
@end table

@findex nnfolder-generate-active-file
@kindex M-x nnfolder-generate-active-file
@code{nnfolder} で読みたいと思う、たくさんの @code{nnfolder} のようなファ
イルを持っているのであれば、
@code{nnfolder} に @code{nnfolder-directory} にある全てのそのようなファ
イルに気付かせるために、命令 @kbd{M-x nnfolder-generate-active-file} を
使う事ができます。これは長いファイル名を使っているときにのみ動作しますが。

@node Comparing Mail Back Ends
@subsubsection メールバックエンドの比較

まず、用語として、@dfn{バックエンド} (back end) は低次の接続方法のための
普通の語です---もし望むなら、透過的であり、それは何かを成し遂げるもので
す。そのこころは、メールはどこからか来なければならず、適切なバックエンド
の選択は、メールを gnus のすぐ近くに取得するために要求される、というもの
です。

同じ概念が Usenet 自身にも存在します。記事への接触は今日では、普通
は @sc{nntp} でなされますが、昔々の憂鬱な深夜の時代は、皆は記事が存在す
るマシン (今日では @sc{nntp} サーバーと呼ぶもの) でリーダーを動かし、リー
ダーからの接続は、直接記事のディレクトリースプールに踏み込むというもの
でした。それでも、たまたまサーバー (もしくは、NFS でスプールが読めるよ
うな場合) にいるような場合は、これらの方法を選ぶため
に @code{nntp} や @code{nnspool} バックエンドのどちらかを選ぶことができ
ました。

メールバックエンドを選択することのゴールは、元の形式を扱うのに適した方法
と、将来使用するために便利な形式にメールを残すことの両方を同時に表現する
ことです。それぞれには良い点と悪い点がいくつかあります:

@table @code
@item nnmbox

UNIX システムは歴史的に単一の、非常に一般的な、上手く定義された形式を持っ
ています。全てのメッセージは単一の @dfn{スプールファイル} に到着し、正規
表現 @samp{^From_} に合致する行で区切られています。(私の @samp{_} の記
号の使用はスペースを意味するためで、この例ではこれは RFC で指定されてい
る @samp{From:} ヘッダーで無いことを明らかにするためです。) Emacs は、そ
れに gnus も、歴史的に Unix 環境から広まりましたので、元の mailbox 形式
をあまりぐちゃぐちゃにしないというのは、最も簡素な方法です。ですから、こ
のバックエンドを選ぶと、本当のスプールからメールを取得して、gnus の好む
ディレクトリーにメールを移動するための gnus の主な活動は、単に、実行過程
で何も (評価できる) 変更をせずに複製することです。それは gnus の環境の使
用可能範囲にメールを移動する ``最も愚かな''方法です。これは定められた場
所に移動するのを速くしますが、gnus がどこに何があるかを調べるときは、解
析が遅くなります。

@item nnbabyl

むかしむかし、TOPS と呼ばれるオペレーティングシステムや、似たようなもの
を実行している DEC-10 と DEC-20 というものがあり、普通の (唯一の?) メー
ルを読む環境は Babyl と呼ばれるものでした。そのシステムに着いたメールが
どのような形式になっていたかは知りませんが、Babyl はメールが変換される、
それ用の内部形式を持っており、主に、Babyl 特有のヘッダーと状態ビットをファ
イルのそれぞれのメッセージの先頭に加えることをしていました。
RMAIL は Emacs の最初のメールリーダーで、Richard Stallman によって書かれ、
Stallman はその TOPS/Babyl 環境の出身であるため、RMAIL を既に存在してい
たメールファイルの一族を理解する様に書きました。Gnus (この問題に関して
は VM も) この形式をサポートし続けています。それは、そのメーラー特有のヘッ
ダー/ビットというものがなかなか質が良いと考えられているからです。
RMAIL 自身ももちろんまだ存在していて、まだ Stallman によって維持されてい
ます。

上の形式の両方はメールをファイルシステムの単独のファイルに入れ、メールを
見るたびに、ファイル全体を解析しなければなりません。

@item nnml

@code{nnml} はほとんど @code{nnspool} 接続の Usenet システムを操作してい
るような感じのするバックエンドです。(実際のところ、すごく以前に、
@code{nnml} は @code{nnspool} から枝分かれしたものだと思います。)
メールは元のスプールファイルから取り出され、それから個々のファイル
に 1:1 で分けられます。Usenet 様式のアクティブファイル (INN や CNews に
基づいたニュースシステムで (例えば) @file{/var/lib/news/active} や、動
詞 @samp{NNTP LIST} で返されるものに類似したもの) を維持し、今からだとか
なり前に @sc{nntp} サーバーのために定義されている、@dfn{overview} ファイ
ルも、グループへ入るときの効率のために作成します。メール分割では、たくさ
んのファイルの作成と、@code{nnml} アクティブファイルの更新、メッセージ毎
の overview への追加のために遅くなりますが、使用時にはアクティブファイル
と overview での索引機能により、とてつもなく速くなります。

@code{nnml} は @dfn{inode} を非常にたくさん消費します。すなわち、ファイ
ルシステムで新しいファイルを入れるための可能な場所を定義する資源をたくさ
ん占有します。システム管理者は、かっちりした共有ファイルシステムでの大量
の inode の占有を快く思いません。しかし、ファイルシステムが自分自身のも
のである個人マシン上で生活しているなら、@code{nnml} は非常に大きな利点が
あります。

また、FAT16 の Windows の世界に生きているなら、問題があるでしょう。たく
さんの小さなファイルで多くの場所を取られてしまいます。

@item nnmh

Rand MH メール閲覧システムは UNIX システムにかなり長い間存在しています。
メッセージのスプールファイルを個々のファイルに分割することにより操作しま
すが、索引機能が少しか、全くないかという程度です -- @code{nnmh} は意味的
には ``@code{nnml} にアクティブファイルと overview のないもの'' と等価で
す。これは議論のあるところですが、最悪の選択です。というのは、個々のファ
イルの作成の遅さが、グループで何が新しいかを知るときの解析のための使用の
遅さが結び付くからです。

@item nnfolder

基本的に @code{nnfolder} の効果はグループ毎の @code{nnmbox} (上で説明さ
れている最初の方法) です。すなわち、@code{nnmbox} 自身は *全て* のメール
を一つのファイルに入れます; @code{nnfolder} はメールグループそれぞれ
が Unix mail box ファイルを持つように少し最適化をします。
@code{nnmobx} よりも、それぞれのグループを別に解析するので速く、そのうえ
メールを移動させるのに最小限の労力を要求する単純な Unix mail box 形式を
提供します。加えて、gnus がそれぞれの別のグループにどのくらいのメッセー
ジがあるかを調べるための ``アクティブ'' ファイルを維持します。

もしたくさんの量のメッセージを受け取ることが予想されるグループがあるなら、
@code{nnfolder} は最善の選択ではありませんが、それなりの量のメールしか受
け取らないなら、おそらく @code{nnfolder} は全ての中で一番適したバックエ
ンドでしょう。

@item nnmaildir

@code{nnmaildir} は大方 @code{nnml} と似たものですが、いくらか顕著な違い
があります。それぞれのメッセージは別々のファイルに格納されますが、ファイ
ル名は gnus の記事番号と関係がありません。ま
た @code{nnmaildir} は @code{nnml} の overview に相当するファイルを記事
ごとに一つ格納するので、@code{nnml} の約二倍の量の iノードを使います。
(@code{df -i} を使って iノードの割り当てがどれほどたくさんあるかを調べて
下さい。) そのために遅くなったり多くの場所を取ってしまうようならば、
ReiserFS (@uref{http://www.namesys.com/}) や他の非ブロック構造のファイル
システムへの転換を検討して下さい。

maildir は受信配送のためのロックを必要としないので、あなたがグループとし
て使っている maildir は、配送されてきたメールを直接受け取るため
の maildir にすることもできます。これは、メールが配送されてくる過程で異
なるメールボックスに仕分されるようになっているのならば、gnus のメール分
割を省略できることを意味します。@code{mail-sources} におけ
る @code{directory} の項には似た効果がありますが、配送されてくるメールを
スプールするためのメールボックスの一揃い (mbox 形式ではそのためにメッセー
ジの本文が壊れる) と、他の (何であれあなたの好みの形式の) グループとして
使われる組が必要です。maildir は @code{new/} サブディレクトリに置かれる
組み込みスプールです。メール分割が二重チェックのような扱いを受ける代わり
に、メールを @code{new/} から @code{cur/} に移動することに、今のところは
気を付けて下さい。

記事は gnus のセッションにまたがって同じ番号を維持する必要はありません。
記事には gnus のセッションごと (もっと正確には @code{nnmaildir} サーバー
をオープンする度に) に 1 から始まる番号が振り直されます。このようにして
記事番号の範囲内に隙間が無くなり、また大きいグループに入るときは、gnus
はより正確な記事数を伝えてくれるでしょう。代償として @code{nnmaildir} は
キャッシュやエージェントでは動作しません。これはおそらく将来は変わるでしょ
う。

@code{nnmaildir} はグループの記事の印を、それに対応する maildir に格納し
ます。gnus の外からそれらを簡単に操作できるようにするために、そのように
作られているのです。maildir を tar でまとめてから別のどこかで展開しても、
印はそのままです。@code{nnml} も印を格納しますが、
@code{nnmaildir} で gnus の外からそれらを使うように簡単ではありません。

期限切れ消去や他のものを設定するために @code{nnmaildir} はグループパラメー
タを使いますが、他のメールバックエンドとは少し違います。

@code{nnmaildir} は速度を上げるためにかなりの量のメモリを使います。
(@code{nnml} の場合はファイルに格納し、@code{nnmh} では何度も記事ファイ
ルを解析して得るものごとを、それはメモリ上に保持します。) これがあなたに
とって問題ならば、@code{nov-cache-size} グループパラメータを何か小さな
値 (0 はおそらくだめだが 1 だったらたぶん動く) に設定することによって、
少ないメモリを使うようにすることができます。

起動と終了は他のバックエンドよりも @code{nnmaildir} が遅いでしょう。その
間にあるすべてのファイルシステムに依存している部分は速いでしょう。

@code{nnmaildir} は @code{nnoo} を使わないので、@code{nnmaildir} から派
生したバックエンドを書くのに @code{nnoo} は使えません。
@end table

@node Browsing the Web
@section Browsing the Web
@cindex web
@cindex browsing the web
@cindex www
@cindex http

ウェブに基づいた議論の場はどんどん広まっています。多くの分野で、ウェブの
掲示板は最も重要な場になり、メーリングリストやニュースグループの重要性を
翳らせています。理由は簡単です---新しい利用者が使い易いからです。ただ場
所をクリックするだけで、議論の場があります。メーリングリストでは、面倒な
購読手続きをしなければならず、ほとんどの人はニュースグループがどこにある
かすら知りません。

この筋書きの問題は、ウェブブラウザーはニュースリーダーとしてはあまり良く
ないということです。どんな記事を読んだかを記録しません。興味のある表題に
スコアを付けることができません。オフラインで読むことができません。何度も
クリックすることを要求し、最後にはあなたは嫌になります。

それで---ウェブブラウザーが掲示板を読むのに適していないのなら、どうして
代わりに gnus を使わないのでしょう?

Gnus はこれらのソースへの界面を提供するバックエンド群を少し備えつつあり
ます。

@menu
* Archiving Mail::              
* Web Searches::                文字列にマッチする記事からグループを作る
* Slashdot::                    Slashdot のコメントを読む
* Ultimate::                    Ultimate Bulletin Board システム
* Web Archive::                 ウェブに保管されたメーリングリストを読む
* Web Newspaper::               ウェブに保管された新聞を読む
* RSS::                         RDF Site Summary を読む
* Customizing w3::              Gnus から Emacs/W3 を操作する
@end menu

@samp{Web Newspaper} を除くすべてのウェブソースは、動作させるため
に Emacs/W3 と url ライブラリが必要です。

これらのウェブソースの一番の問題は長期間は動作しない可能性が高いことです。
@sc{html} データから情報を集めるのはせいぜい推測で、構造が変化したときに
は、gnus バックエンドは動作しません。でも、ある程度新しいバージョンのバッ
クエンドを使っていれば大丈夫のはずです。

これらのウェブ方法に共通することは、ウェブソースはしばしば落ちていたり、
使用可能でなかったり、単純に楽しむには遅すぎることがある、ということです。
そういう場合には、Gnu Agent (@pxref{Gnus Unplugged}) に記事のダウンロー
ドを任せて、ローカルディスクから好きなときに読むようにすることができます。
これで、World Wide Wait とはおさらばです。

@node Archiving Mail
@subsection メールの保存
@cindex archiving mail
@cindex backup of mail

いくつかのバックエンド、特に @code{nnml}, @code{nnfolder} およ
び @code{nnmaildir} は、それぞれのグループの記事の印を本当に保持します。
これらのサーバーで、グループの印を保ちつつ保存したり元に戻すのはかなり簡
単です。

(でも、グループレベルとグループパラメータをも保持するには、今までとお
り @file{.newsrc.eld} の神に、舞いと生贄を捧げなければなりませんが。)

@code{nnml}, @code{nnfolder} または @code{nnmaildir} サーバーにまるごと
保存するには、サーバーのディレクトリを再帰的にコピーします。gnus を終了
する必要は無いので、保存は @code{cron} やそれに類するものが行なうことが
できます。データを復帰させるにはディレクトリ木 (tree) を元に戻すことで行
ない、そのディレクトリを指し示すように gnus のサーバーの定義に追加します。
@ref{Article Backlog}, @ref{Asynchronous Fetching} およびその他は、デー
タを上書きして邪魔をするかもしれないので、あなたはデータを復帰させる前に
gnus を終了したいかもしれません。

個々の @code{nnml}, @code{nnfolder} または @code{nnmaildir} のグループを、
印を保持しつつ保存することもできます。@code{nnml} か @code{nnmaildir} で
は、そのグループのディレクトリにあるすべてのファイルをコピーします。
@code{nnfolder} では、基本のフォルダーファイル (@file{FOO}) と印ファイ
ル (@file{FOO.mrk}) の両方をコピーする必要があります。グループを元に戻す
のは、グループバッファで @kbd{G m} キーを使います。その最後の手順によっ
て、gnus は新しいディレクトリができたことを知ります。@code{nnmaildir} は
自動的に新しいディレクトリを知るので、その場合 @kbd{G m} は不要です。

@node Web Searches
@subsection ウェブ検索
@cindex nnweb
@cindex Google
@cindex dejanews
@cindex gmane
@cindex Usenet searches
@cindex searching the Usenet

それは、なんというか、Usenet から文字列にマッチする記事を検索するのはと
ても素晴らしいんだけど、その、あのウェブブラウザーってやつを使って、そん
でもって、宣伝を読ませられるっていうのは、その、なんというか、ほんとう
に @emph{「不様ね」} というか、それで、gnus ではブラウザーを使わずに、そ
の、@emph{超かっこよく}それができる、ってことです。

@code{nnweb} バックエンドは、強力な検索エンジンに対して簡単なインターフェー
スを提供します。@code{nnweb} グループを作成し、検索パターンを入力し、そ
してそのグループに入って他の普通のグループのように記事を読みます。グルー
プバッファ (@pxref{Foreign Groups}) の @kbd{G w} 命令によってお手軽にこ
れができます。

@code{nnweb} グループは、固定グループになろうとはしません --- このグルー
プでは記事番号はごく一時的なものとして扱います。つまり、@code{nnweb} グ
ループに入るたびに(たとえ検索パターンを変更していなくとも)、記事の順序が
違っているかもしれません。また、重複抑
制 (@pxref{Duplicate Suppression}) を使ってもうまく働かないでしょう。と
いうのは、@code{nnweb} は検索エンジン (例えば Google) を使って記事を読み
込むまでは、@code{Message-ID} を知ることはできないからです。あなたが読ん
だ記事を憶えておくための唯一の方法は、@code{Date} ヘッダーをもとにスコア
を付けることだけです --- つまりあなたがそのグループを最後に読んだ日付よ
り、前に投稿された記事を全て既読にする、ということです。

もし検索エンジンの出力形式が変更されると、@code{nnweb} はそれをうまく解
釈できず、処理は失敗するでしょう。もしウェブ提供者達がそんなことをしたら、
彼らを激しく責めるべきでしょう --- それは広告で金を稼ぐのが彼ら
の @emph{存在理由} であり、社会にサービスを提供することではないからです。
@code{nnweb} は全ての記事から広告を洗い流してしまうので、提供者たちがム
カついていると思われるかも知れません。まあ見ててください。

@code{nnweb} を使うには、@code{url} と @code{w3} パッケージをインストー
ルしておかなくてななりません。

以下は仮想サーバー変数です。

@table @code
@item nnweb-type
@vindex nnweb-type
どの検索エンジンを使っているか。現在サポートされている種類は、
@code{google}, @code{dejanews} そして @code{gmane} です。
@code{dejanews} は @code{google} の別名になっていることに注意して下さい。

@item nnweb-search
@vindex nnweb-search
検索エンジンに与える検索文字列。

@item nnweb-max-hits
@vindex nnweb-max-hits
表示する検索結果の最大数。初期値は 999 です。

@item nnweb-type-definition
@vindex nnweb-type-definition
型・定義連想リスト。この連想リストは、さまざまな検索エンジンの種類に対し
て、@code{nnweb} がどうすべきかを与えます。以下に示す要素を与えなくては
なりません。

@table @code
@item article
記事を復号化し、gnus が理解できる形で提供する関数。

@item map
記事番号からメッセージヘッダーと URL を得る連想リストを作成する関数。

@item search
検索エンジンに検索文字列を送る関数。

@item address
前述の関数が検索文字列を送るべきアドレス。

@item id
@code{Message-ID} をもとに記事を取得するための URL 形式文字列。
@end table
@end table

@node Slashdot
@subsection Slashdot
@cindex Slashdot
@cindex nnslashdot

Slashdot (@uref{http://slashdot.org/}) は人気のあるニュースサイトで、ニュー
ス記事の後に活発な議論がなされています。@code{nnslashdot} では便利な方法
でこの会議室を読むことができます。

ここから読むための一番簡単な方法は以下のようなものを @file{.gnus.el} ファ
イルに入れることです。

@lisp
(setq gnus-secondary-select-methods
      '((nnslashdot "")))
@end lisp

これは gnus に @code{nnslashdot} バックエンドに新しいコメントとグループ
を尋ねるようにします。@kbd{F} 命令はそれぞれの新しいニュース記事を新し
い gnus のグループとして購読し、これらのグループに入ることでコメントを読
むことができます。(初期設定の購読方法では、新しいグループをゾンビとして
購読することに注意してください。他の方法も使えま
す (@pxref{Subscription Methods})。

もしあなたが古い @code{nnslashdot} グループを削除したいのならば、
@kbd{G DEL} が最も手軽な道具です (@pxref{Foreign Groups})。

@code{nnslashdot} コメントにフォローアップ (または新しいコメントの投稿)
をするときは、少し @sc{html} に変換されます。特に、@samp{> } で引用され
たテキストはその代わりに @code{blockquote} で引用され、署名にはそれぞれ
の行の最後に @code{br} が追加されます。それ以外は、メッセージバッファに
直接 @sc{html} を書くことができます。Slashdot はいくつか @sc{html} を選
別することに気をつけてください。

以下の変数で振る舞いを変えることができます:

@table @code
@item nnslashdot-threaded
@code{nnslashdot} がグループをスレッドで表示するかどうか。初期値
は @code{t} です。スレッドを表示できるためには、@code{nnslashdot} はグルー
プに入る際にその全てのコメントを取得する必要があります。スレッド表示が要
求されていないと、@code{nnslashdot} は利用者が欲しいコメントだけを取得し
ます。スレッドの方がきれいですが、スレッド無し表示より、ずっとずっと遅く
なります。

@item nnslashdot-login-name
@vindex nnslashdot-login-name
投稿時に使うログイン名です。

@item nnslashdot-password
@vindex nnslashdot-password
投稿時に使うパスワードです。

@item nnslashdot-directory
@vindex nnslashdot-directory
@code{nnslashdot} がファイルを保存する場所です。初期値
は @samp{~/News/slashdot/} です。

@item nnslashdot-active-url
@vindex nnslashdot-active-url
ニュース記事とコメントを取得するために使われる @sc{url} の文字列です。初
期値は @samp{http://slashdot.org/search.pl?section=&min=%d} です。

@item nnslashdot-comments-url
@vindex nnslashdot-comments-url
コメントを取得するために使用される @sc{url} 文字列です。初期値
は @samp{http://slashdot.org/comments.pl?sid=%s&threshold=%d&commentsort=%d&mode=flat&startat=%d} で
す。

@item nnslashdot-article-url
@vindex nnslashdot-article-url
ニュース記事を取得するために使われる @sc{url} 文字列です。初期値
は @samp{http://slashdot.org/article.pl?sid=%s&mode=nocomment} です。

@item nnslashdot-threshold
@vindex nnslashdot-threshold
スコアのしきい値です。初期値は -1 です。

@item nnslashdot-group-number
@vindex nnslashdot-group-number
最新の 10 に加えて更新を続ける古いグループの数です。初期値は 0 です。
@end table

@node Ultimate
@subsection Ultimate
@cindex nnultimate
@cindex Ultimate Bulletin Board

Ultimate Bulletin Board (@uref{http://www.ultimatebb.com/}) はおそらく一
番良く使われているウェブ掲示板システムでしょう。とても整然として良い界面
で、gnus がグループを最新の状態に保っておくために情報を得ることが可能で
す。

@code{nnultimate} を始めるための一番簡単な方法はグループバッファで以下の
ようなものをすることです: @kbd{B nnultimate RET
http://www.tcj.com/messboard.ubbcgi/ RET}。(興味のある会議室
の @sc{url} (@samp{Ultimate.cgi} 等を最後に含んでいないもの) に変えてく
ださい。Ultimate ウェブサイトにはたくさん挙げられています。) それからサー
バーバッファで興味のあるグループを購読し、グループバッファからそれらを読
んでください。

以下の @code{nnutimate} 変数を変更可能です:

@table @code
@item nnultimate-directory
@vindex nnultimate-directory
@code{nnultimate} がファイルを保存するディレクトリーです。初期値
は @samp{~/News/ultimate/} です。
@end table

@node Web Archive
@subsection Web Archive
@cindex nnwarchive
@cindex Web Archive

メーリングリストの中には例えば、
@uref{http://www.egroups.com/} や @uref{http://www.mail-archive.com/} の
ようにウェブサーバーにしかアーカイブが無いものもあります。とても整然とし
て良い界面で、gnus がグループを最新の状態に保っておくために情報を得るこ
とが可能です。

@code{nnwarchive} を始めるための一番簡単な方法はグループバッファで以下の
ようなものをすることです: @kbd{M-x gnus-group-make-warchive-group RET
an_egroup RET egroups RET www.egroups.comRET your@@email.address RET}。
(@sc{an_egroup} を購読しているメーリングリストに、
@sc{your@@emailaddress} を電子メールアドレスに置き換えてください。)
または @kbd{B nnwarchive RET mail-archive RET} でバックエンドをブラウズ
して下さい。

以下の @code{nnwarchive} 変数を変えることが可能です:

@table @code
@item nnwarchive-directory
@vindex nnwarchive-directory
@code{nnwarchive} がファイルを保存するディレクトリーです。初期値
は @samp{~/News/warchive} です。

@item nnwarchive-login
@vindex nnwarchive-login
ウェブサーバーでのアカウント名です。

@item nnwarchive-passwd
@vindex nnwarchive-passwd
ウェブサーバーでのアカウントのパスワードです。
@end table

@node Web Newspaper
@subsection Web Newspaper
@cindex nnshimbun
@cindex Web Newspaper

最近では幾つかの新聞がウェブで公開されています。Gnus はこれらも適切に取
り扱うことが出来るようになりつつあります。現時点では朝日新聞、読売新聞、
スポニチ、CNET Japan、HOTWIRED Japan、ZDNet Japan などに対応しています。

@code{nnshimbun} は @code{shimbun} ライブラリに依存していますので、それ
を含んでいる emacs-w3m パッケージと外部コマンド w3m を先にインストールし
ておいてください。詳しいことは以下のページで知ることができます。

@example
  @uref{http://emacs-w3m.namazu.org/}
  @uref{http://w3m.sourceforge.net/}
@end example

@findex gnus-group-make-shimbun-group
@kindex G n (グループ)
@code{nnshimbun} を始めるための一番簡単な方法はグループバッファの適当な
場所で @kbd{G n asahi RET national RET} などとタイプすることです。
@samp{asahi} は接続したいサーバーのアドレスを示すシンボルに、
@samp{national} は閲覧したい記事グループにそれぞれ置き換えてください。両
方とも名前の補完ができます。
@c または @kbd{B nnshimbun RET asahi RET} でバックエンドをブラウズすること
@c によっても記事を読むことができます。
加えて、@sc{html} のドキュメントをインライン表示させたい場合は、
@file{~/.gnus} ファイルに以下の設定をして下さい。

@lisp
(require 'mime-w3m)
@end lisp

Web Newspaper に関する以下の @code{nnshimbun} 変数を変えることが可能です:

@table @code
@item nnshimbun-directory
@vindex nnshimbun-directory
@code{nnshimbun} がファイルを保存するディレクトリーです。初期値
は @samp{~/News/shimbun} です。
@end table

@cindex group parameters
@code{nnshimbun} は Gnus が提供する汎用のグループパラメー
タ @footnote{グループパラメータを設定するための最も手軽な方法は、グルー
プバッファで、設定したいグループの場所にカーソルがある状態
で @kbd{G c} をタイプすることです (@xref{Group Parameters})。} に加えて、
@code{nnshimbun} 専用のグループパラメータを利用することができます。それ
らは @code{nnshimbun-group-parameters} という単一のグループパラメータに
まとめられていますが、それが各グループ毎に持つことができる値はプロパティ
リストで、例えば次のような値です。

@lisp
'(index-range all prefetch-articles off encapsulate-images on
              expiry-wait 6)
@end lisp

実際にはこのようなリストの先頭に @code{nnshimbun-group-parameters} とい
うシンボルが付加されたものが、``~/.newsrc.eld'' ファイルに記録されます。
以降は、これらのグループパラメータと、それに関連する変数の説明です。

@table @code
@item prefetch-articles
@vindex nnshimbun-pre-fetch-article
このグループパラメータが @code{off} または @code{nil} 以外の値にセットさ
れているグループでは、@code{nnshimbun} は新着記事を検索と同時に記事のダ
ウンロードも行います。これによって新着記事の検索は遅くなりますが、記事の
閲覧時に待たされることは少なくなります。グループパラメー
タ @code{prefetch-articles} が設定されていないか、その値が @code{nil} に
なっているグループでは、グループパラメータ @code{prefetch-articles} の代
わりにディフォルト値として変数 @code{nnshimbun-pre-fetch-article} の値が
使われます。この変数 @code{nnshimbun-pre-fetch-article} の初期値
は @code{off} です。

@item encapsulate-images
@vindex nnshimbun-encapsulate-images
このグループパラメータが @code{off} または @code{nil} 以外の値にセットさ
れているグループでは、@code{nnshimbun} は元の記事に埋め込まれている画像
データを @samp{multipart/related} の形式で記事にはめ込みます。グループパ
ラメータ @code{encapsulate-images} が設定されていないか、その値が
@code{nil} になっているグループでは、グループパラメー
タ @code{encapsulate-images} の代わりにディフォルト値として変
数 @code{nnshimbun-encapsulate-images} の値が使われます。この変
数 @code{nnshimbun-encapsulate-images} のディフォルト値は、
@code{shimbun} ライブラリの変数 @code{shimbun-encapsulate-images} の値で
す (たぶんその初期値は @code{t} です)。

@item index-range
@vindex nnshimbun-index-range
グループパラメータ @code{index-range} で、ウェブサーバーから取得する記事
の範囲を指定することができます。範囲の指定には以下の値を使って下さい。

@example
@code{nil}, @code{all}:
        すべて
@code{last}:
        最新のみ
@samp{整数N}:
        最新から N ページ
@end example

@code{nnshimbun} はサーバー上に存在する目次ページを使って新着記事の有無
を調べますが、サーバーによってはそのような目次ページが複数存在する場合が
あります。例えば、メーリングリストの記事を提供しているサーバーの場合は、
その記事が投稿された日付によって分類された目次になっていることが一般的で
す。特に遅い回線を利用している時に、このように複数・大量の目次を調べるこ
とになると、大変時間がかかることになります。

@code{nnshimbun} は前回の接続時に調べた目次については、なるべく調べずに
済ませるようになっていますが、更に時間を節約したい場合は @code{last} を
使って下さい。こうすると最新の目次のみを参照して新着記事の検査を行うよう
になります。

グループパラメータ @code{index-range} が設定されていないか、値
が @code{nil} になっているグループでは、変
数 @code{nnshimbun-index-range} の値がディフォルトとして使われます。
なお、@code{nnshimbun-index-range} のディフォルト値は @code{nil} です。

@item nnshimbun-group-parameters-alist
@vindex nnshimbun-group-parameters-alist
@code{nnshimbun-group-parameters-alist} はカスタマイズ可能なユーザオプショ
ンで、各要素にグループ名の正規表現と @code{nnshimbun} 専用のグループパラ
メータと同じプロパティリストを持つことができる連想リストです。連想リスト
の各要素は次のような値を持ちます。初期値は @code{nil} です。

@lisp
'("^nnshimbun\\+asahi:" index-range all prefetch-articles off
  encapsulate-images on expiry-wait 6)
@end lisp

似た性格を持つ複数のグループに対して同じ設定を行なうことができるので、個々
のグループに対してそれぞれグループパラメータを設定する代わりに使うことが
できます。もし正規表現にマッチするグループでグループパラメータの設定が行
なわれていた場合は、その設定値の方が優先されます。
@end table

@cindex article expiry
@cindex auto-expire
@cindex expiry-wait
@vindex nnmail-expiry-wait-function
@vindex nnmail-expiry-wait
ところで @code{nnshimbun} バックエンドでは、記事の期限切れ消去を行なうこ
とができます @footnote{@code{nnshimbun} グループで自動期限切れ消去を行な
う方法には主に二種類あります。一つは ``^nnshimbun\\+'' で始まるグループ
名の正規表現を @code{gnus-auto-expirable-newsgroups} に追加して、消去す
るまでの日数を各グループ毎に @code{nnmail-expiry-wait-function} で指定す
ること。もう一つは @code{nnshimbun} の各グループ毎にグループパラメー
タ @code{auto-expire} を @code{t} にして、同じくグループパラメー
タ @code{expiry-wait} で消去するまでの日数を指定するやり方です。詳しいこ
とは @xref{Expiring Mail} を参照して下さい。なお本編でも触れていますが、
個々に日数を設定しない場合はディフォルトの値が適用されます。}。ああ、も
ちろんあなたが三日前の新聞記事を消去するように設定したからといって、新聞
社のサーバーにある三日前の記事が消えてしまうわけではありません。消えるの
はあなた個人が持っている @code{nnshimbun} 用の @sc{nov} ファイ
ル @footnote{@code{nnshimbun} 用の @sc{nov} ファイルと
は ``~/News/shimbun/asahi/national/.overview'' のようなものです。} の該
当する部分で、それによってその記事は二度と概略バッファに現れなくなります。

@code{nnshimbun} バックエンドでは記事の期限切れ消去を行なわない
と @sc{nov} ファイルが際限無く太り続け、新聞社のサーバーではとっくに無く
なってしまった三年前の記事が、概略バッファではあたかも存在しているように
見えます。それを読もうとしても記事バッファには何も現れません。一方メーリ
ングリストの記事を提供しているサーバーの場合には、過去の全記事を保有して
いる場合が少なくないでしょう。昔あなたが興じた一連の記事を読み返して懐か
しむために、そういうグループでは期限切れ消去はさせたくないと思うかもしれ
ません。

実は @code{nnshimbun} バックエンドでも、他のメールバックエンドと同様の方
法でグループ毎に自動期限切れ消去可能にしたり、残しておく期間を設定するこ
とができるのです。

ただ @code{nnshimbun} バックエンドの期限切れ消去には、他のメールバックエ
ンドと少しだけ違う点があります。第一に、残しておく期間のディフォルト値に
@code{shimbun} ライブラリが提供する値が関係し、以下の優先度で期間が決定
されることです。

@example
グループパラメータの @code{expiry-wait}
@code{nnmail-expiry-wait-function} を評価した値
@code{shimbun} ライブラリが提供するグループ毎のディフォルト値
@code{nnmail-expiry-wait} の値
@end example

第二に、@code{nnmail-expiry-wait-function} が関数だった場合に、その引数
に与えられる文字列に ``nnshimbin+asahi:national'' のようにバックエンドと
サーバーの名前が含まれることです。他のメールバックエンドの場合にはグルー
プ名だけが与えられるのに、です。一つ例を挙げましょう。

@lisp
(setq nnmail-expiry-wait-function
      (lambda (group)
        (cond ((string-equal group "wl") 7)
              ((string-equal group "nnshimbun+airs:wl") 'never))))
@end lisp

これは、例えば @code{nnml} や @code{nnmh} で受信している Wanderlust メー
リングリストの記事は 7日で期限切れ消去するが、@code{nnshimbun} で読む同
じメーリングリストのアーカイブはすべて読める状態にしておく、ということで
す。どうです、なかなか賢いでしょ?

第三に、これはあなたが不審に思ったときに思い出してくれることを期待して書
いておきますが、グループのすべての記事が期限切れ消去の対象になってしまっ
たときに、@code{nnshimbun} は最後の一通だけは消さずに残しておきます。こ
れはあなたの未練心を満足させるためではなく、サーバーから古い記事を再び取
得してしまわないための窮余の策なのです。

@code{nnshimbun} の期限切れ消去に関係するグループパラメータと変数は以下
の通りです。

@table @code
@item expiry-wait
@cindex expiry-wait
どうか混乱なさらないように。gnus が提供している汎用のグループパラメー
タ @code{expiry-wait} と同じ名前で意味も同じものが @code{nnshimbun} 専用
のグループパラメータにも用意されています。あなたはどちらを使っても構いま
せん。もし @code{nnshimbun} 専用のグループパラメータの方を @code{nil} 以
外の値に設定すると、汎用のグループパラメータの値よりも優先して使われます。
これは、グループバッファで @kbd{G c} をタイプしたときに現れる編集画面に
おいて、@code{nnshimbun} に関係するものを一箇所に集めるためと、ユーザオ
プション @code{nnshimbun-group-parameters-alist} で一括して管理できるよ
うにすることを目的に用意したものです @footnote{な
ぜ @code{auto-expire} なども @code{nnshimbun} 専用のグループパラメータに
含めておいてくれないの? という問いに対する答えを用意しています。
@code{expiry-wait} を参照するのが @code{nnshimbun} バックエンドなのに対
して、@code{auto-expire} などを参照するのは Gnus の本体なのですが、本体
の機能を特定のバックエンドの面倒を見るように拡張するのは、Gnus の設計思
想に反しているからです。}。設定できる値は汎用のグループパラメータと同様
に、時限消去の日数、@code{never} または @code{immediate} です。

@item nnshimbun-keep-unparsable-dated-articles
@vindex nnshimbun-keep-unparsable-dated-articles
この変数の値が @code{nil} でない場合は、作成されたり送信された時刻がよく
わからない記事を期限切れ消去しません。なにしろ期限がわからないんですから。
初期値は @code{t} ですが、@code{nil} にすると期限切れ消去の処理が行なわ
れるときに、期限がわからない記事でも有無を言わず消してしまいます。まあ、
年の暮れの大掃除のときにでも使って下さい。
@end table

@node RSS
@subsection RSS
@cindex nnrss
@cindex RSS

いくつかのサイトは RDF site summary (RSS) を持っていま
す @uref{http://purl.org/rss/1.0/spec}。これはとても規則的かつ良質なイン
ターフェースで、gnus がグループを常に新しくしておくための情報を得ること
ができます。

簡単に @code{nnrss} を使い始めるには、グループバッファ
で @kbd{B nnrss RET RET} とタイプして、グループを講読して下さい。

以下の @code{nnrss} 変数が変更可能です:

@table @code
@item nnrss-directory
@vindex nnrss-directory
@code{nnrss} がファイルを書き込むディレクトリーで、ディフォルト
は @samp{~/News/rss/} です。
@end table

概略バッファに説明を表示させたいならば、以下のコードが役に立つでしょう。

@lisp
(add-to-list 'nnmail-extra-headers nnrss-description-field)
(setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-15,15f%]%) %s%uX\n")

(defun gnus-user-format-function-X (header)
  (let ((descr
         (assq nnrss-description-field (mail-header-extra header))))
    (if descr (concat "\n\t" (cdr descr)) "")))
@end lisp

以下のコードは、概略バッファから直接 nnrss の url をオープンするのに便利
かもしれません。
@lisp
(require 'browse-url)

(defun browse-nnrss-url( arg )
  (interactive "p")
  (let ((url (assq nnrss-url-field
                   (mail-header-extra
                    (gnus-data-header
                     (assq (gnus-summary-article-number)
                           gnus-newsgroup-data))))))
    (if url
        (browse-url (cdr url))
      (gnus-summary-scroll-up arg))))

(eval-after-load "gnus"
  #'(define-key gnus-summary-mode-map
      (kbd "<RET>") 'browse-nnrss-url))
(add-to-list 'nnmail-extra-headers nnrss-url-field)
@end lisp

@node Customizing w3
@subsection w3 のカスタマイズ
@cindex w3
@cindex html
@cindex url
@cindex Netscape

Gnus はウェブページを取得するために url ライブラリを、ウェブページを表示
するために Emacs/W3 を使います。Emacs/W3 のことはそのマニュアルに記載さ
れていますが、ここでは Gnus のユーザにとってより適切ないくつかの事柄を述
べることにします。

例えば、よくある質問に Emacs/W3 に @code{browse-url} の機能 (Netscape の
ような外部プラウザーを使うように設定されている) を使ってリンクを参照させ
るにはどうしたらよいか、というのがあります。以下は一つの方法です。

@lisp
(eval-after-load "w3"
  '(progn
    (fset 'w3-fetch-orig (symbol-function 'w3-fetch))
    (defun w3-fetch (&optional url target)
      (interactive (list (w3-read-url-with-default)))
      (if (eq major-mode 'gnus-article-mode)
          (browse-url url)
        (w3-fetch-orig url target)))))
@end lisp

これをあなたの .emacs ファイルに書き込むことによって、Gnus の記事バッファ
で @sc{html} リンクを叩けば、@code{browse-url} を使ってそのリンクを参照
するようになるでしょう。

@node IMAP
@section IMAP
@cindex nnimap
@cindex IMAP

@sc{imap} はメール (もしくは、ニュース、もしくは ...) を読むためのネット
ワークプロトコルです。現代風の @sc{nntp} と考えてください。@sc{imap} サー
バーへの接続はニュースサーバーへの接続と非常に似ていて、そのサーバーのネッ
トワークアドレスを指定するだけになっています。

@sc{imap} には二つの特質があります。一つは、@sc{imap} は POP でできるこ
とは全部できる、それゆえ POP++ のようにも見えるということ。二つ目は、
@sc{imap} は @sc{nntp} がニュースを貯蔵するプロトコルであるように、メー
ルを貯蔵するプロトコルであるということです。しかしなが
ら @sc{imap} は @sc{nntp} より多くの機能を提供します。ニュースは読むだけ
ですが、メールは読み書きができます。

@sc{imap} を POP++ のように使いたいときは、
@code{mail-sources} に imap を登録して下さい。これによっ
て gnus は @sc{imap} サーバーからメールを取り込んで、ローカルディスクに
貯蔵します。ここではその使い方の説明はしませんので、
@xref{Mail Sources} を参照して下さい。

@sc{imap} をメールを貯蔵するプロトコルとして使いたいときは、
@code{gnus-secondary-select-methods} に nnimap を登録して下さい。これに
よって gnus は @sc{imap} サーバーに貯蔵されているメールを操作するように
なります。これがここで説明する使い方です。

いくつかの @sc{imap} サーバーを @code{~/.gnus} で設定すると、たぶん以下
のようなものになるでしょう。(注: SSL/TLS では外部プログラムとライブラリ
が必要です。以下を参照して下さい。)

@lisp
(setq gnus-secondary-select-methods
      '((nnimap "simpleserver") ; 普通の設定
        ; SSH ポートをフォワードしたサーバー:
        (nnimap "dolk"
                (nnimap-address "localhost")
                (nnimap-server-port 1430))
        ; ローカルホストで運転している UW サーバー:
        (nnimap "barbar"
                (nnimap-server-port 143)
                (nnimap-address "localhost")
                (nnimap-list-pattern ("INBOX" "mail/*")))
        ; 匿名で使える cyrus の公衆サーバー:
        (nnimap "cyrus.andrew.cmu.edu"
                (nnimap-authenticator anonymous)
                (nnimap-list-pattern "archive.*")
                (nnimap-stream network))
        ; 標準ではないポートの SSL サーバー:
        (nnimap "vic20"
                (nnimap-address "vic20.somewhere.com")
                (nnimap-server-port 9930)
                (nnimap-stream ssl))))
@end lisp

以下の変数は仮想 @code{nnimap} サーバーを作成するために使うことができま
す。

@table @code
@item nnimap-address
@vindex nnimap-address

遠隔 @sc{imap} サーバーのアドレスです。指定されていない場合は仮想サーバー
のものになります。

@item nnimap-server-port
@vindex nnimap-server-port
接続を試みるサーバーのポートです。初期値では、ポート 143 か、SSL で
は 993 です。

これは整数でなければなりません。以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-server-port 4711))
@end lisp

@item nnimap-list-pattern
@vindex nnimap-list-pattern
使用可能なメールボックスを制限するための文字列かリストです。これは、サー
バーに非常に多くのメールボックスがあるけれど、興味のあるものは少しだけで
あるときに使用します。サーバーにはホームディレクトリーを @sc{imap} 経由
で出すものもありますので、その場合はおそらくメールボックス
を @file{~/Mail/*} に制限したいでしょう。

文字列は REFERENCE と上の文字列との cons であることもできます。ど
の REFERENCE が使用されるかはサーバー特有ですが、ワシントン大学のサーバー
では、メールボックスと連結されたディレクトリーです。

以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-list-pattern ("INBOX" "Mail/*" "alt.sex.*"
                               ("~friend/Mail/" . "list/*"))))
@end lisp

@item nnimap-stream
@vindex nnimap-stream
サーバーに接続するときに使われるストリームの型です。初期設定で
は nnimap は SSL/TLS を除く以下のすべてを自動的に検知してそれを使います。
(SSL/TLS を使う @sc{imap} は STARTTLS で置き換えられています。これは自動
検出できますが、まだ広範囲に配備されていません。)

以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-stream ssl))
@end lisp

@code{nnimap-stream} の値はシンボルでなければならないことに注意して下さ
い!

@itemize @bullet
@item
@dfn{gssapi:} GSSAPI (普通は Kerberos 5) を使います。@samp{imtest} プロ
グラムが必要です。
@item
@dfn{kerberos4:} Kerberos 4 を使います。@samp{imtest} プログラムが必要で
す。
@item
@dfn{starttls:} STARTTLS (SSL に類似) を使います。外部ライブラ
リ @samp{starttls.el} と @samp{starttls} プログラムが必要です。
@item
@dfn{ssl:} SSL を使います。OpenSSL (@samp{openssl} プログラム) か SSLeay
(@samp{s_client}) と外部ライブラリ @samp{ssl.el} が必要です。
@item
@dfn{shell:} シェル命令を使って @sc{imap} 接続を開始します。
@item
@dfn{network:} 生の、TCP/IP のネットワーク接続です。
@end itemize

@vindex imap-kerberos4-program
@samp{imtest} プログラムは Cyrus IMAPD に含まれています。もしあなた
が 2.0.14 未満の Cyrus IMAPD に含まれている @samp{imtest} (バージョ
ン 1.5.x と 1.6.x) を使っているなら、
@code{imap-process-connection-type} をいじり回して、
@code{imap.el} が @samp{imtest} と通信するときにパイプではなく
て pty を使うようにさせる必要があります。そうするとあなたは @sc{imap} コ
マンドの行の長さの制限に悩まされるでしょう。それはメールボックスにたくさ
んの記事があるときに Gnus を無期限にハングさせてしまうかもしれません。変
数 @code{imap-kerberos4-program} は imtest プログラムに渡すパタメータを
含みます。

@vindex imap-ssl-program
SSL 接続のための OpenSSL プログラムは @uref{http://www.openssl.org/} か
ら入手できます。OpenSSL は以前は SSLeay として知られていたもので、
nnimap はそれもサポートします。しかし、SSLeay の最新版である 0.9.x には
重大なバグがあるため使えません。以前の版、特に SSLeay 0.8.x は使えること
がわかっています。変数 @code{imap-ssl-program} は OpenSSL/SSLeay に渡す
パタメータを含みます。加えて @samp{ssl.el}  (例えば W3 に含まれているも
の) が必要です。

@vindex imap-shell-program
@vindex imap-shell-host
@sc{imap} 接続に @code{shell} ストリームを使う場合、変
数 @code{imap-shell-program} は何のプログラムを呼ぶかを指定します。

@item nnimap-authenticator
@vindex nnimap-authenticator

サーバーに接続するために使われる認証です。初期設定では、nnimap はサーバー
が使用可能な一番安全な認証を使用します。

以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-authenticator anonymous))
@end lisp

@code{nnimap-authenticator} の値はシンボルでなければならないことに注意し
て下さい!

@itemize @bullet
@item
@dfn{gssapi:} GSSAPI (普通は Kerberos 5) 認証です。外部プログラ
ム @code{imtest} が必要です。
@item
@dfn{kerberos4:} Kerberos 4 による認証です。外部プログラ
ム @code{imtest} が必要です。
@item
@dfn{digest-md5:} DIGEST-MD5 で暗号化された 利用者名/パスワード です。外
部ライブラリ @code{digest-md5.el} が必要です。
@item
@dfn{cram-md5:} CRAM-MD5 で暗号化された 利用者名/パスワード です。
@item
@dfn{login:} LOGIN 経由での生の 利用者名/パスワード です。
@item
@dfn{anonymous:} 電子メールアドレスをパスワードとし、`anonymous' として
ログインします。
@end itemize

@item nnimap-expunge-on-close
@cindex Expunging
@vindex nnimap-expunge-on-close

パルメニデスと違って、@sc{imap} の設計者達は、存在していないものが実際に
は存在していると決めました。もっと詳しく説明すると、@sc{imap} は実際には
記事を消去しない、記事に @code{Deleted} という印を付ける概念があり、こ
れ (えっと、@code{Deleted} という印を付けることで
す) が nnimap が Gnus で記事を消去するときにすることです (@kbd{B DEL} な
どで)。
(訳注: パルメニデスは紀元前 5 世紀のギリシアの Elea 派の哲学者)

記事を @code{Deleted} フラグで印を付けたときには本当は消去されていないの
で、実際に消去するための方法が必要となります。循環しているように感じます
か?

伝統的に、nnimap はメールボックスを閉じるときに @code{Deleted} という印
の付いた全ての記事を消去してきましたが、今はサーバー変数により設定可能で
す。

選択肢は:

@table @code
@item always
初期設定の振舞い、メールボックスを閉じるときに @code{Deleted} と印の付い
た記事を消去します。
@item never
決して記事を消去しません。現在は、消去の印が付いた記事を nnimap で表示す
る方法はありませんが、他の @sc{imap} クライアントはではできるかもしれま
せん。手で EXPUNGE コマンドを発行したいときは @xref{Expunging mailboxes}。
@item ask
メールボックスを閉じるときに、nnimap が消去された記事を削除するかどうか
を尋ねます。
@end table

@item nnimap-importantize-dormant
@vindex nnimap-importantize-dormant

非-nil (ディフォルト) だったら、他の @sc{imap} クライアントのために保留
記事を印付きとしても印を付けます。gnus の内部では、保留記事は元々すでに
保留記事としてのみ印が付けられています。これは、他の @sc{imap} クライア
ントにおける保留記事を、あたかも印付きのようにきわ立たせます。(別の言い
方をすると、gnus は二つの印を付け、@sc{imap} はたった一つだということで
す。)

たぶんこれをいじりまわすのは、あなたがユーザ単位の保留フラグを付けようと
するだけの理由によるでしょう。こんな感じで:

@lisp
(setcdr (assq 'dormant nnimap-mark-to-flag-alist)
        (format "gnus-dormant-%s" (user-login-name)))
(setcdr (assq 'dormant nnimap-mark-to-predicate-alist)
        (format "KEYWORD gnus-dormant-%s" (user-login-name)))
@end lisp

この場合、あなたはユーザ単位の保留フラグを、他のユーザに印付きとして見ら
れたくないと思っています。

@item nnimap-expunge-search-string
@cindex Expunging
@vindex nnimap-expunge-search-string

この変数には、期限切れ消去するのが望ましい記事を探すときにサーバーに送っ
た @sc{imap} の検索コマンドが入っています。ディフォルト
は @code{"UID %s NOT SINCE %s"} で、ここで最初の @code{%s} は UID で置き
換えられ、二番目の @code{%s} は日付で置き換えられます。

たぶん使いものになる別の値は @code{"UID %s NOT SENTSINCE %s"} で、
nnimap に記事の内部的な日付の代わりに Date: を使うようにさせます。さらな
る情報や使うことができる文字列については、RFC 2060 のセクション 6.4.4 を
見てください。

@item nnimap-authinfo-file
@vindex nnimap-authinfo-file

サーバにログインするために使う認証情報 (authinfo) を含むファイルです。そ
の形式は (ほとんど) @code{ftp} の @file{~/.netrc} ファイルと同じです。厳
密な定義は、変数 @code{nntp-authinfo-file} を見て下さい。そし
て @ref{NNTP} も見て下さい。
@end table

@menu
* Splitting in IMAP::           nnimap でメールを分割する
* Editing IMAP ACLs::           メールボックスへの他の利用者の使用を制限
                                /許可する
* Expunging mailboxes::         "メールボックス圧縮" ボタンと等価なもの
@end menu

@node Splitting in IMAP
@subsection IMAP での分割
@cindex splitting imap mail

分割は gnus の利用者が何年もの間愛してきたもので、今や残りの世界も追いつ
こうとしています。はい、想像してください、@sc{imap} サーバーのなかにサー
バー側で分割できるものはあまり多くなく、しかもそれらは標準でないプロトコ
ルを使っているようです。これは、gnus の @sc{imap} サポートは自分自身で分
割をしなければならないということです。

そして実際にします。

関連する変数は三つです:

@table @code
@item nnimap-split-crosspost
@cindex splitting, crosspost
@cindex crosspost
@vindex nnimap-split-crosspost

nil でなければ、いくつかの分割方法がメールと合致したときに相互投稿をしま
す。nil ならば、@code{nnimap-split-rule} で最初に見つかったものが使われ
ます。

Nnmail で対応するもの: @code{nnmail-crosspost}.

@item nnimap-split-inbox
@cindex splitting, inbox
@cindex inbox
@vindex nnimap-split-inbox

分割の元となる @sc{imap} のメールボックスの名前を指定した文字列か文字列
のリストです。初期値は @code{nil} で、分割は使用しないようになっています!

@lisp
(setq nnimap-split-inbox
      '("INBOX" ("~/friend/Mail" . "lists/*") "lists.imap"))
@end lisp

Nnmail に対応するものはありません。

@item nnimap-split-rule
@cindex Splitting, rules
@vindex nnimap-split-rule

@code{nnimap-split-inbox} で見つかった新しいメールはこの変数に従って分割
されます。

この変数はリストのリストから成ります。副リストの最初の要素
は @sc{imap} のメールボックスで、二つめの要素の正規表現に合致した記事の
移動先を指定します。わかりましたか? いいえ、私もわかりません。例が必要で
す。

@lisp
(setq nnimap-split-rule
      '(("INBOX.nnimap"
         "^Sender: owner-nnimap@@vic20.globalcom.se")
        ("INBOX.junk"    "^Subject:.*MAKE MONEY")
        ("INBOX.private" "")))
@end lisp

これは nnimap メーリングリストからの全ての記事をメールボック
ス INBOX.nnimap に入れ、Subject: 行に MAKE MONEY のある全ての記事
を INBOX.junk に入れ、その他全てのものを INBOX.private に入れます。

最初の文字列は、replace-match で合致したテキストから副表現を挿入するとき
に使用されるのと同じような、`\\1' 形式を含むことができます。例えば:

@lisp
("INBOX.lists.\\1"     "^Sender: owner-\\([a-z-]+\\)@@")
@end lisp

二つ目の要素は関数であることもできます。その場合は、記事のヘッダーがある
バッファで、その規則の最初の要素を引数として呼ばれます。メールがそのグルー
プに属すると考える場合は、@code{nil} でない値を返す必要があります。

Nnmail の利用者は最後の正規表現は全ての記事に合致するように空でなくては
ならないことを覚えているかもしれません (上の例のように)。これ
は nnimap では必要ではありません。正規表現のどれにも合致しない記事
は inbox から移動されません。(inbox に未読記事を大量に置いておくと、分割
のコードは新しいメールを取得するときにそれら全てを調べるので、実行速度に
影響する可能性があります。)

これらの規則は連想リストの最初から終りに向かって実行されます。相互投稿が
使用可能になっていないかぎり、最初に合致した規則が "勝ち" ます。相互投稿
をしている場合は、全ての合致した規則が "勝ち" ます。

この変数はその値として関数を持つこともできます。その関数は記事のヘッダの
部分に範囲が狭められた状態で呼ばれ、記事の移動先だと思うグループを返すも
のでなければなりません。@code{nnimap-split-fancy} を参照して下さい。

分割コードは必要ならメールボックスを作成します。

異なる仮想サーバー毎に違う分割の規則を使ったり、それどころか同じサーバー
の異なる inbox 毎に違う分割の規則を使うことができるようにするために、こ
の変数の構文は以下のように拡張されています。

@lisp
(setq nnimap-split-rule
      '(("my1server"    (".*"    (("ding"    "ding@@gnus.org")
                                  ("junk"    "From:.*Simon")))
        ("my2server"    ("INBOX" nnimap-split-fancy))
        ("my[34]server" (".*"    (("private" "To:.*Simon")
                                  ("junk"    my-junk-func)))))
@end lisp

仮想サーバー名は実際には正規表現なので、同じ規則をいくつかのサーバーに適
用できるでしょう。この例ではサー
バー @code{my3server} と @code{my4server} が同じ規則を使います。同様
に inbox 文字列も正規表現です。上記の分割の規則の実例は、関数、またはグ
ループの正規表現かグループの関数、の両方です。

Nnmail で対応するもの: @code{nnmail-split-methods}.

@item nnimap-split-predicate
@cindex splitting
@vindex nnimap-split-predicate

この述語にマッチする @code{nnimap-split-inbox} にあるメールは分割されま
す。これは文字列で既定値は @samp{UNSEEN UNDELETED} です。

もしあなたが inbox にあるメールを読むために別の @sc{imap} クライアントを
使っているが、購読度に関わらずにすべての記事を gnus に分割させたいならば、
これは役に立つかもしれません。その場合は @samp{UNDELETED} に変えれば良い
でしょう。

@item nnimap-split-fancy
@cindex splitting, fancy
@findex nnimap-split-fancy
@vindex nnimap-split-fancy

もしあなたが特級分割を使いたいならば、@code{nnimap-split-rule} の値
を @code{nnmail-split-fancy} に設定することができます。
@xref{Fancy Mail Splitting}。

しかし nnmail と nnimap とで異なる特級分割方式を持つようにするには、
@code{nnimap-split-rule} の値を @code{nnimap-split-fancy} に設定して、
nnimap 特有の特級分割方式を @code{nnimap-split-fancy} に定義して下さい。

例:

@lisp
(setq nnimap-split-rule 'nnimap-split-fancy
      nnimap-split-fancy ...)
@end lisp

Nnmail で対応するもの: @code{nnmail-split-fancy}.
@end table

@node Editing IMAP ACLs
@subsection IMAP の ACL を編集する。
@cindex editing imap acls
@cindex Access Control Lists
@cindex Editing @sc{imap} ACLs
@kindex G l
@findex gnus-group-nnimap-edit-acl

ACL は Access Control List (使用制限一覧) の略です。@sc{imap} で
は ACL は他の利用者によるあなたのメールボックスの使用を制限 (もしくは許
可) するために使われています。@sc{imap} サーバー全てにこの機能があるわけ
ではなく、無いサーバーでこれらの関数を使うとエラーが発生します。

メールボックスへの ACL を編集するためには、
@kbd{G l} (@code{gnus-group-edit-nnimap-acl}) を入力します。そうすると、
詳しい指示とともに ACL 編集ウィンドウが現れます。

使用の例:

@itemize @bullet
@item
メーリングリストのメールボックスで "anyone" に "lrs" 許
可 (lookup, read, seen/unseen フラグの保持) を与えることで、同じサーバー
の他の利用者がそれを購読することなく読むことができます。
@item
少なくとも Cyrus のサーバーにおいては、"plussing" が動作するために (つま
り、user+mail@@domain が INBOX.mailbox という @sc{imap} のメールボックス
になる)、利用者 "anyone" に投稿 ("p") の許可を与える必要があります。
@end itemize

@node Expunging mailboxes
@subsection メールボックスの削除
@cindex expunging

@cindex Expunge
@cindex Manual expunging
@kindex G x
@findex gnus-group-nnimap-expunge

@code{nnimap-expunge-on-close} に @code{never} を設定していれば、メール
ボックスの全ての消去された記事を手動で削除したいと思うでしょう。
@kbd{G x} がまさにこのことをします。

現時点では、消去された記事を表示する方法はありません。ただ消去できるだけ
です。

@node Other Sources
@section その他のグループ源

Gnus はただ単にニュースやメールを読む以上のことができます。以下
に示す方法によって、gnus でディレクトリーやファイルを、あたかも
ニュースグループであるかのように閲覧することができるようになりま
す。

@menu
* Directory Groups::            ディレクトリーをニュースグループのように
                                読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* SOUP::                        @sc{soup} パケットを ``オフライン'' で読む
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通し
                                て記事を投稿する
@end menu

@node Directory Groups
@subsection ディレクトリーグループ
@cindex nndir
@cindex directory groups

もし、たくさんの記事が個別のファイルとして入っているディレクトリーがあれ
ば、それをニュースグループとして扱うことができます。もちろん、ファイルは
数字のファイル名をもっていなければなりません。

ここで Emacs の素晴らしいパッケージの中でも最も素晴らし
い @code{ange-ftp} (とその後継の @code{efs}) について触れる良い機会でしょ
う。私が @code{nndir} を書いたときは、これ --- ディレクトリーを読むバッ
クエンドについてはあまり考えていませんでした。とんでもないことだね。

@code{ange-ftp} はこの情況を劇的に変化させました。例えば、
@code{ange-ftp} ファイル
名 @file{/ftp.hpc.uh.edu:/pub/emacs/ding-list/} をディレクトリー名として
入力したとすると、@code{ange-ftp} あるいは @code{efs} は実に、
@samp{シナ} の向こうのディレクトリーをニュースグループとして読むことを可
能にするのです。おーい、分散ニュースよ!

@code{nndir} は @sc{nov} ファイルが存在すればそれを利用します。

@code{nndir} は ``読み出し専用'' のバックエンドです --- この選択方法では、
記事の削除や期限切れ消去を行なうことはできません。@code{nndir} が使える
ものなら何でも @code{nnmh} あるいは @code{nnml} を使うことができるので、
もし読み出し専用ではない @code{nndir} が必要だと思ったら、これらのどちら
かの方法に切り替えることもできます。

@node Anything Groups
@subsection なんでもグループ
@cindex nneething

(一つのスプール風ディレクトリーと解釈できる) @code{nndir} バックエンドか
ら @code{nneething} までは、ほんのすぐそこです。それはいかなるディレクト
リーでもニュースグループに見せかけてしまう、というものです。不思議です、
でも真実です。

@code{nneething} にディレクトリーを与えると、そのディレクトリーを走査し、
各ファイルに記事番号を割り当てます。このようなグループに入ったときは、
@code{nneething} は gnus が使う ``ヘッダー'' を作らなくてはなりません。
つまるところ、gnus はニュースリーダなんです。忘れてるかもしれないので念
のため。@code{nneething} はこれを二段階で処理します。最初に、問題となる
ファイルをそれぞれ詮索してまわります。もしそのファイルが記事のように見え
たなら (すなわち、最初の数行がヘッダーのように見えたら) それをヘッダとし
て使います。もしそれがヘッダーのないただの適当なファイル (例えば C のソー
スファイル) であったなら、@code{nneething} はヘッダーを虚空から作り出し
ます。これはファイルの所有者、名前、日付を使い、これらの要素に対してでき
ることを何でもやります。

これはあなたにとっては全て自動的に起こることで、あなたはニュースグループ
にとても良く似た何かを見せられることになるでしょう。ほんとうに寸分違わな
い、ニュースグループのようなものを。記事を選択すると、それはいつものよう
に、記事バッファに表示されるでしょう。

ディレクトリーを表わしている行を選択すると、gnus はあなたをこ
の @code{nneething} グループのための新しい概略バッファに連れて行くでしょ
う。以下同様で、もしあなたがそうしたければ、この方法で全ディスクを駆け巡
ることができます。ですが、gnus は本当は dired ではなく、そのように意図さ
れたものでもない、ということは覚えておいてください。

ここでの動作には全体的に二つのモードがあります --- 一時モードと固定モー
ドです。一時的な操作を行なっているときは(すなわち、グループバッファ
で @kbd{G D} とする)、gnus はどのファイルを読んだか、どのファイルが新し
いか、などの情報を憶えておきません。もし @kbd{G m} で普通に固
定 @code{nneething} グループを作ると、gnus は記事番号とファイル名の対応
表を憶えておき、このグループを他のグループと同様に扱うことができるように
なります。固定 @code{nneething} グループを作動させると、未読記事がいくつ
含まれているかを知らされたり、などなど。

いくつかの変数があります。

@table @code
@item nneething-map-file-directory
@vindex nneething-map-file-directory
全ての固定 @code{nneething} グループの対応表はこのディレクトリーに格納さ
れます。この初期設定値は @file{~/.nneething/} です。

@item nneething-exclude-files
@vindex nneething-exclude-files
この正規表現にマッチするファイルはすべて無視されます。自動保存ファイルな
どを除くのに便利に使えます。そしてそれがまさに初期設定で行なわれる動作で
す。

@item nneething-include-files
@vindex nneething-include-files
そのファイルをグループに含めるかを示す正規表現です。この変数
が @code{nil} でなければ、この正規表現に合致するファイルだけが含まれます。

@item nneething-map-file
@vindex nneething-map-file
対応表ファイルの名前。
@end table

@node Document Groups
@subsection 文書グループ
@cindex nndoc
@cindex documentation group
@cindex help group

@code{nndoc} は一つのファイルをニュースグループとして読むことをできるよ
うにする、ちょっと気の利いたやつです。いくつかのファイル種別がサポートさ
れています。

@table @code
@cindex babyl
@cindex rmail mbox

@item babyl
babyl (rmail) 形式のメールボックス。
@cindex mbox
@cindex Unix mbox

@item mbox
標準 Unix mbox ファイル。

@cindex MMDF mail box
@item mmdf
MMDF 形式のメールボックス。

@item news
いくつかのニュース記事が連結された一つのファイル。

@item rnews
@cindex rnews batch files
rnews のバッチ転送形式。
@cindex forwarded messages

@item forward
転送された記事。

@item nsmail
Netscape のメールボックス。

@item mime-parts
@sc{mime} 部分メッセージ (multipart)。

@item standard-digest
標準 (RFC 1153) まとめ送り形式。

@item mime-digest
@sc{mime} のまとめ送りメッセージ。

@item lanl-gov-announce
ロスアラモス国立研究所 (LANL) Gov Announce からの発表メッセージ。

@item rfc822-forward
RFC822 で転送されたメッセージ。

@item outlook
Outlook のメールボックス。

@item oe-dbx
Outlook Express の dbx メールボックス。

@item exim-bounce
Exim MTA から跳ね返されたメッセージ。

@item forward
非公式の規則で転送されたメッセージ。

@item rfc934
RFC934 形式で転送されたメッセージ。

@item mailman
mailman のまとめ送り。

@item clari-briefs
Clarinet のニュース項目を要約したまとめ送り。

@item slack-digest
非標準まとめ送り形式 --- だいたいはうまくマッチするが、でも扱いは下手。

@item mail-in-mail
最後の手段。
@end table

また、特別な ``ファイル種別'' @code{guess} を使うこともできます。これ
は @code{nndoc} は注目しているファイルの種別を推測しようとする、という意
味です。@code{digest} は @code{nndoc} にそのファイルがどのまとめ送り形式
かを推測させるという意味です。

@code{nndoc} はファイルを書き換えようとしたり、余分なヘッダーを挿入しよ
うとしたりはしません --- 単純に、ファイルをそのグループの主成分として使
えるようにする、というようなものです。それだけのことです。

もしあなたが古い保存記事を持っていて、それを新しくてかっこいい gnus のメー
ルバックエンドに追加したいというときは、おそらく @code{nndoc} が助けにな
ります。例えばあなたがメールを古い @file{RMAIL} で持っていて、それをあな
たの新しい @code{nnml} グループに分配したいとします。あなたはそのファイ
ルを @code{nndoc} を使って開いて (グループバッファで @kbd{G f} 命令を使
う (@pxref{Foreign Groups}))、バッファ内の全記事にプロセスマークを付
け (例えば @kbd{M P b})、そして @code{nnml} を使って再スプー
ル (@kbd{B r}) します。全てがうまく行けば、@file{RMAIL} ファイル内の全て
のメールはたくさんの  @code{nnml} ディレクトリーの中にも保存されます。そ
してあなたはあの厄介な @file{RMAIL} を削除することもできます。あなたにガッ
ツがあれば!

仮想サーバー変数。

@table @code
@item nndoc-article-type
@vindex nndoc-article-type
これは @code{mbox}, @code{babyl}, @code{digest}, @code{news},
@code{rnews}, @code{mmdf}, @code{forward}, @code{rfc934},
@code{rfc822-forward}, @code{mime-parts}, @code{standard-digest},
@code{slack-digest}, @code{clari-briefs}, @code{nsmail}, @code{outlook},
@code{oe-dbx}, @code{mailman} および @code{mail-in-mail} また
は @code{guess} のいずれかでなくてはなりません。

@item nndoc-post-type
@vindex nndoc-post-type
この変数は gnus にそのグループがニュースグループかメールグループかを教え
ます。正当な値は二つあります。@code{mail} (初期設定)か @code{news}です。
@end table

@menu
* Document Server Internals::   あなた独自の文書種別を追加する方法
@end menu

@node Document Server Internals
@subsubsection 文書サーバーの内部

@code{nndoc} で認識される新しい文書種別を追加することは難しくありません。
その文書がどのように見えるのかを寄せ集めて、その文書種別を認識する述語関
数を書き、そして @code{nndoc} に繋げるだけです。

まず、これが文書種別定義の例です。

@example
(mmdf
 (article-begin .  "^\^A\^A\^A\^A\n")
 (body-end .  "^\^A\^A\^A\^A\n"))
@end example

この定義は単に、唯一の名前 (@dfn{name}) とそれに続く正規表現と仮想変数設
定の列からなります。以下がこれに使える変数です --- 変数の数に圧倒されな
いでください。ほとんどの文書種別はごくわずかの設定で定義できます。

@table @code
@item first-article
これがあれば、@code{nndoc} はこの正規表現にマッチする何かが見つかるまで、
全てのテキストを読み飛ばします。マッチする前の全てのテキストは完全に無視
されます。

@item article-begin
この設定は全ての文書種別定義において必ずなくてはなりません。これは各記事
の始まりがどのように見えるかを指定します。

@item head-begin-function
これがある場合、これは記事の先頭にポイントを移動させる関数でなくてはなり
ません。

@item nndoc-head-begin
これがある場合、これは記事のヘッダーにマッチする正規表現でなくてはなりま
せん。

@item nndoc-head-end
これは記事のヘッダーの最後にマッチしなくてはなりません。この初期設定値
は @samp{^$} --- 空行です。

@item body-begin-function
これがある場合、この関数は記事のボディの開始位置にポイントを移動させる関
数でなくてはなりません。

@item body-begin
これは記事のボディの開始位置にマッチしなくてはなりません。この初期設定値
は @samp{^\n} です。

@item body-end-function
これがある場合、この関数は記事のボディの最後の位置にポイントを移動させる
関数でなくてはなりません。

@item body-end
これがあれば、記事のボディの最後にマッチしなくてはなりません。

@item file-end
これがある場合、これはファイルの最後にマッチしなくてはなりません。この正
規表現の後ろのテキストは全て、完全に無視されます。
@end table

このように、これらの変数を使って @code{nndoc} は文書ファイルを、それぞれ
ヘッダーとボディを持った記事の連なりとして解剖することができます。しかし、
全ての文書種別が全てこのようなニュース風になってるわけではないので、さら
にいくつかの変数 --- ヘッダーやボディを gnus の趣味に合うように変形させ
る変数が必要になります。

@table @code
@item prepare-body-function
これがあれば、この関数は記事が要求されたときに呼び出されます。これはボディ
の開始位置のポイントとともに呼び出され、文書の内容の一部が符号化されてい
る場合に有用です。

@item article-transform-function
これがあれば、この関数は記事が要求されたときに呼び出されます。これは、記
事のヘッダーとボディの両方により広範囲な変形を行なうために使われるもので
す。

@item generate-head-function
これがあれば、この関数は gnus が理解できるヘッダーを生成するために呼び出
されます。これは記事番号をパラメータとして呼び出され、問題の記事のきれい
なヘッダーを生成することを求められます。これは全ての記事のヘッダーが要求
されるときに呼び出されます。
@end table

私が作った中で最も複雑な例 --- 標準まとめ送り形式を見てみましょう。

@example
(standard-digest
 (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
 (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
 (prepare-body-function . nndoc-unquote-dashes)
 (body-end-function . nndoc-digest-body-end)
 (head-end . "^ ?$")
 (body-begin . "^ ?\n")
 (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
 (subtype digest guess))
@end example

70 文字のダッシュ(`-')の行より前は全て無視されるというのが分かります。ま
た @samp{^End of} で始まる行より後ろも全て無視されます。各記事は 30 文字
のダッシュの行で始まり、ヘッダーとボディの区切りの行は一個のスペースを含
むことがあり、そしてボディはそれが渡される前
に @code{nndoc-unquote-dashes} を通されます。

あなた独自の文書定義を @code{nndoc} に接続するには、
@code{nndoc-add-type} 関数を使用します。これは二つのパラメータをとりま
す --- 一つ目はその定義自身で、二つ目の (省略可能な) パラメータはこの定
義を、文書種別定義連想リストのどこに置くかを指定します。この連想リストは
順番に走査され、与えられた種別 @code{TYPE} に対し
て @code{nndoc-TYPE-type-p} が呼び出されます。このように文書
が @code{mmdf} 種別であるかどうかを調べるため
に @code{nndoc-mmdf-type-p} が呼び出され、そして以下同様に続きます。これ
らの種別述語関数は、その文書がその種別でない場合は @code{nil} を返し、そ
の種別である場合は @code{t} を返し、その種別かもしれないときは数字を返さ
なくてはなりません。高い数字は高い可能性を意味し、低い数字は低い可能性を
意味します。@samp{0} は正しい値の中でもっとも低い数字です。

@node SOUP
@subsection SOUP
@cindex SOUP
@cindex offline

PC の世界の人々はよく、``オフライン'' ニュースリーダについて話をしていま
す。これはリーダとニュース配送を合体させた、実在するモンスターです。内蔵
モデムプログラム付きでね。きゃはは!

もちろん、我らが Unix キチガイの人間供は @code{uucp} だと
か @code{nntpd} のようなものを使い、神の領域たるメール、ニュースの配送を
正しく設定するのです。そして僕たちはただ普通のニュースリーダを使います。

しかし、あなたがとても遅いモデムを持っていてこれらを正しく設定することに
興味が無ければ、脳みそに楽をさせる方をするのも時には便利です。

@sc{soup} と呼ばれるファイル形式はニュースとメールをサーバーから家のマシ
ンへと転送し、それをまた戻すために開発されました。ちょっと面倒くさいかも
しれないけどね。

はじめにいくつか用語を。

@table @dfn
@item server
これは外の世界に繋がっていて、あなたがニュースとメールを送受信するマシン
です。

@item home machine
これはあなたが実際に読んだり返事を書いたりしたいマシンです。これは普通、
他の世界といかなる形でも接続されていません。

@item packet
メッセージと命令を含んだもの。パケットには二種類あります。

@table @dfn
@item message packets
これはサーバーで作られるパケットで、普通はあなたが読むためのたくさんのメッ
セージが含まれています。これらは初期設定では @file{SoupoutX.tgz} という
名前です。ここで @var{x} は数字です。

@item response packets
(返信パケット) このパケットは自宅マシンで作られるパケットで、普通はあな
たの書いた返事が含まれています。これらは初期設定で
は @file{SoupinX.tgz} という名前です。ここで @var{x} は数字です。
@end table
@end table

@enumerate

@item
まず @sc{soup} パケットを作るためにサーバーにログインします。
@sc{soup} のための専用のブツ (@code{awk} プログラムのような) を使っても
良いし、gnus の @sc{soup} 命令を使ってパケットを作っても良いで
す (@kbd{O s} あるいは @kbd{G s b} そして @kbd{G s p})

(@pxref{SOUP Commands})。

@item
パケットを自宅に転送します。電車で、船で、自動車で、あるいはモデムで、何
でもいいです。

@item
パケットをあなたのホームディレクトリーに置きます。

@item
Gnus をあなたの自宅マシンでかっ飛ばして、@code{nnsoup} バックエンドを基
本サーバーあるいは二次サーバーとして使用します。

@item
記事やメールを読んで必要なやつに返事を書いてフォローアップ記事を書きま
す (@pxref{SOUP Replies})。

@item
@kbd{G s r} 命令を実行して、これらの返事を @sc{soup} パケットに梱包しま
す。

@item
このパケットをサーバーに転送します。

@item
Gnus から @kbd{G s s} 命令を使ってこのパケットからメールを出します。

@item
あとはこれを死ぬまで続けます。

@end enumerate

つまり基本的に二者分割システムができたことになりま
す --- @code{nnsoup} を読むために、gnus を @sc{soup} パケットの梱包と送
出に使います。

@menu
* SOUP Commands::               @sc{soup} パケットを作成、送出する命令
* SOUP Groups::                 @sc{soup} パケットを読むバックエンド
* SOUP Replies::                @code{nnsoup} にメールとニュースを引き継がせ
                                る方法
@end menu

@node SOUP Commands
@subsubsection SOUP 命令

これらの命令は @sc{soup} パケットの作成と操作を行なうものです。

@table @kbd
@item G s b
@kindex G s b (グループ)
@findex gnus-group-brew-soup
現在のグループの全ての未読記事を梱包す
る (@code{gnus-group-brew-soup})。このコマンドはプロセス/接頭引数の習慣
に従います。

@item G s w
@kindex G s w (グループ)
@findex gnus-soup-save-areas
全ての @sc{soup} データファイルを保存しま
す (@code{gnus-soup-save-areas})。

@item G s s
@kindex G s s (グループ)
@findex gnus-soup-send-replies
返信パケットから全ての返信を送出する (@code{gnus-soup-send-replies})。

@item G s p
@kindex G s p (グループ)
@findex gnus-soup-pack-packet
全てのファイルを  @sc{soup} パケットに梱包す
る (@code{gnus-soup-pack-packet})。

@item G s r
@kindex G s r (グループ)
@findex nnsoup-pack-replies
全ての返信を返信パケットに梱包する (@code{nnsoup-pack-replies})。

@item O s
@kindex O s (概略)
@findex gnus-soup-add-article
この概略モード命令は、現在の記事を @sc{soup} パケットに追加しま
す (@code{gnus-soup-add-article})。これはプロセス/接頭引数の習慣に従いま
す (@pxref{Process/Prefix})。
@end table

gnus がこれらの実体をどこに置くかをカスタマイズするいくつかの変数があり
ます。

@table @code
@item gnus-soup-directory
@vindex gnus-soup-directory
@sc{soup} パケットを作成中に gnus が中間ファイルを保存するディレクトリー。
初期設定値は @file{~/SoupBrew/}。

@item gnus-soup-replies-directory
@vindex gnus-soup-replies-directory
返信パケット送信中に gnus が使用する一時ディレクトリー。
@file{~/SoupBrew/SoupReplies/} が初期設定値。

@item gnus-soup-prefix-file
@vindex gnus-soup-prefix-file
gnus が最後に使った接頭引数を保存するファイル名。初期設定値
は @samp{gnus-prefix}。

@item gnus-soup-packer
@vindex gnus-soup-packer
@sc{soup} パケットを梱包する命令文字列の形式。初期設定値
は @samp{tar cf - %s | gzip > $HOME/Soupout%d.tgz}。

@item gnus-soup-unpacker
@vindex gnus-soup-unpacker
@sc{soup} パケットを取り出す命令文字列の形式。初期設定値
は @samp{gunzip -c %s | tar xvf -}。

@item gnus-soup-packet-directory
@vindex gnus-soup-packet-directory
gnus が返信パケットを探しに行く場所。初期設定値は @file{~/}。

@item gnus-soup-packet-regexp
@vindex gnus-soup-packet-regexp
@code{gnus-soup-packet-directory} 内の @sc{soup} パケットにマッチする正
規表現。
@end table

@node SOUP Groups
@subsubsection SOUP グループ
@cindex nnsoup

@code{nnsoup} は @sc{soup} パケットを読むためのバックエンドです。これは
入ってきたパケットを読み、それを取り出して、あなたが暇なときに読むディレ
クトリーに展開します。

これらはこの振る舞いをカスタマイズできる変数です。

@table @code
@item nnsoup-tmp-directory
@vindex nnsoup-tmp-directory
@code{nnsoup} が @sc{soup} パケットを取り出すとき、このディレクトリ内で
行なう (初期設定は @file{/tmp/})。

@item nnsoup-directory
@vindex nnsoup-directory
そして @code{nnsoup} がそれぞれのメッセージと索引ファイルをこのディレク
トリーに移動させる。初期設定は @file{~/SOUP/}。

@item nnsoup-replies-directory
@vindex nnsoup-replies-directory
全ての返信は、返信パケットに梱包される前にこのディレクトリーに格納される。
初期設定は @file{~/SOUP/replies/"}。

@item nnsoup-replies-format-type
@vindex nnsoup-replies-format-type
返信パケットの @sc{soup} 形式。初期設定値
は @samp{?n} (rnews) で、この変数には触るべきではないと私は思います。た
ぶん文書に明記すべきでさえなかったね。ちぇっ! もう手遅れか。

@item nnsoup-replies-index-type
@vindex nnsoup-replies-index-type
返信パケットの索引の種類。初期設定値は @samp{?n} で、意味は ``なし''。こ
れもいじるんじゃないよ!

@item nnsoup-active-file
@vindex nnsoup-active-file
@code{nnsoup} がたくさんの情報を格納する場所。これは @code{nntp} の意味
での ``アクティブファイル'' ではなく、Emacs Lisp のファイルです。このファ
イルを無くしてしまったり、何か壊してしまったら、あなたは死にます。初期設
定値は @file{~/SOUP/active} です。

@item nnsoup-packer
@vindex nnsoup-packer
返信 @sc{soup} パケットを梱包する命令文字列の形式。初期設定値
は @samp{tar cf - %s | gzip > $HOME/Soupin%d.tgz}。

@item nnsoup-unpacker
@vindex nnsoup-unpacker
入ってくる @sc{soup} パケットを取り出すための命令文字列の形式。初期設定
値は @samp{gunzip -c %s | tar xvf -}。

@item nnsoup-packet-directory
@vindex nnsoup-packet-directory
入ってきたパケットを @code{nnsoup} が探す場所。初期設定値は @file{~/}。

@item nnsoup-packet-regexp
@vindex nnsoup-packet-regexp
入ってきた @sc{soup} パケットにマッチする正規表現。初期設定値
は @samp{Soupout}。

@item nnsoup-always-save
@vindex nnsoup-always-save
@code{nil} 以外であれば、メッセージを投稿した後に返信バッファを保存する。
@end table

@node SOUP Replies
@subsubsection SOUP 返信

単に @code{nnsoup} を使うだけでは、@sc{soup} 返信パケット中のあなたの投
稿とメールの送信が、魔法のように自動的に終了するわけではありません。それ
を起こすにはもうちょっと働かなくてはいけません。

@findex nnsoup-set-variables
@code{nnsoup-set-variables} 命令は、あなたの全てのフォローアップ記事と返
信を @sc{soup} システムに確実に終了させるように、適切な変数を設定します。

特別に、これが実際に行われることです。

@lisp
(setq message-send-news-function 'nnsoup-request-post)
(setq message-send-mail-function 'nnsoup-request-mail)
@end lisp

それだけです、ほんとに。もし @sc{soup} システムにニュースだけを入れたかっ
たら、最初の行だけを使ってください。もしメールだけを @sc{soup} させたかっ
たら、二番目を使ってください。

@node Mail-To-News Gateways
@subsection メールからニュースへのゲートウェイ
@cindex mail-to-news gateways
@cindex gateways

もしあなたのローカルの @code{nntp} サーバーが、何らかの理由で投稿を許可
していなければ、数あるメールからニュースへのゲートウェイを使って投稿する
ことができます。@code{nngateway} バックエンドはこのインターフェースを提
供します。

このバックエンドからは何も読み出せないことに注意してください --- これは
投稿するためだけに使われます。

以下はサーバー変数です。

@table @code
@item nngateway-address
@vindex nngateway-address
これがメール・ニュースゲートウェイのアドレスです。

@item nngateway-header-transformation
@vindex nngateway-header-transformation
ニュースヘッダーは、メール・ニュースゲートウェイが受け付けられるように、
奇妙な形に変形しておかなくてはならない時があります。この変数はどんな変形
処理が呼び出されるべきかを示しており、初期設定値
は @code{nngateway-simple-header-transformation} になっています。この関
数は変形するヘッダーに領域制限(narrow)されて呼び出され、一個の引
数 --- ゲートウェイのアドレスを与えられます。

初期設定値の関数は単に新しい @code{To} ヘッダーを、@code{Newsgroups} ヘッ
ダーとゲートウェイアドレスをもとに挿入します。例えば、以下のよう
な@code{Newsgroups} ヘッダー

@example
Newsgroups: alt.religion.emacs
@end example

を持つ記事には、次のような @code{To} ヘッダーが挿入されます。

@example
To: alt-religion-emacs@@GATEWAY
@end example

以下の既製関数が存在します:

@findex nngateway-simple-header-transformation

@table @code
@item nngateway-simple-header-transformaton
@var{newsgroup}@@@code{nngateway-address} のような @code{To} ヘッダーを
つくります。

@findex nngateway-mail2news-header-transformation

@item nngateway-mail2news-header-transformation
@code{nngateway-address} のような @code{To} ヘッダーをつくります。

ここに例があります。

@lisp
(setq gnus-post-method
      '(nngateway
        "mail2news@@replay.com"
        (nngateway-header-transformation
         nngateway-mail2news-header-transformation)))
@end lisp
@end table
@end table

つまり、これを使うには、こんな風にするだけです。

@lisp
(setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))
@end lisp

@node Combined Groups
@section 結合グループ

Gnus は、全てのグループの種類を混合して、大きなグループに結合することが
できます。

@menu
* Virtual Groups::              たくさんのグループの記事を結合する
* Kibozed Groups::              ニューススプールの中からの記事を検索する
* Namazu Groups::               Namazu を使ってメールの山から記事を取り出す
@end menu

@node Virtual Groups
@subsection 仮想グループ
@cindex nnvirtual
@cindex virtual groups

nnvirtual グループ (@dfn{nnvirtual group}) は実は他のグループの集合以上
の何物でもありません。

例えば、もし小さなグループをたくさん読むのが嫌になってきたら、それらを一
つの大きなグループに入れて、嫌になるくらい巨大で手に負えないグループを読
むことができます。これがコンピューターの楽しみだね!

選択方法として @code{nnvirtual} を指定してください。アドレスは、それを構
成するグループにマッチする正規表現です。

仮想グループ内で付けられた全ての印は、その構成グループの記事にくっつけら
れます。つまり、もし仮想グループ内で記事に可視記事の印をつけると、その記
事はもともとの構成グループの中でも可視記事になります。(そして逆も成り立
ちます --- 構成グループ内で付けた印は仮想グループ内でも表示されます。)
空の仮想グループを作るには、グループバッファで @kbd{G V}
(@code{gnus-group-make-empty-virtual}) を実行し、@kbd{M-e}
(@code{gnus-group-edit-group-method}) でメソッドの正規表現を編集して下さ
い。

これが、Andrea Dworkin に関する全てのニュースグループを、一つの巨大でシ
アワセなニュースグループにまとめる @code{nnvirtual} 方法の例です。

@lisp
(nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")
@end lisp

構成グループは基本グループでも外部グループでも構いません。全て問題無く動
くはずですが、もしあなたのコンピューターが爆発でもしてしまったら、それは
たぶん私が悪いんでしょうね。

いくつかのサーバーから同じグループを集めることは、利用者
が Distribution ヘッダーを使って配布範囲を制限している場合は、非常に良い
かも知れません。もしあなたが @samp{soc.motss} を、日本のサーバーとノルウェー
のサーバーの両方から読みたければ、グループの正規表現として以下の値が使え
ます。

@example
"^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"
@end example

(でもちょっと注意。@kbd{G m} でグループを作成するときは、バックスラッシュ
を二重に付けてはいけません。そして文字列の最初と最後の引用記号も取り払っ
てください。)

これはちょっとうまく動作するはずです --- 両方のグループの記事は全部完全
に一つのグループになり、重複も無いはずです。スレッド表示 (とその他) も通
常通りうまく動作するでしょうけど、記事の並ぶ順序には問題があるかもしれま
せん。日付による並べ替えはここでは仕様外となるかもしれませ
ん (@pxref{Selecting a Group})。

なお、ここで一つだけ制限があります --- 仮想グループに含まれるグループは
全て生きている(すなわち、購読または非購読の)状態でなくてはなりません。削
除あるいはゾンビグループは @code{nnvirtual} グループの構成グループになる
ことはできません。

@vindex nnvirtual-always-rescan
@code{nnvirtual-always-rescan} が @code{nil} 以外であれば、
@code{nnvirtual} は仮想グループに入ったとき常に、未読記事を走査します。
この変数が @code{nil} (これが初期設定)であって、仮想グループを作成した後
に構成グループ内の記事を読んだ場合は、その構成グループで読まれた記事は、
仮想グループに入ったときに表示され るでしょう。もし共通の構成グループを
持つ二つの仮想グループがある場合にもこの影響があります。その場合はこの変
数を @code{t} にした方が良いです。あるいは仮想グループに入る時に、毎回そ
のグループの上で @code{M-g} を叩いても良いです --- これはほぼ同様の効果
があります。

@code{nnvirtual} はメールとニュースの両方のグループを構成グループとする
事ができます。@code{nnvirtual} グループの記事に返答するときは、
@code{nnvirtual} は記事の出所の構成グループのバックエンドにそれがニュー
スのバックエンドであるかメールのバックエンドであるかを尋ねなければなりま
せん。しかし、@kbd{^} をしたときには、普通は構成バックエンドがこれを知る
確かな方法はなく、その場合は、@code{nnvirtual} は gnus に記事はニュース
でないバックエンドから来たと告げる事になります。(安全のために。)

このような場合は、メッセージバッファでの @kbd{C-c C-n} が応答しようとし
ている記事から @code{Newsgroups} 行を抜き出して挿入します。

@code{nnvirtual} グループは、構成グループから記事と印以外は継承しません。
例えばグループパラメータもそうなのですが、それらは継承されません。

@node Kibozed Groups
@subsection Kiboze グループ
@cindex nnkiboze
@cindex kibozing

@dfn{Kiboze} する、とは、``ニューススプール全部 (あるいはその一部) か
ら grep すること'' とオックスフォード大辞典によって定義されています。
@code{nnkiboze} はこれをあなたのために行ってくれるバックエンドです。嬉し
いね! これでどんな @sc{nntp} サーバーでも、役に立たない要求で止まってし
まうまで酷使することができるね。ああ、なんて幸せなんだ!

@kindex G k (グループ)
kiboze グループを作成するには、グループバッファで @kbd{G k} 命令を使いま
す。

@code{nnkiboze} 方法におけるアドレス欄は、@code{nnvirtual} と同様に、
@code{nnkiboze} に ``含めたい'' グループにマッチする正規表現です。ここ
が @code{nnkiboze} と @code{nnvirtual} バックエンドの最も類似している点
です。

この構成グループを列挙する正規表現に加えて、@code{nnkiboze} グループには、
グループ内のどの記事を含めるかを決めるスコアファイルがなくてはなりませ
ん (@pxref{Scoring})。

@kindex M-x nnkiboze-generate-groups
@findex nnkiboze-generate-groups
あなたの欲しい @code{nnkiboze} グループを作成した後には、
@kbd{M-x nnkiboze-generate-groups} を実行しなければなりません。この命令
は時間がかかります。とってもかかります。すごく、すごーくかかります。
Gnus はその @code{nnkiboze} グループの一部となるべき記事があるかどうかを
調べるために、全部の構成グループの全部の記事に対してヘッダーを取得し、そ
れら全てに対してスコア処理を実行しなくてはならないのです。

構成グループの数を抑えるように、限定した正規表現を使ってください。さもな
いと、あなたのところのシステム管理者を怒らせてしまって、@sc{nntp} サーバー
からあなたを追い出して二度と入れないようにしてしまうかも知れません。不慣
れな人がよくやることです。

@code{nnkiboze} の構成グループは生きている必要はありません --- 死んでて
も良いし、外部グループでも構いません。無制限です。

@vindex nnkiboze-directory
@code{nnkiboze} グループの生成によって、二つのファイル
 @code{nnkiboze-directory} 内に作成されます。この初期設定値
は @file{~/News/} です。一方のファイルはそのグループの全記事
の @sc{nov} ヘッダー行を含んでいて、もう一方は構成記事を見つけるためにど
のグループが検索されたかの情報を格納する、@file{.newsrc} の補助ファイル
です。

@code{nnkiboze} グループ内の既読となった記事は、その記事の @sc{nov} 行
が @sc{nov} ファイルから削除されます。

@node Namazu Groups
@subsection Namazu を使ってメールの山から記事を取り出す
@cindex namazu

メールは日々貯まっていくばかりです。流量の多いメーリングリストを購読し
ている場合には、特に。でも、大抵の場合、価値ある記事はごく少数で、その
記事を大量の記事の山から見つけ出すのは、とても困難なことです。

こういったことこそ、コンピュータがしてくれるべき仕事ですよね。Gnus は、
Namazu を使って、メールの山からあなたの好きなキーワードを含む記事を見
つけ出す方法を提供します。

最初に悲しいお知らせがひとつ。@file{gnus-namazu.el} は、現時点では、
@code{nnml} バックエンドあるいは @code{nnmh} バックエンドによって保存
されている記事と、@code{gnus-cache-enter-article} によって永続化された
記事しか、取り扱うことができません。@code{nnimap} バックエンドや 
@code{nnmbox} バックエンドを使っている人は、ごめんなさい。

それでは気を取り直して、まず、Namazu を使えるようにしましょう。詳しい
ことは、次のページで知ることができます。

@example
  @uref{http://namazu.org/}
@end example

@findex gnus-namazu-create-index
次に、あなたの秘蔵のメールと永続記事の山の索引を作るために、
@kbd{M-x gnus-namazu-create-index} としてください。さあ、これで準備が
できたはずです。

@kindex C-c C-n (グループ)
@kindex C-c C-n (概略)
@findex gnus-namazu-search
グループバッファで@kbd{C-c C-n}と入力すると、検索式を尋ねられますから、
適当な単語を入力してください。例えば:

@example
  @kbd{C-c C-n gnus namazu RET}
@end example

こうすると、gnus と namazu の双方のキーワードを同時に含むメールを全て
探し出し、それらのメールからなる仮想グループを作成します(@xref{Virtual
Groups})。

@kbd{C-c C-n}によって呼び出される命令 @code{gnus-namazu-search} は、
gnus の通常の数字接頭辞や、プロセス接頭辞を理解します。ですから、あな
たが、あるグループだけを対象として検索を実行したいならば、そのグループ
の行に移動して、次のように検索することができます。

@example
  @kbd{1 C-c C-n namazu RET}
@end example

また、概略バッファから、いきなり検索することもできます。この場合、検索
対象は、自動的にそのグループに限定されます。例えば、あなたがあるグルー
プを閲覧中に、そのグループにおける自分の過去を振り返りたくなったら、次
のようにすれば良いのです。

@example
  @kbd{C-c C-n +from:"Your E-Mail Address" RET}
@end example

@vindex gnus-namazu-index-update-interval
Namazu は、事前に準備された索引を用いて検索を行うように設計された検索
エンジンなので、索引に登録されていないファイルは完全に無視されます。つ
まり、定期的に @code{mknmz} を呼び出して、新たなメールの索引を追加しな
いと、新しいメールはいつまでたっても検索対象にならないことになります。
@file{gnus-namazu.el} は、@code{gnus-namazu-index-update-interval} に
指定された期間毎に自動的に索引を更新する機能を提供しています。ディフォル
トの設定では、3日おきに索引を更新するようになっていますが、もっと頻繁
に (例えば1日おき) に更新するようにしたいならば、以下の設定
を @file{~/.gnus} に追加してください。


@example
(setq gnus-namazu-index-update-interval 86400)
@end example

逆に、索引の更新を自動的に行いたくないならば、以下の指定を 
@file{~/.gnus} に追加してください。

@example
(setq gnus-namazu-index-update-interval nil)
@end example

@findex{gnus-namazu-update-all-indices}
この場合、索引を手動で更新するために @kbd{M-x
gnus-namazu-update-all-indices} とする必要があるかもしれません。

@node Gnus Unplugged
@section Gnus の切り離し
@cindex offline
@cindex unplugged
@cindex Agent
@cindex Gnus Agent
@cindex Gnus Unplugged

いにしえの時代(およそ 1988 年2月頃)、人々はニュースリーダーを、大きなマ
シンの上でネットワークに永続的に接続して走らせていました。ニュースの配送
はニュースサーバーによって取り扱われ、全てのニュースリーダーがすべきこと
は、ニュースを読むことであったのです。信じられないかもしれませんが。

今日では、多くの人々は自宅でニュースやメールを読み、ネットワークに接続す
るためにモデムの類を使います。電話代の請求書が莫大なものに上らないように、
全てのニュースとメールを吸い上げ、電話を切り、数時間掛けて読み、そして送
りたい返信を全て送信する、という手段を持つことは良いことでありましょう。
あとはこの手順を繰り返すのです。

もちろん、これを行うためにニュースサーバーを使うこともできます。私
は @code{inn} を @code{slurp}, @code{pop}, @code{sendmail} と一緒にここ
数年使ってきましたが、しかしこれは退屈な仕事です。もしあるマシン上でニュー
スを読む人があなたしかいなければ、ニュースサーバーの機能をニュースリーダー
に任せるようにすることは理にかなっています。

Gnus を ``オフライン'' のニュースリーダーとして仕立てるのは極めて簡単で
す。実際、あなたは何も設定する必要が無いのです。

もちろん、これをオフラインニュースリーダーとして使うには、いくつか新しい
命令を覚えなくてはなりません。

@menu
* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを gnus エージェン
                                トに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を消す方法
* Agent and IMAP::              エージェントを IMAP で使う方法
* Outgoing Messages::           投稿、メールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための @file{.gnus.el} の例
* Batching Agents::             @code{cron} ジョブによるニュース取得方法
* Agent Caveats::               あなたが予想することと、それが実際にする
                                こと
* Control Agents::              Offline をコントロールする gnus-offline
@end menu

@node Agent Basics
@subsection エージェントの基礎

まず、いくつかの用語を片付けておきましょう。

あなたがネットワークとの通信が切れているとき(でエージェントがそれを知ら
されているとき)は、gnus エージェントは切り離されている (@dfn{unplugged})、
と言います。ネットワークの通信が復活し (そして gnus がそれを知れば)、エー
ジェントは差し込まれている (@dfn{plugged})、と言います。

ローカル (@dfn{local}) マシンとは、あなたが触っているマシンで、ネットワー
クに継続的に接続されているものではありません。

ダウンロード (@dfn{download}) とはネットワークから何かをあなたのローカル
マシンに取ってくることを意味します。アップロード (@dfn{upload}) はその逆
をすることです。

エージェントを使った典型的な gnus の対話操作を見てみましょう。

@itemize @bullet

@item
Gnus を @code{gnus-unplugged} で起動します。これは gnus エージェントを切
り離されている状態で起動します。この状態では、すでに取得しているニュース
記事は全て読むことができます。

@item
そして、新しいニュースが到着しているかどうかを調べることにします。あなた
は (PPP か何かを使って) あなたのマシンをネットワークに接続し、gnus を差
し込むために @kbd{J j} を叩き、そして普通は新着メールを検査するため
に @kbd{g} を使います。gnus エージェントが切り離されてい
る (@dfn{unplugged}) ときの新着メールの検査について
は @pxref{Mail Source Specifiers} を参照して下さい。

@item
そして、その場ですぐに新しいニュースを読むこともできますし、ニュースをロー
カルマシンにダウンロードすることもできます。後者を実行したければ、
@kbd{g} を押して新着メールを検査してから @kbd{J s} で全グループから適切
な記事を全て取得します。(Gnus にどの記事をダウンロードしたいかを指定する
には @pxref{Agent Categories} を参照してください。)

@item
記事を取得した後は @kbd{J j} を押して、gnus を再び切り離し状態にさせ、
PPP 関係(など)を閉じます。そうしてニュースをオフラインで読むことができま
す。

@item
そして第二ステップに戻ります。
@end itemize

以下にエージェントを初めて(かそこらに)使うときに必要ないくつかの作業を示
します。

@itemize @bullet

@item
どのサーバーをエージェントで面倒を見るかを決めます。もしメールバックエン
ドがあれば、それをエージェントに面倒を見させるのはおそらく無意味でしょう。
サーバーバッファーに移動し (グループバッファーで @kbd{^})、エージェント
に扱って欲しいサーバー(複数可)で @kbd{J a} を押すか、またはエージェント
に扱って欲しくないのに自動的に追加されたサーバーで @kbd{J r} を押します。
ディフォルトで
は @code{gnus-select-method} と @code{gnus-secondary-select-methods} に
あるすべての @code{nntp} と @code{nnimap} グループがエージェント化されま
す。

@item
ダウンロード方針を決定します。@xref{Agent Categories}.

@item
ええと…、以上です。
@end itemize

@node Agent Categories
@subsection エージェント分類

ニュース配送機構とニュースリーダーを統合する一つの大きな理由は、どの記事
をダウンロードするかについて、より良い制御を可能とすることです。莫大な量
の記事をダウンロードしてもあまり意味はなく、それらを読んでもあまり面白く
ないことが分かるだけです。何をダウンロードするかの選択はもっと慎重である
べきであり、その記事が面白いと分かった時点で、ダウンロードするための印を
手動で付けるべきなのです。

何をダウンロードするかを制御する主な方法は、分類 (@dfn{category}) を作成
して、そしてその分類にいくつか (あるいは全部) のグループを割り当てます。
他の分類に属さないグループは @code{初期} 分類に属します。Gnus は分類の作
成と管理のための独自のバッファーを持っています。

@menu
* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス
@end menu

@node Category Syntax
@subsubsection 分類の文法

分類は二つのものからなります。

@enumerate
@item
(通常) どの記事をダウンロードするのが適当かという大まかな輪郭を与える述
語。そして

@item
(通常) どの記事をダウンロードするかを決めるときのよりきめの細かいスコア
規則。(このダウンロードスコア (@dfn{download score}) は通常のスコアとは
必ずしも関係が無いことに注意してください。)
@end enumerate

述語の一番単純な形式は @code{true} や @code{false} のような単独の述語か
らなります。これらの二つはそれぞれ、全ての可能な記事をダウンロードするか、
全く何もしないか、です。これらの二つの特別な述語の場合は、追加のスコア規
則は余分です。

@code{high} や @code{low} という述語は下で説明されているように、
@code{gnus-agent-high-score} と @code{gnus-agent-low-score} との記事のス
コアとの関係により記事をダウンロードします。

ダウンロードが適切かどうかの、さらに細かい制御を得るために、述語は論理演
算子が間に散りばめられた述語の組み合わせからなることができます。

おそらくいくつかの例がそのまま使えます。

以下は簡単な述語です。(これは初期設定の述語です。つまり、他のどの分類に
も含まれない全てのグループに対して使用されます。)

@lisp
short
@end lisp

とっても簡単でしょ? この述語は、記事が短い(``短い'' 価値がある) 場合に限
り真になります。

これはもっと複雑な述語です。

@lisp
(or high
    (and
     (not low)
     (not long)))
@end lisp

この意味は、高いスコアを持っているか、あるいはスコアが低くなくてかつ長く
ない、という記事をダウンロードする、ということです。わかるだろ。

使ってもよい論理演算子は、@code{or}, @code{and}, @code{not} です。(もし
使いたければ、より ``C'' 風の演算子 @samp{|}, @code{&}, @code{!} を代り
に使うことができます。)

以下の述語はあらかじめ定義されていますが、これらのどれもあなたのやりたい
ことに一致しなければ、自分で独自のものを書くこともできます。

@table @code
@item short
記事が @code{gnus-agent-short-article} 行より短かければ真。初期設定値
は 100。

@item long
記事が @code{gnus-agent-long-article} 行より長ければ真。初期設定値は 200。

@item low
記事のダウンロードスコアが @code{gnus-agent-low-score} 以下であれば真。
初期設定値は 0。

@item high
記事のダウンロードスコアが @code{gnus-agent-high-score} 以上であれば真。
初期設定値は 0。

@item spam
gnus エージェントがその記事を SPAM だと見做したら真。この発見的手法は、
今後変更されるかもしれませんが、現時点では、これはチェックサムを計算し記
事が一致するかどうかを調べています。

@item true
常に真。

@item false
常に偽。
@end table

あなたが自分の独自の述語関数を作成したければ、これを知っておいてくださ
い:
関数は引数無しで呼び出されますが、
@code{gnus-headers} と @code{gnus-score} 動的変数には便利な値が束縛され
ます。

例えば、一定の日付以上前に投稿された記事 (例えば、
@code{gnus-agent-expire-days} 以前に投稿されたもの) をダウンロードしない
とすることもできます。その場合、以下のような関数を書くでしょう:

@lisp
(defun my-article-old-p ()
  "Say whether an article is old."
  (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
     (- (time-to-days (current-time)) gnus-agent-expire-days)))
@end lisp

そうすると、述語はこのように定義します:

@lisp
(not my-article-old-p)
@end lisp

もしくは、@file{~/.gnus.el} や何か他のものでも、既定
の @code{gnus-category-predicate-list} に自分の述語を追加することもでき
ます。

@lisp
(require 'gnus-agent)
(setq gnus-category-predicate-alist
      (append gnus-category-predicate-alist
              '((old . my-article-old-p))))
@end lisp

そして、単に次のように述語を指定します:

@lisp
(not old)
@end lisp

上のようなものを使うときは、世の中には正しく設定されていないシステム/メ
ーラーがあり、記事の日付はいつ投稿されたかを常に確実に示すわけではありま
せん。あぁ、それを全く気にしない人もいます。

上の述語はその分類に属する*全て*のグループに適用されます。しかし、分類中
の個々のグループに特定の述語を望んだり、怠惰過ぎて新しい分類を設定できな
いときは、グループの個々の述語をグループパラメータで次のようにすることが
できます。

@lisp
(agent-predicate . short)
@end lisp

これは agent 分類の初期値と等価なものです。このような一語の述語を指定し
ているときは、@code{agent-predicate} 指示はドット対記法である必要がある
ことに注意してください。

上のものと等価な長い方の例は:

@lisp
(agent-predicate or high (and (not low) (not long)))
@end lisp

分類の指定で要求される外の丸括弧はここでは入力されておらず、ドット対の記
法でもなく、述語の値はリストあるとみなされます。

さて、ダウンロードスコアの文法は通常のスコアファイルの文法と同じですが、
例外として、実際に記事自身を調べる必要がある要素は禁止されています。つま
り、以下のヘッダーのみがスコア付けできます: @code{Subject}, @code{From}, @code{Date}, @code{Message-ID}, @code{References}, @code{Chars}, @code{Lines} and @code{Xref}.

述語と同様、グループに関して @code{ダウンロードスコア規則} の指定の使用
は、そこの全てのグループに適用可能なら分類の定義、グループに特有ならグ
ループパラメータ、のどちらかにできます。

両方の場所で、@code{ダウンロードスコア規則} は以下の三つの形式を取ること
ができます:

@enumerate
@item
スコア規則

上で書かれているように、スコア付けキーワードの一部分しか使えないことを除
けば、これは普通の gnus スコアファイルの構文と同じです。

例:

@itemize @bullet
@item
分類指定

@lisp
(("from"
       ("Lars Ingebrigtsen" 1000000 nil s))
("lines"
       (500 -100 nil <)))
@end lisp

@item
グループパラメータ指定

@lisp
(agent-score ("from"
                   ("Lars Ingebrigtsen" 1000000 nil s))
             ("lines"
                   (500 -100 nil <)))
@end lisp

また、ここで一番外の括弧が省略されていることに注意してください。
@end itemize

@item
エージェントスコアファイル

これらのスコアファイルは上で述べられている使用可能なスコア付けキーワード
*のみ* である必要があります。

例:

@itemize @bullet
@item
分類指定

@lisp
("~/News/agent.SCORE")
@end lisp

もしくは、たぶん

@lisp
("~/News/agent.SCORE" "~/News/agent.group.SCORE")
@end lisp

@item
グループパラメータ指定

@lisp
(agent-score "~/News/agent.SCORE")
@end lisp

上の様に、追加のスコアファイルを指定することができます。また括弧について
言わなければいけませんか?
@end itemize

@item
@code{普通} のスコアファイルの使用

一つのグループで二つのスコア規則を維持したくなく、グループの望み
の @code{ダウンロード} の基準が @code{読む} 基準と同じなら、エージェント
に何をダウンロードするかを決める際に @code{普通} のスコアファイルを参照
するようにすることができます。

分類定義か、グループパラメータのこれらの指示はエージェントにグループに適
用可能な全てのスコアファイルを読ませ、スコア付けキーワードの使用可能な部
分集合に無いものを *選別して抜き取ります*。

@itemize @bullet
@item
分類指定

@lisp
file
@end lisp

@item
グループパラメータ指定

@lisp
(agent-score . file)
@end lisp
@end itemize
@end enumerate

@node Category Buffer
@subsubsection 分類バッファー

通常は全ての分類は分類バッファーから管理します。(グループバッファー
から @kbd{J c} 命令によって) 初めてこれに入ったとき、初期設定の
分類だけが表示されます。

以下の命令がこのバッファーで使用できます。

@table @kbd
@item q
@kindex q (分類)
@findex gnus-category-exit
グループバッファーに戻る (@code{gnus-category-exit})。

@item k
@kindex k (分類)
@findex gnus-category-kill
現在の分類を消去する (@code{gnus-category-kill})。

@item c
@kindex c (分類)
@findex gnus-category-copy
現在の分類を複製する (@code{gnus-category-copy})。

@item a
@kindex a (分類)
@findex gnus-category-add
新しい分類を追加する (@code{gnus-category-add})。

@item p
@kindex p (分類)
@findex gnus-category-edit-predicate
現在の分類の述語を編集する (@code{gnus-category-edit-predicate})。

@item g
@kindex g (分類)
@findex gnus-category-edit-groups
現在の分類に属するグループの一覧を編集す
る (@code{gnus-category-edit-groups})。

@item s
@kindex s (分類)
@findex gnus-category-edit-score
現在の分類のダウンロードスコア規則を編集す
る (@code{gnus-category-edit-score})。

@item l
@kindex l (分類)
@findex gnus-category-list
全ての分類を表示する (@code{gnus-category-list})。
@end table

@node Category Variables
@subsubsection 分類変数

@table @code
@item gnus-category-mode-hook
@vindex gnus-category-mode-hook
分類バッファーで実行するフック。

@item gnus-category-line-format
@vindex gnus-category-line-format
分類バッファーの行様式 (@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item c
分類の名前。

@item g
分類に属するグループの数。
@end table

@item gnus-category-mode-line-format
@vindex gnus-category-mode-line-format
分類モード行の様式 (@pxref{Mode Line Formatting})。

@item gnus-agent-short-article
@vindex gnus-agent-short-article
この変数より少ない行数の記事は短い。初期設定値は 100。

@item gnus-agent-long-article
@vindex gnus-agent-long-article
この変数より多い行数の記事は長い。初期設定値は 200。

@item gnus-agent-low-score
@vindex gnus-agent-low-score
この値より小さいスコアを持つ記事は低スコアである。初期設定値は 0。

@item gnus-agent-high-score
@vindex gnus-agent-high-score
この値より大きいスコアを持つ記事は高スコアである。初期設定値は 0。
@end table

@node Agent Commands
@subsection エージェント命令

全ての gnus エージェント命令は @kbd{J} サブマップにあります。
@kbd{J j} (@code{gnus-agent-toggle-plugged}) 命令は全てのモード
で動作し、gnus エージェントの切り離し/差し込み状態を切り替えます。

@menu
* Group Agent Commands::        
* Summary Agent Commands::      
* Server Agent Commands::       
@end menu

完全にバッチで動作させるには、コマンド行から以下のおまじないを実行すれば
できます。

@cindex gnus-agent-batch
@example
$ emacs -batch -l ~/.gnus.el -f gnus-agent-batch
@end example

@node Group Agent Commands
@subsubsection グループエージェント命令

@table @kbd
@item J u
@kindex J u (エージェント グループ)
@findex gnus-agent-fetch-groups
現在のグループの適格な記事を全て取得す
る (@code{gnus-agent-fetch-groups})。

@item J c
@kindex J c (エージェント グループ)
@findex gnus-enter-category-buffer
エージェント分類バッファーに入る (@code{gnus-enter-category-buffer})。

@item J s
@kindex J s (エージェント グループ)
@findex gnus-agent-fetch-session
全グループの適格な記事を全て取得する (@code{gnus-agent-fetch-session})。

@item J S
@kindex J S (エージェント グループ)
@findex gnus-group-send-queue
順番待ち (queue) グループにある送信可能なメッセージを全て送信す
る (@code{gnus-group-send-queue})。@xref{Drafts}。

@item J a
@kindex J a (エージェント グループ)
@findex gnus-agent-add-group
現在のグループをエージェント分類に追加する (@code{gnus-agent-add-group})。
この命令はプロセス/接頭辞の習慣を理解します (@pxref{Process/Prefix})。

@item J r
@kindex J r (エージェント グループ)
@findex gnus-agent-remove-group
現在のグループを、もし存在していれば、その分類から消去しま
す (@code{gnus-agent-remove-group})。この命令はプロセス/接頭辞の習慣を理
解します。(@pxref{Process/Prefix})。

@item J Y
@kindex J Y (エージェント グループ)
@findex gnus-agent-synchronize-flags
リモートサーバーが @dfn{unplugged} のときに変更されたフラグがあれば同期
させます。
@end table

@node Summary Agent Commands
@subsubsection 概略エージェント命令

@table @kbd
@item J #
@kindex J # (エージェント 概略)
@findex gnus-agent-mark-article
記事にダウンロードするように印を付ける (@code{gnus-agent-mark-article})。

@item J M-#
@kindex J M-# (エージェント 概略)
@findex gnus-agent-unmark-article
記事からダウンロードする印を消去する (@code{gnus-agent-unmark-article})。

@item @@
@kindex @@ (エージェント 概略)
@findex gnus-agent-toggle-mark
記事をダウンロードするかどうかを切り替え
る (@code{gnus-agent-toggle-mark})。

@item J c
@kindex J c (エージェント 概略)
@findex gnus-agent-catchup
ダウンロード印の無い記事を全て既読にする (@code{gnus-agent-catchup})。

@item J u
@kindex J u (エージェント 概略)
@findex gnus-agent-summary-fetch-group
現在のグループのダウンロード可能な記事を、すべてダウンロードしま
す (@code{gnus-agent-summary-fetch-group})。
@end table

@node Server Agent Commands
@subsubsection サーバーエージェント命令

@table @kbd
@item J a
@kindex J a (エージェント サーバー)
@findex gnus-agent-add-server
現在のサーバーを、gnus エージェントで扱われるサーバーの一覧に追加す
る (@code{gnus-agent-add-server})。

@item J r
@kindex J r (エージェント サーバー)
@findex gnus-agent-remove-server
現在のサーバーを、gnus エージェントで扱われるサーバーの一覧から削除す
る (@code{gnus-agent-remove-server})。
@end table

@node Agent as Cache
@subsection キャッシュとしてのエージェント

gnus が @dfn{plugged} であるときに、すでにエージェントに格納されているヘッ
ダーや記事をダウンロードするのは効率的ではありません。そこで gnus は通常
ヘッダーを一回だけダウンロードしてエージェントに格納します。
@dfn{plugged} か @dfn{unplugged} にかかわらず、それらのヘッダーは後に概
略バッファを生成するときに使われます。ディフォルトでは記事は (それは潜在
的にディスク空間を浪費するであろうから) エージェントにキャッシュされませ
んが、すでにエージェントにダウンロードした記事があるならば、gnus はサー
バーから再び記事をダウンロードせずに、手元に格納されたコピーを使います。

この動作は @code{gnus-agent-cache} で制御されま
す (@pxref{Agent Variables})。

@node Agent Expiry
@subsection エージェント期限切れ消去

@vindex gnus-agent-expire-days
@findex gnus-agent-expire
@kindex M-x gnus-agent-expire
@cindex Agent expiry
@cindex Gnus Agent expiry
@cindex expiry

@code{nnagent} は期限切れ消去を扱いません。その代わりに、特別
な @code{gnus-agent-expire} 命令が @code{gnus-agent-expire-days} 日より
も古い既読記事を全て消去します。これはあなたがディスク容量を使い切りそう
だと思ったときにいつでも実行することができます。これは特に速くもなく効率
的でもなく、一旦始めてしまったら (@kbd{C-g} やその他で) 中断することもあ
まり良いことではありません。

@code{gnus-agent-expire-days} は正規表現/日数のペアのリストであっても構
いません。正規表現はグループ名にマッチし、異なるグループで異なる期限切れ
消去を行なうことを可能にします。

@lisp
(setq gnus-agent-expire-days
      '(("alt\\." 7)
        (".*binary" 1)
        ("." 21)))
@end lisp

もしリストの形式を使う場合は、最後の要素はディフォルトのメソッド、すなわ
ちすべてのグループにマッチするものにしなければなりません。

@vindex gnus-agent-expire-all
@code{gnus-agent-expire-all} が @code{nil} でなければ、この命令は全ての
記事 --- 未読、既読、可視、保留記事を消去します。もし @code{nil} (これが
初期設定値) であれば、既読記事のみが消去の対象となり、未読、可視、保留記
事はさらに無期限に保持します。

@findex gnus-agent-regenerate
期限切れ消去されているはずなのに残っている記事を見つけたならば、たぶんい
くつかの gnus エージェントファイルが壊れています。
@code{gnus-agent-regenerate} は、起こりうる問題を修復するための特別なコ
マンドです。

@node Agent and IMAP
@subsection エージェントを IMAP で使う方法

エージェントは nnimap を含む gnus のどんなバックエンドでも動作します。し
かし @sc{nntp} と @sc{imap} にはいくつかの概念の違いがあるので、この項で
は gnus エージェントを @sc{imap} の @dfn{unplugged} なモードのクライアン
トとして円滑に使えるようにするための、いくつかの情報を提供します。

心に留めておく最初のことは、全てのフラグ (read, ticked など) は nntp の
場合における @code{.newsrc} ではなくて @sc{imap} サーバーに保持されると
いうことです。したがって、gnus は @dfn{unplugged} のときのフラグの変化を
覚えておいて、再び接続したときにそれらのフラグを同期させる必要があります。

gnus はエージェントの元で nnimap グループを読むとき、フラグの変化に絶え
ず注意しています。あなたが再び接続したとき、gnus はあなたが何らかのフラ
グを変更したかどうかを調べて、あなたがそれらをサーバーと同期させたいかど
うかを尋ねます。この挙動は @code{gnus-agent-synchronize-flags} でカスタ
マイズすることができます。

@vindex gnus-agent-synchronize-flags
もし @code{gnus-agent-synchronize-flags} が @code{nil} だったら、エージェ
ントは自動的にフラグを同期させることはしません。もしそれが初期値
の @code{ask} だったら、エージェントはあなたが再接続したときにあなたが何
らかの変更を行なっていたかどうかを調べて、それらを同期させたいかどうかを
尋ねます。もしそれら以外の値だった場合は、全てのフラグは自動的に同期させ
られます。

もしあなたが、再接続したときに自動でフラグを同期させたくないなら、手動で
それを行なうこともできます。これにはグループバッファの @kbd{J Y} キーに
割り当てられた @code{gnus-agent-synchronize-flags} コマンドを使います。

あなたが、@dfn{unplugged} のときの @sc{imap} クライアントに期待するであ
ろういくつかの機能は、現在のエージェントには盛り込まれていません。それら
は以下の通りです。

@itemize @bullet

@item
@dfn{unplugged} のときの nnimap グループへのコピーと移動。

@item
@dfn{unplugged} のときの nnimap グループの作成と削除。
@end itemize

技術的注釈: 全てのローカルなフラグを一度にサーバーに押し込む同期はできま
せんが、ユーザが一つずつフラグを更新することは可能です。したがって、あな
たが記事の一つのフラグをセットして、そのグループを抜け出てから再度そのグ
ループを選択してそのフラグを消せば、あなたが「同期」の操作を行なったとき
に、そのフラグはセットされてサーバーからは削除されます。
@c FIXMETGNUS Does it make sense?
"The queued flag" に関する動作は、エージェントディレクトリにあるサーバー
毎の @code{flags} ファイルの中で見つかるでしょう。それらはあなたがフラグ
を同期させたときに空になります。

@node Outgoing Messages
@subsection 差出用メッセージ

Gnus が切り離されているとき、全ての差出用メッセージ (メールとニュースの
両方) は下書きグループ ``queue'' (@pxref{Drafts}) に格納されます。投稿し
た後でも、ここでそのメッセージを見たり編集するのは意のままです。

Gnus が再び差し込まれたとき、メッセージを送信するために、特別な命令を使っ
て下書きグループから送ることも、グループバッファ内で @kbd{J S} を使って、
下書きグループ内の全ての送信可能メッセージ送信することもできます。

@node Agent Variables
@subsection エージェント変数

@table @code
@item gnus-agent-directory
@vindex gnus-agent-directory
Gnus エージェントがファイルを格納する場所。初期設定値
は @file{~/News/agent/}。

@item gnus-agent-handle-level
@vindex gnus-agent-handle-level
この変数の値より高いレベル (@pxref{Group Levels}) のグループは、エージェ
ントからは無視されます。初期設定値は @code{gnus-level-subscribed} で、こ
れは初期設定では、購読しているグループのみがエージェントの処理の対象とな
るということです。

@item gnus-agent-plugged-hook
@vindex gnus-agent-plugged-hook
ネットワークに接続されたときに実行されるフック。

@item gnus-agent-unplugged-hook
@vindex gnus-agent-unplugged-hook
ネットワークから切断されたときに実行されるフック。

@item gnus-agent-fetched-hook
@vindex gnus-agent-fetched-hook
記事を取り込み終わったときに実行されるフック。

@item gnus-agent-cache
@vindex gnus-agent-cache
plugged のときに、ローカルに持っている @sc{nov} と記事を使うかどうかを制
御する変数で、例えばエージェントをキャッシュとして使うには必須です。ディ
フォルトでは非-@code{nil} で、エージェントをキャッシュとして使います。

@item gnus-agent-go-online
@vindex gnus-agent-go-online
@code{gnus-agent-go-online} が @code{nil} だったら、エージェントはオフラ
イン状態のサーバーをオンライン状態にしません。@code{ask} だったら、それ
がディフォルトですが、エージェントは再接続するときにオフライン状態のサー
バーをオンライン状態にするかどうかを尋ねます。それ以外の値だったら、オフ
ライン状態のサーバーは自動的にオンライン状態になります。
@end table

@node Example Setup
@subsection 設定例

もしあなたがこのマニュアルを読みたくなくて、ごく標準的な設定がされている
とするなら、あなたの @file{.gnus.el} ファイルに以下のような設定をすると
ころから始められるでしょう。

@lisp
;;; Gnus がどのようにニュースを取得するかを定義する。ここでは
;;; ISP のサーバーから @sc{nntp} で取ってくることにする。
(setq gnus-select-method '(nntp "news.your-isp.com"))

;;; Gnus がどのようにメールを読むかを定義する。ISP の POP サーバー
;;; からメールを読むことにする。
(setq mail-sources '((pop :server "pop.your-isp.com")))

;;; Gnus がメールをどのように格納するかを指定する。nnml グループ
;;; を使う。
(setq gnus-secondary-select-methods '((nnml "")))

;;; Gnus をオフラインニュースリーダーにする。
;;; (gnus-agentize) ; 旧式の設定。
;;; (setq gnus-agent t) ; 現在のディフォルト。
@end lisp

基本的にはこれだけで良いはずです。これをあなたの @file{~/.gnus.el} ファ
イルに入れて、あなたの要望に合わせて編集し、PPP (や何か) を起動して、
@kbd{M-x gnus} と打鍵してください。

あなたが初めて gnus を実行するしたときは、いくつかのニュースグループが初
期設定として自動的に購読されます。おそらくもっとたくさんのグループを購読
したくなるでしょうけど、そのためには、@kbd{A A} 命令で @sc{nntp} サーバー
に全グループの一覧を問い合わせなければなりません。これは通常とても時間が
かかりますが、一度だけしか実行する必要はありません。

しばらくの読み込みと解析の後に、グループの一覧を提示させられるでしょう。
@kbd{u} 命令で読みたいグループを購読します。読みたいグループを全部購読し
たら、@kbd{l} で削除グループを全て画面から消去します。(@kbd{A k} で削除
グループは全て戻ってきます。)

さて、ここでその場でグループを読むこともできますし、あるい
は @kbd{J s} 命令で記事をダウンロードすることもできます。あとはこのマニュ
アルの残りを読んで、その他の何百億の項目からカスタマイズしたいことを見つ
け出してください。

@node Batching Agents
@subsection 一括エージェント処理

Gnus エージェントに記事を取得させるのは (そしてあなたの書いた何かのメッ
セージを投稿するのは)、一旦物事を正しく設定してしまえば非常に簡単です。
以下のシェルスクリプトは必要なことを全てやってくれるでしょう。

@example
#!/bin/sh
emacs -batch -l ~/.emacs -f gnus-agent-batch >/dev/null
@end example

@node Control Agents
@subsection gnus-agent 環境を Control する
ここまで読んで来られて、エージェントが非常に便利な機能である事が分かった
と思います。ただ、不満な点があるとすると、毎回 @kbd{J j} や @kbd{J S} 等
をキーで作業しなければならないことでしょう。オンラインと同じような操作で
やりとりできたら、と考えた事はありませんか?
gnus-offline はその機能を提供します。(筆者の趣味で gnus-agent を使用する
事を推奨します。@code{MIEE} については後述参照)

*Group* バッファで @kbd{g} を押す事で

@lisp
 (Dialup の必要な環境では Dialup) ->
  Mail の取得 ->
  Spool に溜った message の送信 ->
  News の送信 ->
  不要な記事の expire
@end lisp

までを行います。

インストールはいたって簡単。(ここまでで gnus-agent の設定は終っていると
仮定しま
す) @file{~/.emacs} の gnus-agent の設定のちょいと前に

@lisp
(load "gnus-ofsetup")
(gnus-setup-for-offline)
(load gnus-offline-setting-file)
@end lisp

といれ、Emacs を再起動してください。すると、さまざまな質問をされると思い
ます。そこでは、あなたの環境にあった答えをしてください。
質問が終ると、設定用のファイル @file{~/.gnus-offline.el} が作成されます。
ここに、必要な設定全てが書かれています。
Gnus の起動が終り、(多分 POP サーバーの password を聞かれると思いますが)
*Group* バッファになったら、@kbd{J j} や @kbd{J S} 等の操作は必要ありま
せん。News/Mail を新規で取得したければ、*Group* バッファで @kbd{g} を押
すだけです。

@code{MIEE} = Message Intercepting and Entrusting Emacs library.
Message を横取りして、offline で post/send するための汎用ライブラリです。

この @code{MIEE} を使うと @code{gnus-offline} を用いて@code{nnspool} も
コントロールする事ができます(ここでは述べませんが…)。(もちろ
ん @code{gnus-agent} + @code{MIEE} という組合せも可能で
す) @code{MIEE} は @uref{http://www.shiojiri.ne.jp/%7Et-ichi/lisp/miee.el} か
ら取って来る事ができます。@code{gnus-setup-for-offline} で設定した場合に
は、@code{MIEE} の設定はいっさいしなくてもかまいません。

@table @code
@vindex gnus-offline-articles-to-fetch
@item gnus-offline-articles-to-fetch
この変数は取得する記事の種類を指定します。'mail の場合は、Mail だけを取
得します。'news の場合は、News だけを取得します。'both の場合は、
Mail/News 両方を取得します。

@vindex gnus-offline-load-hook
@item gnus-offline-load-hook
この変数は @code{gnus-offline} が load される前に評価される hook です。

@vindex gnus-offline-before-online-hook
@item gnus-offline-before-online-hook
この変数は Gnus が Online(Plugged) 状態になる直前に評価される hook です。

@vindex gnus-offline-after-online-hook
@item gnus-offline-after-online-hook
この変数は Gnus が Offline(UnPlugged) 状態になった後に評価される hook で
す。

@vindex gnus-offline-interval-time
@item gnus-offline-interval-time
この変数で指定された間
隔 (秒数) で @code{gnus-offline-articles-to-fetch} で指定され
た article を取得します。動作には@code{gnus-daemon} を使用しています。

@vindex gnus-offline-dialup-function
@item gnus-offline-dialup-function
この変数で指定された関数が dialup 時に実行され、Dialup しサーバーに接続
します。

@vindex gnus-offline-hangup-function
@item gnus-offline-hangup-function
この変数で指定された関数が hangup 時に実行され、サーバーとの回線を切断し
ます。
@end table

@node Agent Caveats
@subsection エージェントの問題点

Gnus Agent はよくある他のオフラインニュースリーダーのようには動作しませ
ん。これらは想像的な人からの良くある質問です:

@table @dfn
@item 接続されているときに記事を読んだら、それは Agent に入るのですか?

@strong{いいえ}。

@item 接続されているときに記事を読んで、Agent に記事が存在している場合、
もう一回ダウンロードされるのですか?

@strong{いいえ}、ただし @code{gnus-agent-cache} が `nil' でなかったら、
ですが。
@end table

要約すると、gnus が切り離されているときはローカルに保存された記事を見る
だけです。接続されているときは ISP と話すだけで、かつローカルに持ってい
る記事を使います。

@node Scoring
@chapter スコア
@cindex scoring

他の人々は @dfn{削除ファイル} を使いますが、ここ gnus タワーは削除よりも
スコアの方を好みますので、他と格闘するよりは切り替える事にしました。それ
らは完全に違う事をしますので、真っ直ぐに座って注意を払ってください!

@vindex gnus-summary-below
全ての記事はスコアの初期値を持ってお
り (@code{gnus-summary-default-score})、これはディフォルトで 0 です。こ
のスコアは対話的や、スコアファイル (score file) の方法により、上げられた
り下げられたりします。@code{gnus-summary-bark-below} よりも低いスコアの
記事には既読の印が付きます。

Gnus は概略バッファを作成する前に、現在のグループに適用されるどん
な @dfn{スコアファイル} も読み込みます。

現在の記事に基づいてスコアの登録を挿入するいくつかの命令が概略バッファに
あります。例えば、gnus に特定の表題の記事のスコアを下げたり上げたりする
ように求める事ができます。

二種類のスコア登録があります: 永続と一時的です。一時的スコア登録は自分自
身で期限がくると削除する登録です。例えば、一週間以上使われていないどんな
登録も、スコアファイルの大きさを小さくするために、静かに削除されます。

@menu
* Summary Score Commands::      現在のグループのためのスコア登録を追加す
                                る
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする
                                (まぁ、なんて用語でしょう)
* Score File Format::           スコアファイルに何を入れるか
* Score File Editing::          手でスコアファイルを編集する事もできる
* Adaptive Scoring::            大姉 (Big Sister) Gnus はあなたが何を読
                                んだか知っている
* Home Score File::             新しいスコア登録がどこへ行くかをどのよう
                                に指定するか
* Followups To Yourself::       人があなたに返答したときに gnus に気付か
                                せる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                どうやって効果的にスコアを付けるか
* Reverse Scoring::             古いものの子であるという問題は問題ではな
                                い
* Global Score Files::          地をつかみ、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにありますが、無視する事
                                ができる
* Converting Kill Files::       消去ファイルをスコアファイルに変換する
* GroupLens::                   どれを読むのが好きかの予言を得る
* Advanced Scoring::            スコアの法則を作るために論理表現を使う
* Score Decays::                スコアを枯れていかせるのは役に立つ事もあ
                                る
@end menu

@node Summary Score Commands
@section 概略スコア命令
@cindex score commands

スコア登録を変更するスコア命令は実際に本当のスコアファイルを修正するわけ
ではありません。それはあまりに非効率です。Gnus は以前にロードされたスコ
アファイルのキャッシュを保持しており、その一つは @dfn{現在のスコアファイ
ル連想リスト} (current score file alist) と考えられています。スコア命令
は単純にこのリストに登録を挿入して、グループから出ると、このリストは保存
されます。

現在 (current) のスコアファイルは、実際にそのようなスコアファイルが存在
していない場合でも、初期設定でグループのローカルスコアファイルになってい
ます。スコア命令を何か他のスコアファイル (例、@file{all.SCORE}) に挿入し
たいなら、まずこのスコアファイルを現在のものにしなければなりません。

一般的なスコア命令は実際にはスコアファイルを変更しません:

@table @kbd
@item V s
@kindex V s (概略)
@findex gnus-summary-set-score
現在の記事のスコアを設定します (@code{gnus-summary-set-score})。

@item V S
@kindex V S (概略)
@findex gnus-summary-current-score
現在の記事のスコアを表示します (@code{gnus-summary-current-score})。

@item V t
@kindex V t (概略)
@findex gnus-score-find-trace
現在の記事に使われている全てのスコア法則 (score rule) を表示しま
す (@code{gnus-score-find-trace})。

@item V w
@kindex V w (概略)
@findex gnus-score-find-favourite-words
スコアに使われている語のリストを表示しま
す (@code{gnus-score-find-favourite-words})。

@item V R
@kindex V R (概略)
@findex gnus-summary-rescore
現在の概略でスコア過程を実行します (@code{gnus-summay-rescore})。これ
は gnus の後ろでいろいろとスコアファイルで遊んで、それの効果を見たいとき
に役立つかもしれません。

@item V c
@kindex V c (概略)
@findex gnus-score-change-score-file
違ったスコアファイルを現在のものにしま
す (@code{gnus-score-change-score-file})。

@item V e
@kindex V e (概略)
@findex gnus-score-edit-current-scores
現在のスコアファイルを編集します (@code{gnus-score-edit-current-scores})。
@code{gnus-score-mode} バッファに移動する事になるでしょう (@pxref{Score
File Editing})。

@item V f
@kindex V f (概略)
@findex gnus-score-edit-file
スコアファイルを編集して、このスコアファイルを現在のものにしま
す (@code{gnus-score-edit-file})。

@item V F
@kindex V F (概略)
@findex gnus-score-flush-cache
現在のスコアキャッシュを書き込みます (@code{gnus-score-flush-cache})。こ
れはスコアファイルを編集した後に役に立ちます。

@item V C
@kindex V C (概略)
@findex gnus-score-customize
視覚的で嬉しい方法でスコアファイルをカスタマイズしま
す (@code{gnus-score-customize})。
@end table

これらの命令の残りはローカルスコアファイルを修正します。

@table @kbd
@item V m
@kindex V m (概略)
@findex gnus-score-set-mark-below
スコアの入力を促進し、それよりも低いスコアの全ての記事に既読の印を付けま
す (@code{gnus-score-set-mark-below})。

@item V x
@kindex V x (概略)
@findex gnus-score-set-expunge-below
スコアの入力を促進し、そのスコアより低い全ての記事を削除するためのスコア
法則を現在のスコアファイルに付け加えま
す (@code{gnus-score-set-expunge-below})。
@end table

実際にスコア登録をするためのキー打ち込みは非常に規則正しい法則に従います
ので、それらの命令全てを表に上げる必要はありません。(たーくさんあります。)

@findex gnus-summary-increase-score
@findex gnus-summary-lower-score

@enumerate
@item
最初のキーはスコアを増やすための @kbd{I} (i の大文字) か、スコアを下げる
ための @kbd{L} です。
@item
二番目のキーはどのヘッダーにスコアをしたいかを表します。以下のキーが使用
可能です:

@table @kbd
@item a
著者 (author) の名前にスコアを付けます。

@item s
表題 (subject) の行にスコアを付けます。

@item x
@code{Xref} 行にスコアを付けます---すなわち、相互投稿行です。

@item r
@code{References} 行にスコアをつけます。

@item d
日付 (date) にスコアを付けます。

@item l
行数 (number of lines) にスコアを付けます。

@item i
@code{Messsage-ID} ヘッダーにスコアを付けます。

@item e
追加のヘッダー (@code{gnus-extra-headers} に設定されていて、@sc{nntp} サー
バーが overview にそれらの情報を記録している) にスコアを付けます。

@item f
フォローアップ (followup) にスコアを付けます---これは著者名との合致をし、
この著者へのフォローアップにスコアを加えます。(このキーを使うことによっ
て @file{ADAPT} ファイルが生成されます。)

@item b
本体 (body) にスコアを付けます。

@item h
ヘッダー (head) にスコアを付けます。

@item t
スレッドにスコアを付けます。(このキーを使うことによって @file{ADAPT} ファ
イルが生成されます。)
@end table

@item
三番目のキーは合致する型です。どの合致の型が有効かはどのヘッダーにスコア
を付けようとしているかに依ります。

@table @code
@item 文字列 (strings)

@table @kbd
@item e
正確な (exact) 合致です。

@item s
文字列の一部の (substring) 合致です。

@item f
あいまいな (fuzzy) 合致です (@pxref{Fuzzy Matching})。

@item r
正規表現 (regexp) の合致です。
@end table

@item 日付 (date)

@table @kbd
@item b
日付の前 (before) です。

@item a
日付の後 (after) です。

@item n
その日付です。
@end table

@item 数字 (number)

@table @kbd
@item <
数字より小さいものです。

@item =
数字と等しいものです。

@item >
数字より大きいものです。
@end table
@end table

@item
四つめで通常は最後のキーです。これが一時的 (すなわち期限切れ消去) のスコ
ア登録か、永続的な (すなわち期限切れ消去でない) スコア登録であるかという
こと、もしくはすぐになされるべきか、スコアファイルに追加する事はしないか
という事を指定します。

@table @kbd
@item t
一時的な (temporary) スコア登録です。

@item p
永続的な (permanent) スコア登録です。

@item i
即座の (immediate) スコア付けです。
@end table

@item
もし `e' (追加の (extra)) ヘッダーでスコア付けを行なっていると、どの名前
のヘッダーで行なうかを尋ねられます。これは @code{gnus-extra-headers} に
ある名前でなければなりません。@samp{TAB} による補完ができます。
@end enumerate

ですから、現在の著者に正確な合致で永続的にスコアを増やしたいとしましょ
う:
@kbd{I a e p}。表題に基づいてスコアを下げたくて、文字列の部分の合致を使
い、一時的なスコア登録をしたいのであれば: @kbd{L s s t}。非常に簡単です。

物事を複雑にするのは、短縮打鍵が存在するからです。二番目か三番目の文字に
大文字を使うと、gnus は残る一つか二つの打鍵に初期値を使います。初期値
は ``文字列の一部'' と ``一時的'' です。ですから、
@kbd{I A} は @kbd{I a s t} と同じで、@kbd{I a R} は @kbd{I a r t} と同じ
です。

これらの関数は数字接頭引数と、シンボル接頭引数を受け付けま
す (@pxref{Symbolic Prefixes})。数字接頭引数はどのくらい記事のスコアを下
げる (もしくは上げる) かを指定します。シンボル接頭引数 @code{a} は命令が
現在のスコアファイルではなくファイル @file{all.SCORE} を使う事を指定しま
す。

@vindex gnus-score-mimic-keymap
@code{gnus-score-mimic-keymap} はこれらの命令がキーマップであるかのよう
に振る舞うかどうかを指定します。

@node Group Score Commands
@section グループスコア命令
@cindex group score commands

残念ながら、まだたくさんはありません。

@table @kbd
@item W f
@kindex W f (グループ)
@findex gnus-score-flush-cache
Gnus は何度もスコア連想リストを読み込むのを避けるために、それのキャッシュ
を保持しています。この命令はキャッシュを書き出しま
す (@code{gnus-score-flush-cache})。
@end table

以下のような事をする事によって、コマンド行からスコア付けをする事がで
きます。

@findex gnus-batch-score
@cindex batch scoring
@example
& emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score
@end example

@node Score Variables
@section スコア変数
@cindex score variables

@table @code
@item gnus-use-scoring
@vindex gnus-use-scoring
@code{nil} であれば、gnus はスコアファイルを調べず、一般的に、スコア関連
の仕事を全くしません。これは初期設定で @code{t} です。

@item gnus-kill-killed
@vindex gnus-kill-killed
この変数が @code{nil} であれば、gnus は既に削除過程を実行された記事に決
してスコアファイルを適用しません。これはたくさんの時間を節約するでしょう
が、もし削除ファイルをグループに適用しているときに、削除ファイルを変更し、
もっと多くの記事を削除するためにそれを再実行しても、それは動作しないとい
う事になります。それをするためにはこの変数を @code{t} に実行しなければな
りません。(これは初期設定で @code{t} です。)

@item gnus-kill-files-directory
@vindex gnus-kill-files-directory
全ての削除とスコアのファイルはこのディレクトリーに蓄積され、それは初期設
定で環境変数 @code{SAVEDIR} によって初期化されます。これは初期設定
で @file{~/News/} です。

@item gnus-score-file-suffix
@vindex gnus-score-file-suffix
スコアファイルにたどり着くためにグループ名に加える接尾語です (初期値
で @samp{SCORE} です。)

@item gnus-score-uncacheable-files
@vindex gnus-score-uncacheable-files
@cindex score cache
全てのスコアファイルは普通はスコアファイルの過剰読み込みを避けるために
キャッシュされます。しかし、これによりあなたの Emacs が大きく肥大化する
のであれば、再び必要とされないようなスコアファイルを除去するためにこの正
規表現を使う事ができます。@file{all.SCORE} のキャッシュを止めるのは悪い
考えですが、@file{comp.infosystems.www.authoring.misc.ADAPT} をキャッシュ
しないのは良い考えでしょう。実際のところ、この変数は初期設定
で @samp{ADAPT$} で、適応スコアファイルはキャッシュされません。

@item gnus-save-score
@vindex gnus-save-score
もし本当に複雑なスコアファイルを持っていて、たくさんの一括スコアをするの
であれば、この変数を @code{t} に設定すると良いかもしれません。これ
は gnus にスコアを @file{.newsrc.eld} ファイルに保存するようにさせます。

これを @code{t} に設定しなければ、手動スコ
ア (@kbd{V s} (@code{gnus-summary-set-score}) で設定されたようなもの) は
グループ移動時に保存されません。

@item gnus-score-interactive-default-score
@vindex gnus-score-interactive-default-score
全ての対話的スコア上げ/下げ命令によって使われる上げ/下げするスコアです。
ディフォルトは 1000 で、過剰だと思うかもしれませんが、これは適応スコア付
けをする余地の存在する事を確実にするためです。手で登録されたデータを適応
スコアでの小さな変更で上書きされたくはありません。

@item gnus-summary-default-score
@vindex gnus-summary-default-score
記事のスコアの初期値で、初期設定では 0 になっています。

@item gnus-summary-expunge-below
@vindex gnus-summary-expunge-below
この変数より低いスコアを持つ記事は概略の行に表示されません。これは初期設
定で @code{nil} で、これはどの記事も隠されないという事です。この変数は各
概略バッファに固有で、@code{gnus-summary-mode-hook} によって設定されるべ
きです。

@item gnus-score-over-mark
@vindex gnus-score-over-mark
初期設定のスコアより大きなスコアを持つ記事に対して (三桁目に) 使われる印
です。初期設定は @samp{+} です。

@item gnus-score-below-mark
@vindex gnus-score-below-mark
初期設定のスコアより小さなスコアを持つ記事に対して (三桁目に) 使われる印
です。初期設定は @samp{-} です。

@item gnus-score-find-score-files-function
@vindex gnus-score-find-score-files-function
現在のグループのスコアファイルを見つけるために使われる関数です。この関数
はグループ名を引数として呼ばれます。

使用可能な既定関数は:

@table @code
@item gnus-score-find-single
@findex gnus-score-find-single
グループ自身のスコアファイルだけを適用します。

@item gnus-score-find-bnews
@findex gnus-score-find-bnews
bnews 構文を使って、全ての合致するスコアファイルを適用します。これが初期
設定です。例えば、現在のグループが @samp{gnu.emacs.gnus} ならば、
@file{gnu.all.SCORE}, @file{not.alt.SCORE} と @file{gnu.all.SCORE} がす
べて適用されます。要するに、スコアファイル名
の @samp{all} が @samp{.*} に変換され、それから正規表現の合致がなされま
す。

これは、全てのグループに適用したいスコア登録がいくつかある場合は、それら
の登録を @file{all.SCORE} ファイルに入れるということです。

Gnus は一般的なスコアファイルを特定のスコアファイル向けのものより前に適
用しようと試みますが、スコアファイルはほとんど無作為の順番で適用されます。
これはスコアファイル名の要素の数を調べる事によってなされます---
@samp{all} 要素を取り除いて。

@item gnus-score-find-hierarchical
@findex gnus-score-find-hierarchical
全ての親グループからの全てのスコアファイルを適用します。これ
は @file{all.SCORE} のようなスコアファイルを持つ事はできないけれど、
@file{SCORE}, @file{comp.SCORE} と @file{comp.emacs.SCORE} を、それぞれ
のサーバーに対して持つ事ができるという事です。
@end table

この変数は関数のリストである事もできます。その場合は、これらの全ての関数
がグループ名を引数として呼ばれ、スコアファイルの返された全てのリストが適
用されます。これらの関数は直接スコア連想リストのリストのリストを返す事も
できます。その場合は、それらのファイルでないスコア連想リストを返す関数は、
返される最後のスコアファイルがローカルスコアファイルである事を確実にする
ために、おそらく ``本当の'' スコアファイル関数よりも前に置かれるべきでしょ
う。ふぅ。

例えば、サーバーを特定しない全体スコアファイルを使って、親グループに準じ
たスコア付けを行なうならば、次の値を使えば良いでしょう。
@example
(list (lambda (group) ("all.SCORE"))
      'gnus-score-find-hierarchical)
@end example

@item gnus-score-expiry-days
@vindex gnus-score-expiry-days
この変数は使われていないスコアファイル登録が期限切れ削除されるまでどのく
らいの日が経つべきかを指定します。この変数が @code{nil} であると、スコア
ファイル登録は削除されません。初期値は 7 です。

@item gnus-update-score-entry-dates
@vindex gnus-update-score-entry-dates
この変数が @code{nil} でないと、一時的に合致したスコア登録は日付が更新さ
れます。(これは gnus が期限切れ消去を操作している方法です---全ての合致し
ない登録は古くなりすぎ、合致する登録を新鮮で若いままです。) しかし、この
変数を @code{nil} に設定すると、合致する登録でさえも古くなり、あの嫌な死
神と直面する事になるでしょう。

@item gnus-score-after-write-file-function
@vindex gnus-score-after-write-file-function
そこでちょうど書かれたスコアファイルの名前と共に呼ばれる関数です。

@item gnus-score-thread-simplify
@vindex gnus-score-thread-simplify
この変数が @code{nil} でないと、記事表題はスレッドと同じ方法で表題スコア
のために単純化されます---現在の gnus-simplify-subject-functions の値によっ
て。スコア登録が @code{文字列部分} か @code{正確な} 合致を使っていると、
合致もこの方法で単純化されます。
@end table

@node Score File Format
@section スコアファイル様式
@cindex score file format

スコアファイルは普通は単純な様式のものだけを含む @code{emacs-lisp} ファ
イルです。無頓着な利用者はこれを編集しないでください。全ては概略バッファ
から変更されるでしょう。

とにかく、それを自分でいじってみたくなったのなら、例があります:

@lisp
(("from"
  ("Lars Ingebrigtsen" -10000)
  ("Per Abrahamsen")
  ("larsi\\|lmi" -50000 nil R))
 ("subject"
  ("Ding is Badd" nil 728373))
 ("xref"
  ("alt.politics" -1000 728372 s))
 ("lines"
  (2 -100 nil <))
 (mark 0)
 (expunge -1000)
 (mark-and-expunge -10)
 (read-only nil)
 (orphan -10)
 (adapt t)
 (files "/hom/larsi/News/gnu.SCORE")
 (exclude-files "all.SCORE")
 (local (gnus-newsgroup-auto-expire t)
        (gnus-summary-make-false-root empty))
 (eval (ding)))
@end lisp

この例はたいていのスコアファイルの要素を説明しています。違った方法につい
ては、@pxref{Advanced Scoring} を見てください。

これは lisp コードのように見えますが、実際はここにあるものは何
も @code{評価} (eval) されません。しかし、lisp リーダーがこの様式を読み
込むのに使われますので、意味的に有効でないとしても、文法的には有効です。

この連想リストでは六つのキーを使う事ができます。

@table @code
@item 文字列 (STRING)
もしキーが文字列であると、それは合致が実行されるヘッダーの名前です。スコ
アはこれらの八つのヘッダーだけに実行されます: @code{From}, @code{Subject}, @code{References}, @code{Message-ID}, @code{Xref}, @code{Lines}, @code{Chars}@code{Date} で
す。これらのヘッダーに加えて、gnus に記事全体を取得して,記事のより大きな
部分で合致を行うようにする三つの文字列があります: @code{Body} は記事の本
体 (Body) で合致を実行し、@code{Head} は記事のヘッダー (Head) で合致を実
行し、@code{All} は記事全体で合致を実行します。最後のこれらの三つのキー
を使う事はグループに入るときに速度を @emph{かなり} 遅くする事に気を付け
てください。スコアを付ける事のできる最後
の ``ヘッダー'' は @code{Followup} です。これらのスコア登録はそれに合致
する記事への全てのフォローアップのための新しいスコア登録が付け加えられる
事になります。

このキーに続くのは任意の数のスコア登録で、それぞれのスコア登録は一つから
四つまでの要素を持ちます。
@enumerate

@item
最初の要素は @dfn{合致要素} です。たいていのヘッダーではこれは文字列です
が、Lines と Chars ヘッダーではこれは整数でなければなりません。

@item
もし二番目の要素が存在するなら、それは数字であるべきで
す---@dfn{スコア要素}。この数字は負の無限大から正の無限大までの間の整数
であるべきです。もし合致が成功すれば、この数字が記事のスコアに加えられま
す。もしこの要素が存在していなければ、数
字 @code{gnus-score-interactive-default-score}が代わりに使われます。これ
は初期設定で 1000 です。

@item
もし三番目の要素が存在していると、それは数字であるべきで
す---@dfn{日付要素} です。この日付は最後にこのスコア登録が合致した時刻を
示し、これはスコア登録の期限切れ消去機構の機能のために使われます。この要
素が存在していなければ、スコア登録は永続します。日付は紀元前 1年12月31日
から経過した日にちの数で表されます。

@item
もし四番目の要素が存在していると、それはシンボルであるべきで
す---@dfn{型要素} です。この要素はこのスコア登録が記事に合致するかどうか
を調べるのにどの関数が使われるべきであるかを指定します。

@table @dfn
@item From, Subject, References, Xref, Message-ID
たいていのヘッダーの型に対して、@code{r} と @code{R} (正規表
現) (regexp) や、@code{s} と @code{S} (文字列の一部) (substring) 型、
@code{e} と @code{E} (正確な合致) (exact match)、
@code{w} (語の合致) (word match) 型が存在します。もしこの要素が存在しな
いと、gnus は文字列の一部の合致が用いられるべきであるとみなします。
@code{R}, @code{S}, @code{E} は合致が大文字と小文字を区別する方法で行わ
れるという点で他のものと異なります。全てのこれらの一文字型は本当
は @code{regexp}, @code{exact}, @code{word} 型の短縮形で、もしそうしたい
と思えばこちらを代わりに使う事ができます。

@item Extra
標準の overview ヘッダーの文字列と同様、@code{gnus-extra-headers} を使っ
ていると、それらのヘッダーの値にスコアを付けることができます。この場合ス
コア登録の 5 番目の要素がスコアを付けるヘッダーの名前になります。
@sc{nntp} サーバーが overview に NNTP-Posting-Host を記録しているならば、
@file{all.SCORE} ファイルの以下の登録は、単一のホストからスパムの攻撃が
ある場合に有効です。

@lisp
("111.222.333.444" -1000 nil s "NNTP-Posting-Host")
@end lisp

@item Lines, Chars
これらの二つのヘッダーは違った合致の型を使います: @code{<}, @code{>}, @code{=}, @code{>=}, @code{<=} で
す。

これらの述語はもし

@example
(PREDICATE HEADER MATCH)
@end example

の評価が @code{nil} でないと、真となります。例えば、上級合
致 @code{("lines" 4 <)} (@pxref{Advanced Scoring}) は結果として以下の式
になります。

@lisp
(< header-value 4)
@end lisp

もしくは他の方法にしましょう: @code{<} を @code{Lines} で 4 を合致として
使っているときは、記事が 4 行よりも少ないときにスコアが追加されます。(混
乱して、反対ではないかと考え易いです。でも、そうではないのです。私が思う
に。)

合致が @code{Lines} でなされていると、いくつかのバックエン
ド (@code{nndir}のようなもの) は @code{Lines} ヘッダーを作成しないために
全ての記事が 0 行であるとして扱われる事に気を付けてください。これはもし
少しの行しかない記事のスコアを下げているのなら、変な結果が起こり得る事に
なります。

@item Date
Date (日付) ヘッダーには三つのなんとなくばかげている合致の型があります:
@code{before}, @code{at}, @code{after} です。私は本当にこれが役立つよう
な機会を想像できないのですが、この関数を提供しないのもなんとなくばかげて
います。そうした場合のためにあるのです。いつ必要になるかは誰にもわかりま
せん。転ばぬ先の杖。短気は損気。本をカバーで判断しては行けません。初めて
のデートでエッチしてはいけません。(しかし、私は少なくとも一人、引用しま
すが、``この関数は欠かせないものである事がわかった'' と言った人がいると
聞いています。)

(訳注: 原典の "Once burnt, twice shy" を "短気は損気" としましたが、もっ
と適切な訳があればお知らせ下さい。)

@cindex ISO8601
@cindex date
もっと役立つ合致の型は @code{正規表現} です。それによって日付文字列に正
規表現を用いて合致させる事ができます。日付はまず ISO8601 短縮様
式 (compact format) に標準化されま
す---@var{YYYYMMDD}@code{T}@var{HHMMSS} です。例えば、もし全ての年
の 4月1日 に投稿された全ての記事にが治させたいのであれば、
@samp{....0401.........} を合致文字列として使う事ができます。(日付は元々
の標準時で保存されていますので、その記事が投稿されたところで 4月1日 に投
稿された記事に合致する事に注意してください。標準時は一家にとって非常に有
益な楽しみでしょう?)

@item Head, Body All
これらの三つの合致のキーは @code{From} ヘッダー (など) と同じ合致の型を
使います。

@item Followup
この合致のキーは少し特別で、それは @code{From} ヘッダーに合致し、合致し
た記事だけでなくその記事への全てのフォローアップのスコアにも影響します。
これはたとえば、あなた自身の記事へのフォローアップのスコアを増やしたり、
良く知られた問題児へのフォローアップ記事のスコアを下げたりするのに使われ
ます。@code{From} ヘッダーが使うのと同じ型の合致を使います。(この合致キー
を使うと、ファイル @file{ADAPT} を作る事になります。)

@item Thread
この合致キーは @code{Followup} 合致キーと同じ行に動作します。
@code{Message-ID} @var{x} で始まっている (副)スレッドにスコアを付けたい
のであれば、@samp{thread} 合致を付け加えます。これは @code{Reference} ヘッ
ダーに @var{x} を持つそれぞれの記事に新しい @samp{thread} 合致を追加しま
す。(これらの新しい @samp{thread} 合致はこれらの合致する記事
の @code{Message-ID} を使います。) これはスレッドのいくつかの記事が完全
な @code{References} ヘッダーを持っていなかったとしても、スレッド全体の
スコアを上げ/下げできる事を保証します。これを使うと、スレッドの記事に決
定的でないスコアが付くかもしれないということに注意してください。(この合
致キーを使うと、ファイル @file{ADAPT} を作る事になります。)
@end table
@end enumerate

@cindex Score File Atoms
@item mark
この登録の値は数字であるべきです。この数字より低いスコアの記事には既読の
印が付きます。

@item expunge
この登録の値は数字であるべきです。この数字より低いスコアの記事は概略バッ
ファから削除されます。

@item mark-and-expunge
この登録の値は数字であるべきです。この数字より低いスコアの記事には既読の
印が付き、概略バッファから削除されます。

@item thread-mark-and-expunge
この登録の値は数字であるべきです。スコアの総計がこの数字より低いスレッド
には既読の印が付き、概略バッファから削除されます。
@code{gnus-thread-score-function} はスレッドのスコアの総計をどのように計
算するかを指定します。

@item files
この登録の値は任意の数のファイル名であるべきです。これらのファイルもスコ
アファイルであるとみなされ、これがされたのと同じような方法で読み込まれま
す。

@item exclude-files
この登録の手がかりは任意の数のファイル名であるべきです。これらのファイル
は何らかの理由で普通は読み込まれるようになっていたとしても、読み込まれま
せん。

@item eval
この登録の値は @code{評価} されます。この要素は全体的スコアファイルを扱っ
ているときは無視されます。

@item read-only
読み込み専用スコアファイルは更新されたり保存されたりしません。全体的スコ
アファイルはこのアトムを使用するべきです (@pxref{Global Score Files})。
(注意: @dfn{全体的} はここでは本当に @dfn{全体的} という意味です。個人的
な全てのグループに適用するスコアファイルの事ではありません。)

@item orphan
この登録の値は数字であるべきです。親記事を持たない記事はスコアにこの数字
が加えられます。@samp{comp.lang.c} のような量の多いニュースグループを追
いかけているとしてください。おそらく二、三のスレッドと新しいスレッドだけ
を追いたいでしょう。

以下の三つのスコアファイル登録によってそれをする事ができます:

@example
        (orphan -500)
        (mark-and-expunge -100)
@end example

最初にこのグループに入ったときは、新しいスレッドだけを見ます。それからお
もしろいと思ったスレッドのスコアを上げ (@kbd{I T} もしくは @kbd{I S} に
よって)、残りを無視 (@kbd{C y}) します。次にグループに入ったときは、おも
しろいスレッドの新しい記事と全く新しいスレッドを見る事になります。

すなわち---orphan (孤児) スコアアトムは普通のスコア法則では発見できない
興味深いスレッドが少し存在しする量の多いグループのためにあります。

@item adapt
この登録は適応スコアを制御します。もしこれが @code{t} であると、初期設定
の適応スコア法則が使われます。もしこれが @code{ignore} であると、このグ
ループには適応スコアは実行されません。もしリストであると、そのリストは適
応スコア法則として用いられます。もしそれが存在しないか、
@code{t} や @code{ignore} でない他のものであれば、初期設定の適応スコア法
則が使われます。たいていのグループに適応スコアを使いたいのであれば、
@code{gnus-use-adaptive-scorint} を @code{t} に設定し、@code{(adapt
ignore)} を適応スコアをしたくないグループに挿入するでしょう。少しのグルー
プでだけ適応スコアを行いたいのであれば、
@code{gnus-use-adaptive-scoring} を @code{nil} に設定し、
@code{(adaptive t)} をそれを行いたいグループのスコアファイルに挿入するで
しょう。

@item adaptive-file
全ての適応スコア登録はこの登録によって名づけられたファイルに入ります。そ
れはグループに入るときにも適用されます。このアトムは多くのグループに同じ
適応スコアファイルを用いる事によって、複数のグループに一度に適応スコアを
付けたいときに便利でしょう。

@item local
@cindex local variables
この登録の値は @code{(VAR VALUE)} 対のリストであるべきです。それぞれ
の @var{var} は現在の概略バッファのバッファ固有になり、指定された
値 (value) に設定されます。これは便利な、もし少し変だとしても、フックを
あまり好まないいくつかのグループで変数を設定する方法です。@var{value} は
評価されない事に注意してください。
@end table

@node Score File Editing
@section スコアファイル編集

普通は全てのスコア命令を概略バッファから発行しますが、手でそれらを編集し
たい気に駆られるかもしれませんので、それのためのモードを提供しています。

それは単純に少しカスタマイズされた @code{emacs-lisp} モードで、以下の追
加の命令が存在します:

@table @kbd
@item C-c C-c
@kindex C-c C-c (スコア)
@findex gnus-score-edit-done
あなたが行った変更を保存して概略バッファに戻りま
す (@code{gnus-score-edit-done})。

@item C-c C-d
@kindex C-c C-d (スコア)
@findex gnus-score-edit-insert-date
現在の日付を数字様式で挿入します (@code{gnus-score-edit-insert-date})。
もしこれがどのようなものであろうと考えているのであれば、これは本当に日の
数字です。

@item C-c C-p
@kindex C-c C-p (スコア)
@findex gnus-score-pretty-print
適応スコアファイルは整えられていない流儀で保存されます。もしこれらのファ
イルの内の一つを読みたいと思っているのであれば、まず @dfn{素敵な表示} を
したいでしょう。この命令 (@code{gnus-score-pretty-print}) があなたのため
にそれをします。
@end table

このモードを使うためには @kbd{M-x gnus-score-mode} と打ってください。

@vindex gnus-score-mode-hook
@code{gnus-score-menu-hook} がスコアモードバッファで実行されます。

概略バッファでは、@kbd{V f} や @kbd{V e} のような命令でスコアファイルの
編集を始める事ができます。

@node Adaptive Scoring
@section 適応性スコア
@cindex adaptive scoring

これらのスコア付けはあなたを憂鬱にさせてしまうかもしれないので、
gnus にはこれらを全て自動的に --- まるで魔法でも使ったように作成
する方法があります。いやむしろ、人工無能によって、という方が正確
かな。

@vindex gnus-use-adaptive-scoring
記事を読んだとき、あるいは記事に既読の印をつけたとき、記事を削除したとき
に、その印を残しておいてください。グループから出るときにgnus は、それら
の印の辺りを嗅ぎ回り、何の印を見つけたかに依存してスコア要素を追加します。
この機能
は @code{gnus-use-adaptive-scoring} を @code{t} か @code{(line)} に設定
することで有効になります。もしスコアを、表題に現れる個別の単語をもとに適
応させたければ、この変数を @code{(word)} に設定してください。両方の適応
方法を使いたければ、この変数を@code{(wordline)} に設定してください。

@vindex gnus-default-adaptive-score-alist
@code{gnus-default-adaptive-score-alist} 変数をカスタマイズすることで、
スコア付けの処理を完全に制御できます。例えば、このような感じになります。

@lisp
(setq gnus-default-adaptive-score-alist
      '((gnus-unread-mark)
        (gnus-ticked-mark (from 4))
        (gnus-dormant-mark (from 5))
        (gnus-del-mark (from -4) (subject -1))
        (gnus-read-mark (from 4) (subject 2))
        (gnus-expirable-mark (from -1) (subject -1))
        (gnus-killed-mark (from -1) (subject -3))
        (gnus-kill-file-mark)
        (gnus-ancient-mark)
        (gnus-low-score-mark)
        (gnus-catchup-mark (from -1) (subject -1))))
@end lisp

見てお分かりのように、この連想リストの各要素は、キーとして印 (変数名かも
しくは ``本当の'' 印 --- つまり文字)を持ちます。このキーの後には任意の数
のヘッダー/スコアの組が続きます。もしそのキーの後にヘッダー/スコアの組が
一つもなければ、そのキーが記事の印としてついている記事に対しては適応性ス
コアは実行されません。例えば上記の例では、@code{gnus-unread-mark} がつい
ている記事は適応性スコアの登録項目にはなりません。

各記事はただ一つの印しか持ち得ないので、それぞれの記事にはこれらの規則の
うちただ一つしか適用されません。

@code{gnus-del-mark} を例に取りましょう --- この連想リストでの意味は、こ
の印 (すなわち @samp{D} の印)がついている記事は全て、@code{From} ヘッダー
をもとに -4 下げられ @code{Subject} で -1 下げられるスコア登録が追加され
ます。これをあなたの偏見に合わせて変更してください。

もし 10 個の記事に同じ subject で @code{gnus-del-mark} の印がついていた
とすると、この印に対する規則は十回適用されます。それはつまり、そ
の subject は -1 の十倍のスコアを得ます。その値は、私が大きく誤解してい
ないかぎり、-10 のはずです。

もし自動期限切れ消去 (メール) グループ (@pxref{Expiring Mail})があれば、
既読記事には全て @samp{E} 印がつけられます。これはおそらく、適応性スコア
付けをちょっとばかり不可能にするので、自動期限切れ消去と適応性スコアは一
緒にはうまくやっていけません。

スコアをつけられるヘッダーに
は @code{from}, @code{subject}, @code{message-id}, @code{references}, @code{xref}, @code{lines}, @code{chars}, @code{date} が
あります。さらに @code{followup} にもスコア付けできます。これは現在の記
事の @code{Message-ID} を使用して @code{References} ヘッダーにマッチ、す
なわちこれに続いたスレッドにマッチする適応性スコア登録を作成します。

また @code{thread} にもスコア付けすることができます。これはスレッド中の
全ての記事にスコア付けしようとします。@code{thread} のマッチは、
@code{Message-ID} を使って記事の @code{References} ヘッダーにマッチさせ
ます。マッチが起こったらその記事の @code{Message-ID} が @code{thread} 規
則に追加されます。(ちょっと考えてみてください。後で頭痛薬を二粒お勧めし
ときますが)

この機構を使うならば、ときどき記事を既読にしてしまう小さな変更を避けるた
めに、スコアファイルの @code{mark} アトムを何か小さい値 --- ことによれ
ば -300 くらいに設定しておいた方が良いです。

適応性スコアを一週間かそこら使ってくると、gnus はそれ相応に調教され、あ
なたが何も言わなくても、あなたの好きな投稿者を強調し、あまり好きではない
投稿者を消去するようになるはずです。

どのグループにおいて適応性スコアを作動させるかは、スコアファイ
ル (@pxref{Score File Format}) を使うことによって制御できます。またこれ
を使って、違ったグループに対して違った規則を使うようにもできます。

@vindex gnus-adaptive-file-suffix
適応性スコア登録項目は、グループ名に @code{gnus-adaptive-file-suffix} を
付加した名前のファイルに入れられます。初期設定値は @samp{ADAPT} です。

@vindex gnus-score-exact-adapt-limit
適応性スコアを行うときは、部分文字列一致やファジーな一致を行った方が、お
そらくほとんどの場合において良い結果が得られるでしょう。しかし、ヘッダー
の一致した部分が短い場合、意図に反するような動作をする可能性が大きくなる
ので、@code{gnus-score-exact-adapt-limit} より短い長さしか一致しない場合
は完全一致が行われます。この変数が @code{nil} であれば、この問題が起こら
ないように常に完全一致が行われます。

@vindex gnus-default-adaptive-word-score-alist
上で述べたように、個別の単語に対してもヘッダー全体に対しても適応を行うこ
とができます。単語に対して適応を行った場合、
@code{gnus-default-adaptive-word-score-alist} 変数によって、各単語に対し
てある印へどんなスコアを与えるかを指定します。

@lisp
(setq gnus-default-adaptive-word-score-alist
      `((,gnus-read-mark . 30)
        (,gnus-catchup-mark . -10)
        (,gnus-killed-mark . -20)
        (,gnus-del-mark . -15)))
@end lisp

これが初期設定値です。単語に対する適応を有効にすると、
@code{gnus-read-mark} の印のついた記事の表題に現れる全ての単語が、スコア
に 30 点追加するというスコア規則を生み出します。

@vindex gnus-default-ignored-adaptive-words
@vindex gnus-ignored-adaptive-words
@code{gnus-default-ignored-adaptive-words} のリストに現れる単語は無視さ
れます。無視したい単語を追加したいときは、この変数ではな
く @code{gnus-ignored-adaptive-words} リストの方を使ってください。

@vindex gnus-adaptive-word-length-limit
短い単語では適応性スコアを作動させるべきではないと思う人もいるでしょう。
もしそうなら @code{gnus-adaptive-word-length-limit} に整数を設定すること
ができ、この数値より短い単語は無視されます。この変数の初期設定値
は @code{nil} です。

@vindex gnus-adaptive-word-syntax-table
スコア付けが終了したとき、@code{gnus-adaptive-word-syntax-table} の文法
表がその影響を受けます。これは標準の文法表と似ていますが、単語の構成要素
とならない文字の数も考慮します。

@vindex gnus-adaptive-word-minimum
もし @code{gnus-adaptive-word-minimum} に数字が設定されていると、単語適
応性スコア付け処理において、記事のスコアがこの数字よりも小さくなることは
ありません。初期設定値は @code{nil} です。

@vindex gnus-adaptive-word-no-group-words
@code{gnus-acaptive-word-no-group-words} が @code{t} に設定されていると、
gnus はグループ名の全ての語について、単語適応性スコアをしません。ほとん
どの表題が @samp{emacs} という語を含んでいる @samp{comp.editor.emacs} の
ようなグループで便利です。

この機構をしばらく使ってみた後には、あなたがどんな単語が好きでどんな単語
が嫌いかを、この規則を通して診断する利用者精神分析命
令 @code{gnus-psychoanalyze-user} を書いてみると良いかもしれません。いや、
良くないかな。

単語適応性スコア付けは非常に実験的なものであって、今後変更されるであろう
ということは心に留めておいてください。第一印象では、これは現状では全く使
い物にならないように思えます。これをもっと使えるようにするためには、(よ
り厳密な統計的手法を巻き添えにして) さらなる作業が必要となるでしょう。

@node Home Score File
@section ホームスコアファイル

新しいスコアファイル登録項目が入れられるスコアファイルは、ホームスコアファ
イル @dfn{home score file} と呼ばれます。これは通常 (初期設定で) そのグ
ループ用のスコアファイルになります。例えば、@samp{gnu.emacs.gnus} 用のホー
ムスコアファイルは @file{gnu.emacs.gnus.SCORE} となるわけです。

しかしながら、これはあなたのお望みではないかもしれません。たくさんのグルー
プ間で共通のホームスコアファイルを共有すると便利なときが多いでしょ
う --- 例えば全ての @samp{emacs} グループで同じホームスコアファイルを使
うこともできます。

@vindex gnus-home-score-file
これを制御する変数が @code{gnus-home-score-file} です。これは以下の値を
取り得ます。

@enumerate
@item
文字列。この場合このファイルが全てのグループでホームスコアファイルとして
使用されます。

@item
関数。この関数の結果がホームスコアファイルとして使用されます。この関数は
グループの名前を引数として呼び出されます。

@item
リスト。このリストの要素は以下の値を取り得ます。

@enumerate
@item
@code{(@var{regexp} @var{file-name})}。@var{regexp} がグループ名にマッチ
すれば、@var{file-name} がホームスコアファイルとして使用されます。

@item
関数。この関数が @code{nil} 以外を返せば、その返却値がホームスコアファイ
ルとして使用されます。

@item
文字列。この文字列をホームスコアファイルとして使用します。
@end enumerate

このリストの中からマッチするものを、最初から後ろの方に向かって探していき
ます。

@end enumerate

というわけで、単に一個のスコアファイルを使いたい場合は、以下のようにすれ
ばできます。

@lisp
(setq gnus-home-score-file
      "my-total-score-file.SCORE")
@end lisp

もし全 @samp{gnu} グループに対して @file{gnu.SCORE} を、全 @samp{rec} グ
ループに対して @file{rec.SCORE} (等々) を使いたければ、このようにできま
す。

@findex gnus-hierarchial-home-score-file
@lisp
(setq gnus-home-score-file
      'gnus-hierarchial-home-score-file)
@end lisp

これは便利なようにあらかじめ提供されている関数です。多の関数は以下の以下
のものを含みます。

@table @code
@item gnus-current-home-scre-file
@findex gnus-current-home-score-file
``現在の'' 標準スコアファイルを返します。これはスコア命令にスコアファイ
ルの ``最内部'' 合致への登録を加えるようにします。
@end table

もし @samp{emacs} グループ用のスコアファイルと、それとは別
の @samp{comp} グループ用のスコアファイルを使い、他の全部のグループでは
それぞれ独自のスコアファイルを使いたいのであれば、

@lisp
(setq gnus-home-score-file
      ;; All groups that match the regexp "\\.emacs"
      '(("\\.emacs" "emacs.SCORE")
        ;; All the comp groups in one score file
        ("^comp" "comp.SCORE")))
@end lisp

@vindex gnus-home-adapt-file
@code{gnus-home-adapt-file} は @code{gnus-home-score-file} と全く同じよ
うに動作しますが、これは代わりに何をホーム適用スコアファイルにするかを指
定します。新しい適用ファイル登録項目は全て、この変数で指定されるファイル
に入れられます。値には同じ文法が許されます。

@code{gnus-home-score-file} と @code{gnus-home-adapt-file} の使用に加え
て、グループパラメータ (@pxref{Group Parameters}) とトピックパラメー
タ (@pxref{Topic Parameters}) を使ってほぼ同様のことができます。グループ、
トピックパラメータはこの変数よりも優先されます。

@node Followups To Yourself
@section 自分自身へのフォローアップ

Gnus は現在のバッファーから @code{Message-ID} ヘッダーを見つけ出すために
二つの命令を提供しています。そして gnus は、他の記事におけ
る @code{References} ヘッダー中にこの @code{Message-ID} を使っている得点
を、スコア規則として追加します。これは実質的に、その記事へ返答した記事で、
現在のバッファーにあるもの全てに対してスコアを増加させます。これはあなた
の言ったことに対してみんなが答えてくれたとき、すぐにそれに目を向けたいと
きにとても便利ですね。

@table @code
@item gnus-score-followup-article
@findex gnus-score-followup-article
これはあなた自身の記事に直接フォローアップした記事にスコアを加算します。

@item gnus-score-followup-thread
@findex gnus-score-followup-thread
これはあなたの記事より ``下'' のスレッドに現れる記事全てに対してスコアを
加算します。
@end table

@vindex message-sent-hook
これら二つの関数は、基本的にはどちらも @code{message-sent-hook} のような
フックの中で使うためのものです。例えばこのように:
@lisp
(add-hook 'message-sent-hook 'gnus-score-followup-thread)
@end lisp

あなたの自分の @code{Message-ID} をじっくりと眺めてみると、はじめの二、
三文字は常に同じであることに気がつくでしょう。以下の二つは私のものです。

@example
<x6u3u47icf.fsf@@eyesore.no>
<x6sp9o7ibw.fsf@@eyesore.no>
@end example

つまりこのマシン上での ``私の'' の識別は @samp{x6} であるということです。
これは使えます --- 以下の規則は私自身へのフォローアップ全てに対してスコ
アを増加させるでしょう。

@lisp
("references"
 ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@@.*eyesore\\.no>"
  1000 nil r))
@end lisp

``あなたの'' が最初の二文字になるか最初の三文字になるかはシステムに依存
します。

@node Scoring On Other Headers
@section 他のヘッダーにスコアを付ける
@cindex scoring on other headers

gnus が ``伝統的'' なヘッダー -- @samp{From}, @samp{Subject} など -- に
スコアを付けるのはとても速いです。ですが、他のヘッダーにスコアを付けるに
は @code{head} のスコアのための規則を書く必要があり、それは合致を探すた
めに gnus が毎回バックエンドから単独の記事を取り寄せなければならないこと
を意味します。これは大きなグループでは長い時間がかかります。

さて、ニュースグループではなくてメールグループでこれを行なうのはさほど大
変ではなく、そのためのすぐれた手段が用意されています。このマニュアル
の @pxref{To From Newsgroups} の項ではこの機構がどう働くかが詳しく説明さ
れていますが、ここでは @code{nnml} で @samp{To} と @samp{Cc} ヘッダーに
スコアを付ける方法の調理の例を挙げましょう。

以下を @file{.gnus.el} ファイルに置いて下さい。

@lisp
(setq gnus-extra-headers '(To Cc Newsgroups Keywords)
      nnmail-extra-headers gnus-extra-headers)
@end lisp

gnus を再起動して、@kbd{M-x nnml-generate-nov-databases} コマンド
で @code{nnml} の overview ファイルを作り直します。もしあなたがたくさん
のメールを持っていると、これには長い時間がかかります。

そして @kbd{I e s p To RET <your name> RET} のようにすると、あなた
は @samp{To} と @samp{Cc} ヘッダーに ``extra headers'' としてスコアを付
けることができます。

わかったかな? 簡単だよね。

@node Scoring Tips
@section スコア付けの奥義
@cindex scoring tips

@table @dfn
@item クロスポスト
@cindex crossposts
@cindex scoring crossposts
クロスポストのスコアを低くしたければ、マッチさせるべき行
は @code{Xref} ヘッダーです。

@lisp
("xref" (" talk.politics.misc:" -1000))
@end lisp

@item 複数のクロスポスト
ある数、例えば三つ以上のグループにクロスポストされている記事のスコアを低
くしたければ、

@lisp
("xref"
  ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
   -1000 nil r))
@end lisp

@item 本文へのマッチ
これは一般的にはあまり良い考えではありません --- それはとても長時間かかっ
てしまうからです。実際 gnus は、それぞれの記事を個別にサーバーから取得し
てこなければならないのです。でも、あなたはそれでもやりたいかも知れません
ね。マッチさせるキーは三つ(@code{Head}, @code{Body}, @code{All}) あるの
ですが、スコアファイル毎に一つ選んでそれに固定した方が良いです。もし二つ
を使うと、それぞれの記事は @emph{二回} 取得されてしまいます。も
し @code{Head} からちょっとだけ、@code{Body} からちょっとだけマッチさせ
たい、というのであれば、素直に @code{All} を使って全部マッチさせてくださ
い。

@item 既読の印付け
ある一定数字以下のスコアを持つ記事には、おそらく既読の印をつけてしまいた
くなるでしょう。これは @file{all.SCORE} ファイルに以下のものを入れておく
ことによって最も簡単に実現できます。

@lisp
((mark -100))
@end lisp

@code{expunge} を使って同様のことを考えることもできます。

@item 否定文字クラス
もし @code{[^abcd]*} みたいなものを指定すると、たぶん期待通りの結果は得
られないでしょう。これは改行文字にもマッチしてしまい、えーと、未知の世界
まで続くかもしれません。代わりに@code{[^abcd\n]*} を使ってください。
@end table

@node Reverse Scoring
@section 逆スコア
@cindex reverse scoring

もし、表題ヘッダーに @samp{Sex with Emacs} という文字がある記事だけを残
して、その他の記事全てを消去してしまいたければ、スコアファイルに以下のよ
うなものを入れることもできます。

@lisp
(("subject"
  ("Sex with Emacs" 2))
 (mark 1)
 (expunge 1))
@end lisp

そして @samp{Sex with Emacs} にマッチする全ての記事を集めて、残りを蹴飛
ばすために既読の印をつけ、消去します。

@node Global Score Files
@section グローバルスコアファイル
@cindex global score files

間違いなく、他のニュースリーダーは ``グローバル削除ファイ
ル (global kill file)'' を持っています。これは普通、全てのグループに適用
される、ユーザのホームディレクトリーに格納されている一つの削除ファイル以
上の何物でもありません。はん! ちっぽけなニュースリーダーだね。弱すぎ。

僕がここで話しているのはグローバルスコアファイルです。全世界中からの、至
る所からのユーザによるスコアファイル、世界の国々を全て、巨大な一つの幸せ
なスコアファイル同盟に団結させるスコアファイル !Ange-score! 新しくてテス
トしていない!

@vindex gnus-global-score-files
他の人のスコアファイルを使うためにしなければならないことは、
@code{gnus-global-score-files} 変数を設定することだけです。それぞれのス
コアファイル毎に、あるいはそれぞれのスコアファイルディレクトリ毎に対して
一つの項目になります。Gnus はどのスコアファイルをどのグループに使うのが
適切であるかを自分で決定します。

例えば @file{/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE} の
スコアファイルと @file{/ftp@@ftp.some-where:/pub/score} ディレクトリにあ
る全てのスコアファイルを使いたければ、

@lisp
(setq gnus-global-score-files
      '("/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
        "/ftp@@ftp.some-where:/pub/score/"))
@end lisp

@findex gnus-score-search-global-directories
@noindent
どうだい、簡単だろう? ディレクトリ名は @samp{/} で終わらなくてはなりませ
ん。これらのディレクトリは普通は、一回の gnus 使用期間中に一回だけしか読
み込みません。もし遠隔ディレクトリを手動で再読み込みする必要が出てきたら、
@code{gnus-score-search-global-directories} 命令を使うことができます。

ただし現時点では、このオプションを使うとグループに入るのがいくらか遅くな
ります。(つまり --- かなり、ですけど)

もしスコアファイルを、他の人たちに使ってもらうように維持したくなってきた
ら、単にあなたのスコアファイルを匿名 FTP に置いて、世界中に公表してくだ
さい。逆司会者になれるよ! その後に続いて間違いなく起こる逆司会者戦争、す
なわち人々の共感を勝ち取るための逆司会者の戦いに参加することで、彼らのス
コアファイルに間違った前提を使わせるように誘導するのだ! やった! これでネッ
トは救われる!

以下に、逆司会者なりたがりのための秘技をいくつか、即席で述べます。

@itemize @bullet

@item
非常に多くの場所にクロスポストされている記事は間違いなく屑である。
@item
一個の不適切な記事を減点するには、@code{Message-ID} で減点する。
@item
特に素晴らしい投稿者たちは永続的な主役達として加算する。
@item
そのグループの憲章無視の投稿を頻繁に繰り返す投稿者は、絶滅させてしまって
差し支えない。
@item
@code{mark} と @code{expunge} アトムを設定し、汚らわしい記事を完全に葬り
去る。

@item
消去のスコア項目を使ってファイルの大きさを小さく抑える。でもおそらくは、
サイトによって古い記事を長期間保存するように、期限切れ消去の期間は長く取
るでしょうけれども。
@end itemize

... 果たして他のニュースリーダーは将来、グローバルスコアファイルをサポー
トするでしょうか? @emph{うふふ}。そう、どう考えてみたって、
Blue Wave や xrn や 1stReader とかいったニュースリーダーはスコアをサポー
トするべきだね。今は固唾を飲んで見守ることにしましょうか?

@node Kill Files
@section 消去ファイル
@cindex kill files

Gnus はまだ、あのうざったい古い消去ファイルをサポートしています。実際消
去ファイルの項目はもう消してもよいのですが、それは Daniel Quinlan がスコ
アファイルを考え出す前に私が書いたものなので、そのコードはまだ残っていま
す。

要するに、消去処理はスコア処理よりもかなり遅いので (私の言いたいの
は @emph{ものすごく})、あなたの消去ファイルはスコアファイルに書き換えた
方が良いかもしれません。

いずれにせよ、消去ファイルは普通の @code{emacs-lisp} ファイルです。この
ファイルの中にはどんな形式でも入れることができます。つまり消去ファイルを
グループに入ったときに実行する一種の原始的なフック関数のように使うことが
できます。まあそれがあまりいい方法ではないとしてもね。

通常の消去ファイルは以下のようになります。

@lisp
(gnus-kill "From" "Lars Ingebrigtsen")
(gnus-kill "Subject" "ding")
(gnus-expunge "X")
@end lisp

これは私が書いた全ての記事に既読の印をつけ、概略バッファから印のついた記
事を削除します。とっても便利です。あなたもそう思うでしょ。

他のプログラムでは全く違う消去ファイルの構文を使っています。も
し gnus が @code{rn} の消去ファイルらしきものに出会ったら、何とかそれを
解釈しようとします。

GNUS 消去ファイルを編集するための二つの概略バッファ関数があります。

@table @kbd
@item M-k
@kindex M-k (概略)
@findex gnus-summary-edit-local-kill
そのグループの消去ファイルを編集す
る (@code{gnus-summary-edit-local-kill})。

@item M-K
@kindex M-K (概略)
@findex gnus-summary-edit-global-kill
一般消去ファイルを編集する (@code{gnus-summary-edit-global-kill})。
@end table

消去ファイルを編集する二つのグループモード関数があります。

@table @kbd
@item M-k
@kindex M-k (グループ)
@findex gnus-group-edit-local-kill
そのグループの消去ファイルを編集する (@code{gnus-group-edit-local-kill})。

@item M-K
@kindex M-K (グループ)
@findex gnus-group-edit-global-kill
一般消去ファイルを編集する (@code{gnus-group-edit-global-kill})。
@end table

消去ファイル変数。

@table @code
@item gnus-kill-file-name
@vindex gnus-kill-file-name
@samp{soc.motss} グループ用の消去ファイルは通
常 @file{soc.motss.KILL} という名前です。このファイル名を得るためにグルー
プ名に付加される接尾辞は、@code{gnus-kill-file-name} 変数で与えられます。
``グローバル'' 消去ファイルは (スコアファイルの意味で
の ``グローバル'' じゃないよ、もちろん) 単に @file{KILL}という名前です。

@vindex gnus-kill-save-kill-file
@item gnus-kill-save-kill-file
この変数が @code{nil} 以外であれば、gnus は処理の後に消去ファイルを保存
します。これは期限切れ削除を行う消去を使っているときに必要です。

@item gnus-apply-kill-hook
@vindex gnus-apply-kill-hook
@findex gnus-apply-kill-file-unless-scored
@findex gnus-apply-kill-file
グループに消去ファイルを適用するために呼び出されるフック。これは初期設定
では @code{(gnus-apply-kill-file)} です。もし同じグループに対してスコア
ファイルがある場合には消去ファイルを無視したければ、このフック
を @code{(gnus-apply-kill-file-unless-scored)} に設定します。消去ファイ
ルを処理させたくなければ、この変数を@code{nil} に設定してください。

@item gnus-kill-file-mode-hook
@vindex gnus-kill-file-mode-hook
消去ファイルモードバッファ内で呼び出されるフック。
@end table

@node Converting Kill Files
@section 消去ファイルの変換
@cindex kill files
@cindex converting kill files

あなたが古い消去ファイルをどっさり持っているのであれば、それらをスコアファ
イルに変換したくなるでしょう。もしそれらが ``普通の''やつであれば、
@file{gnus-kill-to-score.el} パッケージを使うことができます。そうでなけ
れば、手で変換しなければならないでしょう。

消去ファイルからスコアファイルへの変換パッケージは、標準ではgnus には含
まれません。
@uref{http://www.stud.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el} か
ら入手することができます。

もしあなたの消去ファイルが非常に複雑なものであれば --- それ
に @code{gnus-kill} 形式以外のものがたくさん含まれていれば、それらを手で
変換しなければなりません。あるいは単にそれらを、そのままにしておいてくだ
さい。Gnus は以前同様にそれらを使ってくれるでしょう。

@node GroupLens
@section GroupLens
@cindex GroupLens

GoupLens (@uref{http://www.cs.umn.edu/Research/GroupLens/}) は、毎日作成
される多くの量のニュース記事から質の良い記事を他の人と共に見つけるのを助
けるための共同選別機構です。

これを達成するために、GroupLens 機構はあなたが既に読んだ記事に対する意見
を、同じような事をした他の人の意見と結合して、それぞれの未読ニュース記事
に個人化された予言を与えます。GroupLens を仲人のようなものだと見なしてく
ださい。GroupLens はあなたがどのように記事の価値を付けるかを見て、同じよ
うに記事の価値を付ける人を探します。一度あなたの意見と一致する人を発見す
れば、予言の形で、それらの人が記事をどう思うかをあなたに告げます。あなた
はこの予言を記事を読みたいかどうかを決定するのに役立てる事ができます。

@sc{注意:} 残念なことに GroupLens 機構は閉鎖されているようなので、この項
は主として歴史的な興趣のために書かれています。

@menu
* Using GroupLens::             どのように gnus に GroupLens を使わせる
                                ようにするか
* Rating Articles::             GropLens にあなたがどのように値を付ける
                                かを知らせる
* Displaying Predictions::      GropuLens によって与えられた予言を表示す
                                る
* GroupLens Variables::         GoupLens をカスタマイズする
@end menu

@node Using GroupLens
@subsection GroupLens を使う

GroupLens を使うためには、ローカルの Better Bit Berau (BBB) に筆
名 (pseudonym) を登録しなければなりません。
@uref{http://www.cs.umn.edu/Research/GroupLens/bbb.html} が現在、ちまた
に存在する唯一の better bit です。

登録した後で、いくつかの変数を設定する必要があります。

@table @code
@item gnus-use-grouplens
@vindex gnus-use-grouplens
この変数を @code{nil} でない値に設定すると、Gnus が全ての GroupLens 関連
関数をフックするようになります。

@item grouplens-pseudonym
@vindex grouplens-pseudonym
この変数は Better Bit Bureau に登録したときにもらった筆名に設定されるべ
きです。

@item grouplens-newsgroups
@vindex grouplens-newsgroups
GroupLens の予言を得たいと思うグループのリストです。
@end table

これが起き上がって GroupLens を実行するために必要な最低限の設定です。一
度登録すると、GroupLens はあなたに他の人が考える平均に基づいたスコアをあ
なたに提供することを始めます。しかし、GroupLens の本当の利益を受けるため
には、自分自身で記事の値付けを始めなければなりません。そうすると、
GroupLens があなたに提供するスコアはあなたが普段納得するような意見を持っ
た人が既に値を付けた基づいて個人化されます。

@node Rating Articles
@subsection Rating Articles

GroupLens では、記事は 1 から 5 まででそれを含んだ範囲で値を付けられます。
1 は帯域の無駄遣いのようなものだと考えられ、5 は記事が本当に良いと考えら
れるいう事を意味します。あなたが自分自身に尋ねる基本的な質問は、
``1 から 5 の範囲の中で、これと同じような記事をもっと読みたいだろう
か?'' です。

GroupLens で、記事の値を登録するための四つの方法があります。

@table @kbd
@item r
@kindex r (GroupLens)
@findex bbb-summary-rate-article
この関数は 1 から 5 の範囲の値付けの入力を促進します。

@item k
@kindex k (GroupLens)
@findex grouplens-score-thread
この関数は値付けの入力を促進し、スレッドの全ての記事を値付けます。これ
は rec.humor にあるようなあの長い間続くスレッドに対して非常に役に立ちま
す。
@end table

次の二つの命令、@kbd{n} と @kbd{,} は、あなたが読んでいる記事のスコアに
なる数値接頭引数をとります。

@table @kbd
@item 1-5 n
@kindex n (GroupLens)
@findex grouplens-next-unread-article
記事の値を付けて、次の未読記事に移動します。

@item 1-5 ,
@kindex , (GroupLens)
@findex grouplens-best-unread-article
記事の値を付けて次の一番高いスコアの未読記事に移動します。
@end table

もし現在の記事にスコア 4 を付け、次の記事に移動したいのであれば、
@kbd{4 n} と叩いてください。

@node Displaying Predictions
@subsection 予言表示

GroupLens はあなたがニュース記事をどれくらい気に入るかの予言をします。
GroupLens からの予言は 1 から 5 の範囲にあり、1 が最悪で 5 が最良です。
GroupLens からの予言を変数 @code{gnus-grouplens-override-scoring} によっ
て制御される三つの内の一つによって使う事ができます。

@vindex gnus-grouplens-override-scoring
grouplens で予言を表示するために三つの方法があります。GroupLens のスコア
を普通の gnus スコア機構に貢献するか、上書きするかを選ぶ事ができます。上
書きが初期設定です。しかし、gnus のスコアを grouplens のスコアに足すのを
好む人もいます。分離スコアの振る舞いを得るためには、
@code{gnus-grouplens-override-scoring} を @code{'separate} に設定する必
要があります。GroupLens の予言と grouplens スコアを結合するためにはそれ
を @code{'override} に設定し、スコアを結合するために
は @code{gnus-grouplens-override-scoring} を @code{'combine} に設定しま
す。結合付加機能を用いるときは、
@code{grouplens-prediction-offset} と @code{grouplens-score-scale-factor} の
値を設定したいと思うでしょう。

@vindex grouplens-prediction-display
どちらの場合でも、GroupLens は二、三の予言がどのよう表示されたいかの選択
を与えます。予言の表示は変数 @code{grouplens-prediction-display} によっ
て制御されます。

以下のものがその変数で有効な値です。

@table @code
@item prediction-spot
予言が高いほど、右の方に @samp{*} が表示されます。

@item confidence-interval
数字の確信 (confidence) 間隔です。

@item prediction-bar
予言が高いほど、棒が長くなります。

@item confidence-bar
数字確信です。

@item confidence-spot
確信が高いほど点が大きくなります。

@item prediction-num
普通の昔ながらの数値です。

@item confidence-plus-minus
予言の +/- 確信です。
@end table

@node GroupLens Variables
@subsection GroupLens 変数

@table @code
@item gnus-summary-grouplens-line-format
GropuLens 拡張の概略バッファで使われる概略行様式です。普通の概略行様式が
受け付けるものと同じ指定を受け付けます (@pxref{Summary Buffer Lines})。
初期設定は@samp{%U%R%z%l%I%(%[%4L: %-23,23n%]%) %s\n} です。

@item grouplens-bbb-host
bbbd サーバーが実行されているホストです。@samp{goruplens.cs.umn.edu} が
初期設定です。

@item grouplens-bbb-port
bbbd サーバーが実行されているホストのポートです。初期値は 9000 です。

@item grouplens-score-offset
予言から差し引きされる値です。つまり、意味のあるスコアにするために予言の
値からこの数字を引き算します。初期値は 0 です。

@item grouplens-score-scale-factor
利用者はこの変数を使って GroupLens のスコアを拡大する事ができます。掛け
算の要素は差し引きの後に適用されます。初期値は 1 です。
@end table

@node Advanced Scoring
@section 上級スコア付け

表題や From ヘッダーにスコアを付けるのは十分素敵ですが、ある人特定の題に
関して言っている事にだけ本当に興味がある場合はどうすれば良いのでしょ
う? もしくは、A さんが B さんにフォローアップしているときに言っている事
を読みたくないけれど、Cさんにフォローアップしているときは何を言っている
かを知りたいという場合は?

上級スコア法則を使う事で、任意の複雑なスコアの付け方を作成する事ができま
す。

@menu
* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限利用する
@end menu

@node Advanced Scoring Syntax
@subsection 上級スコア付け構文

普通のスコア法則は法則の最初の要素に文字列があります。上級スコア付け法則
は最初の要素にリストがあります。二番目のリストは最初の要素
が @code{nil} でない値に評価されたときに適用されます。

これらのリストは三つの論理作用子からなっており、それらは一方向作用子で、
色々な合致作用子です。

論理作用子:

@table @code
@item &
@itemx and
この論理作用子はそれぞれの引数を @code{false} に評価されるものを見つける
まで評価し、それから停止します。全ての引数が @code{true} の値に評価され
た場合は、この作用子は @code{true} を返します。

@item |
@itemx or
この論理作用子はそれぞれの引数を @code{true} に評価されるものを見つける
まで評価します。もしどの引数も @code{true} でないと、この作用子
は @code{false} を返します。

@item !
@itemx not
@itemx ,A,
この論理作用子は単一の引数のみをとります。それはその引数の値の論理否定を
返します。
@end table

引数をスコア付けされている現在の記事の祖先に適用する @dfn{間接作用子} が
あります。例えば、@code{1-} は現在の記事の親にもスコア法則を適用します。
@code{2-} は現在の記事の祖父母にスコア法則を適用します。代わりに、
@code{^^} を書く事もでき、この時、@code{^} (キャラット) (carat) の数はど
のくらい祖先の記事までさかのぼるかを示します。

最後に、合致作用子があります。これらが本当の仕事をするものです。合致作用
子はヘッダー名の文字列で、その後に合致と合致の型が続きます。典型的な合致
作用子は @samp{("form" "Lars Ingebrigtsen" s)} のようなものです。ヘッダー
名は単純なスコア付けをするときのものと同じで、合致の型も同じです。

@node Advanced Scoring Examples
@subsection 上級スコア付けの例

以下の例はスコアファイルの規則であることにご注意下さい。完璧なスコアファ
イルを作るには、別の括弧の組でそれらを囲んで下さい。

Lars が Gnus に関して話をしているときに彼によって書かれた記事のスコアを
増やしたいとしましょう:

@example
((&
  ("from" "Lars Ingebrigtsen")
  ("subject" "Gnus"))
 1000)
@end example

ね、とても単純でしょ?

長い記事を書いているときは、時々何か素敵な事を言います:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (|
   ("subject" "Gnus")
   ("lines" 100 >)))
 1000)
@end example

しかし、彼が Reig Eigil Logge によって書かれたものに反応しているときは、
彼が書いたものを読みたくありません:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (1- ("from" "Reig Eigir Logge")))
 -100000)
@end example

Redmondo が消えた靴下について書いたときにフォローアップした全ての人はス
コアが上げられますが、それは彼らが白い靴下について語っているときのみです。
しかし、Lars が靴下について話をしているときは、たいていあまりおもしろく
ありません:

@example
((&
  (1-
   (&
    ("from" "redmondo@@.*no" r)
    ("body" "disappearing.*socks" t)))
  (! ("from" "Lars Ingebrigtsen"))
  ("body" "white.*socks"))
 1000)
@end example

可能性は無限大です。

@node Advanced Scoring Tips
@subsection 上級スコアのちょっとした秘訣

@code{&} と @code{|} 論理作用子は、短縮回路論理を行います。すなわち、そ
の作用の結果が明らかになって時点で、引数を実行過程にかける事を止めます。
例えば、@code{&} の引数の評価が @code{false} になると、残りの引数を評価
する目的は存在しなくなります。これは遅い合
致 (@samp{body} や @samp{header}) を最後に持ってきて、速い合
致 (@samp{from} や @samp{subject}) を最初に持ってくるべきであるという事
を意味します。

間接作用子 (@code{1-} など) はそれらの引数をスレッドの一世代前に作用する
ようにします。次のような事をすれば:

@example
...
(1-
 (1-
  ("from" "lars")))
...
@end example

これは ``現在の記事の祖父母の from ヘッダーにスコアを付ける'' という事を
意味します。間接はとても速いですが、次の方よりも:

@example
(1-
 (&
  ("from" "Lars")
  ("subject" "Gnus")))
@end example

次の方が良いです:

@example
(&
 (1- ("from" "Lars"))
 (1- ("subject" "Gnus")))
@end example

@node Score Decays
@section スコア腐敗
@cindex score decays
@cindex decays

スコアは再現無く膨れ上がる傾向がある事に気付くかもしれません。特に、適応
スコアを使っているときは。スコアが大きくなりすぎると、それらは意味を失い
ます---それらは単に最大を通り越してしまって、それを意味のある方法で使う
事は難しくなります。

@vindex gnus-decay-scores
@findex gnus-decay-score
@vindex gnus-decay-score-function
Gnus はこの問題の解決を助けるためにスコアを腐らせる機構を提供します。ス
コアファイルは読み込まれ、@code{gnus-decay-scores} が @code{nil} でない
と、gnus はスコアファイルを腐敗機構を通し、全ての永続でないスコア法則の
スコアを下げます。腐敗自身は関数 @code{gnus-decay-score-function} によっ
て実行され、初期設定は @code{gnus-decay-score} です。以下はその関数の定
義です:

@lisp
(defun gnus-decay-score (score)
  "Decay SCORE.
This is done according to `gnus-score-decay-constant'
and `gnus-score-decay-scale'."
  (floor
   (- score
      (* (if (< score 0) 1 -1)
         (min (abs score)
              (max gnus-score-decay-constant
                   (* (abs score)
                      gnus-score-decay-scale)))))))
@end lisp

@vindex gnus-score-decay-scale
@vindex gnus-score-decay-constant
@code{gnus-score-decay-constant} は初期値として 3 を持ちで、
@code{gnus-score-decay-scale} は初期値として 0.05 を持ちます。これは以下
のような事を引き起こします:

@enumerate
@item
-3 から 3 の間のスコアはこの関数が呼ばれたときに 0 に設定されます。

@item
3 から 60 までの間の大きさのスコアは三つ減らされます。

@item
60 より大きいスコアはスコアの 5% に減らされます。
@end enumerate

もしこの腐敗関数を好きでないなら、自分自身の関数を書いてください。それは
腐敗するべきスコアを唯一の引数として呼ばれ、整数であるべき新しいスコアを
返さなければなりません。

Gnus は一日に一回スコアを腐敗させようとします。例えば、もし gnus を四日
間実行していないと、gnus は四回スコアを腐らせます。

@iftex
@iflatex
@chapter Message
@include message-ja.texi
@chapter Sieve
@include sieve.texi
@end iflatex
@end iftex

@node Various
@chapter いろいろ

@menu
* Process/Prefix::              多くの扱い命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの gnus の関数に選択権を提供する
                                方法
* Formatting Variables::        バッファがどのように見えるべきかを指定す
                                る事ができる
* Window Layout::               Gnus バッファウィンドウを設定する
* Faces and Fonts::             フェイスがどのように見えるかを変更する
* Compilation::                 どのようにして gnus の速度を上げるか
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファを素敵で心地よく見せる
* Buttons::                     簡単な十歩でアキレス腱を得る
* Daemons::                     Gnus はあなたの裏で物事を実行する事がで
                                きる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻す事ができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Image Enhancements::          最新の Emacs/XEmacs は絵を表示できる
* Fuzzy Matching::              大きな綿毛って何?
* Thwarting Email Spam::        余計な商業的電子メールを避ける方法
* Various Various::             本当にいろいろなもの
@end menu

@node Process/Prefix
@section プロセス/接頭引数
@cindex process/prefix convention

多くの関数、その中でも記事の移動、復号化、保存をするための関数は、
@dfn{プロセス/接頭引数の習慣} として知られているものを使います。

これは利用者がどの記事に命令を実行したいかを見つけるための方法です。

それはこのような感じです:

もし数値接頭引数が N であると、現在の記事から始めて、次の N 記事に作業を
実行します。もし数値接頭引数が負であると、現在の記事から始めて、前
の N 記事に作業を実行します。

@vindex transient-mark-mode
@code{transient-mark-mode} が @code{nil} でなく、リージョンが操作されて
いると、リージョンにある全ての記事に作業がなされます。

もし接頭引数が無いけれど、いくつかの記事はプロセス印が付いているという場
合は、プロセス印の付いている記事に作業が実行されます。

数値接頭引数やプロセス印の付いている記事が無い場合は、現在の記事にだけ作
業を実行します。

これは本当に非常に簡単ですが、驚嘆を避けられるように詳細を明らかにしてお
く必要があるのです。

プロセス印に反応する記事は現在のプロセス印の付いている記事のリストをスタッ
クに積み、全てのプロセス印の記事のリストを消去します。前回の設定
を @kbd{M P y} で復旧させる事ができます (@pxref{Setting Process Marks})。

@vindex gnus-summary-goto-unread
多くの人々を驚かせ、恐がらせると思われることは、例えば、@kbd{3 d} は本当
に @kbd{d} @kbd{d} @kbd{d} と同じ事をする事です。それぞれの @kbd{d} (こ
れは現在の記事に既読の印を付けます) は初期設定では印を付けた後に次の未読
記事に移動するので、@kbd{3 d} は概略バッファがどのようであっても、次
の三つの未読記事を既読にします。もっと分かりやすい動作のために
は @code{gnus-summary-goto-unread} を @code{nil} に設定してください。

多くのコマンドはプロセス/接頭引数の習慣を使いません。ということは、この
マニュアルではっきりと述べています。プロセス/接頭引数の習慣を使わないコ
マンドに適用するには、@kbd{M-&} コマンドを使いましょう。例えば、そのグルー
プのすべての記事を期限切れ削除可能として印を付けるには `M P b M-& E' と
します。

@node Interactive
@section 対話的
@cindex interaction

@table @code
@item gnus-novice-user
@vindex gnus-novice-user
もしこの変数が @code{nil} でないと、あなたは Usenet の世界に新しく入って
来た人であるか、非常に慎重な人で、これは本当に良い事です。何か危険な事を
する前に、``本当にこれをしたいのですか?'' というような質問を受けます。
これは初期設定では @code{t} です。

@item gnus-expert-user
@vindex gnus-expert-user
この変数が @code{nil} でないと、あなたは gnus からほとんど質問を受ける事
はありません。これは単純にあなたがどのような変な事をしていても、何をして
いるかをわかっていると見なします。

@item gnus-interactive-catchup
@vindex gnus-interactive-catcup
@code{nil} でないと、グループに追いつく (catchup) 前に、確認を要求します。
これは初期設定で @code{t} です。

@item gnus-interactive-exit
@vindex gnus-interactive-exit
Gnus を終了する前に確認を要求します。この変数は初期設定で @code{t} です。
@end table

@node Symbolic Prefixes
@section シンボルの接頭引数
@cindex symbolic prefixes

非常に多くの Emacs の命令は (数値) 接頭引数に反応します。例えば、
@kbd{C-u 4 C-f} はポイントを 4 文字先に移動し、
@kbd{C-u 9 0 0 I s s p} は永続 @code{Suject} 文字列の一部スコア法則
の 900 を現在の記事に加えます。

これは素敵で良いのですが、命令にもう少し追加の情報を与えたいときはどうす
れば良いのでしょう? えーと、たいていの命令がしている事は、``生の'' 接頭
引数を特別な方法で解釈する事です。例えば、@kbd{C-u 0 C-x C-s} は現在の記
事を保存するときにバックアップファイルを作らないで欲しいということを意味
します。でも、バックアップファイルを作らないで保存し、同時に Emacs に光っ
て欲しく、素敵な音楽を演奏して欲しいときはどうすれば良いでしょう? それは
不可能で、おそらくそれが不可能であってもあなたは幸せでしょう。

@kindex M-i (概略)
@findex gnus-symbolic-argument
私はそうではありません。ですから、私は二つめの接頭引
数---@dfn{シンボル接頭引数} を加えました。接頭キー
は @kbd{M-i} (@code{gnus-symbolic-argument}) で、次に押される文字が値で
す。望むだけ多くの @kbd{M-i} 接頭語を積み重ねる事ができます。
@kbd{M-i a C-M-u} は ``命令 @kbd{C-M-u} にシンボル接頭引数 @code{a} を与
える'' ということです。@kbd{M-i a M-i b C-M-u} は命令 @kbd{C-M-u} にシン
ボル接頭引数 @code{a} @code{b} を与える'' という事です。趣旨は分かったで
しょう。

シンボル接頭引数を受け付けない命令にそれを打鍵する事は何も悪い事をしませ
んが、良い事も何もしません。現在のところ、あまり多くの関数がシンボル接頭
引数を役立てているわけではありません。

もしどのように gnus がこれを実装しているかに興味があるなら、
@pxref{Extended Interactive} を見てください。

@node Formatting Variables
@section 書法仕様変数
@cindex formatting variables

このマニュアルを通して、あなたはおそら
く @code{gnus-group-line-format} や @code{gnus-summary-mode-line-format} の
ように呼ばれるたくさんの変数がある事に気付いたでしょう。これらは gnus が
色々なバッファでどのように行を出力するかを制御します。非常にたくさんのも
のがあります。幸運な事に、それらはすべて同じ構文を使いますので、あまり嫌
な目には会わないでしょう。

書法仕様 (format) 指定の例があります (グループバッファより):
@samp{%M%S%5y: %(%g%)\n}。それは実際に非常に醜く、たくさんのパーセント記
号がどこにでもあります。

@menu
* Formatting Basics::           書法仕様変数は基本的に書法指定文字列であ
                                る
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの
                                規則
* Advanced Formatting::         色々な方法で出力を修正する
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う
@end menu

現在のところ、gnus は以下の書法仕様変数を使います:
@code{gnus-group-line-format}, @code{gnus-summary-line-format}, @code{gnus-server-line-format}, @code{gnus-topic-line-format}, @code{gnus-group-mode-line-format}, @code{gnus-summary-mode-line-format}, @code{gnus-article-mode-line-format}, @code{gnus-server-mode-line-format}, @code{gnus-summary-pick-line-format}。

これら全ての書法仕様変数は任意の elisp 式である事もできます。その場合は、
それらは要求される行に挿入するために @code{評価} されます。

@kindex M-x gnus-update-format
@findex gnus-update-format
Gnus はあなた自身の書法仕様指定を作る手伝いをする命令を備えています。
@kbd{M-x gnus-update-format} は現在の式を @code{評価} し、当の指定を更新
し、結果の lisp 式を実行して行を作成する事を実験できるバッファに移動しま
す。

@node Formatting Basics
@subsection 書法仕様の基本

それぞれの要素 @samp{%} は当のバッファが作成されるときに何らかの文字列や
他のもので置き換えられます。@samp{%5y} は ``@samp{y} 指定を挿入し、5 文
字の場所を得るために空白を入れなさい'' という事です。

普通の C や Emacs Lisp の書法仕様 (format) 文字列と同じように、
@samp{%} と書法仕様の型の文字の間の数値修飾子は常に少なくともその長さに
なるように、出力に @dfn{詰め} れられます。@samp{%5y} はその部分を常
に (少なくとも) 5 文字の長さになるように、左に空白を詰めます。も
し @samp{%-5y} とすれば、代わりに右側に詰め込みます。

特に長い値からその部分を保護するために、長さを制限したいとも思うでしょう。
そのためには、@samp{%4,6y} とする事ができて、これはその領域は決して 6 文
字を超える長さにはならず、4 文字より少ない長さにならないという事です。

gnus は @samp{%&user-date;} のような、いくつかの拡張様式指示もサポートし
ます。

@node Mode Line Formatting
@subsection モード行書法仕様

モード行書法仕様変数 (すなわち、@code{gnus-summary-mode-line-format}) は
以下の二つの違い以外は、バッファ行に基づく書法仕様変数
と (@pxref{Formatting Basics}) 同じような規則に従います:

@enumerate

@item
最後に改行 (@samp{\n}) があってはなりません。

@item
特別な @samp{%%b} 指定をバッファ名を表示するために使うことができます。えー
と、本当はそれは指定ではないのです---@samp{%%} は単に書法仕様が機械的に
切り裂くのを切り抜けて @samp{%} をそのまま渡すための方法で、
Emacs が @samp{%b} を受け取ると、Emacs のモード行表示の部分がそれ
を ``バッファ名を表示しなさい'' と解釈します。Emacs が理解するモード行指
定の完全な一覧を見るためには、変数 @code{mode-line-format} の説明文を見
て下さい。

@end enumerate

@node Advanced Formatting
@subsection 上級書法仕様

何らかの方法で領域を後で処理するのは頻繁に役に立ちます。部分を詰め込む、
制限する、切り取ることと特定の値を抑制する事は、@dfn{チルダ修飾子} を使
う事により達成されます。よくあるチルダ指定はこのように見えるかもしれませ
ん @samp{%~(cut 3)~(ignore "0")y}。

これらは有効な修飾子です:

@table @code
@item pad
@itemx pad-left
要求された長さになるまで、領域に空白を左側から詰め込みます。

@item pad-right
要求された長さになるまで、領域に空白を右側から詰め込みます。

@item max
@itemx max-left
指定された長さになるように、文字を左側から切り取ります。

@item max-right
指定された長さになるように、文字を右側から切り取ります。

@item cut
@itemx cut-left
指定された数の文字を左側から切り落とします。

@item cut-right
指定された数の文字を右側から切り落とします。

@item ignore
領域が指定された値と等しければ (equal)、空文字列を返します。

@item form
@samp{@@} 指定が使われたときに、指定された式を領域の値として使います。

これは例です:

@lisp
"~(form (current-time-string))@@"
@end lisp
@end table

例を出してみましょう。概略モード行での @samp{%o} 指定は小型の ISO0861 様
式の日付を返します---@samp{19960809T230410} です。これは発音しにくいので、
世紀を表す数と時間を削ぎ落として、6 文字の日付を残したいと思います。それ
は @samp{%~(cut-left 2)~(max-right 6)~(pad 6)o} となるでしょう。(切り落
とし (cutting) は 最大限 (maxing) より先になされますので、桁で素敵に見え
るようにするために日付が 6 文字より少なく無くならない事を保証するために
詰め込み (padding) が必要になります。)

無視 (ignore) が最初になされます。それから切り落とし (cut) が行われます。
そして、それから最後の操作、詰め込み (pad) が行われます。

@vindex gnus-compile-user-specs
もしあなたが強い個性の持ち主で @code{gnus-compile-user-specs} を
@code{nil} にしていて (初期値は@code{t})、これらの上級参照をたくさん使っ
ているなら、T-gnus がとても遅くなるのがわかるでしょう。これはあなたが行
の外見に満足したときに @kbd{M-x gnus-compile} を実行する事で格段に速度低
下を減らす事ができます。@xref{Compilation}。

@node User-Defined Specs
@subsection 利用者定義の指定

全ての指定は利用者定義---@samp{u} の指定を挿入する事ができます。書法仕様
文字列の次の文字はアルファベットである必要があります。Gnus は関
数 @code{gnus-user-format-function-}@samp{X} を呼び、ここ
で @samp{X} は @samp{%u} に続くアルファベットです。関数には単一の引数が
与えられます---引数の意味は関数がどのバッファから呼ばれているかによって
変わります。関数は文字列を返すべきで、それは他の指定からの情報と全く同じ
ようにバッファに挿入されます。関数は意味の無い値と共に呼ばれる事もありえ
ますので、それの対策をするべきです。

gnus は @samp{%u&foo;} のような拡張利用者定義指示もサポートします。
gnus は関数 @code{gnus-user-format-function-}@samp{foo} を呼び出します。

新しい関数を定義しないでも、チルダ修飾
子 (@pxref{Advanced Formatting}) を使ってほとんど同じ事を達成する事がで
きます。例です: @samp{%~(form (count-lines (point-min) (point)))@@}。
ここで与えられた式は評価されて、現在の行数をもたらし、それから挿入されま
す。

@node Formatting Fonts
@subsection 書法仕様フォント

ハイライトのための指定があり、それらは全ての書法仕様変数によって共有され
ています。@samp{%(} と @samp{%)} 指定の間の文章は特別
な @code{mouse-face} プロパティが設定され、それはそこにマウスのポインター
をあわせたときに (@code{gnus-mouse-face} によって) ハイライトされること
になります。

@samp{%@{} と @samp{%@}} 指定の間の文章は @code{gnus-face-0} を使って普
通のフェイスが設定され、それは初期設定で @code{bold} です。も
し @samp{%@{1} としたなら、代わりに @code{gnus-face-1} を得、以下同様で
す。欲しいだけたくさんのフェイスを作ってください。同じ事
が @code{mouse-face} 指定にも言えま
す---@samp{hello} が @code{gnus-mouse-face-3} でマウス−ハイライトされる
ためには、@samp{%3(hello%)} とする事ができます。

@samp{%<} と @samp{%>} 指示子の間のテキストは特別
な @code{balloon-help} プロパティが @code{gnus-balloon-face-0} に設定さ
れます。@samp{%1<} とすると、@code{gnus-balloon-face-1} を得て、他も同様
です。@code{gnus-balloon-face-*} 変数は文字列か文字列を返す関数を指すシ
ンボルのどちらかである必要があります。@code{balloon-help-mode} では、マ
ウスがプロパティの設定されているテキストの上を通過すると、バルーンウィン
ドウが現れて、文字列を表示します。これの詳しい情報
は @code{balloon-help-mode} の説明文字列を参照してください。

これはグループバッファの代替手法です:

@lisp
;; 三つのフェイスの型を作る。
(setq gnus-face-1 'bold)
(setq gnus-face-3 'italic)

;; 我々は記事の数をボールドで緑のフェイス
;; にしたいので、`my-green-bold' と呼ばれる
;; 新しいフェイスを作った。
(copy-face 'bold 'my-green-bold)
;; 色を設定する。
(set-face-foreground 'my-green-bold "ForestGreen")
(setq gnus-face-2 'my-green-bold)

;; 新しい上等の書法仕様を設定する。
(setq gnus-group-line-format
      "%M%S%3@{%5y%@}%2[:%] %(%1@{%g%@}%)\n")
@end lisp

あなたがこの案を使って完全に読めなくて非常に下品な表示を作る事ができると
確信しています。楽しんでください!

@samp{%(} 指定 (やその類のもの) はモード行変数では全く意味をなさない事に
注意してください。

@node Positioning Point
@subsection ポイントの移動

gnus は通常ほとんどのバッファで、ポイントを各行のあらかじめ決められた場
所に移動します。ディフォルトでは、ポイントは行の最初のコロンに移動します。
あなたはこの振るまいを、三つの違う方法でカスタマイズすることができます。

また、あなたはコロンを行のどの場所にでも移動することができます。

@findex gnus-goto-colon
あなたはコロンの位置にポイントを移動させるための関数を定義し直すことがで
きます。その関数は @code{gnus-goto-colon} と呼ばれています。

でも、もしあなたが行にコロンを含めたくないならば、これを扱うためのおそら
く最も手ごろな方法は @samp{%C} 指示子を使うことです。あなたの行の書法仕
様の定義に @samp{%C} を入れておけば、gnus はそこにポイントを置きます。

@node Tabulation
@subsection 整列

あなたは通常は、延ばしたり縮めたりして文字列をディスプレイに並べることが
できます。でも大きさが違う異なる文字列を連結させる場合は、単に文字列を出
力してしまうのがより手ごろであることが多いはずで、しかしそうするとその後
に続くテキストを並べるのに悩むことになります。

それを行なうため、gnus は整列子 (tabulator) の指定 @samp{%=} を備えてい
ます。これには二つの形
式 @dfn{hard tabulators} と @dfn{soft tabulators} があります。

@samp{%50=} は文字列が 50桁から始まるように空白文字を詰め込みます。も
し 50桁より後ろにすでにテキストがある場合は何も挿入しません。これは穏や
か (soft) な整列子です。

@samp{%-50=} もまた、文字列が 50桁から始まるように空白文字を詰め込みます。
ですが、もし 50桁より後ろにすでにテキストがある場合、50桁より後ろにある
過剰なテキストは削除されます。これは厳密 (hard) な整列子です。

@node Wide Characters
@subsection Wide Characters

多くの地域において、プロポーショナルなフォントは同じ幅の文字を持っていま
す。しかしいくつかの地域、よく知られている東アジアの国々では、ラテン文字
と幅の広い文字が混在して使われています。

整形において、gnus は文字列が 10個の文字の幅だとしたら、スクリーンで
も 10個分のラテン文字の幅になると仮定しますが、それは問題です。かの国々
では、それは正しくありません。

@vindex gnus-use-correct-string-widths
それを救済するために、あなた
は @code{gnus-use-correct-string-widths} を @code{t} に設定することがで
きます。これはバッファの生成を遅くしますが、より美しい結果を得ることがで
きるでしょう。既定値は @code{t} です。

@node Window Layout
@section ウィンドウの配置
@cindex window layout

いえ、X に関する事はありませんので、おとなしくして下さい。

@vindex gnus-use-full-window
もし @code{gnus-use-full-window} が @code{nil} でないと、gnus は全ての他
のウィンドウを消して、Emacs の画面全体を占有します。これは初期設定
で @code{t} です。

この変数を @code{nil} に設定するのはそれなりに動作しますが、問題もありま
す。危険を覚悟の上で使ってください。

@vindex gnus-buffer-configuration
@code{gnus-buffer-configuration} はそれぞれの gnus のバッファがどのくら
いの空間を与えられるべきかを現します。これはこの変数の抜粋です:

@lisp
((group (vertical 1.0 (group 1.0 point)
                      (if gnus-carpal (group-carpal 4))))
 (article (vertical 1.0 (summary 0.25 point)
                        (article 1.0))))
@end lisp

これは連想リストです。@dfn{キー} は何らかの動作や他のものを任命するシン
ボルです。例えば、グループバッファを表示するときは、ウィンドウ設定関数
は @code{group} をキーとして使います。使用可能な名前の完全な一覧は下に挙
げられています。

@dfn{値} (すなわち、@dfn{分割}) はそれぞれのバッファがどれくらいを占める
べきかを指定します。@code{article} 分割を例に取ると -

@lisp
(article (vertical 1.0 (summary 0.25 point)
                       (article 1.0)))
@end lisp

この @dfn{分割} は概略バッファ (summary buffer) が画面の上の 25% を占め
るべきで、それは記事バッファ (article buffer) の上に配置されます。お気づ
きの通り、100% + 25% は実際は 125% です (えぇ、皆さんの計算はこの様になっ
たと思います。) しかし、特別な数字 @code{1.0} は、残りのバッファが必要な
ものを取り去った後に、使用可能な残りの空間全てを吸い取る、という事を合図
するために使われます。一つの分割につき、@code{1.0} の大きさ指定のバッファ
は一つだけでなくてはなりません。

ポイントは省略可能な三つ目の要素、@code{point} を持つバッファに置かれま
す。@code{frame} 分割では、タグ @code{frame-focus} が構成要素である (す
なわち、@code{point} タグが存在するかどうかによって、リストの三番目か四
番目かに存在する要素) 葉分割を持つ最後の副分割が焦点を得る事になります。

次はもっと複雑な例です:

@lisp
(article (vertical 1.0 (group 4)
                       (summary 0.25 point)
                       (if gnus-carpal (summary-carpal 4))
                       (article 1.0)))
@end lisp

もし大きさ指定が浮動小数点数の代わりに整数であったなら、それは割合ではな
く、どのくらい多くの行をバッファが占めるべきかを指定するために使われます。

もし @dfn{分割} が @code{評価} されるもののように見えるときは (明確にす
ると---分割の @code{car} が関数か原始関数 (subr) であるときは)、この分割
は @code{評価} されます。結果が @code{nil} でないなら、それは分割として
用いられます。これは、@code{gnus-carpal} が @code{nil} であれば三つのバッ
ファが、@code{gnus-carpal} が @code{nil} でないなら、四つのバッファが存
在するという事です。

まだ複雑ではないですって? それでは、大きさにこれを試してみて下さい:

@lisp
(article (horizontal 1.0
             (vertical 0.5
                 (group 1.0)
                 (gnus-carpal 4))
             (vertical 1.0
                 (summary 0.25 point)
                 (summary-carpal 4)
                 (article 1.0))))
@end lisp

おぉっと。二つのバッファに不思議な 100% タグが付いています。そして、あ
の @code{horizontal} っていうものは何でしょう?

もし分割の一つの最初の要素が @code{horizontal} であったなら、gnus は ウィ
ンドウを水平に分割し、二つのウィンドウを横に並べます。これらのそれぞれの
小片の中では、全てを普通の流儀で行う事ができます。@code{horizontal} の後
の数字は、この小片に画面のどれくらいの割合が与えられるかを指定します。

それぞれの分割では、100% のタグを持つ要素が @emph{必ず} 一つある必要があ
ります。分割は決して正確には行われませんので、このバッファが分割から残さ
れた全ての行を占領します。

もう少し正式にするために、ここに有効な分割がどのようになるかの定義があり
ます:

@example
split      = frame | horizontal | vertical | buffer | form
frame      = "(frame " size *split ")"
horizontal = "(horizontal " size *split ")"
vertical   = "(vertical " size *split ")"
buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
size       = number | frame-params
buf-name   = group | article | summary ...
@end example

制限には、@code{frame} は最上位の分割としてしか現れる事ができないという
ものがあります。@var{form} は有効な分割を返す Emacs Lisp の式 (form) で
なければなりません。それぞれの分割は完全に再帰的で、任意の数
の @code{vertical} と @code{horizontal} 分割を含む事ができます。

@vindex gnus-window-min-width
@vindex gnus-window-min-height
@cindex window height
@cindex window width
正しい大きさを見つけるのは少し複雑です。どのウィンドウ
も @code{gnus-window-min-height} (初期値 1) の文字の高さよりも小さくては
ならず、少なくとも @code{gnus-window-min-width} (初期値 1) の文字幅でな
くてはなりません。Gnus は分割を適用する前にこれを強制しようと試みます。
もし普通の Emacs のウィンドウの幅/高さ制限を使いたいなら、この二つの変数
を @code{nil} にするだけで良いです。

もし Emacs の用語になじんでいないのなら、
@code{horizontal} と @code{vertical} 分割は、期待するものと反対の動作を
するでしょう。@code{horizontal} 分割の中のウィンドウは横に並んで表示され、
@code{vertical} 分割の中のウィンドウは上下に表示されます。

@findex gnus-configure-frame
ウィンドウの設置に関して実験をしてみたいのであれば、よい方法は分割で直
接 @code{gnus-configure-frame} を呼ぶことです。これはバッファを分割する
ときに全ての本当の仕事をする関数です。下のものは 5 ウィンドウのとてもば
かげた設定です。二つをグループバッファに、三つを記事バッファのために充て
ます。(それはばかげていると言ったでしょ。) もし下の文を @code{評価} する
と、普通の gnus の経路を使わないで、すぐにそれがどのように見えるかの考え
を得る事ができます。満足するまでそれで遊んで、それか
ら @code{gnus-add-configuration} を使って新しい想像をバッファ設定リスト
に加えて下さい。

@lisp
(gnus-configure-frame
 '(horizontal 1.0
    (vertical 10
      (group 1.0)
      (article 0.3 point))
    (vertical 1.0
      (article 1.0)
      (horizontal 4
        (group 1.0)
        (article 10)))))
@end lisp

いくつかのフレームも欲しいかもしれません。簡単です---@code{frame} 分割を
使うだけです:

@lisp
(gnus-configure-frame
 '(frame 1.0
         (vertical 1.0
                   (summary 0.25 point frame-focus)
                   (article 1.0))
         (vertical ((height . 5) (width . 15)
                    (user-position . t)
                    (left . -1) (top . 1))
                   (picon 1.0))))

@end lisp

この分割の結果は、最初 (もしくは、``主な'') フレームは見慣れた概略/記事
ウィンドウ設定で、小さな追加のフレームが picon を表示するために作られる
という事になります。ご覧の通り、普通の @code{1.0} 最上位指定の代わりに、
それぞれの追加の分割がフレームパラメータ連想リストを大きさ指定として持た
なければなりません。@xref{Frame Parameters, , Frame Parameters, elisp,
The GNU Emacs Lisp Reference Manual}. XEmacs では、フレームプロパティリ
ストも使えます---例えば、@code{(height 5 width 15 left -1 top 1)} はその
ようなパラメータリストです。
@code{gnus-buffer-configuration} に使用可能な全てのキーの一覧はその初期
値で見つけることができます。

キー @code{message} は @code{gnus-group-mail} と @code{gnus-summary-mail-other-window} の
両方で使われる事に注意して下さい。もし二つを区別するほうが望ましいなら、
このような物を使う事ができます:

@lisp
(message (horizontal 1.0
                     (vertical 1.0 (message 1.0 point))
                     (vertical 0.24
                               (if (buffer-live-p gnus-summary-buffer)
                                   '(summary 0.5))
                               (group 1.0))))
@end lisp

複数のフレームへの良くある要望は、メールとニュースの作成には別のフレーム
を使い、元のフレームはそのままに残すというものです。これの達成には、以下
のようなものでできます。

@lisp
(message
  (frame 1.0
         (if (not (buffer-live-p gnus-summary-buffer))
             (car (cdr (assoc 'group gnus-buffer-configuration)))
           (car (cdr (assoc 'summary gnus-buffer-configuration))))
         (vertical ((user-position . t) (top . 1) (left . 1)
                    (name . "Message"))
                   (message 1.0 point))))
@end lisp

@findex gnus-add-configuration
変数 @code{gnus-buffer-configuration} はとても長く複雑なので、単一の設定
の変更を簡単にするための関数があります: @code{gnus-add-configuration} で
す。もし、例えば、@code{article} の設定を変えたいのなら、次のようにでき
ます:

@lisp
(gnus-add-configuration
 '(article (vertical 1.0
               (group 4)
               (summary .25 point)
               (article 1.0))))
@end lisp

普通はこれらの @code{gnus-add-configuration} 呼び出しをファイ
ル @code{.gnus.el} に入れるか、何らかの起動時のフックに入れるでしょ
う---それらは gnus が読み込まれた後に実行されるべきです。

@vindex gnus-always-force-window-configuration
もし設定で言及された全てのウィンドウが既に見えているのであれば、gnus は
ウィンドウの設定を変更しません。もし常に ``正しい'' ウィンドウ設定を強制
したいのであれば、
@code{gnus-always-force-window-configuration} を @code{nil} でない値に設
定する事ができます。

木表示を使っていて (@pxref{Tree Display})、木ウィンドウは垂直方向に別の
ウィンドウで表示されるなら、ウィンドウの大きさが変更されることを避けるた
めに @code{gnus-tree-minimize-window} をいじるのが良いでしょう。

@subsection ウィンドウ設定の例

@itemize @bullet
@item
左側を狭めてグループバッファに。右側を分割して概略バッファ (上 1/6) と
記事バッファ (下) に。

@ifinfo
@example
+---+---------+
| G | Summary |
| r +---------+
| o |         |
| u | Article |
| p |         |
+---+---------+
@end example
@end ifinfo

@lisp
(gnus-add-configuration
 '(article
   (horizontal 1.0
               (vertical 25 (group 1.0))
               (vertical 1.0
                         (summary 0.16 point)
                         (article 1.0)))))

(gnus-add-configuration
 '(summary
   (horizontal 1.0
               (vertical 25 (group 1.0))
               (vertical 1.0 (summary 1.0 point)))))
@end lisp
@end itemize

@node Faces and Fonts
@section フェイスとフォント
@cindex faces
@cindex fonts
@cindex colors

フォントとフェイスを弄るのは非常に難しかったのですが、今日では非常に簡単
です。単に @kbd{M-x customize-face} とやって、変えたいフェイスを選び出し
て、標準のカスタマイズインターフェースを使って変更する事ができます。

@node Compilation
@section コンパイル
@cindex compilation
@cindex byte-compilation

@findex gnus-compile

あの行書法仕様指定変数を覚えています
か? @code{gnus-summary-line-format}, @code{gnus-group-line-format} など
などです。通常 T-gnus はこれらの変数をバイトコンパイルして使うので、速度
低下は最小限に食い止められます。しか
し @code{gnus-compile-user-specs} を @code{nil} (初期値は @code{t}) にし
た場合は、不運な事にそれらを変更すると大変重大な速度低下を引き起こす事に
なります。(これらの変数の初期値はそれらに関連付けられたバイトコンパイル
された関数を持っていますが、利用者作成のものはもちろんそうではありません。)

これを改善するために、変数を弄りまわして、(なんとなく) 満足したと感じた
後で、@kbd{M-x gnus-compile} を実行する事ができます。これは新しい指定が
バイトコンパイルされ、もう一度最高速度に復帰できるという事です。ただ
し T-gnus はこれらのバイトコンパイルされた指定をファイ
ル @file{.newsrc.eld} に保存しません。

@table @code
@item gnus-compile-user-specs
@vindex gnus-compile-user-specs
この値を @code{nil} 以外にしておくと、利用者が作成した行書法仕様変数を自
動的にコンパイルします。初期値は @code{t} で、
@code{gnus-*-line-format-spec} の各内部変数の値に影響します。
@end table

@node Mode Lines
@section モード行
@cindex mode lines

@vindex gnus-update-mode-lines
@code{gnus-updated-mode-lines} はどのバッファがそのモード行を常に最新の
ものにしておくかを指定します。それはシンボルのリストです。使う事のできる
シンボル
は @code{group}, @code{article}, @code{summary}, @code{server}, @code{browse}, @code{tree} な
どです。もし対応するシンボルが存在すると、gnus は該当するであろう情報で
モード行を更新します。この変数が @code{nil} であるなら、画面の再描画はもっ
と速いでしょう。

@cindex display-time

@vindex gnus-mode-non-string-length
初期設定では、gnus は概略バッファと記事バッファのモード行に現在の記事の
情報を表示します。Gnus が表示したい情報 (例えば、記事の表題) はしばしば
モード行よりも長いことがあるので、どこかで切り落とされなければなりません。
変数 @code{gnus-mode-non-string-length} はその行の他の要素 (すなわち、情
報でない部分) がどのくらいの長さであるかを指定します。もしモード行に追加
の要素を入れたなら、この変数を修正する必要があります:

@c Hook written by Francesco Potorti` <pot@cnuce.cnr.it>
@lisp
(add-hook 'display-time-hook
          (lambda () (setq gnus-mode-non-string-length
                           (+ 21
                              (if line-number-mode 5 0)
                              (if column-number-mode 4 0)
                              (length display-time-string)))))
@end lisp

もしこの変数が @code{nil} であるなら (これが初期値ですが)、モード行は切
り落とされず、詰め込みもされません。初期設定は、バッファの完全なパーセン
ト表示さえもモード行から追いやられる可能性もありますので、おそらく望まし
い設定ではないという事に注意して下さい。利用者が自分の設定に合うようにこ
の変数を適切に設定しなければなりません。

@node Highlighting and Menus
@section ハイライトとメニュー
@cindex visual
@cindex highlighting
@cindex menus

@vindex gnus-visual
変数 @code{gnus-visual} はたいていの gnus を素敵にする部分の操作をします。
@code{nil} であると、gnus はメニューを作ったり、素敵な色やフォントを使っ
たりしようとしません。これはファイル @file{gnus-vis.el} を読み込む事も禁
止します。

この変数は使用可能な視覚的プロパティのリストである事ができます。以下の要
素は有効で、初期設定ですべて含まれています:

@table @code
@item group-highlight
グループバッファでハイライトをします。
@item summary-highlight
概略バッファでハイライトをします。
@item article-highlight
記事バッファでハイライトをします。
@item highlight
全てのバッファでハイライトをするようにします。
@item group-menu
グループバッファでメニューを作成します。
@item summary-menu
概略バッファでメニューを作成します。
@item article-menu
記事バッファでメニューを作成します。
@item browse-menu
ブラウズバッファでメニューを作成します。
@item server-menu
サーバーバッファでメニューを作成します。
@item score-menu
スコアバッファでメニューを作成します。
@item menu
全てのバッファでメニューを作成します。
@end table

ですから、記事バッファだけをハイライトしたく、全てのバッファでメニューを
作りたい場合は、このようにする事ができます:

@lisp
(setq gnus-visual '(article-highlight menu))
@end lisp

もしハイライトだけで、メニューの類は欲しくないときは、次のようにできます:

@lisp
(setq gnus-visual '(highlight))
@end lisp

@code{gnus-visual} が @code{t} であると、ハイライトとメニューは全て
の gnus のバッファで使用されます。

他の全てのバッファの外見に影響する総合的な変数は:

@table @code
@item gnus-mouse-face
@vindex gnus-mouse-face
これは gnus でマウスのハイライトに使われるフェイス (すなわち、フォン
ト) です。@code{gnus-visual} が @code{nil} であると、マウスハイライトは
なされません。
@end table

全く違ったメニューを作成するために関連するフックがあります:

@table @code
@item gnus-article-menu-hook
@vindex gnus-article-menu-hook
記事モード (article mode) メニューを作成した後に呼ばれるフックです。

@item gnus-group-menu-hook
@vindex gnus-group-menu-hook
グループモード (group mode) メニューを作成した後に呼ばれるフックです。

@item gnus-summary-menu-hook
@vindex gnus-summary-menu-hook
概略モード (summary mode) メニューを作成した後に呼ばれるフックです。

@item gnus-server-menu-hook
@vindex gnus-server-menu-hook
サーバーモード (server mode) メニューを作成した後に呼ばれるフックです。

@item gnus-browse-menu-hook
@vindex gnus-browse-menu-hook
概観モード (browse mode) メニューを作成した後に呼ばれるフックです。

@item gnus-score-menu-hook
@vindex gnus-score-menu-hook
スコアモード (score mode) メニューを作成した後に呼ばれるフックです。
@end table

@node Buttons
@section ボタン
@cindex buttons
@cindex mouse
@cindex click

最近では、最新流行のマウス @dfn{mouse} 装置が、ちゃんとした操作法を学び
たがらないナウなヤングの間で大人気です。それでは、私が Tops 20 システム
上で Emacs を使っていた頃の '89 年の夏を思い起こしてみましょう。300 人の
利用者が、一つのマシン上で、みんなが Simula コンパイラを走らせていました。
ああ、ばかばかしい!

ほんとにそうだね。

@vindex gnus-carpal
まずですね、@code{gnus-carpal} を @code{t} に設定することによって、クリッ
クするだけで何でもできるボタンだらけのバッファを gnus に表示させることが
できます。とっても簡単です、ほんとに。指圧療法の先生に教えてあげて。(訳
注: carpal とは手首の骨のこと)

@table @code
@item gnus-carpal-mode-hook
@vindex gnus-carpal-mode-hook
全ての手首モードバッファで実行するフック。

@item gnus-carpal-button-face
@vindex gnus-carpal-button-face
ボタンに使われるフェイス。

@item gnus-carpal-header-face
@vindex gnus-carpal-header-face
手首バッファのヘッダーで使用されるフェイス。

@item gnus-carpal-group-buffer-buttons
@vindex gnus-carpal-group-buffer-buttons
グループバッファのボタン。

@item gnus-carpal-summary-buffer-buttons
@vindex gnus-carpal-summary-buffer-buttons
概略バッファのボタン。

@item gnus-carpal-server-buffer-buttons
@vindex gnus-carpal-server-buffer-buttons
サーバーバッファのボタン。

@item gnus-carpal-browse-buffer-buttons
@vindex gnus-carpal-browse-buffer-buttons
閲覧バッファのボタン。
@end table

全ての @code{buttons} 変数はリストです。このリストの要素は、
@code{car} が表示される文で @code{cdr} が関数シンボルの cons セルか、も
しくはただの文字列のどちらかです。

@node Daemons
@section デーモン
@cindex demons
@cindex daemons

Gnus、それは(言い伝えによれば)かつて書かれたいかなるプログラムよりも大き
く、あなたがやって欲しいと思うさまざまな奇妙なことを、あなたのいないとこ
ろで行ってくれるものです。例えば、あなたは時たま新着メールをチェックして
もらいたくなるかも知れません。あるいは Emacs をしばらく放っておいたとき
全てのサーバの接続を切断してもらいたくなるかもしれません。他にも何かそう
いったことです。

Gnus はさまざまな制御子 @dfn{handlers} を定義することによってそのような
ことを可能にします。各制御子は三つの要素から成ります。
@var{関数}, @var{時間}, @var{空転} パラメータです。

以下は Emacs が何もしない空転状態が三十分続いたときに接続を切断する制御
子の例です。

@lisp
(gnus-demon-close-connections nil 30)
@end lisp

以下は Emacs が何もしていないとき、一時間毎に PGP ヘッダーを走査する制御
子です。

@lisp
(gnus-demon-scan-pgp 60 t)
@end lisp

この @var{時間} パラメータとそして @var{空転} パラメータは、奇妙でかつ素
晴らしい方法で一緒に動作します。基本的には、@var{空転} が @code{nil} の
時にはこの関数は @var{時間} 分毎に呼び出されます。

もし @var{空転} が @code{t} であれば、この関数は Emacs が何もしていない
時に限り、@var{時間} 分後に呼び出されます。一旦 Emacs がずっと空転状態に
なった後は、この関数は @var{時間} 分毎に呼び出されます。

@var{空転} が数で @var{時間} も数である場合、この関数は、Emacs の空転状
態が @var{空転} 分続いた時に限り、@var{時間} 分毎に呼び出されます。

@var{空転} が数で @var{時間} が @code{nil} の場合、この関数は、Emacs の
空転状態が @var{空転} 分続く度に一度呼び出されます。

そして @var{時間} が文字列の場合は、@samp{07:31} のような形式でなければ
ならず、この関数は毎日その頃の時間になると一度呼び出されます。もちろん、
@var{空転} パラメータで動作が変わります。

@vindex gnus-demon-timestep
(ここで ``分'' と言ったとき、それは実際に
は @code{gnus-demon-timestep} 秒のことです。これは初期設定では 60 です。
もしこの変数を変更すると、全ての制御子の計時に影響を与えます。)

というわけで、制御子を追加したければ、@file{.gnus} ファイルに、以下のよ
うなものを書くことができます。

@findex gnus-demon-add-handler
@lisp
(gnus-demon-add-handler 'gnus-demon-close-connections 30 t)
@end lisp

@findex gnus-demon-add-nocem
@findex gnus-demon-add-scanmail
@findex gnus-demon-add-rescan
@findex gnus-demon-add-scan-timestamps
@findex gnus-demon-add-disconnection
このための既製関数がいくつか作成されています。
@code{gnus-demon-add-nocem}, @code{gnus-demon-add-disconnection}, @code{gnus-demon-add-nntp-close-connection}, @code{gnus-demon-add-scan-timestamps}, @code{gnus-demon-add-rescan}, @code{gnus-demon-add-scanmail} で
す。これらの能力が欲しければ、単にこれらの関数を @file{.gnus} に入れてく
ださい。

@findex gnus-demon-init
@findex gnus-demon-cancel
@vindex gnus-demon-handlers
もし @code{gnus-demon-handlers} で制御子を直接追加した場合には、それを効
かせるために @code{gnus-demon-init} を実行してください。全てのデーモンを
取り消すには、@code{gnus-demon-cancel} 関数を使うことができます。

デーモンの追加は、やりすぎるのはとってもお行儀のよくないことです。全ての
サーバーから全てのニュースとメールを二秒毎に調べまわす関数を付け加えちゃっ
たりすると、どんな立派なシステムでも間違いなくお払い箱にしてしまいます。
そう動くんだもん。

@node NoCeM
@section NoCeM
@cindex nocem
@cindex spam

スパム @dfn{Spam} とは、同じ記事を何回も何回も何回も投稿することです。ス
パムは悪いことです。スパムは凶悪です。

スパムは通常一日かそこらで、さまざまな反スパム機関から取り消しされます。
これらの機関は通常一緒に、@dfn{NoCeM} メッセージも送信します。
@dfn{NoCeM} は ``no see-'em'' (彼らを見たくない)と発音され、意味はその名
前の通りです --- このメッセージは、罪を犯している記事を、つまり、消して
しまいます。

どうせその記事が取り消しされてしまうのなら、これら NoCeM メッセージは何
に使われるのでしょう? あるサイトでは取り消しメッセージを引き受けず、ある
サイトでは特定の数人からの取り消しメッセージのみしか引き受けません。それ
で、あなたは NoCeM メッセージを使いたくなるかもしれないわけです。これら
は @samp{alt.nocem.misc} ニュースグループで配布されています。

Gnus はこのグループのメッセージを自動的に読み、解釈することができ、これ
でスパムを消し去ります。

もちろん、これらをカスタマイズするための変数がいくつかあります。

@table @code
@item gnus-use-nocem
@vindex gnus-use-nocem
この変数を @code{t} に設定することで活動を開始させます。初期設定で
は @code{nil} です。

@item gnus-nocem-groups
@vindex gnus-nocem-groups
Gnus はこのグループリストから NoCeM メッセージを探します。初期設定値
は @code{("news.lists.filters" "news.admin.net-abuse.bulletins" "alt.nocem.misc" "news.admin.net-abuse.announce")} で
す。

@item gnus-nocem-issuers
@vindex gnus-nocem-issuers
NoCeM メッセージを発行する人はたくさんいます。このリストでは、誰の言うこ
とに従いたいかを指定します。初期設定値は @code{(("Automoose-1"
"clewis@@ferret.ocunix.on.ca" "cosmo.roadkill" "SpamHippo"
"hweede@@snafu.de")} です。彼らはみんな、立派で高潔な市民です。

このリストに含められる有名な反スパム家たち
は @uref{http://www.xs4all.nl/~rosalind/nocemreg/nocemreg.html} に載って
います。

これら全ての人々の NoCeM メッセージに留意する必要はありません --- 言うこ
とを聞きたい人だけでいいんです。またその人からの NoCeMメッセージ全てを受
け入れる必要もありません。NoCeM メッセージにはそれぞれ種別 @dfn{type} ヘッ
ダーがついており、これはそのメッセージの厳密な定義を与えています(多少は
厳密な、程度ね。たいていは少だけど)。良く使われる種別には、
@samp{spam}, @samp{spew}, @samp{mmf}, @samp{binary}, @samp{troll} があり
ます。これを指定するには、リストの中で @code{(@var{発行者} @var{条
件} @dots{})} 要素を使う必要があります。各条件は文字列 (使いたい種別にマッ
チする正規表現) か、または @code{(not @var{文字列})} という形式のリスト
です。この場合は @var{文字列} は使いたくない種別にマッチする正規表現です

例えば、Chris Lewis からの NoCeM メッセージで、@samp{troll} メッセージ以
外の全てを欲しい場合には、

@lisp
("clewis@@ferret.ocunix.on.ca" ".*" (not "troll"))
@end lisp

一方、彼の @samp{spam} と @samp{spew} メッセージ以外は何もしたくなければ、
以下のようにできます。

@lisp
("clewis@@ferret.ocunix.on.ca" (not ".*") "spew" "spam")
@end lisp

この指定は左から右に適用されます。

@item gnus-nocem-verifyer
@vindex gnus-nocem-verifyer
@findex mc-verify
これは NoCeM 発行者が誰であるかと言っているかを証明する関数でなくてはな
りません。初期設定では @code{mc-verify} であり、これは Mailcrypt 関数で
す。もしこれが非常に遅くて、あなたが証明結果を気にしない (これはたぶん危
険です) のであれば、この変数を @code{nil} にすることができます。

もし署名済みの NoCeM メッセージを証明済み、未署名のメッセージを未証
明 (でもそれを使う) としたいのなら、以下のようにすることができます。

@lisp
(setq gnus-nocem-verifyer 'my-gnus-mc-verify)

(defun my-gnus-mc-verify ()
  (not (eq 'forged
           (ignore-errors
             (if (mc-verify)
                 t
               'forged)))))
@end lisp

まあ、これはたぶん危険でしょうけどね。

@item gnus-nocem-directory
@vindex gnus-nocem-directory
これは gnus が NoCeM キャッシュファイルを保存する場所です。初期設定値
は @file{~/News/NoCeM/} です。

@item gnus-nocem-expiry-wait
@vindex gnus-nocem-expiry-wait
古い NoCeM 項目をキャッシュから消すまでの日数。初期設定値は 15 です。こ
れを短くするほど gnus は速くなりますが、古いスパムを見ることになってしま
うかもしれません。

@item gnus-nocem-check-from
@vindex gnus-nocem-check-from
非@code{nil} では、記事のボディにある発行人の正当性を調べます。そうでな
い場合は、著者が正しい発行人でなくても気にせずに記事を取り込みますが、も
しあなたが正しい発行人を見分けられるならば、そうした方がとても速くなるで
しょう。

@item gnus-nocem-check-article-limit
@vindex gnus-nocem-check-article-limit
非@code{nil} で、全ての NoCeM グループにおけるチェックする記事の最大数を
指定します。NoCeM グループは巨大になることがあり、そうなると処理がとても
遅くなります。
@end table

NoCeM を使うと、もしかするとメモリ喰いになるかもしれません。あなたがたく
さんの生きたグループ (つまり購読あるいは非購読グループ) を持っているのな
ら、Emacs プロセスは大きくなってしまうでしょう。もしこれが問題であれば、
非購読のグループを全部 (あるいはその多くを) 消し去ってしまった方が良いで
す (@pxref{Subscription Commands})。

@node Undo
@section やり直し
@cindex undo

実行したことのやり直しができると、とても便利です。普通の Emacs バッファ
では、これは十分簡単です --- 単に @code{undo} ボタンを押すだけです。しか
し gnus のバッファでは、これは簡単ではありません。

Gnus がバッファー内に表示しているものは、gnus にとっては全く何の価値もあ
りません --- これはみんな、利用者に奇麗に見えるようにデザインされている
ただのデータなのです。@kbd{C-k} でグループバッファからグループを消去する
のは、その行は消え去りますが、それは実際の動作 --- 問題のグループ
を gnus の内部構造体から削除すること、の単なる副作用でしかありません。こ
れらのやり直しは、通常の Emacs の @code{undo} 関数では行なうことができま
せん。

Gnus は、利用者が何をするかを憶えておき、その利用者の動作の逆を行なう動
作を提供することによって、これを何とか救済しようとします。そして利用者
が @code{undo} キーを押したとき、gnus はその一つ手前の動作あるいは動作群
の逆のコードを実行します。しかし、全ての動作が簡単に可逆であるわけではな
いので、gnus は現在、やり直し可能なキー関数は僅かしか提供していません。
これらは、グループの削除、グループの貼り付け、グループの既読記事のリスト
の変更、それだけなんです。将来はもっと関数が追加されるかもしれませんが、
関数の追加はそれぞれ保存するべきデータを増やすことになるので、gnus は決
して完全やり直し可能にはならないでしょう。

@findex gnus-undo-mode
@vindex gnus-use-undo
@findex gnus-undo
やり直し機能は @code{gnus-undo-mode} マイナーモードによって提供されます。
これは @code{gnus-use-undo} が @code{nil} 以外であれば使用され、これが初
期設定です。@kbd{C-M-_} キーが @code{gnus-undo} 命令を実行します。これは
通常の Emacs の @code{undo} 命令にちょっとだけ似ていると思われるでしょう。

@node Predicate Specifiers
@section 述語の設定
@cindex predicate specifiers

いくつかの gnus の変数
は @dfn{述語指示子} (@dfn{predicate specifiers}) です。これは述語の仕様
に融通を効かせることができる特別な形式です。

これらの指示子は関数によるリスト、シンボルまたはリストです。

これは例です:

@lisp
(or gnus-article-unseen-p
    gnus-article-unread-p)
@end lisp

利用できるシンボルは @code{or}、@code{and} および @code{not} です。関数
はすべて一つのパラメータを受け取ります。

@findex gnus-make-predicate
内部的に、gnus は呼ぶことができる関数を作るために、これらの指示子につい
て @code{gnus-make-predicate} を使います。この関数へのこの入力パラメータ
は、述語指示子のすべての関数に渡されます。

@node Moderation
@section 司会役
@cindex moderation

もしあなたが司会者 (モデレーター) ならば、@file{gnus-mdrtn.el} パッケー
ジを使うことができます。これは標準 gnus パッケージには含まれません。
@samp{larsi@@gnus.org} に、どのグループの司会を行なうのかを述べたメール
を書いてください。そうすればコピーを手に入れられます。

司会者用パッケージは概略バッファのマイナーモードとして実装されています。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-moderate)
@end lisp

をあなたの @file{.gnus.el} ファイルに入れてください。

あなたが @samp{rec.zoofle} の司会者だとすると、これは以下のように動作す
るようになっています。

@enumerate
@item
@samp{Newsgroups:.*rec.zoofle} にマッチする受信メールを分離します。これ
は投稿されようとしている記事を全てあるメールグループ --- 例え
ば @samp{nnml:rec.zoofle} に入れます。

@item
あなたは時折このグループに入り、@kbd{e} (edit-and-post) あるい
は @kbd{s} (just send unedited) 命令を使って記事を投稿します。

@item
@samp{rec.zoofle} ニュースグループを読んでいる途中で、もしあなたが承認し
ていない記事をたまたま見つけたとしたら、@kbd{c} 命令で取り消しできます。
@end enumerate

二つのグループで司会者モードを使うとすれば、こうなります。

@lisp
(setq gnus-moderated-list
      "^nnml:rec.zoofle$\\|^rec.zoofle$")
@end lisp

@node Image Enhancements
@section 画像の拡張

XEmacs、それに Emacs 21 は絵やその他のものを表示することができるので、
gnus はこれを利用することにします。

@menu
* Picons::                      あなたが読んでいるものの絵を表示する方法
* Smileys::                     表示されるべく生まれた幸せそうな顔を表示
                                する方法
* X-Face::                      ファンキーなちっちゃな白黒の絵を表示する
* Toolbar::                     クリック猿
* XVarious::                    その他の XEmacs で Gnus な変数
@end menu

@node Picons
@subsection Picons

@iftex
@iflatex
\include{picons}
@end iflatex
@end iftex

それで…、あなたはこのニュースリーダーをさらにもっと遅くしたいってわけだ
ね! これはそうするのにぴったりな方法です。さらにこれは、あなたがニュース
を読んでいるんだということを、あなたの肩越しに見つめている人に印象づける
ための素晴らしい方法でもあります。

@menu
* Picon Basics::                picon とは何で、どうやって手に入れるのか
* Picon Requirements::          XEmacs を使ってなければここからは読まな
                                いで
* Easy Picons::                 picon の表示 --- 楽な方法
* Hard Picons::                 本来すべきこと。何かを学ぶことができるだ
                                ろう
* Picon Useless Configuration::  その他のぶっ壊したりひねったりいじった
                                り遊んだりする変数
@end menu

@node Picon Basics
@subsubsection Picon の基礎

Picon とはなんでしょう? Picons ウェブサイトから直接引用しましょう。

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex

@quotation
@dfn{Picon} とは、``個人アイコン (personal icons)'' の略です。これは、ネッ
ト上の利用者やドメインを表現するのに使われるための小さな画像で、データベー
スを持たせて、ある電子メールアドレスがあったら、それに適切な画像を見つけ
られるようにしておくものです。利用者とドメイン以外にも、Usenet ニュース
グループや天気予報のためのpicon データベースがあります。picon は白黒
の @code{XBM} 形式でもカラーの @code{XPM} 形式でも @code{GIF} 形式でも構
いません。
@end quotation

@vindex gnus-picons-piconsearch-url
あなたがインターネットへ常時接続しているのならば、
@code{gnus-picons-piconsearch-url} に文字
列 @uref{http://www.cs.indiana.edu/picons/search.html} を設定することで、
Steve Kinzler の picon 検索エンジンを使うことができます。

@vindex gnus-picons-database
そうでなければ、彼のデータベースを手元に複製する必要があります。picon デー
タベースの入手とインストールの手順は、ウェブブラウザー
で @uref{http://www.cs.indiana.edu/picons/ftp/index.html} に行ってみてく
ださい。Gnus は picons が @code{gnus-picons-database} で示される場所にイ
ンストールしてあるものと期待します。

もしあなたが Debian GNU/Linux を使っているのなら、@samp{apt-get install
picons.*} と言えば gnus が見つけることができる picon がインストールされ
ます。

@node Picon Requirements
@subsubsection Picon の動作条件

Gnus に picon を表示させるには @code{x} サポート付きで XEmacs をコンパイ
ルしていなくてはなりません。白黒よりももっと奇麗な色付きの picon を表示
するためには、@code{xpm} か @code{gif} のどちらかが使えるようにコンパイ
ルされた XEmacs である必要もあります。

@vindex gnus-picons-convert-x-face
@code{X-Face} ヘッダーの顔を表示したいのなら、XEmacs を @code{xface} サ
ポート付きでコンパイルしなければなりません。そうでなければ、
@code{netpbm} ユーティリティをインストールしておくか、あるいは他の何かを
使うように @code{gnus-picons-convert-x-face} 変数をいじくってください。
(注: 変数/関数名には @code{xface} ではなく @code{x-face} が使われます。)

@node Easy Picons
@subsubsection 楽々 Picons

picon 表示を有効にするには、単に以下の行を @file{~/.gnus} ファイルに入れ
て、gnus を起動してください。

@lisp
(setq gnus-use-picons t)
(setq gnus-treat-display-picons t)
@end lisp

@code{gnus-picons-database} が picon データベースが含まれているディレク
トリを指していることを確認してください。

その代わりに Web 上の picon 検索エンジンを使いたければ、これを追加します。

@lisp
(setq gnus-picons-piconsearch-url
      "http://www.cs.indiana.edu:800/piconsearch")
@end lisp

@node Hard Picons
@subsubsection 難解 Picons

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex

Gnus は、グループや記事に入ったり出たりするのに従って picon を表示するこ
とができます。Gnus は picon データベースの三つの章とどう相互作用すればよ
いかを知っています。すなわち、gnus はニュースグループの絵、著者の顔の絵、
著者のドメインの picon を表示することができます。この機能を有効にするに
は、picon をどこから持ってくるか、そしてどこに表示するかを選択する必要が
あります。

@table @code
@item gnus-picons-database
@vindex gnus-picons-database
picon データベースの場所。@file{news}, @file{domains}, @file{users} (な
どなど) のサブディレクトリーが含まれているディレクトリーを指していなけれ
ばなりません。これは @code{gnus-picons-piconsearch-url} が @code{nil} で
あるときのみ使用されます。初期設定値は @file{/usr/local/faces/} です。

@item gnus-picons-piconsearch-url
@vindex gnus-picons-piconsearch-url
Web 上の picon 検索エンジンの URL。現在知られている唯一のエンジン
は @uref{http://www.cs.indiana.edu:800/piconsearch} です。ネットワーク遅
延を回避するために icon はバックグラウンドで取得されます。もしこれが
@code{nil} (初期設定値) であれば、
picon は @code{gnus-picons-database} で示されるローカルのデータベースか
ら取得されます。

@item gnus-picons-display-where
@vindex gnus-picons-display-where
picon 画像が表示される場所。これは初期設定では @code{picons} です (これ
は初期設定で @samp{*Picons*} バッファに位置します)。他の有効な場所として
は @code{article}, @code{summary} あるいは @samp{*scratch*} だろうと知っ
たことではありません。ただそのバッファを標準の gnus 窓配置処
理 --- @pxref{Window Layout} によって見えるようにしておくことを確認して
ください。

@item gnus-picons-group-excluded-groups
@vindex gnus-picons-group-excluded-groups
この正規表現にマッチするグループではそのグループアイコンを表示させません。
@end table

注意: もし @code{gnus-use-picons} を @code{t} に設定すると、窓配置
に @code{picons} バッファを含めるように設定されます。

さて、これらを決定した後には、これらの絵が正しい時に表示されるように、以
下の関数を適切なフックに追加する必要があります。

@vindex gnus-picons-display-where

@table @code
@item gnus-article-display-picons
@findex gnus-article-display-picons
著者と著者のドメインの picon を探し、@code{gnus-picons-display-where} バッ
ファに表示します。

@item gnus-picons-article-display-x-face
@findex gnus-picons-article-display-x-face
X-Face ヘッダーがあればそれを復号化し表示します。(注: 変数/関数名に
は @code{xface} ではなく @code{x-face} が使われます。)
@end table

@node Picon Useless Configuration
@subsubsection 無意味な Picon 設定

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex

以下の変数は、さらにこれらをどう実行するか、どこに配置するか、その他役に
も立たないどうでもよいことを制御できるようにします。

@table @code
@item gnus-picons-news-directories
@vindex gnus-picons-news-directories
@code{gnus-picons-database} からニュースグループフェイスを探すためのサブ
ディレクトリーのリスト。@code{("news")} が初期設定値です。

@item gnus-picons-user-directories
@vindex gnus-picons-user-directories
@code{gnus-picons-database} から利用者フェイスを探すためのサブディレクト
リーのリスト。@code{("local" "users" "usenix" "misc")} が初期設定値です。

@item gnus-picons-domain-directories
@vindex gnus-picons-domain-directories
@code{gnus-picons-database} からドメイン名フェイスを探すためのサブディレ
クトリーのリスト。初期設定値は @code{("domains")} です。このリスト
に @samp{"unknown"} を追加しておきたくなる人もいるでしょう。

@item gnus-picons-convert-x-face
@vindex gnus-picons-convert-x-face
もし XEmacs に @code{xface} サポートが組み込まれていなければ、この命令が
@code{X-Face} ヘッダーを X ビットマップ (@code{xbm}) に変換するのに使用
されます。初期設定値
は @code{(format "@{ echo '/* Width=48, Height=48 */'; uncompface; @} | icontopbm | pbmtoxbm > %s" gnus-picons-x-face-file-name)} で
す。(注: 変数/関数名には @code{xface} ではなく @code{x-face} が使われま
す。)

@item gnus-picons-x-face-file-name
@vindex gnus-picons-x-face-file-name
@code{X-Face} ビットマップを格納しておく一時ファイルの名前。初期設定値
は @code{(format "/tmp/picon-xface.%s.xbm" (user-login-name))}。(注: 変
数/関数名には @code{xface} ではなく @code{x-face} が使われます。)

@item gnus-picons-has-modeline-p
@vindex gnus-picons-has-modeline-p
@code{gnus-picons-display-where} を @code{picons} に設定してしまうと、
XEmacs のフレームはめちゃめちゃになってしまうでしょう。これを多少なりと
も軽減するには、@code{gnus-picons-has-modeline-p} を @code{nil} に設定し
てください。これは picon バッファからモード行を取り除きます。これは
@code{gnus-picons-display-where} が @code{picons} のときのみ意味がありま
す。

@item gnus-picons-refresh-before-display
@vindex gnus-picons-refresh-before-display
nil 以外であれば、picon を計算する前に記事バッファを表示。初期設定値
は @code{nil} です。

@item gnus-picons-display-as-address
@vindex gnus-picons-display-as-address
@code{t} であれば絵と一緒に文字で電子メールアドレスを表示。初期設定値
は @code{t} です。

@item gnus-picons-file-suffixes
@vindex gnus-picons-file-suffixes
picon ファイル名として試してみる拡張子の順序リスト。初期設定値
は @code{("xpm" "gif" "xbm")} から XEmacs に組み込まれていないものを引い
たものです。

@item gnus-picons-setup-hook
@vindex gnus-picons-setup-hook
picon がもし表示されていれば、picon バッファで実行されるフックです。

@item gnus-picons-display-article-move-p
@vindex gnus-picons-display-article-move-p
picon を表示しているときにカーソル位置を最初の空行まで動かすかどうかを指
定。これは @code{gnus-picons-display-where} の値が @code{article} である
ときのみ効果があります。

@code{nil} であれば、picon を @code{From} と @code{Newsgroup} の間に表示
します。これが初期設定です。

@item gnus-picons-clear-cache-on-shutdown
@vindex gnus-picons-clear-cache-on-shutdown
Gnus を終了するときに picon キャッシュを消し去るかどうか。Gnus は実行中
に見つけた picon を全てキャッシュします。これは検索処理の時間を多少節約
できますが、メモリをいくらか食います。もしこの変数を @code{nil} に設定す
れば、gnus はそのキャッシュを決して消しません。それを消し去るには手
で @code{gnus-picons-clear-cache} を呼び出す必要があります。
@code{nil} でなければキャッシュは gnus が終了するたびに消去されます。初
期設定値は @code{t} です。

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex
@end table

@node Smileys
@subsection スマイリー
@cindex smileys

@iftex
@iflatex
\gnusfig{-3cm}{0.5cm}{\epsfig{figure=ps/BigFace,height=20cm}}
\input{smiley}
@end iflatex
@end iftex

スマイリー @dfn{smiley} は gnus とは別のパッケージですが、スマイリーを使っ
ているパッケージは現在 gnus だけですので、ここで説明します。

一言で言えば --- gnus でスマイリーを使うには、以下を @file{.gnus.el} ファ
イルに書いてください。

@lisp
(setq gnus-treat-display-smileys t)
@end lisp

スマイリーは、文字の顔マーク --- @samp{:-)}, @samp{:-=}, @samp{:-(} など
といったもの --- を絵に対応させ、文字の顔マークの代わりにその絵を表示し
ます。この変換は文字にマッチする正規表現とそれのファイル名への対応のリス
トで制御されます。

@vindex smiley-nosey-regexp-alist
@vindex smiley-deformed-regexp-alist
スマイリーは初期設定では二つの変換連想リストの例を提供しています。
@code{smiley-deformed-regexp-alist} (@samp{:)}, @samp{:(} などにマッチ
する) と、@code{smiley-nosey-regexp-alist} (@samp{:-)}, @samp{:-(} など
にマッチする) です。

使用される連想リストは @code{smiley-regexp-alist} 変数で指定されます。こ
の初期設定値は @code{smiley-deformed-regexp-alist} です。

各要素の最初の項目はマッチさせたい正規表現で、二番目の要素は絵で置き換え
たいグループにマッチする正規表現、そして三番目の要素は表示させたいファイ
ルの名前です。

以下の変数は、スマイリーがこれらのファイルを探す場所、あるいはどの色を使
うかと、その他のものをカスタマイズします。

@table @code
@item smiley-data-directory
@vindex smiley-data-directory
スマイリーが顔ファイルを探す場所。

@item smiley-flesh-color
@vindex smiley-flesh-color
肌の色。初期設定値は、人種差別的だけど @samp{yellow} です。

@item smiley-features-color
@vindex smiley-features-color
フェイスの機能の色。初期設定値は @samp{black} です。

@item smiley-tongue-color
@vindex smiley-tongue-color
舌の色。初期設定値は @samp{red} です。

@item smiley-circle-color
@vindex smiley-circle-color
顔の周りの丸の色。初期設定値は @samp{black} です。

@item smiley-mouse-face
@vindex smiley-mouse-face
マウスで強調表示したときの顔。
@end table

@node X-Face
@subsection X-Face
@cindex x-face

@code{X-Face} ヘッダーは、メッセージの著者を表わすことになっている 48×
48 画素の白黒 (1 bit の深さ) の絵を描きます。これは進化し続けるあまたの
メールとニュースリーダーによってサポートされるでしょう。

@cindex x-face
@findex gnus-article-display-x-face
@findex gnus-article-x-face-command
@vindex gnus-article-x-face-command
@vindex gnus-article-x-face-too-ugly
@iftex
@iflatex
\include{xface}
@end iflatex
@end iftex
@c @anchor{X-Face}

@code{X-Face} ヘッダーの復号には、Emacs が @samp{compface} をサポー
ト (XEmacs のほとんどがサポート) しているか、あなたのシステム
に @samp{compface} がインストールされている必要があります。もしどちらか
が真ならば、gnus はディフォルトで @code{X-Face} ヘッダーを表示します。

これを制御するのは変数 @code{gnus-article-x-face-command} です。この変数
が文字列ならば、この文字列がサブシェルで実行されます。関数ならば、この関
数が顔を引数として呼ばれます。も
し @code{gnus-article-x-face-too-ugly} (これは正規表現で
す) が @code{From} 欄に合致すれば、顔は表示されません。

Emacs 20 でのディフォルトの動作は @code{display} プログラ
ム @footnote{@code{display} は ImageMagick パッケージに含まれています。
@code{uncompface} と @code{icontopbm} の両プログラムについては、
`compface' や GNU/Linux システムにおける `faces-xface' のようなパッケー
ジを探して下さい。} をフォークして見ようとします。

XEmacs か静止画をサポートしている Emacs 21+ でのディフォルトの動作
は @code{From} 欄の前に顔を表示することです。(XEmacs が X-Face 機能付き
でコンパイルされていると良いでしょう――それは表示を少し早くします。もし
根本的 X-Face 機能がないのであれば、gnus は @code{pbmplus} やその仲間の
外部プログラムを使って @code{X-Face} 欄を変換しようと試みます @footnote{
GNU/Linux システムでは @code{netpbm}、@code{libgr-progs} また
は @code{compface} のような名前のパッケージを探して下さい。}。)

(注: 変数/関数名には @code{xface} ではなく @code{x-face} が使われます。)

gnus は、外に出すメッセージに X-Face ヘッダーを簡単に挿入するための、便
利な関数と変数を少しばかり提供します。

@findex gnus-random-x-face
@code{gnus-random-x-face} は @code{gnus-x-face-directory} にあるすべて
の @samp{pbm} をくまなく探してランダムに一つを選び取り、シェルコマン
ド @code{gnus-convert-pbm-to-x-face-command} を使ってそれを X-Face の形
式に変換します。@samp{pbm} ファイルは 48×48 画素の大きさでなければなり
ません。

@code{gnus-x-face-from-file} はパラメータとしてファイルを受け取り、シェ
ルコマンド @code{gnus-convert-image-to-x-face-command} を使ってそのファ
イルを X-Face の形式に変換します。

前者は一般的に使うであろう関数です。以下のようなもの
を @file{.gnus.el} ファイルに書いて下さい:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(X-Face . gnus-random-x-face))))
@end lisp

後者の関数を使うのは、このようになるでしょう:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(X-Face . (lambda ()
                                (gnus-x-face-from-file
                                 "~/My-face.gif"))))))
@end lisp

@node Toolbar
@subsection ツールバー

@table @code
@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex

@item gnus-use-toolbar
@vindex gnus-use-toolbar
@code{nil} ならばツールバーを表示しない。@code{nil} 以外の場合は、
@code{default-toolbar}, @code{top-toolbar}, @code{bottom-toolbar}, @code{right-toolbar}, @code{left-toolbar} の
どれかでなくてはなりません。

@item gnus-group-toolbar
@vindex gnus-group-toolbar
グループバッファ内のツールバー。

@item gnus-summary-toolbar
@vindex gnus-summary-toolbar
概略バッファ内のツールバー。

@item gnus-summary-mail-toolbar
@vindex gnus-summary-mail-toolbar
メールグループの概略バッファ内のツールバー。
@end table

@node XVarious
@subsection さまざまな XEmacs 変数

@table @code
@item gnus-xmas-glyph-directory
@vindex gnus-xmas-glyph-directory
これは gnus が絵を探す場所です。Gnus は通常このディレクトリを自動検出し
ますが、もし標準的でないディレクトリー構造を持っている場合は、これを手動
で設定することができます。

@item gnus-xmas-logo-color-alist
@vindex gnus-xmas-logo-color-alist
これは連想リストで、キーは種別シンボル、値はタイトル頁絵文字の前面色と背
景色です。

@item gnus-xmas-logo-color-style
@vindex gnus-xmas-logo-color-style
これは前記の連想リストで色を検索するのに使われるキーです。有効な値に
は @code{flame}, @code{pine}, @code{moss}, @code{irish}, @code{sky}, @code{tin}, @code{velvet}, @code{grape}, @code{labia}, @code{berry}, @code{neutral}, @code{september} が
あります。

@item gnus-xmas-modeline-glyph
@vindex gnus-xmas-modeline-glyph
全ての gnus モード行で表示される絵文字。これは初期設定ではちいさな
ヌー (gnu) の頭です。

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex
@end table

@node Fuzzy Matching
@section ファジーな一致
@cindex fuzzy matching

Gnus は、スコア付け、スレッドの形成、スレッド比較などを行うときに、
@code{Subject} 行のファジーな一致 @dfn{fuzzy matching} 方法を提供してい
ます。

正規表現一致とは違って、ファジーな一致はとってもファジーです。あまりにも
ファジーすぎて、何がファジー @dfn{fuzziness} であるかという定義さえあり
ませんし、実装も何度も変更されています。

基本的には、これは比較の前に行から邪魔物を取り除こうとします。
@samp{Re: } や挿入句の印や空白文字等々は文字列から除去され、その結果を比
較します。これはほとんどの場合妥当な結果を出します --- たとえニュースリー
ダーの仮面をかぶった文字列切り刻み機で生成された文字列が差し出されても、
です。

@node Thwarting Email Spam
@section spam メールの裏をかく
@cindex email spam
@cindex spam
@cindex UCE
@cindex unsolicited commercial email

ここ最近の USENET では、宣伝のハゲタカどもが、彼らの詐欺や製品を押し付け
るための電子メールアドレスを探そうとして、気違いのようにニュース上をうろ
ついて grep しまくっています。これに対する反動として、多くの人々
が @code{From} 行に無意味なアドレスを入れはじめるようになってしまいまし
た。これは非生産的なことだと私は思います --- あなたが書いたことに対する
返信として正当なメールを送ることを面倒にさせ、また誰が書いたものなのかを
分かりづらくします。こんな書き換えは結局は、押し付け宣伝メールそれ自身よ
りも大きな脅威となるかもしれません。

私にとっての spam メールの最大の問題は、嘘の口実で入ってくるからです。私
が @kbd{g} を押したとすると、gnus は十通の新着メールがありますと陽気に私
に教えてくれます。私は ``おおっ、わーい! 僕って幸せ!'' と言ってメールグ
ループを選択します。しかしそこには、二つのネズミ講と、七つの広
告 (``最新! 奇跡の増毛トニック、ふさふさでつやつやの髪を、あなたのつま先
まで!'') と、悔い改め神を信じよ、という一つのメールがあるだけなのです。

これは不愉快です。

@menu
* Anti-Spam Basics::            たくさんの spam を減らす簡単な方法
* SpamAssassin::                Spam 対策ツールの使い方
* Hashcash::                    CPU 時間を費やして spam 退治する
@end menu

@node Anti-Spam Basics
@subsection Spam 退治の基礎
@cindex email spam
@cindex spam
@cindex UCE
@cindex unsolicited commercial email

Spam に対処する一つの方法は、gnus に全ての spam を @samp{spam} メールグ
ループに分離させてしまうことです (@pxref{Splitting Mail})。

最初に、あなたに到達性のある正しいメールアドレスを一つ選び、それを全ての
あなたのニュース記事の @code{From} ヘッダーに入れます。(ここでは
@samp{larsi@@trym.ifi.uio.no} を選びましたが、
@samp{larsi+usenet@@ifi.uio.no} 形式のたくさんのアドレスの方が良い選択で
す。あなたのサイトの sendmail の設定がメールアドレスのローカル部としてど
んなキーワードを受け付けるかは、あなたのサイトのシステム管理者に聞いてく
ださい。)

@lisp
(setq message-default-news-headers
      "From: Lars Magne Ingebrigtsen <larsi@@trym.ifi.uio.no>\n")
@end lisp

そして @code{nnmail-split-fancy} に以下の分離規則を入れま
す (@pxref{Fancy Mail Splitting})。

@lisp
(
 ...
 (to "larsi@@trym.ifi.uio.no"
      (| ("subject" "re:.*" "misc")
         ("references" ".*@@.*" "misc")
         "spam"))
 ...
)
@end lisp

この意味は、このアドレスに届いた全てのメールをまず疑いますが、
@samp{Re:} で始まる @code{Subject} がついているか、@code{References} ヘッ
ダーがついていればおそらく OK だろう、ということです。残りは全て
@samp{spam} グループに行きます。(このアイデアはおそらく Tim Pierce 氏に
よるものです。)

これに加えて、多くのメール spam 屋は、あなたのところの @sc{smtp} サーバー
と直接話し、@code{To} ヘッダーにあなたのメールアドレスが明示されないよう
にします。なんでそんなことをするのかはわかりませんが --- おそらく私たち
の裏をかく機構の裏をかくためかな? どちらにしても、対処は簡単なことで
す --- あなた宛てでないものを全部 @samp{spam} グループにいれるだけです。
これはお好み分離規則の最後にこんな風に入れることでできます。

@lisp
(
 ...
 (to "larsi" "misc")
 "spam")
@end lisp

私の経験では、これで事実上全てが正しいグループに分類されます。まあ、それ
でもときどき @samp{spam} グループをチェックして、正しいメールがあるかチェッ
クしなくてはいけませんけどね。もしあなたは自分が良いネットワーク市民であ
ると思っているなら、それぞれの押し付け宣伝メールの関係当局に苦情を送り付
けることさえもできます --- 暇なときにでもね。

また、あなたが怠け者のネットワーク市民でもあるなら、
@file{gnus-junk.el} パッケージによって自動的に苦情をいう方が良いと思うか
もしれません。これ
は @* @uref{http://stud2.tuwien.ac.at/~e9426626/gnus-junk.html} か
ら「無料で」利用できます。ほとんどの spam メールは自動的に送られているの
で、ちょっとだけ宇宙のバランスがとれるかもしれません。

これで私のところでは動いています。これでみんなは簡単な方法で私に連絡を取
ることができ (普通に @kbd{r} を押すだけでできる)、私は spam に煩わされる
ことは全くありません。得々状態です。私の意見としては、@code{From} ヘッダー
を偽造して存在しないドメインに送らせるのはキタナイです。

@node SpamAssassin
@subsection SpamAssassin, Vipul's Razor, DCC, etc
@cindex SpamAssassin
@cindex Vipul's Razor
@cindex DCC

Spam を避けるための前項のヒントが十分だった日々は過ぎ去りました。今では
受け取ったたくさんの spam を減らすための多くの道具があります。この項は新
旧置き換えによってすぐに時代遅れになってしまうでしょうが、幸いなことにほ
とんどの道具は類似のインターフェースを持っています。この項は例とし
て SpamAssassin を使っていますが、他のほとんどの道具にも簡単に適合するは
ずです。

もしあなたが使う道具がメールサーバーにインストールされていないならば、あ
なた自身がそれを呼び出す必要があります。以下に @code{:postscript} メール
ソース指示子 (@pxref{Mail Source Specifiers}) を使う場合の考え方を示しま
す。

@lisp
(setq mail-sources
      '((file :prescript "formail -bs spamassassin < /var/mail/%u")
        (pop :user "jrl"
             :server "pophost" 
             :postscript "mv %t /tmp/foo; formail -bs spamc < /tmp/foo > %t")))
@end lisp

いったんメールを受けるスプールで、例えば spam であることを表示するヘッダー
をメールに含めるようにして、それをふるい落とす準備をします。使うのは普通
の分割方式 (@pxref{Splitting Mail}) です:

@lisp
(setq nnmail-split-methods '(("spam"  "^X-Spam-Flag: YES")
                             ...))
@end lisp

または特級分割方式 (@pxref{Fancy Mail Splitting}) です:

@lisp
(setq nnmail-split-methods 'nnmail-split-fancy
      nnmail-split-fancy '(| ("X-Spam-Flag" "YES" "spam")
                             ...))
@end lisp

いくらかの人たちは @code{:prescript} を使ってメールをいろんなプログラム
にパイプすることを嫌うかもしれません (もし何かのプログラムにバグがあった
ら、すべてのメールを失ってしまうかもしれません)。あなたがそれらの一人な
らば、別の解は分割するときに外部の道具を呼ぶことです。特級分割方式の例で
す:

@lisp
(setq nnmail-split-fancy '(| (: kevin-spamassassin)
                             ...))
(defun kevin-spamassassin ()
  (save-excursion
    (let ((buf (or (get-buffer " *nnmail incoming*")
                   (get-buffer " *nnml move*"))))
      (if (not buf)
          (progn (message "Oops, cannot find message buffer") nil)
        (set-buffer buf)
        (if (eq 1 (call-process-region (point-min) (point-max)
                                       "spamc" nil nil nil "-c"))
            "spam")))))
@end lisp

以上がこれに関することです。いくつかの spam はどうしても素通りしてしまう
ので、spam を読むはめになったときに呼ぶための気の利いた関数が欲しいでしょ
う。これがその気の利いた関数です:

@lisp
 (defun my-gnus-raze-spam ()
  "Submit SPAM to Vipul's Razor, then mark it as expirable."
  (interactive)
  (gnus-summary-show-raw-article)
  (gnus-summary-save-in-pipe "razor-report -f -d")
  (gnus-summary-mark-as-expirable 1))
@end lisp

@node Hashcash
@subsection Hashcash
@cindex hashcash

Spam と戦うための新しい技法は、メッセージを送信する際にいくばくかの負担
を送信者に強います。これはインターネット標準の一部ではないので、世界中の
すべての人がこの技法を使うことは当てにできないという明らかな欠点がありま
すが、小規模な共同体では役に立つでしょう。

前項の道具類が実際にうまく働いたとしても、それらは新しい形式の spam が現
れるたびにしょっちゅう更新かつ整備されることによってのみ動作します。この
ことは、小さなパーセンテージの spam がいつも素通りしてしまうことを意味し
ます。それはまた、どこかでだれかがそれらの道具を更新するために、たくさん
の spam を読まなければならないことをも意味します。Hashcash はそれを回避
しますが、代わりにあなたが通信するすべての人たちが、その仕組みを使ってい
ることが必要です。あなたは実用 (pragmatic) と教条 (dogmatic) の二つの取
り組みを考えることができます。それらの取り組みには利点もあれば不利な点も
ありますが、それは世の中では普通のことで、それらを連係させたものが他のば
らばらなものより強力なのです。

@cindex X-Hashcash
「いくばくかの負担」とは CPU 時間を消費することで、具体的には一定数のビッ
トまでハッシュの衝突 (hash collision) を計算することです。その結果として
の hashcash クッキーは @samp{X-Hashcash:} ヘッダーに挿入されます。もっと
詳しいこと、そしてこの機能を使うためにインストールする必要がある外部アプ
リケーションの @code{hashcash} について
は @uref{http://www.cypherspace.org/~adam/hashcash/} を参照して下さい。
さらなる情報が @uref{http://www.camram.org/} で見つかるでしょう。

送信するメッセージのそれぞれについて hashcash を呼ぼうと思うなら、こんな
ふうにして下さい:

@lisp
(require 'hashcash)
(add-hook 'message-send-hook 'mail-add-payment)
@end lisp

@code{hashcash.el} ライブラリ
は @uref{http://users.actrix.gen.nz/mycroft/hashcash.el} か開発版
の gnus の contrib ディレクトリにあります。

いくつかの追加の変数の設定もしなければなりません:

@table @code
@item hashcash-default-payment
@vindex hashcash-default-payment
この変数はハッシュの衝突を成すディフォルトのビット数を示します。規定値
は 0 で、何も行なわれないことを意味します。提案されている有効な値
は 17 から 29 までの数です。

@item hashcash-payment-alist
@vindex hashcash-payment-alist
何人かの受取人は、あなたにディフォルトより多くの CPU 時間を費やすことを
要求するかもしれません。この変数は @samp{(ADDR AMOUNT)} の形式の要素のリ
ストで、ADDR は受取人 (メールアドレスかニュースグループ)、AMOUNT は必要
とされる衝突のビット数です。これはまた @samp{(ADDR STRING AMOUNT)} の要
素を持つことも可能で、STRING は文字列 (通常はメールアドレスかニュースグ
ループ名) として使われます。

@item hashcash
@vindex hashcash
@code{hashcash} バイナリがインストールされている場所を示します。
@end table

今のところ gnus に hashcash クッキーを認証する手段はありません。あなたが
手作業でメールをふるいにかけるスクリプトをカスタマイズすることが求められ
ています。しかし、この分野における改良は有用な貢献になるでしょう。

@node Various Various
@section いろいろのいろいろ
@cindex mode lines
@cindex highlights

@table @code
@item gnus-home-directory
全ての gnus のパス変数はこの変数によって初期化されます。その初期設定値
は @file{~/} です。

@item gnus-directory
@vindex gnus-directory
たくさんの gnus 格納パス変数はこの変数によって初期化されます。その初期設
定値は @samp{SAVEDIR} 環境変数の値か、その変数が設定されていない場合
は @file{~/News/} です。

@file{.gnus.el} ファイルが読まれたときは gnus のほとんどはすでに読み込ま
れているということに注意してください。これはつまり、この変数
を @file{.gnus.el} の中で設定しても、この変数によって初期化される他のディ
レクトリー変数は正しく設定されないだろうということです。この変数は代わり
に @file{.emacs} で設定してください。

@item gnus-default-directory
@vindex gnus-default-directory
上記の変数には全く関係ありません --- この変数は全ての gnus バッファーの
ディフォルトディレクトリーをどうすべきかを設定します。も
し @kbd{C-x C-f} のような命令を実行すると、現在のバッファーのディフォル
トディレクトリーを起点にしたプロンプトが出てくるでしょう。

この変数が @code{nil} (これが初期設定値) であれば、gnus を起動したときに
あなたがいたバッファーのディフォルトディレクトリーがディフォルトディレク
トリーになるでしょう。

@item gnus-verbose
@vindex gnus-verbose
この変数は 0 から 10 まで間の整数です。大きい数字ほどたくさんのメッセー
ジが表示されます。この変数が 0 であれば gnus は何のメッセージも見せませ
ん。これが 7 (初期設定値) であれば特に重要なメッセージが表示され、10 で
あれば gnus は決してお喋りを止めず、たくさんのメッセージであなたにめまい
を起こさせるでしょう。

@item gnus-verbose-backends
@vindex gnus-verbose-backends
この変数は @code{gnus-verbose} と同様に動作しますが、gnus 本体ではな
く gnus のバックエンドに対して適用されます。

@item nnheader-max-head-length
@vindex nnheader-max-head-length
バックエンドが記事のヘッダーをまっすぐ読んでいるときは、できる限り少ない
量だけを読もうと努力します。この変数 (初期設定値 4096) は、バックエンド
がヘッダーと本文の間の区切り行を見つけるまでに読み込もうとする絶対最大長
を指定します。この変数が @code{nil} であれば、読み込み上限はありません。
もし @code{t} であれば、バックエンドは記事を部分部分で読み込もうとはせず、
記事全体を読み込みます。これは @code{ange-ftp} や @code{efs} のあるバー
ジョンで意味をもちます。

@item nnheader-head-chop-length
@vindex nnheader-head-chop-length
この変数 (初期設定値 2048) は、前記の操作を行っているときに、どれくらい
の大きさの単位で各記事を読み込むかを設定します。

@item nnheader-file-name-translation-alist
@vindex nnheader-file-name-translation-alist
@cindex file names
@cindex invalid characters in file names
@cindex characters in file names
これはファイル名の文字をどのように変換するかを指定する連想リストです。例
えば、もし @samp{:} があなたのシステムではファイル名の文字としては使えな
い場合 (あなたは OS/2 ユーザです)、以下のようにすることができます。

@lisp
(setq nnheader-file-name-translation-alist
      '((?: . ?_)))
@end lisp

実際には、これは OS/2 と (くそ) MS Windows システム上でのこの変数の初期
設定値です。

@item gnus-hidden-properties
@vindex gnus-hidden-properties
これは ``不可視'' テキストを隠すために使われる属性のリストです。ほとんど
のシステムでは初期設定値は @code{(invisible t intangible t)} で、これは
不可視テキストを見えなくして触れなくします。

@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
ヘッダーを解釈する前に呼び出されるフック。これは例えば、取得したヘッダー
の統計情報を取るとか、あるいはある種のヘッダーを取り除くことに使うことが
できます。まあ、私は何でこんなものが欲しいかよくわかんないんだけどね。

@item gnus-shell-command-separator
@vindex gnus-shell-command-separator
二つのシェル命令を区切るのに使用される文字列。初期設定値
は @samp{;} です。

@item gnus-invalid-group-regexp
@vindex gnus-invalid-group-regexp

ユーザにグループ名を確認するときに使う、``使えない'' グループ名にマッチ
する正規表現です。既定値は gnus の内部動作 (選択方法とグループの境界に、
通常 @samp{:} を使っている) をめちゃめちゃにしてしまうかもしれない、いく
つかの @strong{本当に} 使えないグループ名を捕まえます。

@sc{imap} ユーザはグループ名に @samp{/} を使いたいと思うでしょうけれど。
@end table

@node The End
@chapter 終わり

はい、以上がマニュアルです---あなたはもう自分自身の人生を送る事ができま
す。連絡をとって下さい。あなたの猫に今日は、といっておいて下さい。

おお、@strong{神よ}---さよならを耐える事はできません。(すすり泣き。)

Ol' Charles Reznikoff はそれを非常によく現していますので、ここは彼のため
に譲ります:

@quotation
@strong{Te Deum}

@sp 1
Not because of victories @*
I sing,@*
having none,@*
but for the common sunshine,@*
the breeze,@*
the largess of the spring.

@sp 1
Not for victory@*
but for the day's work done@*
as well as I was able;@*
not for a seat upon the dais@*
but at the common table.@*
@end quotation

試訳:

@quotation
@strong{Te Deum}

@sp 1
勝利したからではなく @*
私は歌う @*
何も無いけれど @*
あの日光や @*
息吹や @*
春の大きさのために @*

@sp 1
勝利のためではなく @*
一日の労働のために @*
また、それを達成できたことに @*
高座の上の席のためではなく @*
普通のテーブルのところで @*
@end quotation

@node Appendices
@chapter 付録

@menu
* XEmacs::                      XEmacs でインストールするための要件
* History::                     どうやって gnus が今日のようになったか
* On Writing Manuals::          なぜこれが初心者用の案内でないか
* Terminology::                 我々は本当に難しい、語のような語を使う
* Customization::               あなたの要求に沿って gnus を仕立てる
* Troubleshooting::             上手く行かなかったときに試すかもしれない
                                こと
* Gnus Reference Guide::        色々な技術的なもの
* Emacs for Heathens::          Emacs の用語の手短な導入
* Frequently Asked Questions::
@end menu

@node XEmacs
@section XEmacs
@cindex XEmacs
@cindex Installing under XEmacs

XEmacs はパッケージの蒐集として配布されています。gnus の XEmacs パッケー
ジが必要とするものは何であれ、あなたはインストールすべきです。今のところ
必要なのは @samp{gnus}, @samp{w3}, @samp{mh-e}, @samp{mailcrypt},
@samp{rmail}, @samp{eterm}, @samp{mail-lib}, @samp{xemacs-base} および
@samp{fsf-compat} です。

@node History
@section 歴史

@cindex history
@sc{gnus} は 梅田 政信氏によって書かれました。94年の夏が忍び寄ってくるこ
ろ、Lars Magne Ingebrigtsen は飽きてきて、Gnus を書き直そうと決心しまし
た。

この無礼を行った人物を調べてみたいのなら、あなたの (くそ!) ウェブブラウ
ザーを @uref{http://quimby.gnus.org/} に向ける事ができます。
これは新しくて粋な版の gnus の第一配布場所で、Newsrc をぶっ壊して人々を
激怒されるサイトとして知られています。

最初のアルファ版の開発期間に、新しい Gnus は ``(ding) Gnus'' と呼ばれて
いました。@dfn{(ding)} はもちろん、@dfn{ding is not Gnus} の短縮形で、こ
れは全く完全な嘘ですが、だれがそんなことを気にするでしょうか? (ところで、
この短縮形の ``Gnus'' はおそらく梅田さんの意図通り ``ニュース'' と発音さ
れるべきで、そうするともっと適切な名前になります。そう思いませんか?)

どちらにせよ、全てのエネルギーを新しい元気の良い名前を付けるのに使い果た
した後、その名前は @emph{あまりに} 元気が良すぎるという事になり、それ
を ``Gnus'' と再び命名しました。でも、今回は大文字と小文字を混ぜています。
``Gnus'' と ``@sc{gnus}'' です。新しいもの と 古いもの。

@menu
* Gnus Versions::               どんなバージョンの Gnus がリリースされて
                                いるか
* Other Gnus Versions::         リリースされている他のバージョンの Gnus
* Why?::                        Gnus の目的は何?
* Compatibility::               Gnus は @sc{gnus} とどれくらい互換性がある
                                の?
* Conformity::                  Gnus は全ての標準を満たそうとする
* Emacsen::                     Gnus はいくつかの現代的な Emacs 環境で実
                                行できる
* Gnus Development::            Gnus が開発されている方法
* Contributors::                大量の人々
* New Features::                Gnus の新しい事に関する手がかり
@end menu

@node Gnus Versions
@subsection Gnus Versions
@cindex ding Gnus
@cindex September Gnus
@cindex Red Gnus
@cindex Quassia Gnus
@cindex Pterodactyl Gnus
@cindex Oort Gnus
@cindex No Gnus

最初の ``適切な'' Gnus 5 のリリースは 1995年11月に Emacs 19.30 の配布に
含まれたときになされました (132 の (ding) Gnus のリリース 足すこと
の Gnus5.0 の 15 リリース)。

1996年3月に次の世代の Gnus (別名 ``September Gnus'' (99 リリースの後
で)) が ''Gnus 5.2`` という名前でリリースされました (40 リリース)。

1996年の 7月28日に Red Gnus の作業が始まり、それは 1997年1月25日
に (84 リリースの後で) ``Gnus 5.4'' としてリリースされました (67 リリー
ス)。

1997年9月13日に、Quassia Gnus が開始され、37 リリース続きました。それ
は ``Gnus 5.6'' として 1998年3月8日にリリースされました (46 リリース)。

1998年8月29日に Gnus 5.6 から Pterodactyl Gnus が生まれ、1999年12月3日
に (99 リリースと CVS リポジトリでの作業の後) ``Gnus 5.8'' としてリリー
スされました。

2000年10月26日に Oort Gnus が開始されました。

もし接頭辞を持った版の Gnus -- ``(ding) Gnus'', ``September Gnus'',
``Red Gnus'', ``Quassia Gnus'', ``Pterodactyl Gnus'', ``Oort Gnus''
-- に出会っても、混乱しないでください。あなたが恐がっている事を知られて
はいけません。後ろに下がりなさい。ゆっくりと。他に何をしても、走ってはい
けません。それが届かくなるまで、静かに歩き去りなさい。適切にリリースされ
た版の Gnus を見つけて、代わりにそれに寄り添って下さい。

@node Other Gnus Versions
@subsection 他の gnus のバージョン
@cindex Semi-gnus

Lars さんが調製してリリースした Gnus に加えて、日本では Semi-gnus の開発
が行なわれています。これは @sc{semi} という @sc{mime} の機能を実現するた
めのライブラリを使うことを前提としています。

これらの gnus は Gnus 5.6 と Pterodactyl Gnus を元にしています。それら
は ``Semi-gnus'' と総称され、T-gnus, Nana-gnus および Chaos の異なった系
統があります。これらは強力な @sc{mime} の機能と各国語対応の機能を提供す
るもので、特に日本人のユーザにとって大事なものです。

@node Why?
@subsection なぜ?

Gnus の目的は何ですか?

私は、あなたの考え付く事を全てできる ``すばらしい'' ``かっこいい'' ``い
かす'' ``はやりの'' ニュースリーダを提供したいと思います。これは私の大元
の動機ですが、Gnus の作業をしている間に、この世代のニュースリーダーは本
当に石器時代に属しているという事が明らかになりました。ニュースリーダーは、
インターネットの幼児期からほとんど発展していませんでした。もし現在の増加
率で量が増加しつづければ、全ての現在のニュースリーダーは全く役に立たなく
なるでしょう。一日に 1000 やもっとたくさんの新しい記事のあるニュースグルー
プを扱うにはどうすれば良いのでしょう? 投稿をする百万やそれより多い人々に
遅れないように付いていくにはどうすれば良いのでしょう?

Gnus はこれらの質問に本当の解決を提案しますが、私は Gnus がニュースを読
み、取得するための新しい方法を実験する場として使われて欲しいです。梅田さ
んのニュースリーダーをバックエンドから分離するという賢明な方針を拡張する
事によって、Gnus はメールを取得したり、違ったところからニュースを取得す
るための新しいバックエンドを書きたい人のために、簡単で単純なインターフェー
スを提供しています。私は、役に立つであろうという部分にすべて、カスタマイ
ズのためのフックを加えました。それをする事によって、探検し、発明したい全
ての人を招いているのです。

おそらく Gnus は完成する事はないのかもしれません。
@kbd{C-u 100 M-x all-hail-emacs} と @kbd{C-u 100 M-x all-hail-xemacs} で
す。

@node Compatibility
@subsection 互換性

@cindex compatibility
Gnus は @sc{gnus} と完全に互換性があるように設計されています。ほとんど全
てのキーバインディングはそのまま残っています。もちろん、多くのキーバイン
ディングが追加されましたが、一つか二つのあいまいな場合を除いて、古いバイ
ンディングが変更された事はありません。

我々のモットーは:
@quotation
@cartouche
@center 鋼鉄の骨組みの空高く。
@end cartouche
@end quotation
です。

全ての命令はその名前が変わっていません。いくつかの内部関数は名前を変えま
した。

@code{gnus-uu} パッケージは劇的に変化しています。@xref{Decoding
Articles}.

一つの主要な互換性の質問は、いくつかの概略バッファが存在する事です。全て
のグループを読み込むときに関連する変数はそれが属する概略バッファのバッファ
固有です。多くの重要な変数はそれの全体の版にも複製されますが、概略バッファ
で命令が実行されると、この変更は、あなたが注意していないと、正しくない値
になるかも知れません。

@sc{gnus} の内部の知識に依存した全てのコードは実行できないでしょう。二つ
例を挙げます: @code{gnus-newsrc-alist} の並び替え (もしくは、実際は何ら
かの方法でそれを変更する事) は絶対に禁止されています。Gnus はこの連想リ
ストの登録を指し示すハッシュテーブルを保持しており (それは多くの関数の速
度を上げます)、直接連想リストを変更する事は異常な結果をもたらすでしょう。

@cindex hilit19
@cindex highlighting
古い hilit19 のコードは全く動作しません。実際のところ、おそらく全て
の hilit コードを全ての Gnus のフッ
ク (@code{gnus-group-prepare-hook} と @code{gnus-summary-prepare-hook}) か
ら取り除くべきでしょう。Gnus はハイライトのためのいろいろな統合された関
数を提供します。これらはもっと速くもっと正確です。全ての人の人生を楽にす
るために、Gnus は初期設定で全ての hilit フックから全ての hilit 呼び出し
を取り除きます。きたないもの! とんでけ!

@code{expire-kill} のようなパッケージはもう動作しません。実際、Gnus を使
い始めたときには、おそらく全ての古い @sc{gnus} パッケージ (と他のコー
ド) を消去するべきでしょう。@sc{gnus} に実行させるために書いたコードは、
Gnus が既に実行しているという事は良くある事です。(くすくす。)

物事を実行する古い方法はまだ使用できますが、新しい方法だけがこのマニュア
ルに記載されています。もしこのマニュアルを読んでいる間に何かをする新しい
方法を発見しても、古い方法を止めなければならないという事ではありません。

Gnus は全ての @sc{gnus} 起動ファイルを理解します。

@kindex M-x gnus-bug
@findex gnus-bug
@cindex reporting bugs
@cindex bugs
全体として、@sc{gnus} の内部に依存したコードをほとんど書いていない普通の
利用者は問題に苦しむ事はないでしょう。問題が起これば、魔法の命
令 @kbd{M-x gnus-bug} を実行する事によって私に知らせて下さい。

@vindex gnus-bug-create-help-buffer
@emph{非常に} よくバグ報告を送る癖があるのであれば、しばらくすると役に立
つ help バッファがうるさいと感じるかもしれません。そうであれば、それが表
示されるのを避けるために、
@code{gnus-bug-create-help-buffer} を @code{nil} に設定して下さい。

@node Conformity
@subsection 一致性

これは、理由無き反抗、じゃないですよ、奥さん。我々は全ての知られている標
準に沿っています。もちろん、我々が賛成できない標準と/もしくは習慣は除き
ますが。

@table @strong
@item RFC (2)822
@cindex RFC 822
@cindex RFC 2822
この標準への知られている違反はありません。

@item RFC 1036
@cindex RFC 1036
この標準も知られている違反はありません。

@item Son-of RFC 1036
@cindex Son-of RFC 1036
これにはいくつかの違反があります。

@table @emph
@item X-Newsreader
@item User-Agent
これは ``つまらないヘッダー'' と考えられていますが、私は消費者の情報であ
ると見なしています。@code{tin} と @code{Netscape} から送られてくる非常に
多くの様式に沿っていない記事を見た後で、私はそれらを記事を投稿するために
は使わない方が良いという事を知りました。もし @code{X-Newsreader} ヘッダー
が無ければ私はその情報を得る事はなかったでしょう。
@end table

@item USEFOR
@cindex USEFOR
USEFOR は、IETF の working group が Son-of-RFC 1036 に基づいて、
RFC 1036 の後継として書いているものです。ニュース記事の様式に対して、い
ろいろな変更を提案した draft を作成しました。Gnus タワー
は draft が RFC として認められたときに変更の実装を調べることになるでしょ
う。

@item MIME - RFC 2045-2049 etc
@cindex MIME
@sc{mime} 関連のすべての RFC がサポートされています。

@item Disposition Notifications - RFC 2298
Message Mode は受信者に開封確認を要求することができます。

@ignore
@item PGP - RFC 1991 and RFC 2440
@cindex RFC 1991
@cindex RFC 2440
RFC 1991 is the original PGP message specification, published as a
Information RFC.  RFC 2440 was the follow-up, now called Open PGP, and
put on the Standards Track.  Both document a non-@sc{mime} aware PGP
format.  Gnus supports both encoding (signing and encryption) and
decoding (verification and decryption).

@item PGP/MIME - RFC 2015/3156
RFC 2015 (superceded by 3156 which references RFC 2440 instead of RFC
1991) describes the @sc{mime}-wrapping around the RF 1991/2440 format.
Gnus supports both encoding and decoding.

@item S/MIME - RFC 2633
RFC 2633 describes the @sc{s/mime} format.

@end ignore
@item IMAP - RFC 1730/2060, RFC 2195, RFC 2086, RFC 2359, RFC 2595, RFC 1731
RFC 1730 は @sc{imap} バージョン 4 で、RFC 2060 (@sc{imap} 4 改定 1) で
多少更新されています。RFC 2195 は @sc{imap} の CRAM-MD5 認証について述べ
ています。RFC 2086 は @sc{imap} の使用制限一覧 (ACL) について述べていま
す。RFC 2359 は @sc{imap} のプロトコルの拡張について述べています。RFC
2595 は @sc{imap} における適切な TLS の統合 (STARTTLS) について述べてい
ます。RFC 1731 は @sc{imap} の GSSAPI/Kerberos4 の手法について述べていま
す。
@end table

上に書かれている文章に関する事で、Gnus がそれを満たしていないような動作
をしている事に気付いたら、ためらわずに Gnus タワーと我々に知らせて下さい。

@node Emacsen
@subsection Emacsen
@cindex Emacsen
@cindex XEmacs
@cindex Mule
@cindex Emacs

Gnus は以下のもので動作します:

@itemize @bullet

@item
Emacs 19.34 とそれ以上の Mule 機能付き。

@item
XEmacs 21.1.1 以上の Mule 機能付き

@item
Meadow 1.00 以上。(Mule for Windows では動きません。)
@end itemize

この Gnus の版はこれより古いどんな Emacsen でも完全に動作しないでしょう。
少なくとも、信頼できる動作はしないでしょう。古い版の gnus は古
い Emacs の版でも動作するでしょう。とは言うものの、T-gnus はバージョ
ン 21.1.1 未満の XEmacs, 例えば 20.4 でも使えるかもしれません。詳しいこ
とは T-gnus の配布に含まれている README ファイルを読んで下さい。

いろいろなプラットフォームの Gnus の間にはいくつかの漠然とした違いがあり
ます---XEmacs はもっと画像機能 (ロゴとツールバー) を特徴にしています--し
かし、その他は、全ての Emacsen でほとんど同じはずです。

@node Gnus Development
@subsection Gnus の開発

Gnus は二つの段階の循環で開発されています。最初の段階
は @samp{ding@@gnus.org} でのたくさんの議論があり、そこで変更や新しい機
能を提案します。この段階は @dfn{アルファ} 段階と呼ばれます。というのは、
この段階でリリースされた Gnusae は @dfn{アルファリリース} もしくは (他
の団体ではより良く使われる) @dfn{スナップショット} と呼ばれるものだから
です。この段階では、gnus は不安定であると考えられており、一般の利用者に
よって使われるものではありません。Gnus アルファリリース
は ``Red Gnus'' や ``Quassia Gnus'' のような名前になっています。

50-100 くらいのリリースの後で、Gnus は @dfn{凍結} されたと宣言され、バグ
修正のみが適用されます。Gnus は接頭辞が取れ、その代わり
に ``Gnus 5.6.32'' のように呼ばれます。これら普通の人が使うことのできる
ものと考えられ、主に @samp{gnu.emacs.gnus} ニュースグループで議論されて
います。

@cindex Incoming*
@vindex mail-source-delete-incoming
アルファ Gnusae と リリースされた Gnusae では変数の初期値が違うものがあ
ります。特に、@code{mail-source-delete-incoming} はアルファ gnusae で
は @code{nil} で、リリースされた gnusae では @code{t} です。これはメール
を扱っている際に、アルファリリースの齟齬によりメールを失なうことを避ける
ためです。

ding メーリングリストと Gnus ニュースグループにおける議論の分離は純粋に
公衆の関心によってなされているわけではありません。アルファ Gnus リリース
が (ときどき) するかもしれない恐ろしいことを公衆の場で書くのは、皆を恐れ
させるというのも事実ですが、もっと重要なことは、導入された新しい実験的な
機能について話すことは一般の使用者を混乱させる可能性があります。新しい機
能は頻繁に導入され、いじくられ、不十分であると判断され、そうすると捨てら
れるか、完全に書き換えられるかのどちらかです。メーリングリストを読んでい
る人は普通はこの速い変更に付いていきますが、ニュースグループの人もそうで
あるとみなすことはできません。

@node Contributors
@subsection 貢献者
@cindex contributors

新しい Gnus の版は (ding) メーリングリストの全ての人の助けが無ければでき
なかったでしょう。一年以上、私は毎日とてもたくさんの素敵なバグレポートを
受け取り、そのそれぞれが私を喜びで満たしました。愛撫。このリストの人々は
忍耐を超えて私の ``あぁ、それはすばらしい考えだ <type type>、うん、私は
待たずにそれをすぐリリースしよう <ship off>、それは全く動作しない <type
type>、うん、私はすぐに出そう <ship off> いや、纏う、それは全く動作しな
いぞ''' というリリースに関する主義を変えて試してきた人々です。
Micro$oft---あぁ。アマチュア。私は @emph{もっと} 悪い。(もしくは、
``より悪い''? ``もっと悪い''? ``最悪''?)

私はこの機会にこの学会に... おおっと、違った。

@itemize @bullet

@item
梅田 政信---元の @sc{gnus} を書いた人です。

@item
Shenghuo Zhu---uudecode.el, mm-uu.el, rfc1843.el, webmail.el,
nnwarchive と @sc{mime} と他の形式の符号化/復号化やバグ修正、新しい機能
などのほんとうに多くのもの。

@item
Per Abrahamsen--custom、スコア、ハイライトと @sc{soup} コード (他の多く
の事と共に)。

@item
Luis Fernandes---デザインとグラフィック。

@item
Joe Reiss---スマイリーの顔の作者。

@item
Justin Sheehy--FAQ のメインテイナー。

@item
Erik Naggum---援助、考え、サポート、コードとその他。

@item
Wes Hardaker---@file{gnus-picon.el} と @dfn{picon} の部分のマニュア
ル (@pxref{Picons})。

@item
Kim-Minh Kaplan---picon コードに置ける更なる作業。

@item
Brad Miller---@file{gnus-gl.el} と Grouplens の部分のマニュア
ル (@pxref{GroupLens})。

@item
Sudish Joseph---数え切れないほどのバグの修正。

@item
Ilja Weis---@file{gnus-topic.el}。

@item
Steven L. Baur---たくさんのたくさんのたくさんのバグの発見と修正。

@item
Vladimir Alexiev---refcard とリファレンスの小冊子。

@item
Felix Lee & Jamie Zawinski---私は Felix Lee と JWZ の XGnus 配布からいく
つかの部分を盗みました。

@item
Scott Byer---@file{nnfolder.el} の拡張と改訂。

@item
Peter Mutsaers---古事記事のスコアコード。

@item
Ken Raebburn---POP メールサポート。

@item
Hallvard B Furuseth---いろいろな小さな物や部分、特に .newsrc ファイルを
扱う部分。

@item
Brian Edmonds---@file{gnus-bbdbb.el}。

@item
David Moore--@file{nnvirtual.el} の改訂と多くの他の事。

@item
Kevin Davidson---@dfn{ding} の名前を思い付きました。ですから、彼を責めて
下さい。

@item
Fran,Agois Pinard---多くの、多くの興味深く完全なバグレポートと autoconf の
サポート。
@end itemize

このマニュアル (Gnus 英語版) は Adrian Aichner と Ricardo Nassif, Mark
Borges によって校正され、Jost Krieger によって一部分を校正されました。

以下の人々は多くのパッチと提案で貢献しました:

Christopher Davis,
Andrew Eskilsson,
Kai Grossjohann,
David K,Aegedal,
Richard Pieri,
Fabrice Popineau,
Daniel Quinlan,
Jason L. Tibbitts, III,
and
Jack Vinson.

それと、以下の人にもパッチやその他のものを感謝します:

Jari Aalto,
Adrian Aichner,
Vladimir Alexiev,
Russ Allbery,
Peter Arius,
Matt Armstrong,
Marc Auslander,
Miles Bader,
Frank Bennett,
Alexei V. Barantsev,
Robert Bihlmeyer,
Chris Bone,
Mark Borges,
Mark Boyns,
Rob Browning,
Lance A. Brown,
Kees de Bruin,
Martin Buchholz,
Joe Buehler,
Kevin Buhr,
Alastair Burt,
Joao Cachopo,
Zlatko Calusic,
Massimo Campostrini,
Castor,
David Charlap,
Dan Christensen,
Kevin Christian,
Jae-you Chung, @c ?
James H. Cloos, Jr.,
Laura Conrad,
Michael R. Cook,
Glenn Coombs,
Andrew J. Cosgriff,
Neil Crellin,
Frank D. Cringle,
Geoffrey T. Dairiki,
Andre Deparade,
Ulrik Dickow,
Dave Disser,
Rui-Tao Dong, @c ?
Joev Dubach,
Michael Welsh Duggan,
Dave Edmondson,
Paul Eggert,
Mark W. Eichin,
Karl Eichwalder,
Enami Tsugutomo, @c Enami
Michael Ernst,
Luc Van Eycken,
Sam Falkner,
Nelson Jose dos Santos Ferreira,
Sigbjorn Finne,
Sven Fischer,
Paul Fisher,
Decklin Foster,
Gary D. Foster,
Paul Franklin,
Guy Geens,
Arne Georg Gleditsch,
David S. Goldberg,
Michelangelo Grigni,
Dale Hagglund,
D. Hall,
Magnus Hammerin,
Kenichi Handa, @c Handa
Raja R. Harinath,
Yoshiki Hayashi, @c ?
P. E. Jareth Hein,
Hisashige Kenji, @c Hisashige
Scott Hofmann,
Marc Horowitz,
Gunnar Horrigmo,
Richard Hoskins,
Brad Howes,
Miguel de Icaza,
Fran,Agois Felix Ingrand,
Tatsuya Ichikawa, @c ?
Ishikawa Ichiro, @c Ishikawa
Lee Iverson,
Iwamuro Motonori, @c Iwamuro
Rajappa Iyer,
Andreas Jaeger,
Adam P. Jenkins,
Randell Jesup,
Fred Johansen,
Gareth Jones,
Simon Josefsson,
Greg Klanderman,
Karl Kleinpaste,
Michael Klingbeil,
Peter Skov Knudsen,
Shuhei Kobayashi, @c Kobayashi
Petr Konecny,
Koseki Yoshinori, @c Koseki
Thor Kristoffersen,
Jens Lautenbacher,
Martin Larose,
Seokchan Lee, @c Lee
Joerg Lenneis,
Carsten Leonhardt,
James LewisMoss,
Christian Limpach,
Markus Linnala,
Dave Love,
Mike McEwan,
Tonny Madsen,
Shlomo Mahlab,
Nat Makarevitch,
Istvan Marko,
David Martin,
Jason R. Mastaler,
Gordon Matzigkeit,
Timo Metzemakers,
Richard Mlynarik,
Lantz Moore,
Morioka Tomohiko, @c Morioka
Erik Toubro Nielsen,
Hrvoje Niksic,
Andy Norman,
Fred Oberhauser,
C. R. Oldham,
Alexandre Oliva,
Ken Olstad,
Masaharu Onishi, @c Onishi
Hideki Ono, @c Ono
Ettore Perazzoli,
William Perry,
Stephen Peters,
Jens-Ulrik Holger Petersen,
Ulrich Pfeifer,
Matt Pharr,
Andy Piper,
John McClary Prevost,
Bill Pringlemeir,
Mike Pullen,
Jim Radford,
Colin Rafferty,
Lasse Rasinen,
Lars Balker Rasmussen,
Joe Reiss,
Renaud Rioboo,
Roland B. Roberts,
Bart Robinson,
Christian von Roques,
Markus Rost,
Jason Rumney,
Wolfgang Rupprecht,
Jay Sachs,
Dewey M. Sasser,
Conrad Sauerwald,
Loren Schall,
Dan Schmidt,
Ralph Schleicher,
Philippe Schnoebelen,
Andreas Schwab,
Randal L. Schwartz,
Justin Sheehy,
Danny Siu,
Matt Simmons,
Paul D. Smith,
Jeff Sparkes,
Toby Speight,
Michael Sperber,
Darren Stalder,
Richard Stallman,
Greg Stark,
Sam Steingold,
Paul Stevenson,
Jonas Steverud,
Paul Stodghill,
Kiyokazu Suto, @c Suto
Kurt Swanson,
Samuel Tardieu,
Teddy,
Tozawa Akihiko, @c Tozawa
Chuck Thompson,
Philippe Troin,
James Troup,
Trung Tran-Duc,
Jack Twilley,
Aaron M. Ucko,
Aki Vehtari,
Didier Verna,
Vladimir Volovich,
Jan Vroonhof,
Stefan Waldherr,
Pete Ware,
Barry A. Warsaw,
Christoph Wedler,
Joe Wells,
Lee Willis,
Katsumi Yamaoka @c Yamaoka
and
Lloyd Zusman.

それぞれの人々が行った事の完全な概観を得るために、ChangeLog が Gnus のア
ルファ配布には含まれていて、豊富な読み物を与えるでしょう。(550KB といく
らか)。

私が忘れた全ての人に謝罪します。間違いなくたくさんの人を忘れている事でしょ
う。

わぁ、これはなんとも多い人のリストだなぁ。おそらく実際に Gnus 入るという
事に違いないでしょう。それに誰が感謝したでしょう!

@node New Features
@subsection 新しい機能
@cindex new features

@menu
* ding Gnus::                   最初の新しい Gnus である Gnus 5.0/5.1 の
                                新しい事
* September Gnus::              公式に Gnus 5.2/5.3 として知られているも
                                の
* Red Gnus::                    三番目の最上のもの---Gnus 5.4/5.5
* Quassia Gnus::                2 かける 2 は 4、もしくは Gnus 5.6/5.7
* Pterodactyl Gnus::            五番目、P で始まる、もしくは Gnus 5.8
                                /5.9 として知られているもの
@end menu

このリストは、もちろん、@emph{たいていの} 重要な新しい機能に関す
る @emph{短い}概観でしかありません。いいえ、本当はそうではありません。もっ
ともっとたくさんのものがあります。はい、我々は創造性の完全な効果を感じて
いるのです。

@node ding Gnus
@subsubsection (ding) Gnus

Gnus 5.0/5.1 の新しい機能:

@itemize @bullet

@item
全てのバッファの外観はフォーマットのような変数 (@pxref{Group Buffer
Format} と @pxref{Summary Buffer Format}) によって設定を変える事ができる
ようになりました。

@item
ローカルスプールと、いくつかの @sc{nntp} サーバーを同時に使う事がでるよ
うになりました (@pxref{Select Methods})。

@item
グループを事実上のグループに結合できるようになりました (@pxref{Virtual
Groups})。

@item
多くの違ったメール様式 (@pxref{Getting Mail}) を読めるようになりました。
全てのメールバックエンドは便利なメール期限切れ消去機構を実装していま
す (@pxref{Expiring Mail})。

@item
Gnus は根っこ (root) を失ったスレッドを集めるためのいろいろな戦略 (それ
によってまばらな副スレッドを一つのスレッドにする) を使ったり、一旦戻って
完全なスレッドをくみ上げるのに十分なヘッダーを取得しする事ができま
す (@pxref{Customizing Threading})。

@item
切られたグループ (killed group) はぐループバッファに表示する事ができて、
それも読む事ができます (@pxref{Listing Groups})。

@item
Gnus は部分的グループ更新をする事ができます---2,3 のグループの新しい記事
を調べるためにアクティブファイル全体を取得する必要はありませ
ん (@pxref{The Active File})。

@item
Gnus はグループの段階的購読度を実装しました (@pxref{Group Levels})。

@item
任意の数の基準に従って記事にスコアを付ける事ができます (@pxref{Scoring})。
あなたのために記事をどのようにスコアを付けるかを Gnus に見つけさせる事も
できます (@pxref{Adaptive Scoring})。

@item
Gnus は普通の Emacs の方法で自動保存されるドリブルバッファを保持していま
すので、あなたのマシンが落っこちたときでもあまりデータを失わないでしょ
う (@pxref{Auto Save})。

@item
Gnus は今やファイル @file{.emacs} をぐちゃぐちゃにする事を避けるために専
用の起動ファイル (@file{.gnus}) を持つようになりました。

@item
グループと記事の両方にプロセス印を付けることができ、全ての印の付いた項目
に演算をする事ができます (@pxref{Process/Prefix})。

@item
グループの一部を grep して、その結果からグループを作る事ができま
す (@pxref{Kibozed Groups})。

@item
えーと、全てにしたがって、グループの一覧を挙げる事ができま
す (@pxref{Listing Groups})。

@item
外部サーバーを概観して、それらのサーバーのグループを購読する事ができま
す (@pxref{Browse Foreign Server})。

@item
Gnus はサーバーとの二つ接続で、記事を非同期にとってくる事ができま
す (@pxref{Asynchronous Fetching})。

@item
記事をローカルにキャッシュする事ができます (@pxref{Article Caching})。

@item
uudecode の関数が拡張され、一般化されました (@pxref{Decoding Articles})。

@item
過去の @sc{gnus} のあまり知られていない機能の uuencode された記事をまだ
投稿する事ができます (@pxref{Uuencoding and Posting})。

@item
親記事 (と他の記事) の取得は今や、実際に突然故障する事無く動作するように
なりました (@pxref{Finding the Parent})。

@item
Gnus は FAQ とグループの記述を取得する事ができます (@pxref{Group
Information})。

@item
記事をハイライトし、カスタマイズする事ができます (@pxref{Customizing
Articles})。

@item
URL と他の外部参照がボタンになるようになりました (@pxref{Article
Buttons})。

@item
Gnus のウィンドウとフレームの設定でたくさんの変な事をできるようになりま
した (@pxref{Window Layout})。

@item
キーボードを使う代わりに、ボタンをクリックできるようになりまし
た (@pxref{Buttons})。
@end itemize

@node September Gnus
@subsubsection September Gnus

@iftex
@iflatex
\gnusfig{-28cm}{0cm}{\epsfig{figure=ps/september,height=20cm}}
@end iflatex
@end iftex

Gnus 5.2/5.3 の新しい機能:

@itemize @bullet

@item
新しいメッセージ作成モードが使われます。
@code{mail-mode}, @code{rnews-reply-mode} と @code{gnus-msg} の全ての古
いカスタマイズ変数は今や旧式になりました。

@item
Gnus は @dfn{まばら} スレッドを作成する事ができるようになりました---スレッ
ドの失われた記事があるところは空の節で表現されるようになっていま
す (@pxref{Customizing Threading})。

@lisp
(setq gnus-build-sparse-threads 'some)
@end lisp

@item
外に出ていく記事は特別な保管サーバーに保存されるようになりまし
た (@pxref{Archived Messages})。

@item
記事が参照されたときに、スレッドの部分作成が起こるようになりました。

@item
Gnus は GroupLens の予言を使う事ができるようになりまし
た (@pxref{GroupLens})。

@item
Picons (personal icons) (個人アイコン) が XEmacs で表示できるようになり
ました (@pxref{Picons})。

@item
@code{trn} のような木バッファが表示されるようになりました (@pxref{Tree
Display})。

@lisp
(setq gnus-use-trees t)
@end lisp

@item
@code{nn} のような取って読むマイナーモードが概略バッファで使う事ができる
ようになりました (@pxref{Pick and Read})。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@item
バイナリーグループで特別なバイナリーマイナーモードを使う事ができるように
なりました (@pxref{Binary Groups})。

@item
Group が折り畳みトピック階層にグループ分けできるようになりまし
た (@pxref{Group Topics})。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@item
Gnus が失敗メールを再送できるようになりました (@pxref{Summary Mail
Commands})。

@item
グループがスコアを持つ事ができるようになり、訪れる回数に基づいて並び替え
をできるようになりました (@pxref{Group Score})。

@lisp
(add-hook 'gnus-summary-exit-hook 'gnus-summary-bubble-group)
@end lisp

@item
グループにプロセス印を付けられるようになり、グループのぐループに命令が実
行できるようになりました (@pxref{Marking Groups})。

@item
事実上のグループでキャッシュができるようになりました。

@item
@code{nndoc} は全ての集配配送、メールボックス、rnews ニュース一括、
ClariNet 短収集、そして全てのその他を理解できるようになりまし
た (@pxref{Document Groups})。

@item
Gnus は SOUP パケットを作成/読み込みをするための新しいバックエン
ド (@code{nnsoup}) を持っています。

@item
Gnus キャッシュがずっと速くなりました。

@item
グループを多くの基準に従って並び替えできるようになりまし
た (@pxref{Sorting Groups})。

@item
アドレスのリストと期限切れ消去の時間を設定する新しいグループパラメータが
導入されました (@pxref{Group Parameters})。

@item
全てのフォーマット指定が使われるフェイスを指定できるようになりまし
た (@pxref{Formatting Fonts})。

@item
@kbd{M P} 副マップにプロセス印の付いた記事の設定/削除/実行のためのいくつ
かの命令があります (@pxref{Setting Process Marks})。

@item
広い範囲の基準に基づいて、概略バッファが可能な記事の部分の表示に制限でき
るようになりました。これらの命令は @kbd{/} 副マップのキーにバインドされ
ています (@pxref{Limiting})。

@item
@kbd{*} 命令によって、記事を永続にする事ができるようになりまし
た (@pxref{Persistent Articles})。

@item
記事の要素を隠す全ての関数は切り替え関数になりました。

@item
記事のヘッダーがボタンにする事ができるようになりました (@pxref{Article
Washing})。

@item
全てのメールバックエンドで @code{Message-ID} による記事の取得を使用でき
るようになりました。

@item
重複メールを適切に扱う事ができるようになりました (@pxref{Duplicates})。

@item
全ての概略モード命令が記事バッファから直接使用できるようになりまし
た (@pxref{Article Keymap})。

@item
フレームが @code{gnus-buffer-configuration} の部分になる事ができま
す (@pxref{Window Layout})。

@item
デーモンのプロセスでメールを再走査することができるようになりまし
た (@pxref{Daemons})。
@iftex
@iflatex
\marginpar[\mbox{}\hfill\epsfig{figure=ps/fseptember,height=5cm}]{\epsfig{figure=ps/fseptember,height=5cm}}
@end iflatex
@end iftex

@item
Gnus はスパムを根絶やしにするために NoCeM ファイルを使う事ができるように
なりました (@pxref{NoCeM})。

@lisp
(setq gnus-use-nocem t)
@end lisp

@item
グループを永久可視にする事ができるようになりました (@pxref{Listing
Groups})。

@lisp
(setq gnus-permanently-visible-groups "^nnml:")
@end lisp

@item
カスタマイズを簡単にするために多くの新しいフックが導入されました。

@item
Gnus は @code{Mail-Copies-To} ヘッダーに注意を払うようになりました。

@item
@code{References} ヘッダーを集める事によりスレッドを集める事ができるよう
になりました (@pxref{Customizing Threading})。

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp

@item
既読記事は再取得を避けるために特別なバックログバッファに貯められるように
なりました (@pxref{Article Backlog})。

@lisp
(setq gnus-keep-backlog 50)
@end lisp

@item
簡単な扱いのために、現在の記事のきれいな複製がいつも別バッファに蓄積され
るようになりました。

@item
Gnus がどこに記事を保存するかを提案できるようになりました (@pxref{Saving
Articles})。

@item
Gnus は保存するときに同じくらいの促進をしなくても良いようになりまし
た (@pxref{Saving Articles})。

@lisp
(setq gnus-prompt-before-saving t)
@end lisp

@item
@code{uu} は記事を取得している間に非同期で復号化されたファイルを閲覧でき
るようになりました (@pxref{Other Decode Variables})。

@lisp
(setq gnus-uu-grabbed-file-functions 'gnus-uu-grab-view)
@end lisp

@item
引用された文章に対して、記事バッファでの折り返しが適切に動作するようにな
りました (@pxref{Article Washing})。

@item
隠された引用文は隠す事を切り替えるボタンを加え、どのくらいの引用文を隠す
かをカスタマイズできるようになりました (@pxref{Article Hiding})。

@lisp
(setq gnus-cited-lines-visible 2)
@end lisp

@item
退屈なヘッダーを隠す事ができます (@pxref{Article Hiding})。

@item
スコアの初期値がメニューバーから設定できるようになりました。

@item
出て行く記事の更なる構文チェックができるようになりました。
@end itemize

@node Red Gnus
@subsubsection Red Gnus

Gnus 5.4/5.5 の新しい機能:

@iftex
@iflatex
\gnusfig{-5.5cm}{-4cm}{\epsfig{figure=ps/red,height=20cm}}
@end iflatex
@end iftex

@itemize @bullet

@item
@file{nntp.el} は非同期の流儀で完全に改訂されました。

@item
スコア付けは @code{and}, @code{or}, @code{not} のような論理演算子と、親
の再方向で実行できるようになりました (@pxref{Advanced Scoring})。

@item
記事の洗濯状態が記事モード行に表示されるようになりまし
た (@pxref{Misc Article})。

@item
@file{gnus.el} が多くの小さいファイルに分割されました。

@item
Message-ID に基づいた、重複記事の抑制がなされるようになりまし
た (@pxref{Duplicate Suppression})。

@lisp
(setq gnus-suppress-duplicates t)
@end lisp

@item
どのスコアと適応ファイルがホームのスコアと適応ファイルであるかを指定す
る (@pxref{Home Score File}) 新しい変数が加えられました。

@item
@code{nndoc} が簡単に拡張可能になるように改訂されまし
た (@pxref{Document Server Internals})。

@item
グループは親のトピックからグループパラメータを継承できるようになりまし
た (@pxref{Topic Parameters})。

@item
記事編集が改訂され、実際に使用可能になりました。

@item
署名がもっと知的な方法で認識されるようになりました (@pxref{Article
Signature})。

@item
概略ピックモードがもっと @code{nn} のようになりました。行数が表示されて、
命令 @kbd{.} が記事を取るために使う事ができるようになりまし
た (@code{Pick and Read})。

@item
あるサーバーから別のサーバーへ @file{.newsrc.eld} を移動する命令が加えら
れました (@pxref{Changing Servers})。

@item
今や、バッファの行を作成するときに、抑制される ``おもしろくない'' 部分を
指定する方法があります (@pxref{Advanced Formatting})。

@item
グループバッファでのいくつかの命令は @kbd{C-M-_} で元に戻す事ができるよ
うになりました (@pxref{Undo})。

@item
新しいスコアの型 @code{w} を使う事で、語にスコア付けをする事が可能になり
ました (@pxref{Score File Format})。

@item
表題に一語一語を基にして適応スコアをできるようになりまし
た (@pxref{Adaptive Scoring})。

@lisp
(setq gnus-use-adaptive-scoring '(word))
@end lisp

@item
スコアが腐敗できるようになりました (@pxref{Score Decays})。

@lisp
(setq gnus-decay-scores t)
@end lisp

@item
日付のヘッダーに正規表現を使ってスコア付けを実行できるようになりました。
日付はまず短縮 ISO 8601 様式で正規化されます (@pxref{Score File Format})。

@item
基本サーバーの記事に関する全てのデータを取り除く命令が加えられまし
た (@pxref{Changing Servers})。

@item
文書の集合を読むための新しい命令 (@code{nndoc} と @code{nnvirtual} の上
で) が加えられました---@kbd{C-M-d} (@pxref{Really Various Summary
Commands})。

@item
プロセス印の設定が push と pop できるようになりました (@pxref{Setting
Process Marks})。

@item
新しいメールからニュースへのバックエンドが @sc{nntp} サーバーが投稿を
許可していない場合でも、投稿できるようになりまし
た (@pxref{Mail-To-News Gateways})。

@item
ウェブ検索エンジ
ン (@dfn{DejaNews}, @dfn{Alta Vista}, @dfn{InReference}) からの検索結果
を読む新しいバックエンドが加えられました (@pxref{Web Searches})。

@item
標準の並び替え関数を使ってグループの中のトピックを並び代えする事ができ、
それぞれのトピックが独立して並び替えできるようになりまし
た (@pxref{Topic Sorting})。

@item
グループの一部分が独立して並び替えできるようになりまし
た (@code{Sorting})。

@item
キャッシュされた記事がグループに入れられるようになりまし
た (@pxref{Summary Generation Commands})。
@iftex
@iflatex
\marginpar[\mbox{}\hfill\epsfig{figure=ps/fred,width=3cm}]{\epsfig{figure=ps/fred,width=3cm}}
@end iflatex
@end iftex

@item
スコアファイルがもっと信頼できる順番で適用できるようになりまし
た (@pxref{Score Variables})。

@item
メールメッセージがどこに行くかの報告を作成する事ができるようになりまし
た (@pxref{Splitting Mail})。

@item
入って来たメールを保存する前にがらくたを取り除くフックと関数がもっと追加
されました (@pxref{Washing Mail})。

@item
強調文が適切にフォントが変更されるようになりました:
@end itemize

@node Quassia Gnus
@subsubsection Quassia Gnus

Gnus 5.6 の新しい機能:

@itemize @bullet

@item
Gnus をオフラインニュースリーダーとして使う新機能が加えられました。過剰
なほどの新しい命令とモードが追加されました。完全な話に付いて
は @pxref{Gnus Unplugged} を見て下さい。

@item
@code{nndraft} バックエンドが戻ってきましたが、依然とは違うように動作す
るようになりました。全てのメッセージバッファは @code{nndraft} グループの
記事でもあり、それは自動的に作成されます。

@item
@code{gnus-alter-header-function} がヘッダーの値を変えるために使われるよ
うになりました。

@item
@code{gnus-summary-goto-article} が Message-ID を受け付けるようになりま
した。

@item
リージョンの外のメッセージの本文の文章を消去するための新しいメッセージ命
令があります: @kbd{C-c C-v}。

@item
@kbd{C-u C-c C-c} によって @code{nnvirtual} グループを生成しているグルー
プに投稿できるようになりました。

@item
@code{nntp-rlogin-program}---カスタマイズを簡単にするための新しい変数で
す。

@item
@code{gnus-article-edit-mode} の @code{C-u C-c C-c} は記事バッファの再ハ
イライトを禁止するようになりました。

@item
@code{gnus-boring-article-headers} に新しい要素があります---
@code{long-to}。

@item
@kbd{M-i} シンボル接頭引数命令があります。詳細は "Symbolic Prefixes" の
部分を見て下さい。

@item
概略バッファの @kbd{L} と @kbd{I} はファイル "all.SCORE" にスコア法則を
加えるためにシンボル接頭引数 @kbd{a} を受け付けるようになりました。

@item
変数 @code{gnus-simplify-subject-functions} により単純化をもっと制御でき
るようになりました。

@item
@kbd{A T}---現在のスレッドを取得するための新しい命令です。

@item
@kbd{/ T}---現在のスレッドを制限に含めるための新しい命令です。

@item
@kbd{M-RET} は引用文を止めるための新しいメッセージ命令です。

@item
@samp{\\1} 表現が @code{nnmail-split-methods} で有効になりました。

@item
関数 @code{custom-face-lookup} が取り除かれました。あなたの初期化ファイ
ルでこの関数を使っているのなら、代わりに @code{face-spec-set} を使うよう
に書き直さなければなりません。

@item
投稿取り消しは現在の選択方法を使うようになりました。シンボル接頭
辞 @kbd{a} は普通の投稿方法を強制します。

@item
M******** sm*rtq**t*s を適切な文章に翻案する新しい命令があります---
@kbd{W d}。

@item
@code{nntp} のより簡単なデバッグのために、
@code{nntp-record-commands} を @code{nil} でない値に設定する事ができます。

@item
@code{nntp} は @file{~/.authinfo} を使うようになり、これ
は @file{.netrc} のようなファイルで、どこでどのよう
に @sc{authinfo} を @sc{nntp} サーバーに送るかを制御するためのものです。

@item
概略バッファのグループパラメータを編集するための命令が加えられました。

@item
メールがどこに分割されたかの履歴を使用可能になりました。

@item
新しい記事日付命令が加えられました---@code{article-date-iso8601}。

@item
@code{gnus-score-thread-simplify} を設定する事によりスレッドを作成してい
るときは表題が単純化されるようになりました。

@item
メッセージで引用をするための新しい関数が加えられました---
@code{message-cite-original-without-signature}。

@item
@code{article-strip-all-blank-lines}---新しい記事命令です。

@item
記事の終わりまでを切る新しいメッセージ命令が加えられました。

@item
変数 @code{gnus-adaptive-word-minimum} を使う事により最小限適応スコアを
指定する事ができます。

@item
命令 @code{gnus-start-date-timer} により ``過失日付'' 記事ヘッダーが継続
的に更新されるようになりました。

@item
ウェブ listserv アーカイブが @code{nnlistserv} バックエンドにより読む事
ができるようになりました。

@item
古い dejanews アーカイブが @code{nnweb} から読む事ができるようになりまし
た。
@end itemize

@node Pterodactyl Gnus
@subsubsection Pterodactyl Gnus

Gnus 5.8 の新しい機能:

@itemize @bullet

@item
メールを取り込む機能が変わりました。たくさんの詳細についてはマニュアルを
見て下さい。特に、procmail で取り込むためのすべての変数が無くなっていま
す。

このような procmail の使い方は

@lisp
(setq nnmail-use-procmail t)
(setq nnmail-spool-file 'procmail)
(setq nnmail-procmail-directory "~/mail/incoming/")
(setq nnmail-procmail-suffix "\\.in")
@end lisp

現在は次のように変わっています。

@lisp
(setq mail-sources
      '((directory :path "~/mail/incoming/"
                   :suffix ".in")))
@end lisp

もっと詳しい情報は info の Select Methods -> Getting Mail -> Mail
Sources で得ることができます。

@item
Gnus は @sc{mime} に対応したリーダーになりました。これは Gnus の多くの部
分に影響していて、たくさんの新しいコマンドが追加されています。詳細はマニュ
アルを参照して下さい。(訳注: T-gnus は @sc{semi} および @sc{flim} の諸機
能に基づいています。)

@item
Gnus はまた各国語対応になりました。ここでは要約できないくらいに Gnus の
多くの部分に影響していて、新しいたくさんの変数が追加されています。(訳注:
T-gnus は @sc{semi} および @sc{flim} の諸機能に基づいています。)

@item
@code{gnus-auto-select-first} が関数であってもよくなりました。

@item
Summary バッファと @sc{nov} ファイルに含める追加のヘッダーを、ユーザが決
めることができるようになりました。

@item
@code{gnus-article-display-hook} が削除されました。代わり
に @code{gnus-treat-} で始まるたくさんの変数が追加されました。

@item
Gnus posting styles が再び改装されました。現在は微妙に違う規則で動作しま
す。

@item
新しいウェブに基づいたバックエンドが追加されました。@code{nnslashdot},
@code{nnwarchive} および @code{nnultimate} です。nnweb は再び改作され、
常に変化する構成を続けます。

@item
Gnus は @code{nnimap} によって @sc{imap} メールを読むことができます。
@end itemize

@iftex

@page
@node The Manual
@section マニュアル
@cindex colophon
@cindex manual

このマニュアルは TeXinfo ファイルから作成され、それか
ら @code{texi2dvi}
@iflatex
もしくは、Lars さんの作られた Texinfo to \LaTeX 変換を通り、それから、
@code{latex} と @code{dvips}
@end iflatex
を実行して、手元にあるもになりました。

以下の習慣が用いられました:

@enumerate
これは @kbd{キー打鍵} です。

@item
これは @file{ファイル} です。

@item
これは @code{シンボル} です。

@end enumerate

ですから、私が ``@code{flargnoze} を @samp{yes} に設定する'' と言ったと
きは、次のような意味です:

@lisp
(setq flargnoze "yes")
@end lisp

もし、私が ``@code{flargnoze} を @code{yes} に設定する'' と言ったときは、
次のような意味です:

@lisp
(setq flumphel 'yes)
@end lisp

@samp{yes} と @code{yes} は二つの @emph{全く} 違ったものです---絶対に混
同しないでください。

@iflatex
@c @head
もちろん、このマニュアルの全ては重大な興味のあることですので、あなたは全
て読むべきです。何度も。しかし、マニュアルを斜め読みしたいのであれば、そ
このマージンにあるヌーの頭を見るべきでしょう---それはそこで議論されてい
るのが残りのものより重要であるということです。(一方、全てが無限に重要の
であれば、どうすればそれよりもっと重要なものができるのでしょう? この世界
の、不思議の一つでしょう、たぶん。)
@end iflatex

@end iftex

@node On Writing Manuals
@section マニュアルを書く

おそらく、たいていのマニュアルは事実の後で書かれていると思います。すでに
あるプログラムを文書化しています。このマニュアルはそういう方法で書かれて
いません。何かを実装するときは、何かをそのままマニュアルの一節に書きます。
それから機能の説明が難しいことを発見して、それがどのようにあるべきである
かを書き、それから実装を変更します。文書とコードを書くのは一緒に行なわれ
ていきます。

もちろん、これはこのマニュアルには流れ構造がほとんど無いか、あっても少し
だということです。gnus の完全に全てのことが説明されていますが、探してい
る場所ではないということがよくあります。これはリファレンスマニュアルであ
り、gnus を始めるための手引きではありません。

それはまったく違った本になり、このリファレンスマニュアルを元として使って
書かれたものになるでしょう。とても違ったものになるはずです。

@page
@node Terminology
@section 用語

@cindex terminology

@table @dfn
@item ニュース (news)
@cindex news
これはあなたがそのためにこのものを使いたいと思っているものです---ニュー
スを読む事です。ニュースは一般的には近くの @sc{nntp} サーバーから取得さ
れ、普通は全ての人に広く利用可能なものです。もしニュースを投稿すれば、全
世界があなたがちょうど書いたものを読む可能性があり、それらは全ていたずらっ
ぽくクスクス笑われるでしょう。あなたの知らないところで。

@item メール (mail)
@cindex mail
あなたに個人的に配送されるもの全てがメールです。いくつかのニュース/メー
ルリーダー (gnus のような) はメールとニュースの違いをぼやけさせますが、
そこには違いは存在します。メールは私的です。ニュースは公的です。メールを
送信する事は投稿ではなく、返信はフォローアップではありません。

@item 返信 (reply)
@cindex reply
あなたが読んでいるものを書いた人にメールを送る事です。

@item フォローアップ (follow up)
@cindex follow up
あなたが読んでいる記事に応答して現在のニュースグループに記事を投稿する事
です。

@item バックエンド (back end)
@cindex back end
Gnus はニュースとメールの両方のいろいろなバックエンドが与えた記事を得ま
す。Gnus は、いわゆる下に横たわっているメディアを扱う事はしません---これ
はすべてバックエンドによってなされます。

@item 基本 (native)
@cindex native
Gnus はいつも一つの方法 (とバックエンド) をニュースを得るための @dfn{基
本} もしくは初期設定 として使います。

@item 外部 (foreign)
@cindex foreign
同時に任意の数の外部グループを活動状態にすることもできます。これらはニュー
スを取得するための、基本でなく、二番目でもないバックエンドを使うグループ
です。

@item 二番目 (secondary)
@cindex secondary
二番目のバックエンドは、基本と外部の間くらいにあるバックエンドで、ほとん
ど基本と同じように動作するものです。

@item 記事 (article)
@cindex article
ニュースとして投稿されたメッセージです。

@item メールメッセージ (mail message)
@cindex mail message
メールで送られたメッセージです。

@item メッセージ
@cindex message
メールメッセージもしくはニュース記事です。

@item ヘッド (head)
メッセージの最上部で、認証情報 (等) が入れられているところです。

@item 本体 (body)
@cindex body
記事の残りの部分です。ヘッドでないものはすべて本体です。

@item ヘッダー (header)
@cindex header
記事のヘッドからの行です。

@item ヘッダー群 (headers)
@cindex headers
そのような行の集合もしくは、ヘッドの集合です。もしくは、@sc{nov} 行の集
合です。

@item @sc{nov}
@cindex nov
Gnus がグループに入ると、グループの全ての未読記事のヘッダーをバックエン
ドに求めます。ほとんどのサーバーは News OverView 様式が使用可能で、それ
は普通の @sc{head} 様式よりもっと手短でもっと速く読んで解析 (parse) する
ことができます。

@item レベル (level)
@cindex levels
それぞれのグループは何らかの @dfn{レベル} か他のもの (1-9) で購読されて
います。低いレベルのものは高いレベルのものより ``より'' 購読されています。
実際のところ、レベル 1-5 のグループは @dfn{購読}; 6-7 は @dfn{未購
読}; 8 は @dfn{ゾンビ}; 9 は @dfn{切られた} と見なされます。グループをリ
ストしたり、新しいグループを走査したりする命令はすべて数値接頭引数
を @dfn{動作レベル} として使います。

@item 切られたグループ (killed groups)
@cindex killed groups
切られたグループの情報は蓄積されたり更新されたりしませんので、切られたグ
ループを購読されたグループより簡単に扱えるようになります。

@item ゾンビグループ (zombie groups)
@cindex zombie groups
ほとんど切られたグループと同じで、それより少し死んでいるだけです。

@item アクティブファイル (active file)
@cindex active file
ニュースサーバーはどの記事を運んでいるか、どのグループが存在するかを記録
しておかなければなりません。全てのこの情報は現状ファイルに蓄積され、それ
はあなたが想像するように比較的大きいです。

@item 偽グループ (bogus groups)
@cindex bogus groups
ファイル @file{.newsrc} に存在するグループですが、サーバーに知られていな
いグループ (すなわち、それはアクティブファイルにありません) は @emph{偽
グループ} です。これは、おそらく (すでに) そのグループは存在していないの
でしょう。

@item 活動化 (activating)
@cindex activating groups
サーバーにグループの情報を尋ね、未読記事の数を演算する行為は @dfn{グルー
プを活動化する} と呼ばれています。非活動グループはグループバッファ
に @samp{*} とともに一覧表示されます。

@item サーバー (server)
@cindex server
接続して、ニュース (もしくはメール) を取得する事のできるグループです。

@item 選択方法 (select method)
@cindex select method
バックエンド、サーバーと、事実上のサーバー設定を指定する構造です。

@item 事実上のサーバー (virtual server)
@cindex virtual server
命名された選択方法です。選択方法は (物理的) サーバーに接続するために必要
な方法を定義するため、物事を全体として受けるのは事実上のサーバーになりま
す。

@item 洗濯 (washing)
@cindex washing
バッファを持ってきて、何らかの種類の選別機にかける事です。結果は (多かれ
少なかれ) 元のものよりもよりきれいで喜ばしいものになるでしょう。

@item 一時グループ (ephemeral groups)
@cindex ephemeral groups
たいていのグループはどの記事を読んだかのデータを蓄積します。
@dfn{一時} グループはデータが溜められないグループです---グループを出ると、
それは天空に消え去ります。

@item 固定グループ (solid groups)
@cindex solid groups
これは一時グループの反対です。グループバッファに挙げられている全てのグルー
プは固定グループです。

@item まばら記事 (sparse articles)
@cindex sparse articles
@code{gnus-build-sparse-threads} の機能を使用しているときは、概略バッファ
に記事の入れ場所が表示されます。

@item スレッド作り (threading)
@cindex threading
それが応答した記事の直後にその記事への応答を置くことです---階層的流儀で。

@item 根 (root)
@cindex root
@cindex thread root
スレッドの最初の記事が根です。それはスレッドの全ての記事の祖先です。

@item 親 (parent)
@cindex parent
応答のある記事です。

@item 子 (child)
@cindex child
違った記事---その親 に応答する記事です。

@item 集配 (digest)
@cindex digest
複数のメッセージを一つのファイルに集めたものです。もっとも普通の集配様式
は RFC1153 で指定されています。
@end table

@page
@node Customization
@section カスタマイズ
@cindex gerenal customization

全ての変数はこのマニュアルのどこか別のところで適切に説明されています。こ
の部分は非常に良くある状況でどのように gnus をカスタマイズすれば良いかの
総合適指示先を与えるために考案されています。

@menu
* Slow/Expensive Connection::   ローカルの Emacs を立ち上げて、他のとこ
                                ろからニュースを得る事ができる。
* Slow Terminal Connection::    遠隔 Emacs を実行する
* Little Disk Space::           大きな起動ファイルを持つ事はまずい
* Slow Machine::                速い機械を買おうと感じるであろう
@end menu

@node Slow/Expensive Connection
@subsection 遅い/高い NNTP 接続

もし Emacs をローカルのマシンで実行していて、非常に細い線の向こうのマシ
ンからニュースを取得しているのであれば、gnus が @sc{nntp} サーバーから取
得するデータの総量を減らしたいと思うでしょう。

@table @code
@item gnus-read-activie-file
これを @code{nil} にして下さい。そうすれば、gnus にサーバーからアクティ
ブファイル全体を要求する事を禁止できます。このファイルはしばしば非常に大
きくなっています。それに加えて、gnus が突然とにかく現状ファイルを取得し
ようと決定しない事を確実にするために、
@code{gnus-check-new-newsgroups} と @code{gnus-check-bogus-newsgroups} も @code{nil} に
設定しなければなりません。

@item gnus-nov-is-evil
これも @code{nil} にしていなければなりません。もしそうでなければ、
@sc{nntp} サーバーから記事のヘッダーをつかんでくるのがあまり速くなりませ
ん。全ての @sc{nntp} サーバーが @sc{xover} の機能を提供しているわけでは
ありません。Gnus が自分自身でそれを検査します。
@end table

@node Slow Terminal Connection
@subsection 遅いターミナル接続。

あなたは、ホームコンピューターを Emacs と gnus を実行しているシステムに
ダイアルアップするために使っているとしましょう。もしあなたのモデムが遅け
れば、(可能な限り) 線を伝って送られているデータの総量を減らしたいと思う
でしょう。

@table @code
@item gnus-auto-center-summary
Gnus が常に概略バッファを中心再設定をすることを禁止するためにこれ
を @code{nil} に設定して下さい。これが @code{vertical} であると、垂直方
向の (vertical) 中心再設定のみをします。@code{nil} で
も @code{vertical} でも無ければ、水平方向と垂直方向の両方の中心再設定を
行います。

@item gnus-visible-headers
記事に含まれるヘッダーを最小限に減らします。実際のところ、全部なくしてし
まっても何とかなります---とにかく、たいていの役に立つデータは概略バッファ
にあります。この変数を @samp{^NEVVVVER} や @samp{From:} や、何でも好きな
ものに設定して下さい。

このフックに全ての使用可能な隠匿命令を設定します:
@lisp
(setq gnus-treat-hide-headers 'head
      gnus-treat-hide-signature t
      gnus-treat-hide-citation t)
@end lisp

@item gnus-use-full-window
これを @code{nil} に設定する事で、全てのウィンドウを小さくする事ができま
す。これは総じてそんなに減らしません。これは、記事をどっちにしろ読みたく
ないという事を決定する前に、少しの部分しか見る必要が無いという事です。

@item gnus-thread-hide-subtree
これが @code{nil} でなければ、全ての概略バッファのスレッドは初めに隠され
ます。

@item gnus-updated-mode-lines
これが @code{nil} であると、gnus はバッファのモード行に情報を入れません
ので、時間を節約できるでしょう。
@end table

@node Little Disk Space
@subsection 少しのディスク容量
@cindex disk space

起動ファイルは比較的大きくなりますので、空き容量が少なくなってきていると
きはその大きさを少し小さくしたいと思うでしょう。

@table @code
@item gnus-save-newsrc-file
これが @code{nil} であると、gnus は決して @file{.newsrc} を保存しませ
ん---それは @file{.newsrc.eld} のみを保存します。これは、gnus の他のニュー
スリーダーを使えないという事です。この変数は初期設定で @code{t} です。

@item gnus-read-newsrc-file
これが @code{nil} であれば、gnus は @file{.newsrc} を決して読みませ
ん ---@file{.newsrc.eld} だけを読みます。これは、gnus 以外のニュースリー
ダーを使えなくなる、ということです。この変数は初期設定では @code{t} です。

@item gnus-save-killed-list
これが @code{nil} であると、gnus は死んだグループのリストを保存しません。
この変数を @code{nil} に設定したときは、
@code{gnus-check-new-newsgroups} を @code{ask-server} に、
@code{gnus-check-bogus-newsgroups} を @code{nil} に設定するべきでしょう。
この変数は初期設定で @code{t} です。
@end table

@node Slow Machine
@subsection 遅い機械
@cindex slow machine

もし遅い機械を持っているか、もしくは単に本当に忍耐力がない時は、gnus の
実行を把握するためにできる事が少しあります。

起動を速くするため
に @code{gnus-check-new-newsgroups} と @code{gnus-check-bogus-newsgroups} を @code{nil} に
設定して下さい。概略バッファに入る事と抜ける事を速くするために、
@code{gnus-show-threads} と @code{gnus-use-cross-reference} と @code{gnus-nov-is-evil} を @code{nil} に
設定して下さい。

@page
@node Troubleshooting
@section 問題解決
@cindex troubleshooting

Gnus は箱から出してすぐに @emph{非常に} よく動作します---何も問題の起こ
ることは想像できません、本当に。

オッホン。

@enumerate

@item
あなたのコンピュータのスイッチが入っている事を確かめて下さい。

@item
本当に現行の gnus 版を読み込んでいる事を確認して下さい。今ま
で @sc{gnus} を実行してきたのであれば、gnus が動作するように一
度 Emacs を終了して再起動する必要があります。

@item
@kbd{M-x gnus-version} を試して下さい。もし、
@samp{T-gnus 6.15.* (based on Oort Gnus v0.*; for SEMI 1.1*, FLIM
1.1*)} のようなものが出てきたなら、正しいファイルが読み込まれています。
もし、@samp{NNTP 3.x} や @samp{nntp flee} のようなものが出てきたときは、
そこにあるいくつかの古い @file{.el} ファイルが読み込まれています。それら
を消して下さい。

@item
FAQ と how-to を読むためにヘルプグループ (グループバッファ
で @kbd{G h}) を読んで下さい。

@item
@vindex max-lisp-eval-depth
Gnus は多くの多くの再帰構造で動作し、何らかの極端な (そして非常にまれ
な) 事例では、gnus は再帰を ``あまりに深く'' 降りすぎて、Emacs があなた
にビープ音を鳴らす事があります。もしこれが起こったなら、
@code{max-lisp-eval-depth} を 500 かそれくらいの値に設定して下さい。
@end enumerate

もし他の全てが失敗したなら、バグとして問題を報告して下さい。

@cindex bugs
@cindex reporting bugs

@kindex M-x gnus-bug
@findex gnus-bug
もし gnus のバグを見つけたなら、命令 @kbd{M-x gnus-bug} によってそれを報
告する事ができます。
@kbd{M-x set-variable RET debug-on-error RET t RET} として、それから私に
バックトレースを送って下さい。私はバグを修正しようとしますが、あなたがバ
グを再現させる方法を正確に書いてくれたときのみ、それを修正する事ができま
す。

バグ報告では、詳細すぎることは決してありません。バグ報告をするときは、そ
れが使うたびに 10Kb メールを作り、もしあなたの環境を以前私に 500 回送っ
てきたとしても、命令 @kbd{M-x gnus-bug} を使って下さい。

私は、記憶という種類のものは全く持っていない事を覚えておく事も重要です。
もしあなたがバグ報告を送ると、私が返答を送ります。そして、それからあなた
が ``いや、そうではない! このばか者!'' とだけ送り返してくると、私はあな
たが何に対して私を侮辱しているかがわかりません。常に、全てを説明しすぎて
下さい。それは我々全てにとってもっと簡単になります---もし私が必要な全て
の情報を得られなかったら、私はあなたにメールを送ってさらなる情報を求め、
その結果全てがより多くの時間を取る事になります。

もしあなたの直面している問題が非常に視覚的で、それを上手く説明できない場
合は、Emacs のウィンドウをファイルにコピーして (例えば、@kbd{xwd} で)、
それをどこか手の届くどこかにおいて、その画像の URL をバグ報告に含めて下
さい。

@cindex patches
もしあなたがバグの修正や改善のためのパッチを寄稿して下さるのでしたら、す
みませんがそのパッチは @samp{diff -u} で作って下さい。

もし援助が欲しいだけであれば、@samp{gnu.emacs.gnus} で尋ねるのが良いでしょ
う。私はあまり役に立ちません。

@cindex gnu.emacs.gnus
@cindex ding mailing list
また、ding メーリングリスト---@samp{ding@@gnus.org} に訊ねる事もでき
ます。購読するためには @samp{ding-request@@gnus.org} に書いて下さい。

@page
@node Gnus Reference Guide
@section Gnus の参照ガイド

私の願いは、他の誰かが gnus でできる何か賢いものを考え出し、その上その賢
いものを書いてくれるということです。これを容易にするためには、gnus の内
部動作を記述するのが良い方法だろうと私は思いました。あと、そんなに内部じゃ
ない動作をいくつかと、私が今やってることと。

プログラムの内部構造が変更されることはない、などと思ってはいけませんが、
gnus とそのバックエンド間のインターフェース (これは完全に記述されてい
る) や、スコアファイルの形式 (これも同様)、データ構造 (これは他より変更
されやすいものもある)、操作用の一般メソッド、などを (細部にわたって) 定
義していきます。

@menu
* Gnus Utility Functions::      使用できる共通の関数と変数
* Back End Interface::          Gnus はどうやってサーバーと通信するのか
* Score File Syntax::           スコアファイル規格の BNF 定義
* Headers::                     Gnus はヘッダーを内部的にどのように格納
                                するか
* Ranges::                      たくさんの数を格納する便利な形式
* Group Info::                  グループ情報形式
* Extended Interactive::        記号接頭辞など
* Emacs/XEmacs Code::           Gnus は全ての近代 Emacsen で動作する
* Various File Formats::        Gnus の使用するファイルの形式
@end menu

@node Gnus Utility Functions
@subsection Gnus の有用な関数
@cindex Gnus utility functions
@cindex utility functions
@cindex functions
@cindex internal variables

フックなどから実行される小さな関数を書くときは、gnus の内部関数
や変数にアクセスすることは絶対必要です。以下が最もよく使われるも
のの一覧です。

@table @code
@item gnus-newsgroup-name
@vindex gnus-newsgroup-name
この変数は現在のニュースグループの名前を保持しています。

@item gnus-find-method-for-group
@findex gnus-find-method-for-group
@var{group} の選択方法を返す関数です。

@item gnus-group-real-name
@findex gnus-group-real-name
正規の (接頭辞付きの) gnus グループ名を受け取り、接頭辞無しの名前
を返します。

@item gnus-group-prefixed-name
@findex gnus-group-prefixed-name
接頭辞無しのグループ名と選択方法を受け取り、正規の (接頭辞付きの)
gnus グループ名を返します。

@item gnus-get-info
@findex gnus-get-info
@var{group} のグループ情報一覧を返します。

@item gnus-group-unread
@findex gnus-group-unread
@var{group} の未読記事の数か、もしくはそれが分からない場合は @code{t} で
す。

@item gnus-active
@findex gnus-active
@var{group} の活動登録です。

@item gnus-set-active
@findex gnus-set-active
@var{group} に活動登録を設定します。

@item gnus-add-current-to-buffer-list
@findex gnus-add-current-to-buffer-list
Gnus 終了時に消去するバッファの一覧に現在のバッファを追加します。

@item gnus-continuum-version
@findex gnus-continuum-version
引数として gnus のバージョン文字列を受け取り、浮動小数点数を返し
ます。古いバージョンは必ず新しいバージョンよりも小さい数になりま
す。

@item gnus-group-read-only-p
@findex gnus-group-read-only-p
@var{group} が読み出し専用であるかどうかを示します。

@item gnus-news-group-p
@findex gnus-news-group-p
@var{group} がニュースバックエンドであるかどうかを示します。

@item gnus-ephemeral-group-p
@findex gnus-ephemeral-group-p
@var{group} が短期グループであるかどうかを示します。

@item gnus-server-to-method
@findex gnus-server-to-method
@var{server} に対応している選択方法を返します。

@item gnus-server-equal
@findex gnus-server-equal
二つの仮想サーバーが同一のものであるかどうかを示します。

@item gnus-group-native-p
@findex gnus-group-native-p
@var{group} が基本グループであるかどうかを示します。

@item gnus-group-secondary-p
@findex gnus-group-secondary-p
@var{group} が二次グループであるかどうかを示します。

@item gnus-group-foreign-p
@findex gnus-group-foreign-p
@var{group} が外部グループであるかどうかを示します。

@item group-group-find-parameter
@findex group-group-find-parameter
@var{group} のパラメータ一覧を返します。二つ目の引数を与えると、
@var{group} 用のそのパラメータの値を返します。

@item gnus-group-set-parameter
@findex gnus-group-set-parameter
三つの引数 @var{group}, @var{parameter}, @var{value} を取ります。

@item gnus-narrow-to-body
@findex gnus-narrow-to-body
現在のバッファの記事の本文を制限表示します。

@item gnus-check-backend-function
@findex gnus-check-backend-function
二つの引数 @var{function}, @var{group} を取ります。@var{group} バックエ
ンドが @var{function} をサポートしているなら、@code{nil} 以外を返します。

@lisp
(gnus-check-backend-function "request-scan" "nnml:misc")
@result{} t
@end lisp

@item gnus-read-method
@findex gnus-read-method
利用者に選択方法をプロンプト入力してもらいます。
@end table

@node Back End Interface
@subsection バックエンドインターフェース

Gnus は @sc{nntp} やスプール、メール、仮想グループについては何にも知りま
せん。ただ仮想サーバー @dfn{virtual servers} と対話する方法を知っている
だけです。仮想サーバーはバックエンド @dfn{back end} といくつかのバックエ
ンド変数 @dfn{back end variables} からなります。前者の例として
は @code{nntp}, @code{nnspool}, @code{nnmbox} などがあります。後者の例と
しては @code{nntp-port-number} や @code{nnmbox-directory} があります。

Gnus がバックエンド --- 例えば @code{nntp} --- に何かの情報を要求すると
きは、通常関数の引数として仮想サーバー名を含めます。(もしなければ、バッ
クエンドは ``現在の'' 仮想サーバーを使用します。) 例えば、
@code{nntp-request-list} はその唯一の (省略可能な) 引数として仮想サーバー
を取ります。もしこの仮想サーバーが開かれていなければ、この関数は失敗しま
す。

仮想サーバー名は、物理的なサーバー名とは何の関係も無いことに注意してくだ
さい。この例を見てください。

@lisp
(nntp "odd-one"
      (nntp-address "ifi.uio.no")
      (nntp-port-number 4324))
@end lisp

ここで、物理サーバー名は @samp{ifi.uio.no} であるのに対し、仮想サーバー
名は @samp{odd-one} です。

バックエンドは複数の仮想サーバーを切り替え可能でなければなりません。標準
のバックエンドはこれを、仮想サーバー環境を必要なときに取り出し・押し込み
を行なう連想リストを保持することによって実現しています。

インターフェース関数は二つのグループがあります。必ず存在しなければならな
い必須関数 @dfn{required functions} と、gnus が呼び出しを行なう前にそれ
が存在するかを常に確認する任意関数 @dfn{optional functions} です。

これらの関数は全て、返却データ
を @code{nntp-server-buffer} (@samp{*nntpd*}) バッファーに返すことが求め
られます。これはちょっと不運な名前付けですが、これで我慢しなければなりま
せん。私が結果のデータ @dfn{resulting data} と言ったときは、そのバッファー
の中のデータを指しています。返却値 @dfn{return value} と言ったときは、関
数呼び出しによって返される関数の値のことを言っています。関数が失敗したと
きは返却値として@code{nil} を返さなくてはいけません。

バックエンドにはサーバー形式 @dfn{server-forming} のバックエンドであると
呼ばれるものがあり、またそう呼ばれないものもあります。後者は一般には、同
時には一つだけしか操作しないバックエンドで、``サーバー'' の概念がありま
せん。このサーバーとは、グループを持ち、そのグループに情報を配送するもの
で、それ以上のものではありません。

Gnus はグループ名と記事番号によってそれぞれのメッセージを特定します。そ
れら記事番号に関するちょっとした説明をすることは有益かもしれません。まず
第一に、その数字は正の整数です。第二に、Gnus を混乱させることなく古い記
事番号を後で再使用することは普通はできません。それは、もしあるグループが
かつて 42 番の記事を持っていたとしたら、その番号で他の記事を持つことはで
きないか、または Gnus が混乱してしまうかもしれないということです。
@footnote{See the function @code{nnchoke-request-update-info},
@ref{Optional Back End Functions}。} 第三に、記事番号はそのグループでの
到着順になっていなければならないことです。とは言えメッセージの日付も到着
順である必要はありませんが。

すでに前の節で、記事番号は一回使われただけで役目を終わらなければならな
い `厳しい' 制限について説明しました。しかし、記事番号の並びに抜けがある
と Gnus はとても混乱してしまうので、@emph{通し} 番号を付けることが有用な
のかもしれません。ただし `再使用不可' の制限があるので、いつでも番号の抜
けを回避できるとは限りません。また、可能な限り記事番号を 1 から始めるこ
とは、番号を使い切ってしまうことを避けるために役立ちます。

ここでの例と定義では、想像上のバックエンド @code{nnchoke} を引き合いに出
すことにします。

@cindex @code{nnchoke}

@menu
* Required Back End Functions::  実装しなければならない関数
* Optional Back End Functions::  実装しなくてもよい関数
* Error Messaging::             メッセージやエラー報告を得る方法
* Writing New Back Ends::       古いバックエンドの拡張
* Hooking New Back Ends Into Gnus::  Gnus 側でしなければならないこと
* Mail-like Back Ends::         メール風バックエンドのための助言
@end menu

@node Required Back End Functions
@subsubsection 必須バックエンド関数

@table @code
@item (nnchoke-retrieve-headers ARTICLES &optional GROUP SERVER FETCH-OLD)

@var{articles} は記事番号の範囲かあるいは @code{Message-ID} のリストです。
現在のバックエンドではどちらも完全にはサポートしていません --- 連続した
記事番号 (のリスト) だけで、多くのバックエンドでは @code{Message-ID} に
よる取得はサポートしていません。でもどちらもサポートしていくべきでしょう

結果のデータは HEAD か @sc{nov} 行のいずれかであり、返却値はこれを反映し
た @code{headers} か @code{nov} のいずれかでなくてはなりません。これは今
後、HEAD と @sc{nov} 行が混在する @code{various} に拡張されるかもしれま
せんが、現在の gnus ではサポートされていません。

@var{fetch-old} が @code{nil} 以外であれば、ある意味での「余分なヘッダー」
を取得しようとします。これは通常、@code{articles} の中の最小番号の記事よ
りも小さい記事から (少なくとも) @var{fetch-old} 個の余分なヘッダーを取得
し、空所を埋めることを行ないます。もしバックエンドがこの要求に従うことを
煩わしいと思った場合には、このパラメータの存在は無視されることもあります。
この値が @code{nil} でも数字でもなければ、最大限の取得を行ないます。

これが HEAD の例です。

@example
221 1056 Article retrieved.
Path: ifi.uio.no!sturles
From: sturles@@ifi.uio.no (Sturle Sunde)
Newsgroups: ifi.discussion
Subject: Re: Something very droll
Date: 27 Oct 1994 14:02:57 +0100
Organization: Dept. of Informatics, University of Oslo, Norway
Lines: 26
Message-ID: <38o8e1$a0o@@holmenkollen.ifi.uio.no>
References: <38jdmq$4qu@@visbur.ifi.uio.no>
NNTP-Posting-Host: holmenkollen.ifi.uio.no
.
@end example

つまり、返却値が @code{headers} であるときは、データバッファにこれらヘッ
ダーがいくつかあるということを意味します。

これがそのバッファーの BNF 定義です。

@example
headers        = *head
head           = error / valid-head
error-message  = [ "4" / "5" ] 2number " " <error message> eol
valid-head     = valid-message *header "." eol
valid-message  = "221 " <number> " Article retrieved." eol
header         = <text> eol
@end example

もし返却値が @code{nov} であれば、データバッファーに
は @dfn{network overview database} 行が含まれてなくてはなりません。
これは基本的には複数の欄をタブで区切ったものです。

@example
nov-buffer = *nov-line
nov-line   = 8*9 [ field <TAB> ] eol
field      = <text except TAB>
@end example

これらの欄にどのようなものが含まれるかをより詳しく見たければ、
@pxref{Headers} を参照してください。

@item (nnchoke-open-server SERVER &optional DEFINITIONS)

ここでの @var{server} は仮想サーバー名です。@var{definitions} は
この仮想サーバーを定義する @code{(VARIABLE VALUE)} 組のリストで
す。

もしサーバーを開くことができなければ、エラーはシグナルでは通知さ
れません。そしてバックエンドは、それ以後のこのサーバーへの接続要
求を拒否することもできます。実際、そうすべきです。

もしそのサーバーがすでに開いていれば、この関数は @code{nil} 以外
の値を返却しなければなりません。このとき、返される結果のデータは
ありません。

@item (nnchoke-close-server &optional SERVER)

@var{server} への接続を閉じ、これに関連するすべての資源を開放し
ます。もし何らかの理由でサーバーを閉じることができなければ、
@code{nil} を返却します。

返される結果のデータはありません。

@item (nnchoke-request-close)

全てのサーバーの接続を閉じ、バックエンドが保有している全ての資源
を開放します。このバックエンドによって作成されたバッファは全て削
除されます。(@code{nntp-server-buffer} は削除されませんが。) こ
の関数は通常、gnus が終了するときにのみ呼び出されます。

返される結果のデータはありません。

@item (nnchoke-server-opened &optional SERVER)

もし @var{server} が現在の仮想サーバーで、その物理サーバーへの接
続が生きていれば、この関数は @code{nil} 以外の値を返します。この
関数はどんな場合でも、接続が失われたサーバーへの再接続を行なうこ
とはありません。

返される結果のデータはありません。

@item (nnchoke-status-message &optional SERVER)

この関数は @var{server} からの最後のエラーメッセージを返却します。

返される結果のデータはありません。

@item (nnchoke-request-article ARTICLE &optional GROUP SERVER TO-BUFFER)

この関数の結果のデータは、@var{article} で指定された記事です。この指定
は @code{Message-ID} か番号のいずれかです。@code{Message-ID} による記事
の取得を実装するかどうかは任意ですが、可能であると嬉しいですね。

@var{to-buffer} が @code{nil} 以外であれば、結果のデータは通常のデータバッ
ファの代わりに、このバッファに返されます。これにより多量のデータをあるバッ
ファから別のバッファにコピーすることを避けることができ、そして gnus は通
常、記事バッファに直接記事を挿入するように要求しています。

もし可能であるのなら、この関数は、@code{car}が取得した記事のあるグループ
名で、@code{cdr} が記事番号である cons セルを返すべきです。これによ
り @code{Message-ID} によって記事を取得したとき、gnus が本当のグループと
記事番号を知ることができるようになるでしょう。これが不可能な場合には、記
事の取得が成功したときは @code{t} を返します。

@item (nnchoke-request-group GROUP &optional SERVER FAST)

@var{group} のデータを取得します。この関数は、@var{group} を現在のグルー
プにする、という副作用もあります。

@var{fast} があれば、便利なデータを返す面倒を行なわずに、単に
@var{group} を現在のグループにします。

これが結果のデータの例と、それの定義です。

@example
211 56 1000 1059 ifi.discussion
@end example

最初の数字は状態で、これは 211 でなくてはなりません。次はそのグループに
ある記事の総数、最小の記事番号、最大の記事番号、そして最後がグループ名で
す。記事の総数は、最大・最小記事番号から単純に考えられる数よりも小さいこ
とがあることに注意してください。いくつかの記事は取り消されているかもしれ
ません。Gnus は総数は単に捨ててしまっているので、(もしそれが問題となると
きに) 正しい値を生成する面倒を負うべきかどうかは、読者への課題として残し
てあります。もしそのグループに記事が無ければ、最小記事番号は 1、最大
は 0 として報告されなければなりません。

@example
group-status = [ error / info ] eol
error        = [ "4" / "5" ] 2<number> " " <Error message>
info         = "211 " 3* [ <number> " " ] <string>
@end example

@item (nnchoke-close-group GROUP &optional SERVER)

@var{group} を閉じ、それに接続されている全ての資源を開放します。これはほ
とんどのバックエンドでは何もすることがないでしょう。

返される結果のデータはありません。

@item (nnchoke-request-list &optional SERVER)

@var{server} 上で利用可能な全てのグループの一覧を返します。これ
は @emph{全部} という意味です。

これが、たった二つしかグループを持っていないサーバーからの例です。

@example
ifi.test 0000002200 0000002000 y
ifi.discussion 3324 3300 n
@end example

各行にはグループ名があり、そしてそのグループ内の最大の記事番号、最小の記
事番号、そして最後にフラグです。もしそのグループに記事が無ければ、最小記
事番号は 1、最大は 0 として報告されなければなりません。

@example
active-file = *active-line
active-line = name " " <number> " " <number> " " flags eol
name        = <string>
flags       = "n" / "y" / "m" / "x" / "j" / "=" name
@end example

フラグは、そのグループが読み出し専用 (@samp{n}) であるか、司会者付
き (@samp{m}) であるか、死んでいる (@samp{x}) か、どこか他のグループの別
名 (@samp{=other-group}) であるか、上記のどれでもない (@samp{y}) か、と
いうことを示しています。

@item (nnchoke-request-post &optional SERVER)

この関数は、現在のバッファを投稿します。これは投稿が成功したかどうかを返
却しても構いませんが、必須ではありません。例えば、投稿が非同期に行われる
のであれば、この関数が終了した時点では投稿は普通完了していません。その場
合この関数は、投稿を完了させることができないとき、それをはっきりと利用者
に知らせる見張り関数のようなものを設定するべきでしょう。

この関数から返される結果のデータはありません。
@end table

@node Optional Back End Functions
@subsubsection 任意バックエンド関数

@table @code
@item (nnchoke-retrieve-groups GROUPS &optional SERVER)

@var{groups} はグループのリストであり、この関数はそれら全部のグ
ループのデータを要求します。どうやってそれを行なうかは gnus の知っ
たことではありませんが、これはできるだけ迅速な方法で行なわなけれ
ばなりません。

この関数の返却値は @code{active} か @code{group} のいずれかで、
結果のデータの形式が何であるかを示します。前者
は @code{nnchoke-request-list} によるデータと同じ形式であり、一方後
者は @code{nnchoke-request-group} が与えるものと同じ形式の行でバッ
ファは埋められます。

@example
group-buffer = *active-line / *group-status
@end example

@item (nnchoke-request-update-info GROUP INFO &optional SERVER)

Gnus グループ情報 (@pxref{Group Info}) が変更箇所としてバックエ
ンドに渡されます。これはバックエンドが (仮想グループや imap グルー
プの場合のように) 本当に全ての情報を持っている場合に便利になりま
す。この関数は、その要求に適合させる情報を破壊的に置き換え、そ
の (置き換えられた) グループ情報を返します。

この関数から返される結果のデータはありません。

@item (nnchoke-request-type GROUP &optional ARTICLE)

利用者が ``ニュースを送信する'' 命令 (例えば、概略バッファで @kbd{F}) を
実行したとき、gnus は利用者がフォローアップしようとしている記事がニュー
スであるかメールであるかを知らなくてはなりません。この関数
は @var{group} の中の @var{article} がニュースであれば @code{news} を、
メールであれば @code{mail} を、その種別を決定できなけれ
ば @code{unknown} を返却します。(@var{article} 引数は、メールグループと
ニュースグループがごちゃまぜになってるかもしれない @code{nnvirtual} にお
いて必要です。) @var{group} と@var{article} は両方とも @code{nil} である
かもしれません。

この関数から返される結果のデータはありません。

@item (nnchoke-request-set-mark GROUP ACTION &optional SERVER)

記事の印を設定/消去/追加します。普通は gnus は記事の印 (既読、可視、時限
消去など) を内部で扱い、@code{~/.newsrc.eld} に保存します。しかし、バッ
クエンドには (@sc{imap} のように) 記事の全ての情報をサーバーに収めるの
で、gnus は印の情報をサーバーに伝達しなければならないものがあります。

ACTION はこのような様式の印設定の要求のリストです:

@example
(RANGE ACTION MARK)
@end example

RANGE は印を付けたい記事の範囲です。ACTION は @code{add} また
は @code{del} で、印を追加したり消します (言及されていないすべての印は保
存します)、印の消去 (言及されていない印は保存します) です。MARK は印
のリストです。それぞれの印はシンボルです。現在使われている印
は @code{read}, @code{tick}, @code{reply}, @code{expire}, @code{killed},
@code{dormant}, @code{save}, @code{download},  @code{unsend},
@code{forward} および @code{recent} ですが、もし可能なら、あなたのバック
エンドはこれらに制限をするべきではありません。

矛盾する動作が指定されたとき、リストの最後の動作が効力を持つものになりま
す。すなわち、動作に記事 1 に @code{可視} 印を追加する要求があり、リスト
の後で同じ記事から印を消去することを要求していれば、印は実際に消去される
べきです。

動作リストの例です:

@example
(((5 12 30) 'del '(tick))
 ((10 . 90) 'add '(read expire))
 ((92 94) 'del '(read)))
@end example

関数は印を設定できなかった記事の範囲を返すべきです (現在は全く使われてい
ません)。

この関数からは結果のデータはありません。

@item (nnchoke-request-update-mark GROUP ARTICLE MARK)

もし利用者が、このバックエンドの気に入らない印を設定しようとしたら、この
関数が印を変更することができます。Gnus はもとの @var{mark} の代わりに、
この関数が返したものを @var{article} への印として使います。バックエンド
が気にすることが特になければ、元の @var{mark} を返さなければなりません。
@code{nil} やその他のゴミを返してはいけません。

私が知っているこれのこれの利用法は、@code{nnvirtual} が行なっていること
だけです --- もし構成グループが自動期限切れ消去可能であれば、この仮想グ
ループで既読の印を付けると、結果としてその記事に期限切れ消去の印が付けら
れます。

この関数から返される結果のデータはありません。

@item (nnchoke-request-scan &optional GROUP SERVER)

この関数は、バックエンドが到着記事を確認する要求を行なうときにいつで
も (gnus かそれ以外によって)、あれやこれやと呼び出されることがあります。
メールバックエンドはこの関数が起動されたとき、典型的にはスプールファイル
を読むか POP サーバーに問い合わせにいきます。@var{group} は特に気に留め
る必要はありません --- もしバックエンドが、一つだけのグループを走査する
のは大変すぎると判断した場合には、全グループの全走査を行なっても構いませ
ん。ですが、実用的にできればそれを局所的に閉じておく方が良いでしょう。

この関数に返される結果のデータはありません。

@item (nnchoke-request-group-description GROUP &optional SERVER)

この関数によって返される結果のデータは、@var{group} の説明です。

@example
description-line = name <TAB> description eol
name             = <string>
description      = <text>
@end example

@item (nnchoke-request-list-newsgroups &optional SERVER)

この関数によって返される結果のデータは、サーバー上で利用できるグ
ループ全ての説明です。

@example
description-buffer = *description-line
@end example

@item (nnchoke-request-newgroups DATE &optional SERVER)

この関数から返される結果のデータは、@samp{date} 以降に作成された全てのグ
ループです。@samp{date} は通常の人間が読める日付の形式 (すなわち、メール
やニュースのヘッダーで使われる形式で、ディフォルトでは関
数 @code{message-make-date} から返されたもの) です。データは active バッ
ファの形式でなければなりません。

この関数が多すぎるグループを返してもオーケイです。いくつかのバックエンド
は新しいグループを見つけるよりも、楽をして全てのグループのリストを返すか
もしれません。しかしバックエンドが返す多くのグループに対してこれ (訳注:
新しいグループとして扱うこと) をしてはいけません。普通、ユーザー自身が作っ
たグループならば多すぎることはないでしょう。ですから @code{nnml} とそれ
に類するものはたぶん心配ありません。しかし @code{nntp} のようなバックエ
ンドではグループはサーバーによって作られていますから、多くのグループが返っ
てくることがありえます。

@item (nnchoke-request-create-group GROUP &optional SERVER)

この関数は、@var{group} という名前の空のグループを作成します。

返される結果のデータはありません。

@item (nnchoke-request-expire-articles ARTICLES &optional GROUP SERVER FORCE)

この関数は、@var{articles} の範囲の全ての記事に対して期限切れ消去処理を
行ないます。(@var{articles} は現在は記事番号の単純なリストです。) この
関数で消去される前の、記事がどれだけ古い記事であるかの決定はバックエンド
に任されています。@var{force} が @code{nil} 以外であれば、それがどんなに
新しいものであっても、全ての@var{articles} が消去されます。

この関数は削除しなかった、あるいは削除することができなかった記事のリスト
を返します。

返される結果のデータはありません。

@item (nnchoke-request-move-article ARTICLE GROUP SERVER ACCEPT-FORM
&optional LAST)

この関数は @var{article} (番号) を、@var{group} か
ら @var{accept-form} を呼び出して移動します。

この関数は、問題の記事を移動させるための準備として、記事に付加されたヘッ
ダー行を全て削除し、一般に記事を「きれいさっぱり」にします。そして ``き
れいな'' 記事のあるバッファーで @var{accept-form} を @code{eval} します。
これは本当に複製を行ないます。もし @code{eval} が @code{nil} 以外の値を
返したら、その記事は削除されません。

@var{last} が @code{nil} であれば、この直後にさらに要求が発行される見込
みが高い、という意味になり、これによって最適化がいくらかできるようになり
ます。

この関数は、グループ名が @code{car} で、その記事の移動先の記事番号が
@code{cdr} である cons セルを返します。

返される結果のデータはありません。

@item (nnchoke-request-accept-article GROUP &optional SERVER LAST)

この関数は、現在のバッファを取り、それを @var{group} の中に挿入します。
@var{last} が @code{nil} であれば、この関数へのさらなる呼び出しが直ちに
行われるという意味です。

この関数はグループ名が @code{car} で、その記事の移動先の記事番号が
@code{cdr} である cons セルを返します。

返される結果のデータはありません。

@item (nnchoke-request-replace-article ARTICLE GROUP BUFFER)

この関数は @var{article} (番号) を @var{group} から削除し、代わりに
@var{buffer} をそこに挿入します。

返される結果のデータはありません。

@item (nnchoke-request-delete-group GROUP FORCE &optional SERVER)

この関数は @var{group} を消去します。もし @var{force} があれば、そのグ
ループ内の全ての記事を本当に消去し、そしてそのグループ自身を消去します。
(もし ``グループ自身'' というものがあれば。)

返される結果のデータはありません。

@item (nnchoke-request-rename-group GROUP NEW-NAME &optional SERVER)

この関数は @var{group} から @var{new-name} に名前を変更します。
@var{group} 内にある記事は全て @var{new-name} に移動します。

返される結果のデータはありません。
@end table

@node Error Messaging
@subsubsection エラーメッセージ表示

@findex nnheader-report
@findex nnheader-get-report
バックエンドはエラー状況を報告するのに @code{nnheader-report} を使わなく
てはなりません --- 要求を実行できないときにエラーを生起させてはいけませ
ん。この関数の最初の引数はバックエンド名のシンボルで、残りは、複数の引数
があれば @code{format} への引数として解釈され、一つであればただの文字列
になります。この関数は常に@code{nil} を返さなくてはなりません。

@lisp
(nnheader-report 'nnchoke "You did something totally bogus")

(nnheader-report 'nnchoke "Could not request group %s" group)
@end lisp

一方 gnus は、サーバーから @code{nil} を返されたとき
に @code{nnheader-get-report} を呼び出し、そしてこの関数が問題のバックエ
ンドに対して最後に報告されたメッセージを返します。この関数は一つの引
数 --- サーバーのシンボルを取ります。

内部的には、これらの関数は @var{back-end}@code{-status-string} にアクセス
ます、つまり @code{nnchoke} バックエンドはそのエラーメッセージ
を @code{nnchoke-status-string} に格納します。

@node Writing New Back Ends
@subsubsection 新しいバックエンドを書く

多くのバックエンドはとても類似しています。
@code{nnml} は @code{nnspool} にとても似ていますが、サーバー上の記事を編
集することができます。@code{nnmh} は @code{nnml} にとても似ていますが、
これはアクティブファイルを使わず、概要データベースも保持しません。
@code{nndir} は @code{nnml} にとても似ていますが、これには ``グループ''
の概念はなく、記事の修正はできません。

新しいバックエンドを書くときに他のバックエンドから関数を ``継承'' するこ
とが可能であってほしい、と思うのは理に適っています。そしてまさに、あなた
がそうしたければ、それができるのです。(あなたがそうしたくなければしなく
ても良いですよ、もちろん。)

全てのバックエンドは公開変数と公開関数を、@code{nnoo} と呼ばれるパッケー
ジを使って宣言します。

他のバックエンドから関数を継承するには (そして現在のバックエンドから他の
バックエンドに関数を継承できるようにするには)、以下のマクロを使用しなけ
ればなりません。

@table @code
@item nnoo-declare
このマクロは、最初の引数を、その後に続く引数の子供であることを宣言します。
例えば、

@lisp
(nnoo-declare nndir
  nnml nnmh)
@end lisp

これで @code{nndir}は、@code{nnml} と @code{nnmh} の両方から関数を継承し
ようとしていることを宣言します。

@item defvoo
このマクロは @code{defvar} と同義ですが、その変数を公開サーバー変数とし
て登録します。ほとんどの状態指向型の変数は @code{defvar} ではな
く @code{defvoo} によって宣言するべきです。

通常の @code{defvar} 引数に加えて、このマクロは親バックエンドの変数のリ
ストを取り、この関数がそのバックエンド内で実行されるときに変数を置き換え
ます。

@lisp
(defvoo nndir-directory nil
  "Where nndir will look for groups."
  nnml-current-directory nnmh-current-directory)
@end lisp

これは @code{nndir} のために @code{nnml} の関数が呼び出されたときに、
@code{nnml-current-directory} は @code{nndir-directory} に設定されるとい
う意味です。(@code{nnmh} も同様です。)

@item nnoo-define-basics
このマクロは、ほとんど全部のバックエンドが持つべき共通関数をいくつか定義
します。

@example
(nnoo-define-basics nndir)
@end example

@item deffoo
このマクロはまさに @code{defun} のようなもので、同一の引数を取ります。通
常の @code{defun} 処理に加えて、このマクロはその関数を公開しているものと
して登録し、他のバックエンドがそれを継承できるようにします。

@item nnoo-map-functions
このマクロは現在のバックエンドの関数から親バックエンドの関数への置き換え
を行なえるようにします。

@example
(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0))
@end example

これは @code{nndir-retrieve-headers} が呼び出されたとき、一番目、三番目、
四番目の引数が @code{nnml-retrieve-headers} に渡され、一方、二番目の引数
は @code{nndir-current-group} の値として設定される、という意味です。

@item nnoo-import
このマクロは他のバックエンドから関数を取り込みます。これは単にまだ定義さ
れていない関数を定義するだけなので、ソースファイルの最後の処理として書か
なければなりません。

@example
(nnoo-import nndir
  (nnmh
   nnmh-request-list
   nnmh-request-newgroups)
  (nnml))
@end example

これは、@code{nndir-request-list} への呼び出しは単
に @code{nnmh-request-list} に引き渡され、一方、@code{nnml} の公開関数で
まだ @code{nndir} で定義されていないものをここで定義します。
@end table

以下は @code{nndir} バックエンドのちょっと短縮した版です。

@lisp
;;; nndir.el --- single directory newsgroup access for Gnus
;; Copyright (C) 1995,96 Free Software Foundation, Inc.

;;; Code:

(require 'nnheader)
(require 'nnmh)
(require 'nnml)
(require 'nnoo)
(eval-when-compile (require 'cl))

(nnoo-declare nndir
  nnml nnmh)

(defvoo nndir-directory nil
  "Where nndir will look for groups."
  nnml-current-directory nnmh-current-directory)

(defvoo nndir-nov-is-evil nil
  "*Non-nil means that nndir will never retrieve NOV headers."
  nnml-nov-is-evil)

(defvoo nndir-current-group ""
  nil
  nnml-current-group nnmh-current-group)
(defvoo nndir-top-directory nil nil nnml-directory nnmh-directory)
(defvoo nndir-get-new-mail nil nil nnml-get-new-mail nnmh-get-new-mail)

(defvoo nndir-status-string "" nil nnmh-status-string)
(defconst nndir-version "nndir 1.0")

;;; Interface functions.

(nnoo-define-basics nndir)

(deffoo nndir-open-server (server &optional defs)
  (setq nndir-directory
        (or (cadr (assq 'nndir-directory defs))
            server))
  (unless (assq 'nndir-directory defs)
    (push `(nndir-directory ,server) defs))
  (push `(nndir-current-group
          ,(file-name-nondirectory
            (directory-file-name nndir-directory)))
        defs)
  (push `(nndir-top-directory
          ,(file-name-directory (directory-file-name nndir-directory)))
        defs)
  (nnoo-change-server 'nndir server defs))

(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0)
  (nnmh-request-group nndir-current-group 0 0)
  (nnmh-close-group nndir-current-group 0))

(nnoo-import nndir
  (nnmh
   nnmh-status-message
   nnmh-request-list
   nnmh-request-newgroups))

(provide 'nndir)
@end lisp

@node Hooking New Back Ends Into Gnus
@subsubsection 新しいバックエンドを gnus に繋げる

@vindex gnus-valid-select-methods
@findex gnus-declare-backend
あなたの新しいバックエンドを gnus で使いはじめるのはとても簡単で
す --- 単に @code{gnus-declare-backend} 関数で宣言するだけです。これはバッ
クエンドを @code{gnus-valid-select-methods} 変数に追加します。

@code{gnus-declare-backend} は二つの引数を取ります --- バックエンドの名
前と適当な数の能力 @dfn{abilities} です。

これが例です。

@lisp
(gnus-declare-backend "nnchoke" 'mail 'respool 'address)
@end lisp

そして上記の行は @file{nnchoke.el} ファイルに入れます。

能力には以下のものがあります。

@table @code
@item mail
これはメール風バックエンドです --- フォローアップは (たいていは) メール
で送られます。
@item post
これはニュース風バックエンドです --- フォローアップは (たいていは) ニュー
スで送られます。
@item post-mail
このバックエンドはメールとニュースの両方をサポートします。
@item none
これはニュースでもメールでもないバックエンドです --- 全く違った何かです。
@item respool
これは再スプールをサポートします --- というよりは、その元の記事とグルー
プを修正することができます。
@item address
仮想サーバー名の中にサーバーの名前が含まるということです。これはほとんど
全部のバックエンドで必要になります。
@item prompt-address
グループバッファで @kbd{B} などでこの命令を実行したとき、ユーザはアドレ
スのプロンプト入力を求められます。これは例えば、@code{nntp} のようなバッ
クエンドでは必要で、@code{nnmbox} では必要ではありません。
@end table

@node Mail-like Back Ends
@subsubsection メール風バックエンド

メールバックエンドがその他のバックエンドに対して一線を画している点は、ほ
とんどのメールバックエンドは @file{nnmail.el} の中の共通関数に強く依存し
ているという点です。例えば、@code{nnml-request-scan} の定義はこのように
なります。

@lisp
(deffoo nnml-request-scan (&optional group server)
  (setq nnml-article-file-alist nil)
  (nnmail-get-new-mail 'nnml 'nnml-save-nov nnml-directory group))
@end lisp

単に @code{nnmail-get-new-mail} にいくつか引数を与えて呼び出すだけで、
@code{nnmail} がメールの移動や分離を全ての面倒を見てくれます。

この関数は四つの引数を取ります。

@table @var
@item method
これは、この呼び出しをどのバックエンドが責任を負うかを指示するシンボルで
す。

@item exit-function
この関数は分離が実行された後に呼び出されます。

@item temp-directory
一時ファイルを格納する場所です。

@item group
この省略可能な引数は、分離が一つのグループに対してのみ実行されるべきであ
るときのグループ名です。
@end table

@code{nnmail-get-new-mail} は各記事を保存するため
に @var{back-end}@code{-save-mail} を呼び出します。
@var{back-end}@code{-active-number} はこの記事に割り当てられた記事番号を
調べるために呼び出されます。

この関数は次の変数も使用します。
@var{back-end}@code{-get-new-mail} (このバックエンドの新着メールを調べる
かどうか) と、新しいアクティブファイルを生成するため
の @var{back-end}@code{-group-alist} と @var{back-end}@code{-active-file} で
す。@var{back-end}@code{-group-alist} グループのアクティブ連想リストで、
以下のようなものです。

@example
(("a-group" (1 . 10))
 ("some-group" (34 . 39)))
@end example

@node Score File Syntax
@subsection スコアファイルの構文

スコアファイルは簡単に分析可能で、しかし非常に柔軟なように意図されていま
す。それには Emacs Lisp のリストと同じ読み込み構文な様なものがその指定に
合うだろうという事が決定されました。

これは良くあるスコアファイルです:

@lisp
(("summary"
  ("win95" -10000 nil s)
  ("Gnus"))
 ("from"
  ("Lars" -1000))
 (mark -100))
@end lisp

スコアファイルの BNF 定義です。

@example
score-file      = "" / "(" *element ")"
element         = rule / atom
rule            = string-rule / number-rule / date-rule
string-rule     = "(" quote string-header quote space *string-match ")"
number-rule     = "(" quote number-header quote space *number-match ")"
date-rule       = "(" quote date-header quote space *date-match ")"
quote           = <ascii 34>
string-header   = "subject" / "from" / "references" / "message-id" /
                  "xref" / "body" / "head" / "all" / "followup"
number-header   = "lines" / "chars"
date-header     = "date"
string-match    = "(" quote <string> quote [ "" / [ space score [ "" /
                  space date [ "" / [ space string-match-t ] ] ] ] ] ")"
score           = "nil" / <integer>
date            = "nil" / <natural number>
string-match-t  = "nil" / "s" / "substring" / "S" / "Substring" /
                  "r" / "regex" / "R" / "Regex" /
                  "e" / "exact" / "E" / "Exact" /
                  "f" / "fuzzy" / "F" / "Fuzzy"
number-match    = "(" <integer> [ "" / [ space score [ "" /
                  space date [ "" / [ space number-match-t ] ] ] ] ] ")"
number-match-t  = "nil" / "=" / "<" / ">" / ">=" / "<="
date-match      = "(" quote <string> quote [ "" / [ space score [ "" /
                  space date [ "" / [ space date-match-t ] ] ] ] ")"
date-match-t    = "nil" / "at" / "before" / "after"
atom            = "(" [ required-atom / optional-atom ] ")"
required-atom   = mark / expunge / mark-and-expunge / files /
                  exclude-files / read-only / touched
optional-atom   = adapt / local / eval
mark            = "mark" space nil-or-number
nil-or-number   = "nil" / <integer>
expunge         = "expunge" space nil-or-number
mark-and-expunge = "mark-and-expunge" space nil-or-number
files           = "files" *[ space <string> ]
exclude-files   = "exclude-files" *[ space <string> ]
read-only       = "read-only" [ space "nil" / space "t" ]
adapt        = "adapt" [ space "ignore" / space "t" / space adapt-rule ]
adapt-rule      = "(" *[ <string> *[ "(" <string> <integer> ")" ] ")"
local           = "local" *[ space "(" <string> space <form> ")" ]
eval            = "eval" space <form>
space           = *[ " " / <TAB> / <NEWLINE> ]
@end example

スコアファイルの認識不可能な要素は無視されるべきですが、捨てられるわけで
はありません。

ご覧の通り、空白が必要ですが、空白の量と型は無関係です。これはスコアファ
イルの様式はプログラマーに任されているという事です---全てを一つの長ーー
い行に吐き出すのが簡単であれば、それは構いません。

いろいろなアトムの意味はこのマニュアルのどこかで説明されていま
す (@pxref{Score File Format})。

@node Headers
@subsection ヘッダー

内部的には gnus は不思議な流儀で、@sc{nov} 様式に対応する記事のヘッダー
を溜めておく様式を使います。ある人は、作者が @sc{nov} の仕様を見て恥じる
事無く全てを @emph{盗んだ} と思うかもしれませんが、その人は正しいです。

@dfn{ヘッダー} は非常に負担のかけられすぎた語です。
``ヘッダー'' は RFC1036 では記事の頭の行の事 (例えば、@code{From}) を話
すのに用いられています。それは多くの人か
ら ``ヘッド''---``ヘッダーと本体'' の同義語として使われています。(これ
は、私の意見では避けられるべきです。) そして、gnus は内部で
は ``ヘッダー'' と呼ぶ様式を使っており、私はここでそれについて説明します。
これは九つの要素からなるベクトルで、基本的に、それぞれのヘッ
ダー (あ痛) が一つの空き場所を占めています。

これらの空き場所は、順番
に: @code{number}, @code{subject}, @code{from}, @code{date}, @code{id}, @code{chars}, @code{lines}, @code{xref}, @code{extra} で
す。これらの空き場所に触って設定するマクロがあります---それらは全て、そ
れぞれ @code{mail-header-} と @code{mail-header-set-} いう予想される名前
を持っています。

@code{extra} の場所はヘッダー/値の対の連想リストである以外はこれらの全て
の場所は文字列です (@pxref{To From Newsgroups})。

@node Ranges
@subsection 範囲

@sc{gnus} は私には非常に役に立つと思われる概念を導入しましたので、私はそ
れをたくさん使い、かなり念入りに作り上げてきました。

質問は単純です: もしあなたが大量の数字により同一性を保証される も
の (object) (@emph{乱暴な} 例を挙げると、記事がそうで
す) を ``含まれている'' として見なしたいときは、普通の連続的行為はあまり
役に立ちません。(長さ 200,000 の連続物は少し息が長すぎます。)

これの解決策は質問と同じくらい単純です。単にその連続物を壊せば良いだけで
す。

@example
(1 2 3 4 5 6 10 11 12)
@end example

は次のものに変形されます。

@example
((1 . 6) (10. 12))
@end example

あの嫌な @samp{(13. 13)} のような要素を避けるために、それのみの も
の (object) を示すために @samp{13} は有効な要素になっています。

@example
((1 . 6) 7 (10 . 12))
@end example

これは二つの範囲を比較してそれが等価 (equal) であるかを調べる事は少し手
のこんだことになります:

@example
((1 . 5) 7 8 (10 . 12))
@end example

と

@example
((1 . 5) (7. 8) (10 . 12))
@end example

は等価です。実際のところ、下降しないリストは範囲です:

@example
(1 2 3 4 5)
@end example

は完全に有効な範囲です。とても息の長いものですが。これも有効です:

@example
(1 . 5)
@end example

そして、これは前の範囲と等価です。

これは範囲の BNF 定義です。もちろん、数字の意味上の要求は下降していない
という事は覚えておく必要があります。(任意の回数の同じ数字の繰り返しは許
されていますが、範囲の扱いからは消え去る傾向があります。)

@example
range           = simple-range / normal-range
simple-range    = "(" number " . " number ")"
normal-range    = "(" start-contents ")"
contents        = "" / simple-range *[ " " contents ] /
                  number *[ " " contents ]
@end example

Gnus は現在のところ既読記事と記事の印の情報を付けておくために範囲を使っ
ています。私は 次の権力者 が私にさせてくれるのであれば、C で数の範囲の実
装を計画しています。(私はまだその人に尋ねていません。と言うのは、私はそ
れを普通の連続物に変換し直さないで世の中を完全に範囲に基づいたものにする
ためにもう少し考える必要があるからです。)

@node Group Info
@subsection グループ情報

Gnus はグループの全ての永続情報を @dfn{group info} リストに保存します。
このリストの長さは 3 から 6 (もしくはもっと) の要素で徹底的にグループを
記述します。

ここにあるのはグループ情報 (group info) の二つの例です。一つは非常に単純
なグループで、二つめはもっと複雑なものです:

@example
("no.group" 5 ((1 . 54324)))

("nnml:my.mail" 3 ((1 . 5) 9 (20 . 55))
                ((tick (15 . 19)) (replied 3 6 (19 . 3)))
                (nnml "")
                ((auto-expire . t) (to-address . "ding@@gnus.org")))
@end example

最初の要素は @dfn{グループ名} です---どのようにしろ、gnus がそれによって
グループを知っているものです。二番目の要素は @dfn{購読度} で、普通は小さ
な整数です。(それは @dfn{階級} になる事もできます。それは、コンスセルで、
@code{car} がレベルで、@code{cdr} がスコアです。) 三番目の要素は既読記事
の範囲のリストです。四番目の要素はいろいろな種類の記事の印のリストのリス
トです。五番目の要素は選択方法です (もしくは、こちらの方が良いのであれば
事実上のサーバーです)。六番目の要素は @dfn{グループパラメータ} のリスト
で、この部分はそのためにあります。

最後の三つの要素はどれでも、必要が無ければ存在しない事もあります。実際、
グループの非常に大部分は最初の三つの要素だけを持ち、それはたくさんのコン
スセルを節約する事ができます。

これはグループ情報様式の BNF 定義です:

@example
info          = "(" group space ralevel space read
                [ "" / [ space marks-list [ "" / [ space method [ "" /
                space parameters ] ] ] ] ] ")"
group         = quote <string> quote
ralevel       = rank / level
level         = <integer in the range of 1 to inf>
rank          = "(" level "." score ")"
score         = <integer in the range of 1 to inf>
read          = range
marks-lists   = nil / "(" *marks ")"
marks         = "(" <string> range ")"
method        = "(" <string> *elisp-forms ")"
parameters    = "(" *elisp-forms ")"
@end example

実のところ法則 @samp{marks} は嘘です。
@samp{marks} は @samp{<string>} が @samp{range} の上に構成されているもの
ですが、疑似 BNF でそれを現すのは不愉快なものです。

もし gnus 情報を持っていて、要素を調べたいのときは、gnus はそれらの要素
を取得/設定 (get/set) するための一連のマクロを提供しています。

@table @code
@item gnus-info-group
@itemx gnus-info-set-group
@findex gnus-info-group
@findex gnus-info-set-group
グループ名を取得/設定 (get/set) します。

@item gnus-info-rank
@itemx gnus-info-set-rank
@findex gnus-info-rank
@findex gnus-info-set-rank
グループの階級 (rank) を取得/設定します (@pxref{Group Score})。

@item gnus-info-level
@itemx gnus-info-set-level
@findex gnus-info-level
@findex gnus-info-set-level
グループのレベルを取得/設定します。

@item gnus-info-score
@itemx gnus-info-set-score
@findex gnus-info-score
@findex gnus-info-set-score
グループスコアを取得/設定します (@pxref{Group Score})。

@item gnus-info-read
@itemx gnus-info-set-read
@findex gnus-info-read
@findex gnus-info-set-read
既読記事の範囲を取得/設定します。

@item gnus-info-marks
@itemx gnus-info-set-marks
@findex gnus-info-marks
@findex gnus-info-set-marks
印しつき記事の範囲のリストを取得/設定します。

@item gnus-info-method
@itemx gnus-info-set-method
@findex gnus-info-method
@findex gnus-info-set-method
グループ選択方法を取得/設定します。

@item gnus-info-params
@itemx gnus-info-set-params
@findex gnus-info-params
@findex gnus-info-set-params
グループパラメータを取得/設定します。
@end table

全ての取得関数は一つの引数を取ります---情報のリストです。設定関数は二つ
の引数を取ります---情報リストと新しい値です。

グループ情報の最後の三つの要素は強制的なものではありませんので、要素を設
定する前にグループ情報を拡張する必要があるかも知れません。もしこれが必要
な場合は、これが自動的に起こるために @code{nil} でない三番目の引数を三つ
の最終設定関数に与えるだけです。

@node Extended Interactive
@subsection 拡張対話
@cindex interactive
@findex gnus-interactive

Gnus は Emacs の標準の @code{interactive} 指定をシンボル接頭辞を簡単に使
えるために少し拡張しています (@pxref{Symbolic Prefixes})。これはその使い
方の例です:

@lisp
(defun gnus-summary-increase-score (&optional score symp)
  (interactive (gnus-interactive "P\ny"))
  ...
  )
@end lisp

最上の方法は @code{gnus-interactive} を式 @code{interactive} を返すマク
ロとして実装する事でしょうが、これは Emacs は関数が対話的であるかどうか
をラムダ式に対して単純に @code{assq} を行う事により調べる事から不可能で
す。

この関数は (ほとんど) 全ての @code{interactive} 指定を受付けますが、もう
少し加えます。

@table @samp
@item y
@vindex gnus-current-prefix-symbol
現在の接頭引数シンボル---変数 @code{gnus-current-prefix-symbol} です。

@item Y
@vindex gnus-current-prefix-symbols
現在の接頭引数シンボルのリストです---変
数 @code{gnus-current-prefix-symbol} です。

@item A
現在の記事番号です---関数 @code{gnus-summary-article-number} です。

@item H
現在の記事ヘッダーです---関数 @code{gnus-summary-article-header} です。

@item g
現在のグループ名です---関数 @code{gnus-group-group-name} です。
@end table

@node Emacs/XEmacs Code
@subsection Emacs/XEmacs コード
@cindex XEmacs
@cindex Emacsen

Gnus は Emacs, XEmacs と Mule で動作しますので、そのうちの一つを主環境と
する事に決めました。私は Emacs を選びました。私が XEmacs や Mule を好き
ではないと言う事ではなく、それがアルファベットで最初に来たからです。

これは gnus は Emacs で全く警告なくバイトコンパイルできるのに対して、
XEmacs はバイトコンパイルをしている間にギガバイトくらいの警告を出すと言
う事です。私は些細な失敗を見つけ出すことを助けるためにバイトコンパイルの
警告を使っていますので、それは非常に役に立ちます。

私は継続的に Emacs の関数の界面 (interface) を使ってきましたが、関数に
は gnus の別名関数 (alias) を使ってきました。例を出しましょう: Emacs は
関数 @code{run-at-time} を定義していますが、XEmacs は関
数 @code{start-itimer} を定義しています。そこで私
は @code{gnus-run-at-time} と呼ばれる関数を定義し、それ
は Emacs の @code{run-at-time} と同じ引数を取ります。Gnus を Emacs で実
行しているときは、前の関数は単に後のものの別名関数 (alias) になっていま
す。しかし、XEmacs で実行したときは、前者は次の関数の別名関数 (alias) と
なっています:

@lisp
(defun gnus-xmas-run-at-time (time repeat function &rest args)
  (start-itimer
   "gnus-run-at-time"
   `(lambda ()
      (,function ,@@args))
   time repeat))
@end lisp

この種類のものが多くの関数に対してなされています。Gnus は XEmacs で実行
しているときに、元からある Emacs の関数を再定義しません---それは、代わり
に gnus の等価なものと @code{defalias} をする事によって実行します。全体
的に、よりきれいになります。

XEmacs の関数界面の方が明らかにきれいな場合は、私は代わりにそれを使いま
す。例えば、@code{gnus-region-active-p} は XEmacs で
は @code{region-active-p} の別名であるのに対して、Emacs では関数です。

もちろん、私は XEmacs を私の基本プラットフォームに選んで、関数の割り当て
を逆にする事もできました。でも、私はそうしませんでした。
XEmacs で gnus を実行するときに、こういう逆向きのための速度低下は少しで
しょう。

@node Various File Formats
@subsection いろいろなファイル様式

@menu
* Active File Format::          使用可能な記事グループの情報
* Newsgroups File Format::      グループの記述
@end menu

@node Active File Format
@subsubsection アクテイブファイル様式

アクティブファイルは当のサーバーの全ての使用可能なグループの一覧を挙げま
す。それはそれぞれのグループの最低と最高の記事番号の一覧もあります。

これは普通のアクティブファイルからの抜粋です:

@example
soc.motss 296030 293865 y
alt.binaries.pictures.fractals 3922 3913 n
comp.sources.unix 1605 1593 m
comp.binaries.ibm.pc 5097 5089 y
no.general 1000 900 y
@end example

これはこのファイルの疑似 BNF 定義です。

@example
active      = *group-line
group-line  = group spc high-number spc low-number spc flag <NEWLINE>
group       = <non-white-space string>
spc         = " "
high-number = <non-negative integer>
low-number  = <positive integer>
flag        = "y" / "n" / "m" / "j" / "x" / "=" group
@end example

このファイルの完全な記述を得るためには、@samp{innd} のマニュアル頁、特
に @samp{active(5)} を見て下さい。

@node Newsgroups File Format
@subsubsection ニュースグループファイル様式

ニュースグループファイルはグループをその記述と共に一覧を挙げます。サーバー
にある全てのグループが一覧にされなければならないのではなく、また、ファイ
ルの全てのグループがサーバーに存在しなければならないのではありません。こ
のファイルは純粋に利用者の情報のためにあります。

様式は非常に簡単です: グループ名、タブ、そして記述です。これは定義です:

@example
newsgroups    = *line
line          = group tab description <NEWLINE>
group         = <non-white-space string>
tab           = <TAB>
description   = <string>
@end example

@page
@node Emacs for Heathens
@section 異教徒への Emacs

信じるかどうかは知りませんが、gnus を使う人の中には Gnus Love Boat での
旅に搭乗する前にあまり Emacs を使った事が無いという人がいます。もしあな
たが ``@kbd{C-M-a}'' や ``リージョンを切る''、そし
て ``@code{gnus-flargblossen} を連想リストに設定してください。そのキーは
グループ名に合致するために使われる正規表現です'' が少しの意味か全く意味
の無い魔法の言葉である不幸な人であれば、この付録はあなたのためにあります。
もしあなたが既に Emacs に親しんでいるのであれば、これを無視して車を可愛
がりに行って下さい。

@menu
* Keystrokes::                  文章を入力して命令を実行する
* Emacs Lisp::                  備え付けの Emacs プログラミング言語
@end menu

@node Keystrokes
@subsection 打鍵

@itemize @bullet
@item
Q: 経験のある Emacs の利用者とは何ですか?

@item
A: 端末がペダルを持っていたらなぁと願う人の事です。
@end itemize

はい、あなたが Emacs を使うと、あなたはコントロールキー、シフトキー、メ
タキーをたくさん使うようになるでしょう。これは一部の人 (主に、
@code{vi} 利用者) には非常にうるさく感じられるでしょう。残りの人々は、そ
れによりもたらされる地獄を愛します。あきらめて服従して下さい。Emacs は本
当は ``Escape-Meta-Alt-Control-Shift'' の略で、他の評判の悪い出
所 (Emacs の作者のような) から聞いた ``Editing Macros'' ではありません。

シフトキーは普通は小指の近くに位置しており、普通は大文字やその他のもを得
るために使われます。あなたはずっとそれを使う事でしょう。コントロールキー
は普通は ``CTRL'' やそのようなもので印が付いています。メタキーは、おもし
ろい事に、どのキーボードでもそのように印が付けられていません。それは普通
はキーボードの左手側に位置していて、普通は最下段にあります。

これから、我々 Emacs の人々は、それがあまりに不便なため、
``meta-control-m キーを押す'' とは言いません。私たちは ``@kbd{C-M-m} を
押す'' と言います。@kbd{M-} は ``メタ'' を現す接頭辞で、``C-'' は ``コン
トロール'' を意味する接頭辞です。ですから、``@kbd{C-k} を押す'' は ``コ
ントロールキーを下に押し、@kbd{k} を押している間、それを下に保ちなさ
い'' と言う事です。``@kbd{C-M-k} を押す'' は ``メタキーとコントロールキー
を押して下に保った後で @kbd{k} を押す'' と言う事です。簡単でしょ。ね?

これは全てのキーボードがメタキーを持っているわけではないと言う事実により
少し複雑になっています。そのような場合は、``エスケープ'' キーを使う事が
できます。それはメタキーを持っているときよりもっと作業が大変になりますの
で、そういう場合は、私はメタキーのあるキーボードを手に入れる事を恭しくお
勧め致します。それ無しでは生きて行けないでしょう。

@node Emacs Lisp
@subsection Emacs Lisp

Emacs はそれが本当は Lisp インタープリターである事から、エディターの王様
です。あなたが叩く、それぞれの全てのキーは何らかの Emacs Lisp のコードの
小片を実行し、Emacs Lisp はインタープリターで実行される言語である事から、
それはどんなキーでも任意のいろいろなコードを実行するように設定できると言
う事です。あなたは、単に、そうすれば良いだけです。

Gnus は Emacs Lisp によって書かれていて、それはたくさんの逐次解釈実行さ
れる関数により実行されます。(これらは速度のためにバイトコンパイルされて
いますが、それでもまだ逐次解釈されます。) もし gnus がするある事を好きで
はないと思ったなら、違ったように実行させるのは取るに足らない事です。(えー
と、少なくとも Lisp コードの書き方を知っていれば。) しかし、それはこのマ
ニュアルの範囲外なので、我々は単に gnus をカスタマイズするためにファイ
ル @file{.emacs} で普通使われるいくつかの普通の構文についてだけ話をしま
す。

もし変数@code{gnus-florgbnize} を四 (4) に設定したいのであれば、以下のも
のを書きます:

@lisp
(setq gnus-florgbnize 4)
@end lisp

この関数 @code{setq} (本当は ``特殊形式'' (special form)) を使って、変数
を何かの値に設定する事ができます。これは本当にあなたが知るべき全ての事で
す。これからは gnus の動作を変更するために、たくさんのこのようなものでファ
イル @code{.emacs} を埋め尽くす事ができます。

もしあなたがそのようなものをファイル @code{.emacs} に入れたら、それは次
回に Emacs を起動したときに読み込まれ @code{評価} (それは ``実
行'' の lisp 語です) されます。もし変数をすぐに変更したいのであれば、閉
じ括弧の後で単に @kbd{C-x C-e} とするだけです。それは前にあ
る ``式'' を @code{評価} し、それはここでは簡単な @code{setq} 文です。

がんばって---もしあなたが Emacs の前にあるのであればちょっと試して下さい。
@kbd{C-x C-e} の後で、反響区域 (echo area) に @samp{4} が現われるのが見
えるでしょう。それはあなたが @code{評価} した式の返り値です。

いくつかの落とし穴:

もしマニュアルが ``@code{gnus-read-active-file} を @code{some} に設定し
なさい'' と言ったなら、それは:

@lisp
(setq gnus-read-active-file 'some)
@end lisp

と言う事です。

一方、マニュアル
が ``@code{gnus-nntp-server} を @samp{nntp.ifi.uio.no} に設定しなさい'' と
言ったなら、それは:

@lisp
(setq gnus-nntp-server "nntp.ifi.uio.no")
@end lisp

と言う事です。

ですから、文字列 (後者) を シンボル (前者) と混同しないように注意して下
さい。マニュアルは明確に区別していますが、混乱しやすいかもしれません。

@page
@include gnus-faq-ja.texi

@node Index
@chapter Index
@printindex cp

@node Key Index
@chapter Key Index
@printindex ky

@summarycontents
@contents
@bye

@iftex
@iflatex
\end{document}
@end iflatex
@end iftex

@c Local Variables:
@c mode: texinfo
@c coding: iso-2022-7bit
@c use-kuten-for-period: t
@c use-touten-for-comma: t
@c End:
% LocalWords:  BNF mucho detailmenu cindex kindex kbd
% LocalWords:  findex Gnusae vindex dfn dfn samp nntp setq nnspool nntpserver
% LocalWords:  nnmbox newusers Blllrph NEWGROUPS dingnusdingnusdingnus
% LocalWords:  pre fab rec comp nnslashdot regex ga ga sci nnml nnbabyl nnmh
% LocalWords:  nnfolder emph looong eld newsreaders defun init elc pxref
