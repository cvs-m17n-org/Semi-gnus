\input texinfo                  @c -*-texinfo-*-

@setfilename gnus-ja
@settitle Semi-gnus 6.4.0 Manual
@synindex fn cp
@synindex vr cp
@synindex pg cp
@c @direntry
@c * Gnus-ja: (gnus-ja).   The news reader gnus (日本語版).
@c @end direntry
@iftex
@finalout
@end iftex
@setchapternewpage odd

@iftex
@iflatex
\documentclass[twoside,a4paper,openright,11pt]{book}
\usepackage[latin1]{inputenc}
\usepackage{pagestyle}
\usepackage{epsfig}
\usepackage{bembo}
\usepackage{pixidx}

\makeindex
\begin{document}

\newcommand{\gnuschaptername}{}
\newcommand{\gnussectionname}{}

\newcommand{\gnusbackslash}{/}

\newcommand{\gnusxref}[1]{See ``#1'' on page \pageref{#1}}
\newcommand{\gnuspxref}[1]{see ``#1'' on page \pageref{#1}}

\newcommand{\gnuskindex}[1]{\index{#1}}
\newcommand{\gnusindex}[1]{\index{#1}}

\newcommand{\gnustt}[1]{{\fontfamily{pfu}\fontsize{10pt}{10}\selectfont #1}}
\newcommand{\gnuscode}[1]{\gnustt{#1}}
\newcommand{\gnussamp}[1]{``{\fontencoding{OT1}\fontfamily{pfu}\fontsize{10pt}{10}\selectfont #1}''}
\newcommand{\gnuslisp}[1]{\gnustt{#1}}
\newcommand{\gnuskbd}[1]{`\gnustt{#1}'}
\newcommand{\gnusfile}[1]{`\gnustt{#1}'}
\newcommand{\gnusdfn}[1]{\textit{#1}}
\newcommand{\gnusi}[1]{\textit{#1}}
\newcommand{\gnusstrong}[1]{\textbf{#1}}
\newcommand{\gnusemph}[1]{\textit{#1}}
\newcommand{\gnusvar}[1]{{\fontsize{10pt}{10}\selectfont\textsl{\textsf{#1}}}}
\newcommand{\gnussc}[1]{\textsc{#1}}
\newcommand{\gnustitle}[1]{{\huge\textbf{#1}}}
\newcommand{\gnusauthor}[1]{{\large\textbf{#1}}}

\newcommand{\gnusbullet}{{${\bullet}$}}
\newcommand{\gnusdollar}{\$}
\newcommand{\gnusampersand}{\&}
\newcommand{\gnuspercent}{\%}
\newcommand{\gnushash}{\#}
\newcommand{\gnushat}{\symbol{"5E}}
\newcommand{\gnusunderline}{\symbol{"5F}}
\newcommand{\gnusnot}{$\neg$}
\newcommand{\gnustilde}{\symbol{"7E}}
\newcommand{\gnusless}{{$<$}}
\newcommand{\gnusgreater}{{$>$}}

\newcommand{\gnushead}{\raisebox{-1cm}{\epsfig{figure=ps/gnus-head.eps,height=1cm}}}
\newcommand{\gnusinteresting}{
\marginpar[\mbox{}\hfill\gnushead]{\gnushead}
}

\newcommand{\gnuscleardoublepage}{\ifodd\count0\mbox{}\clearpage\thispagestyle{empty}\mbox{}\clearpage\else\clearpage\fi}

\newcommand{\gnuspagechapter}[1]{
{\mbox{}}
}

\newdimen{\gnusdimen}
\gnusdimen 0pt

\newcommand{\gnuschapter}[2]{
\gnuscleardoublepage
\ifdim \gnusdimen = 0pt\setcounter{page}{1}\pagestyle{gnus}\pagenumbering{arabic} \gnusdimen 1pt\fi
\chapter{#2}
\renewcommand{\gnussectionname}{}
\renewcommand{\gnuschaptername}{#2}
\thispagestyle{empty}
\hspace*{-2cm}
\begin{picture}(500,500)(0,0)
\put(480,350){\makebox(0,0)[tr]{#1}}
\put(40,300){\makebox(500,50)[bl]{{\Huge\bf{#2}}}}
\end{picture}
\clearpage
}

\newcommand{\gnusfigure}[3]{
\begin{figure}
\mbox{}\ifodd\count0\hspace*{-0.8cm}\else\hspace*{-3cm}\fi\begin{picture}(440,#2)
#3
\end{picture}
\caption{#1}
\end{figure}
}

\newcommand{\gnusicon}[1]{
\marginpar[\mbox{}\hfill\raisebox{-1.5cm}{\epsfig{figure=tmp/#1-up.ps,height=1.5cm}}]{\raisebox{-1cm}{\epsfig{figure=tmp/#1-up.ps,height=1cm}}}
}

\newcommand{\gnuspicon}[1]{
\margindex{\epsfig{figure=#1,width=2cm}}
}

\newcommand{\gnusxface}[2]{
\margindex{\epsfig{figure=#1,width=1cm}\epsfig{figure=#2,width=1cm}}
}

\newcommand{\gnussmiley}[2]{
\margindex{\makebox[2cm]{\hfill\epsfig{figure=#1,width=0.5cm}\hfill\epsfig{figure=#2,width=0.5cm}\hfill}}
}

\newcommand{\gnusitemx}[1]{\mbox{}\vspace*{-\itemsep}\vspace*{-\parsep}\item#1}

\newcommand{\gnussection}[1]{
\renewcommand{\gnussectionname}{#1}
\section{#1}
}

\newenvironment{codelist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{kbdlist}%
{\begin{list}{}{
\labelwidth=0cm
}
}{\end{list}}

\newenvironment{dfnlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{stronglist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{samplist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{varlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{emphlist}%
{\begin{list}{}{
}
}{\end{list}}

\newlength\gnusheadtextwidth
\setlength{\gnusheadtextwidth}{\headtextwidth}
\addtolength{\gnusheadtextwidth}{1cm}

\newpagestyle{gnuspreamble}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\mbox{}}\textbf{\hfill\roman{page}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\roman{page}\hfill\mbox{}}}
}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnusindex}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\gnuschaptername\hfill\arabic{page}}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnus}%
{
{
\ifodd\count0
{
\makebox[12cm]{\hspace*{3.1cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{chapter}.\arabic{section}} \textbf{\gnussectionname\hfill\arabic{page}}}}}
}
\else
{
\makebox[12cm]{\hspace*{-2.95cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\hfill \mbox{}
\fi
}

\pagenumbering{roman}
\pagestyle{gnuspreamble}

@end iflatex
@end iftex

@iftex
@iflatex
\begin{titlepage}
{

%\addtolength{\oddsidemargin}{-5cm}
%\addtolength{\evensidemargin}{-5cm}
\parindent=0cm
\addtolength{\textheight}{2cm}

\gnustitle{\gnustitlename}\\
\rule{15cm}{1mm}\\
\vfill
\hspace*{0cm}\epsfig{figure=ps/gnus-big-logo.eps,height=15cm}
\vfill
\rule{15cm}{1mm}\\
\gnusauthor{by Lars Magne Ingebrigtsen}
\newpage
}

\mbox{}
\vfill

\thispagestyle{empty}

Copyright \copyright{} 1995,96,97 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果をこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

\newpage
\end{titlepage}
@end iflatex
@end iftex

@ifinfo

This file documents gnus, the GNU Emacs newsreader.

このファイルは GNU Emacs のニュースリーダである gnus に関する説明書です。

Copyright (C) 1995,96 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

@ignore
Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

この段落が取り除かれているのを除き、これと同じ複製に関する許可文が表示され
ている限り、このファイルを Tex にかけて、その結果を印刷することを許可する。

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果もこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

@end ifinfo

@tex

@titlepage
@title Semi-gnus 6.4.0 Manual

@author by Lars Magne Ingebrigtsen
@author by members of Semi-gnus mailing-list
@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1995,96,97 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果をこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

@end titlepage
@page

@end tex


@node Top
@top The gnus Newsreader

@ifinfo

Gnus を使うことによって Emacs でニュース (news) を（それにメール (mail) 
も）読むことができます。ニュースは @sc{nntp}、ローカルスプール、mbox ファ
イルなどのあらゆる極悪な手段を駆使して手に入れることができます。運試しを
してみようと思うならば、全てを同時に用いることもできます。

Semi-gnus は SEMI API に基づく MIME 機能を提供します。そういう訳で、
Semi-gnus は、大きな絵が入っていたりさまざまな形式を用いたりしているちょっ
と変わった記事を読む権利を擁護します。Semi-gnus は MULE API に基づく国際
化・地域化、および、多字化機能を提供します。よって、Semi-gnus はさまざま
な言語圏を差別しません。ああ、クリンゴンの方は Unicode Next Generationを
お待ちください。

この説明書は Semi-gnus 6.4.0 に対応します。

@end ifinfo

@iftex

@iflatex
\tableofcontents
\gnuscleardoublepage
@end iflatex

Gnus は GNU Emacs の先進的で、説明のある、カスタマイズ可能で、拡張可能な、
リアルタイムでないニュースリーダです。

おおっと。不思議なことに以前にも似たようなことを聞いたことがあるような気
がします。真似をしたと非難されないうちに説明を始めましょう：

Gnus はメッセージを読むことに関する実験場です。Gnus はすべてをニュースグ
ループのように表示します。Gnus でメールを読み、ディレクトリーをブラウズ
し、@code{ftp} をすることができます。ああ、それに、ニュースを読むことさ
えできます！

Emacs が文章を編集する人に力を与えるように、gnus はニュースを読む人に力
を与えようとしています。Gnus は利用者が実行可能なことに制限を設けません。
利用者が自分で望む動作をするように gnus を拡張することを奨励しています。
プログラムが人を操作するべきではありません。人がプログラムを使う（もしく
は濫用する）ことによって、やりたいことをできるようになっているべきです。

@end iftex


@menu
* Starting Up::           ニュースを見つけるのには苦労が伴うかも知れない
* The Group Buffer::      グループを選択し、講読し、削除する
* The Summary Buffer::    記事を読み、保存し、投稿する
* The Article Buffer::    記事を表示し、扱う
* Composing Messages::    メールとニュースを送るための情報
* Select Methods::        Gnus は全てのメッセージをいろいろな選択方法で読む
* Scoring::               記事に値をつける
* Various::               一般的な設定
* The End::               さらば、そしてさようなら
* Appendices::            用語、Emacs 入門、FAQ、歴史、内部構造
* Index::                 変数、関数、概念の索引
* Key Index::             キー索引
@end menu

@node Starting Up
@chapter gnus の起動
@cindex starting up

@kindex M-x gnus
@findex gnus
システム管理者が適切な設定をしていたならば、gnus を起動してニュースを読
むのは非常に簡単です。そう、Emacs で @kbd{M-x gnus} と打つだけです。

@findex gnus-other-frame
@kindex M-x gnus-other-frame
別のフレームで gnus を起動したいときは、コマンド @kbd{M-x
gnus-other-frame} を使うことができます。

開始時に何かがうまくいかないときは @file{~/.gnus} ファイルの中で変数をい
くつかいじくりまわさなければならないでしょう。このファイルは 
@file{~/.emacs} と似ていますが、これは gnus が起動するときに読み込まれま
す。

この説明書でよくわからない用語がでてきたときは、用語の項 
(@pxref{Terminology}) を参照してください。

@menu
* Finding the News::    ニュースを取得する方法を選ぶ
* The First Time::      最初に起動したときに gnus は何をするか
* The Server is Down::  どうすればそのようなときにメールを手に入れることができるか
* Slave Gnusae::        同時に一つ以上の gnus を作動させることができる
* Fetching a Group::    グループを読むためだけに gnus を起動する
* New Groups::          Gnus が新しいグループに対して何をするか
* Startup Files::       やっかいなスタートアップファイル--@file{.newsrc}
* Auto Save::           クラッシュからの回復
* The Active File::     遅い回線からのファイルの取得には時間がかかる
* Changing Servers::    あるサーバから別のサーバへ移りたいかもしれない
* Startup Variables::   変更したいと思うかもしれない変数
@end menu


@node Finding the News
@section ニューズを見つける
@cindex finding news

@vindex gnus-select-method
@c @head
変数 @code{gnus-select-method} は gnus がどこでニュースを探すべきかを示
しています。この変数ははじめの要素が@dfn{どのようにして}、２番目の要素が
@dfn{どこで}を表すリストである必要があります。この方法はあなたの基本方法 
(native method) になります。この方法で取ってこないグループは全て外の
(foreign) グループです。

たとえば、@sc{nntp} サーバ @samp{news.somewhere.edu} から毎日一定の量の
ニュース（薬のように）を摂取したいのであれば、

@lisp
(setq gnus-select-method '(nntp "news.somewhere.edu"))
@end lisp

のようにすることができます。

ローカル・スプールのディレクトリを読み込みたい場合は、

@lisp
(setq gnus-select-method '(nnspool ""))
@end lisp

のようにできます。

ローカルのスプールを使えるのであれば、かなりの確率でその方がずっと速いで
しょうし、それを使うべきでしょう。

@vindex gnus-nntpserver-file
@cindex NNTPSERVER
@cindex @sc{nntp} server
もしこの変数が設定されていなければ、gnus は @code{NNTPSERVER} 環境変数を
読みにいきます。もしその変数が設定されていなければ、gnus は
@code{gnus-nntpserver-file}（設定されていない場合は 
@file{/etc/nntpserver}）がこの件に関して何かを言っていないかを調べます。
もしそれも失敗したなら、gnusは Emacs が動作しているサーバーを @sc{nntp} 
サーバーとして使おうとします。随分な当て推量ですけどね。

@vindex gnus-nntp-server
@code{gnus-nntp-server} が設定されていると、この変数は
@code{gnus-select-method} を上書きします。ですから、
@code{gnus-nntp-server} は @code{nil} に設定するべきで、標準設定でもその
ようになっています。

@vindex gnus-secondary-servers
Gnus に @sc{nntp} サーバーの名前の入力を対話的に指定することもできます。
@code{gnus} に数値でない接頭引数を渡すと（例：@kbd{C-u M-x gnus}）、gnus 
は @code{gnus-secondary-servers} リスト（もし存在するならば）からサーバー
を選ぶことができるようにします。ただ単に接続したいと思ったサーバーの名前
を打つこともできます。

@findex gnus-group-browse-foreign-server
@kindex B (Group)
しかし、普段日常的には一つの @sc{nntp} サーバを使い、違ったサーバーには興
味のあるグループが少ししかない場合、グループバッファで @kbd{B} 命令を使う
ことの方が良いでしょう。それは、選択可能なグループを表示し、その中からどれ
でも好きなものを購読することができます。これは、@file{.newsrc} の保持をずっ
とやりやすくします。@xref{Foreign Groups}.

@vindex gnus-secondary-select-methods
@c @head
外のグループに対する少し違ったやり方は、変数
@code{gnus-secondary-select-methods} を設定することです。この変数に表さ
れている選択方法は、多くの点で @code{gnus-select-method} サーバーとの選
択方法と同じように扱われます。起動中にアクティブファイルを探しにいきますし
（もし要求されていれば）、これらのサーバー上にできた新しいニュースグルー
プは元々のグループと同じように購読（もしくは不購読）されます。

たとえば、メールを読むために @code{nnmbox} バックエンド (backend) を使い
たいときは、普通、この変数を、

@lisp
(setq gnus-secondary-select-methods '((nnmbox "")))
@end lisp

と設定します。

@node The First Time
@section 一番初め
@cindex first time usage

起動用ファイルが存在しないときは、gnus はディフォルトでどのグループが購
読されているべきかを決定しようとします。

@vindex gnus-default-subscribed-newsgroups
変数 @code{gnus-default-sebscribed-newsgroups} が設定されていると、gnus
はそのリストの中のグループを購読し、残りを削除します。システム管理者はこ
の変数を何か役に立つものに設定しておくべきです。

そうでないときは、gnus は少しの任意のグループを購読します（例：
@samp{*.newusers}）。（@dfn{任意}はここでは、@dfn{Lars さんが読むべきで
あると考えるもの}というように定義されています）

また、たいていの共通の問題の解決の手助けになるよう、gnus に関する文書の
グループも購読することになるでしょう。

@code{gnus-default-subscribed-newsgroups} が @code{t} のときは、gnus は新
しいグループを扱うのに普通の関数を使い、特別なことは何もしません。


@node The Server is Down
@section サーバーが落ちている
@cindex server errors

標準 (default) のサーバーが落ちているときは、当然 gnus の起動にいくつか
の問題が発生します。しかし、ニュースグループの他にいくつかメールのグルー
プがあれば、それにもかかわらず gnus を起動したいと思うかもしれません。

Gnus は、信頼できるプログラムの一つとして、サーバーと接続できないときは
基本選択方法なしで続けるかどうかを尋ねます。これは実際にはサーバーが存在
しないとき（例えば、アドレスを間違えた場合）やサーバーが何らかの理由で一
時的に調子がおかしくなっているときに起こります。もしそのまま続行すること
にして、外のグループが一つも無い場合、実はグループバッファではほとんど何
もできないということに気がつくでしょう。でも、ねぇ、それはあなたの問題で
す。ハハハッ。

@findex gnus-no-server
@kindex M-x gnus-no-server
@c @head
サーバーが完全に落ちているのを知っているか、サーバーでわずらうことなくメー
ルだけを読みたいときは、gnus を起動するのに、@code{gnus-no-server} 命令を
使うことができます。急いでいるときにもぴったりでしょう。この命令は本来のサー
バーには接続しません――その代わりに、レベル１と２にあるすべてのグループを
活動状態にします（基本グループでないグループはその２つのレベルにしておくの
が望ましいでしょう）。


@node Slave Gnusae
@section gnus をスレーブにする
@cindex slave

あなたは２つ以上の Emacs と、２つ以上の gnus を同時に動かしたいと思うか
もしれません。違った @file{.newsrc} ファイルを使っているなら（例えば、２
つの違ったサーバーから読み込むために、２つの違った gnus を動作させている
場合）、まったく問題はありません。それを行えば良いだけです。

問題は、同じ @code{.newsrc} ファイルを使う２つの gnus を動かそうとしたと
きに起こります。

この問題に対処するために、gnus タワーのシンクタンクにいる我々は新しい概
念にたどりつきました。@dfn{マスター} と @dfn{スレーブ} です。（我々はこ
の概念に特許を申請しました。そして、その言葉の著作権を得ました。お互いに
関連してこれらの言葉を使いたいなら、１回使う毎に、私に $1 を送らなければ
なりません。もちろん、@dfn{コンピューターアプリケーションのマスター／ス
レーブ関係}の使用料はもっと高くなります。）

とにかく、@kbd{M-x gnus}（もしくは、普段やっている方法）で gnus を普通に
起動します。その後のスレーブ gnus はそれぞれ @kbd{M-x gnus-slave} で起動
します。スレーブは普通の @file{.newsrc} は保存しませんが、代わりに 
@dfn{スレーブファイル} にスレーブの起動中にどのようなグループが読まれた
かという情報だけを保存します。マスター gnus が起動するとき、それはそれら
のスレーブファイルを読み込み（そして消し）、それらからすべての情報を取り
込みます。（スレーブファイルは、最終的な変更が優先されるようにそれらが作
られた一連の動作の中で読まれます。） 

もちろん、スレーブファイルからの情報は普通の（例えば、マスターの）ファイ
ルよりも優先されます。


@node Fetching a Group
@section グループを取得する
@cindex fetching a group

@findex gnus-fetch-group
時々、“このグループを読みたいのであって、gnus が起動しているかどうかを
気にしたくない。”ということができれば便利なことがあります。これは、利用
者よりもプログラムのコードを書く人に便利な機能ですが、どちらにしろ、コマ
ンド @code{gnus-fetch-group} はこの機能を提供します。そのコマンドは、グ
ループの名前を引数としてとります。


@node New Groups
@section 新しいグループ
@cindex new groups
@cindex subscription

@vindex gnus-check-new-newsgroups
新しいニュースグループを全く見ないで満足であるならば、
@code{gnus-check-new-newsgroups} を @code{nil} に設定することができます。
これを設定した場合、起動にかかる時間が短くなります。この変数が nil に設
定されていても、グループバッファで @kbd{U} を押せばいつでも新しいグルー
プを購読することができます (@pxref{Group Maintenance})。設定されていない
場合 (default) ではこの変数は @code{ask-server} です。この変数が 
@code{always} に設定されていると、命令 @kbd{g} を実行したときでも gnus 
はバックエンドに新しいグループを探すことを求めます (@pxref{Scanning New
Messages})。

@menu
* Checking New Groups::      どのグループが新しいかを決定する。
* Subscription Methods::     新しいグループに対して gnus は何をすべきか
* Filtering New Groups::     Gnus に特定の新しいグループを無視させる
@end menu


@node Checking New Groups
@subsection 新しいグループを調べる

Gnus は、普通はグループが新しいかどうかを、購読しているグループと削除され
ているグループのリストと現状ファイル (active file) を比較することにより決
定しています。この方法は特に速いというわけではありません。
@code{gnus-check-new-newsgroups} が @code{ask-server} であると、gnus はサー
バーに、最後に接続してから新しいグループができているかどうかを尋ねます。こ
の方法は速いし、安上がりです。これにより、削除されたグループのリストを保持
しておくことからから完全に開放されます。ですから、
@code{gnus-save-killed-list} を @code{nil} にすることができるでしょう。そ
うすれば、起動、終了の両方、そして全体にわたって時間を節約できます。ディス
ク消費量も少なくなります。それなら、どうしてこれが標準 (default) ではない
のでしょう？残念ながら、すべてのサーバーがこの命令を理解するわけではないの
です。

私は今あなたが何を考えているかを当てられます。どうすればサーバーが
@code{ask-server} を理解するかがわかるのでしょう？え、違うのですか？あぁ、
良かった。というのは、確実な答は存在しないのです。私に言えることは、この変
数を @code{ask-server} に設定して、数日間新しいグループが現れるかどうかを
調べてください、ということだけです。もしいくつかのグループが現れたなら、そ
れで動作しています。一つも現れなければ、それは動作しません。私は、gnus に
サーバーが @code{ask-server} を理解するかどうかを推量させる関数を書くこと
もできますが、それは単に推量しているにすぎません。ですから、その関数を書く
ことはないでしょう。他の方法としては、サーバーに @code{telnet} をして、
@code{HELP} と打ち、サーバーが理解するコマンドの中に @samp{NEWGROUPS} があ
るかどうかを調べることもできます。もしあれば、おそらく動作するでしょう（し
かし、適切に機能を提供することなく @samp{NEGROUPS} をリストに含めるサーバー
もあります）。

この変数は、選択方法のリストであることもできます。そのときは、gnus は命
令 @code{ask-server} をそれぞれの選択方法に対して実行し、普通の方法で購
読（もしくは、不購読）します。これの副作用は、起動にかなり時間がかかるの
で、待っている間に瞑想できることです。永久の幸福を達成するために、マント
ラ ``dingnusdingnusdingnus'' を使ってください。


@node Subscription Methods
@subsection 購読方法

@vindex gnus-subscribe-newsgroup-method
新しいグループに遭遇したときに gnus が何をするかは、変数
@code{gnus-subscribe-nesgroup-method} によって決定されます。

この変数は関数を含んでいる必要があります。この関数は新しいグループの名前
を唯一の引数として呼ばれます。

いくつかの手軽なプレハブ関数は、以下のようになっています。

@table @code

@item gnus-subscribe-zombies
@vindex gnus-subscribe-zombies
すべての新しいグループをゾンビ (zombie) にします。これが標準 (default) に
なっています。後でゾンビを (@kbd{A z} によって) 概観したり、（@kbd{S z} に
よって）適切に全てを削除したり、（@kbd{u} によって）購読したりできます。

@item gnus-subscribe-randomly
@vindex gnus-subscribe-randomly
任意の順番ですべての新しいグループを購読します。実際には、すべての新しい
グループはグループバッファの『一番上』に加えられます。

@item gnus-subscribe-alphabetically
@vindex gnus-subscribe-alphabetically
すべての新しいグループをアルファベット順に購読します。

@item gnus-subscribe-hierarchically
@vindex gnus-subscribe-hierarchically
すべての新しいグループを階層的に購読します。この関数と
@code{gnus-subscribe-alphabetically} の違いは少ししかありません。
@code{gnus-subscribe-alphabetically} は新しいグループを厳密にアルファベッ
ト順にならべますが、この関数はグループをその階層の中に入れます。ですから、
@samp{rec} の階層を @samp{comp} の階層の前に持ってきたい場合、この関数は
その配置をぐちゃぐちゃにはしません。もしくは、そのようなものです。

@item gnus-subscribe-interactively
@vindex gnus-subscribe-interactively
新しいグループを対話的に購読します。これは gnus が @strong{全て} のグルー
プに対して尋ねることを意味しています。購読するグループは階層的に購読され
ます。

@item gnus-subscribe-killed
@vindex gnus-subscribe-killed
すべての新しいグループを削除します。

@end table

@vindex gnus-subscribe-hierarchical-interactive
上の変数と良く関係した変数は、
@code{gnus-subscribe-hierarchical-interactive} です。この変数が
@code{nil} でないと、gnus は階層的な方法で新しいグループを購読するかどうか
を尋ねます。gnus はそれぞれの階層で、それを下に降りるかどうかを尋ねます。

良くある間違いは、数段落前の変数 (@code{gnus-subscribe-newsgroup-method}
) を @code{gnus-subscribe-herarchical-interactive} に設定することです。
これは誤りです。これは動作しません。これはおめでたい人のすることです。で
すから、絶対にしないでください。


@node Filtering New Groups
@subsection 新しいグループを選別する

どの新しいグループが購読（もしくは、無視）されるべきかを管理する快適で手
軽な方法は、ファイル @file{.newsrc} の先頭に @dfn{options} 行を挿入する
ことです。次は、例です。

@example
options -n !alt.all !rec.all sci.all
@end example

@vindex gnus-subscribe-options-newsgroup-method
この行は、明らかにまじめで理知的で科学的な人間（もしくは単なる古く退屈な
人間）が書いたものです。なぜなら、これは @samp{alt} と @samp{rec} で始ま
る名前を持つグループは全て無視され、@samp{sci} で始まる名前を持つグルー
プは全て購読する、ということを表しているからです。Gnus はこれらのグルー
プを購読するのに、普通の購読方法を用いません。代わりに、
@code{gnus-subscribe-options-newsgroup-method} が用いられます。この変数
は標準 (default) では @code{gnus-subscribe-alphabetically} です。

@vindex gnus-options-not-subscribe
@vindex gnus-options-subscribe
ファイル @file{.newrc} をいじりたくない場合は、
@code{gnus-options-subscribe} と @code{gnus-options-not-subscribe} の２
つの変数だけを設定することもできます。この２つの変数はファイル 
@file{.newrc} の @samp{optinos -n} 行と全く同じことをします。どちらの変
数も正規表現で、新しいグループは前者に合致すれば無条件に購読され、後者に
合致すると無視されます。

@vindex gnus-auto-subscribed-groups
さらにここでおせっかいをする変数は、@code{gnus-auto-subscribed-groups} 
です。それは @code{gnus-options-subscribe} と全く同じように動作しますの
で、本当は余分なものです。しかし、私はこの二つがあった方が良いと思いまし
た。もう一方の変数はユーザがいじくるのに使われるのに対して、この変数はい
くつかの基本的な規則を設定するためのものです。ディフォルトではこの変数は
メールバックエンド (@code{nnml} 、@code{nnbabyl} 、@code{nnfolder} 、
@code{nnmbox} と@code{nnmh}) からできる全ての新しいグループを購読するよ
うになっています。それが嫌であれば、この変数を @code{nil} に設定してくだ
さい。

この正規表現に合致する新しいグループは 
@code{gnus-subscribe-options-newsgroup-method} を使って購読されます。


@node Changing Servers
@section サーバーを換える
@cindex changing servers

ときどき、ある @sc{nntp} サーバーから別のサーバーへ移動しなければならな
いことがあります。このようなことはめったにおきませんが、おそらくあなたが
仕事を変えたり、使っているサーバーがとても不安定で、別のものに乗り換えた
いというときに必要になるでしょう。

サーバーを変更するのはとても簡単ですよね？
@code{gnus-select-method} を新しいサーバーを指し示すように変更すればいい
だけですね？

@emph{違います！}

記事の番号は違った @sc{nntp} サーバーでも (どうにかして) 同じにしてある、
ということはありません。そして、 guns がどの記事を読んだかを記録する唯一
の方法は、記事番号を記録することです。ですから、
@code{gnus-select-method} を変更したときは、ファイル @file{.newsrc} は意
味がなくなります。

Gnusはファイル @file{.newsrc} をあるサーバー用から別のサーバー用に変換す
る関数を2、3用意しています。それらには一つ共通点があります---実行にながーー
い時間がかかることです。おそらく、どうしても必要になったとき以外にこの関
数を使おうとは思わないでしょう。

@kindex M-x gnus-change-server
@findex gnus-change-server
もし両方のサーバーに接続できるなら、gnusはあなたが読んだ記事全てに対して
ヘッダー (headers) を要求して、@code{Message-ID} を比較し、読んだ記事と
記事の印を新しく記録します。コマンド @kbd{M-x gnus-change-server} はこれ
をすべての基本グループに対して行います。そのコマンドは移動先の方法の入力
を促します。

@kindex M-x gnus-group-move-group-to-server
@findex gnus-group-move-group-to-server
個々のグループを命令 @kbd{M-x gnus-group-move-group-to-server} で移
動することもできます。これはあるサーバーから別のサーバーへ一つの (外の) 
グループを移動したいときに役に立ちます。

@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
古いサーバーと新しいサーバーの両方に接続することができないとき、印と読ん
だ範囲はすべて意味が無くなります。そのようなときは、コマンド @kbd{M-x
gnus-group-clear-data-on-native-groups} を使って、基本グループに関するデー
タをすべて消去することができます。このコマンドは注意して使ってください。 


@node Startup Files
@section 起動ファイル
@cindex startup files
@cindex .newsrc
@cindex .newsrc.el
@cindex .newsrc.eld

今や、あなたはファイル @file{.newrc} についてすべて知っています。すべて
の購読情報は伝統的にこのファイルに蓄積されます。

@sc{GNUS} では物事が少々複雑になっています。ファイル @file{.newsrc} を最
新のものにするだけではなく、ファイル @file{.newsrc} には合わない情報を保
存しておくために @file{.newsrc.el} と呼ばれるファイルを使います。 (実際
は、ファイル @file{.newsrc} の全ての情報を複製して保持しています。)
@sc{gnus}はこれらの中で一番最後に保存されたものを使います。これをするこ
とにより、@sc{GNUS} と他のニュースリーダーを切り替えて使うことができます。

これはちょっとばかな方法なので、Gnus はもっと良い方法を編み出しました。
@file{.newsrc} と @file{.newsrc.el} ファイルに加えて、 Gnus は
@file{.newsrc.eld} と呼ばれるファイルも持っています。Gnus はこれらの中で
一番新しいファイルを読みますが、ファイル @file{.newsrc.el} に書き込むこ
とはありません。ファイル @file{.newsrc.eld} は絶対に消すべきではありませ
ん。---それはファイル @file{.newsrc} にはないたくさんの情報を保持してい
ます。 

ちなみに、gnus は何も変えてません。Lars 同志、万歳！


@vindex gnus-save-newsrc-file
@code{gnus-save-newsrc-file} を @code{nil} にすることによってファイル
@file{.newsrc} に書き込むのを止めることができます。そうすれば、そのファ
イルを削除することができ、ディスク容量を節約することができ、gnus の終了
が速くなります。しかし、そうすると他のニュースリーダーを使えなくなります。
でも、ちょっと、誰かそうしたい人がいるでしょうか。 

@vindex gnus-save-killed-list
@code{gnus-save-killed-list} (ディフォルト では @code{t}) が @code{nil} 
であると、gnus は削除されたグループを起動ファイルに保存しません。これは、
(起動時と終了時の) 時間と、(ディスクの) 容量を節約します。こうすると、
gnusがどのグループが新しいかの記録を持っていないことになりますので、新し
いグループの自動購読方法は意味が無くなります。この変数を @code{nil} にし
たときは、@code{gnus-check-new-newsgroups} を常に @code{nil} か 
@code{ask-server} にしておくべきでしょう (@pxref{New Groups})。この変数
は正規表現であることもできます。そのような場合は、ファイルを保存する直前
にその正規表現に合致しないすべてのグループを消去します。これは、すべての
サーバーが @code{ask-server} を理解するわけではない、といったような、特
定のあいまいな状況のときに役に立つでしょう。 

@vindex gnus-startup-file
変数 @code{gnus-startup-file} は起動ファイルがどこにあるかを指定します。
ディフォルトの値は @file{~/.newsrc} で、それがどのようなものであれ、
末尾に @samp{.eld} をつけたものが gnus (El Dingo) の起動ファイルになりま
す。 

@vindex gnus-save-newsrc-hook
@vindex gnus-save-quick-newsrc-hook
@vindex gnus-save-standard-newsrc-hook
@code{gnus-save-newsrc-hook} は newsrc ファイルの中のどれかを保存する前に実
行されるのに対し、@code{gnus-save-quick-newsrc-hook} はファイル
@file{.newsrc.eld} を保存する前に実行され、
@code{gnus-save-standard-newsrc-hook} はファイル @file{.newsrc.eld} を保
存する前に実行されます。後の二つは普通は版管理を入れたり切ったりするのに
使われます。ディフォルトでは、起動ファイルを保存するときに版管理に入りま
す。バックアップファイルの作成を止めたいときは、次のようにしてください。 

@lisp
(defun turn-off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'gnus-save-quick-newsrc-hook 'turn-off-backup)
(add-hook 'gnus-save-standard-newsrc-hook 'turn-off-backup)
@end lisp

@vindex gnus-init-file
Gnus が起動すると、@code{gnus-site-init-file} (ディフォルトでは
@file{.../site-lisp/gnus}) と @code{gnus-init-file} (ディフォルトでは
@file{~/.gnus}) のファイルを読み込みます。これらは普通の Emacs Lisp ファ
イルで、@file{~/.emacs} や @file{site-init} ファイルを gnus 関係のもので
乱雑にしないようにするために使うことができます。Gnus はこれらと同じ名前
のファイルを調べますが、接尾語 @file{.elc} と @file{.el} がついているも
のも調べます。言い換えれば、@code{gnus-init-file} を @file{~/.gnus} に設
定すると、gnus は (この順番に) @file{~/.gnus.elc} 、@file{~/.gnus.el} を
探し、最後に @file{~/.gnus} を探します。



@node Auto Save
@section 自動保存
@cindex dribble file
@cindex auto-save

何か gnus のデータを変更すること (記事を読む、印を付ける、グループを削除
または購読する) をしたとき、変更は特別な@dfn{ドリブルバッファ (dribble
buffer)} に書き込まれます。このバッファはEmacs が普通するように自動保存
されます。ファイル @file{.newsrc} を保存する前に Emacsが落ちたときは、す
べての変更をこのファイルから回復することができるでしょう。

起動時に gnus がこのファイルの存在を発見すると、gnus はそれを読み込むか
どうかを利用者に尋ねます。本当の起動ファイルが保存されれば、自動保存ファ
イルは削除されます。 

@vindex gnus-use-dribble-file
@code{gnus-use-dribble-file} が @code{nil} であると、gnus はドリブルバッ
ファをつくったり、維持したりしません。ディフォルトは @code{t} です。

@vindex gnus-dribble-directory
Gnus はドリブルファイルを @code{gnus-dribble-directory} に置きます。ディ
フォルトではそのようになっていますが、この変数が @code{nil} であると、
gnus はファイル@file{.newsrc} の置かれているディレクトリ (これは普通は利
用者のホームディレクトリです) に入っていってドリブルファイルを作ります。
ドリブルファイルは @code{.newsrc} と同じ許可属性を与えられます。 


@node The Active File
@section 現状ファイル
@cindex active file
@cindex ignored groups

Gnus は起動したときや、実際に新しい記事が到着しているかを決定しようとす
るときに、現状ファイルを読み込みます。これはとても大きなファイルで、その
サーバーの活動中のグループと記事のすべてのリストが入っています。

@vindex gnus-ignored-newsgroups
現状ファイルを検査する前に、gnus は正規表現 
@code{gnus-ignored-newsgroups} に合うすべての行を削除します。これは主に
偽の名前を持つグループを排除するために使われてきましたが、興味の無いグルー
プの階層を無視するために使うこともできます。しかし、これはお勧めできませ
ん。本当のことを言うと、全く賛成できません。代わりに、そのような用途に用
いられる変数の概略を知るために、@pxref{New Groups} を参照してください。

@c This variable is
@c @code{nil} by default, and will slow down active file handling somewhat
@c if you set it to anything else.

@vindex gnus-read-active-file
@c @head
現状ファイルは比較的大きくなる傾向があるので、遅い回線を使っているときは、
現状ファイルを読み込まないように @code{gnus-read-active-file} を 
@code{nil} に設定することができます。この変数はディフォルトでは
@code{some} です。

そのような時は、gnus は実際に購読されているグループに関する情報だけを得
てやっていこうとします。

気を付けてほしいのは、あなたが山ほどのたくさんのグループを購読していると
きにこの変数を @code{nil} 設定すると、gnus は速くなるどころか、遅くなっ
てしまうということです。現状では、ニューズを 2400bps 以上のモデムを通し
て読んでいるのでない限り、gnus の速度はかなり遅くなるでしょう。

この変数は @code{some} という値も取ることができます。その時は、gnus は現
状の情報を購読されているグループのものだけを得ようとします。いくつかのサー
バー (命令@code{LIST ACTIVE group} を使うことのできる、最新鋭の INN サー
バー) では、非常に早くなるでしょうが、他のサーバーでは速くはありません。
どのようにせよ、遅い回線では @code{some} は @code{nil} よりも速く、それ
はもちろん@code{t} よりも速くなります。

もしこの変数が @code{nil} であると、gnus は完全にがんじがらめの方法でグ
ループの情報を得ようとします。そして、これはあまり速くありません。もしそ
れが @code{some} で @sc{nntp} サーバーを使っているときは、gnus はできる
だけ速く命令を出し、一撃ですべての返答を読み込みます。この方が普通はより
良い結果をもたらしますが、サーバーが命令 @code{LIST ACTIVE group} を理解
しないなら、サーバーにとってはあまり良いとは言えません。

@code{some} か @code{nil} を使うのであれば、どちらにしろ速度を上げるため
にすべての興味の無いグループを必ず削除するべきでしょう。

この変数は２番目の (secondary) 方法の現状ファイル取得にも影響することに気
を付けてください。


@node Startup Variables
@section 起動変数

@table @code

@item gnus-load-hook
@vindex gnus-load-hook
Gnus が読み込まれているときに実行されるフックです。何度 gnus を起動しても、
Emacs が起動してから終了するまでに普通はこのフックは一回しか実行されないこ
とに注意してください。

@item gnus-before-startup-hook
@vindex gnus-before-startup-hook
Gnus の起動に成功した後に実行されるフックです。

@item gnus-startup-hook
@vindex gnus-startup-hook
Gnus が起動された後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook
Gnus の起動に成功した後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook

ファイル @file{.newsrc} を読み込んだ後で、グループバッファを作成する前に
実行されるフックです。

@item gnus-check-bogus-newsgroups
@vindex gnus-check-bogus-newsgroups
もし @code{nil} でないと、gnus は起動時に調べてすべての偽グループを削除
します。@dfn{偽グループ (bogus group)} はあなたの @file{.newsrc} ファイ
ルには存在するけれど、ニューズサーバーには実際には存在しない、というグルー
プのことです。偽グループを調べるのにはかなり時間がかかりますので、時間と
資源を節約するために、この機能は使わないほうがいいでしょう。そして、代わ
りにグループバッファで時々偽グループを調べるのが良いでしょう
(@pxref{Group Maintenance} を参照してください)。

@item gnus-inhibit-startup-message
@vindex gnus-inhibit-startup-message
もし @code{nil} でないと、起動時のメッセージは表示されません。そのように
すれば、仕事の代わりにニューズを読んでいるのを上司に気付かれにくくなるで
しょう。この変数は @file{.gnus.el} がロードされる前に使われますので、
@code{.emacs} に設定するべきである点を注意してください。

@item gnus-no-groups-message
@vindex gnus-no-groups-message
グループが一つも存在しないときに gnus が表示するメッセージです。

@item gnus-play-startup-jingle
@vindex gnus-play-startup-jingle
もし @code{nil} でないと、起動時に gnus の短い曲を演奏します。

@item gnus-startup-jingle
@vindex gnus-startup-jingle
上の変数が @code{nil} でないときに演奏される短い曲です。ディフォルトは
@samp{Tuxdemoon.Jingle4.au} です。

@end table


@node The Group Buffer
@chapter グループバッファ
@cindex group buffer

グループバッファ @dfn{group buffer} は有効なグループを全部（あるいは一部を）
一覧表示します。これは gnus を起動したときに最初に表示されるバッファで、
gnus が生きている限り決して消されることはありません。


@iftex
@iflatex
\gnusfigure{The Group Buffer}{320}{
\put(75,50){\epsfig{figure=tmp/group.ps,height=9cm}}
\put(120,37){\makebox(0,0)[t]{Buffer name}}
\put(120,38){\vector(1,2){10}}
\put(40,60){\makebox(0,0)[r]{Mode line}}
\put(40,58){\vector(1,0){30}}
\put(200,28){\makebox(0,0)[t]{Native select method}}
\put(200,26){\vector(-1,2){15}}
}
@end iflatex
@end iftex

@menu
* Group Buffer Format::    表示されている情報と変更の方法。
* Group Maneuvering::      グループバッファを移動するコマンド。
* Selecting a Group::      実際にニュースを読む。
* Group Data::             グループの情報を変更する。
* Subscription Commands::  購読、購読中止、消去。
* Group Levels::           レベル？それって何？
* Group Score::            あなたの好きなグループを見つけ出す方法。
* Marking Groups::         グループに印をつけておいて、後で処理できます。
* Foreign Groups::         グループの作成と修正。
* Group Parameters::       グループ毎に違ったパラメータを持たせられます。
* Listing Groups::         Gnus はグループをいろいろな分け方で表示できます。
* Sorting Groups::         グループの順番の配置替え。
* Group Maintenance::      きれいな @file{.newsrc} の保ち方。
* Browse Foreign Server::  サーバをブラウズできます。何が読めるのか見てみよう。
* Exiting Gnus::           ニュース読むのをやめて、仕事をしよう。
* Group Topics::           グループを切り混ぜて、トピックごとに分割する。
* Misc Group Stuff::       他にできること。
@end menu


@node Group Buffer Format
@section グループバッファの形式

@menu
* Group Line Specification::       グループバッファの見え方を決める。
* Group Modeline Specification::   グループバッファのモード行。
* Group Highlighting::             グループバッファにきれいに色をつける。
@end menu


@node Group Line Specification
@subsection グループ行の仕様
@cindex group buffer format

グループバッファのデフォルトでの形式はきれいでつまんないけど、こ
れは君の好きなように、サイコーにダサくすることもできます。

これがグループ行の例です。

@example
     25: news.announce.newusers
 *    0: alt.fan.andrea-dworkin
@end example

とっても簡単でしょ？

@samp{news.announce.newusers} には 25 の未読記事があるのがわかります。
@samp{alt.fan.andrea-dworkin} には未読記事はないけれども、印をつけた記事が
いくつかあります（行頭のちっちゃなアスタリスクが見える？）。

@vindex gnus-group-line-format
この形式は @code{gnus-group-line-format} 変数をいじることで、どんな風にで
も変えられます。この変数は @code{format} の仕様風に動作します。つまり（あ
のクソ）C 言語を使う人たちのため、printf の仕様とほぼ同じです。
@xref{Formatting Variables}

@samp{%M%S%5y: %(%g%)\n} という値で上記の行を生成します。

コロンは、この行の中に必ず無くてはいけません。カーソルは、何かの操作をした
後は常にコロンのところに移動するからです。他には何も必要ではありません――
グループ名さえもです。表示されている文字は全てただの画面の飾りであり、
gnus がそれを調べることはありません。Gnus は必要とする全ての実情報を、テキ
スト属性を使って憶えています。


（もし君が、すごくヘンな、素晴らしい、表計算風のレイアウトを作ったとしたら、
みんな、君は会計の仕事が忙しくって、ニュースを読んで時間を無駄使いしたりな
んかしてない、って信じてくれるよ。）

以下が使用できるフォーマット文字のリストです。

@table @samp

@item M
そのグループが印のついた記事だけのときは、アスタリスク文字。

@item S
そのグループが購読されているかどうか。

@item L
購読度のレベル。

@item N
未読記事の数。

@item I
保留記事の数。

@item T
印付き記事の数。

@item R
既読記事の数。

@item t
推定全記事数（これは実際は @var{max-number} - @var{min-number} + 1）。

@item y
未読でも、印付きでも、保留でもない記事の数。

@item i
印付き記事と保留記事の数。

@item g
グループ名のフルネーム。

@item G
グループ名。

@item D
ニューズグループの説明。

@item o
モデレーテッドの場合 @samp{m}.

@item O
モデレーテッドの場合 @samp{(m)}.

@item s
選択メソッド。

@item n
どこからの選択か。

@item z
外部選択メソッドが使われている場合、@samp{<%s:%n>} と同じ文字列。

@item P
トピック (@pxref{Group Topics}) のレベルに応じた字下げ。

@item c
@vindex gnus-group-uncollapsed-levels
短い（省略した）グループ名。@code{gnus-group-uncollapsed-levels} 変数は、
どのレベルまでグループ名を全部残すかを示します。デフォルトは 1 です――こ
の意味は、@samp{gnu.emacs.gnus} のようなグループ名を @samp{g.emacs.gnus} 
に短縮するということです。

@item m
@vindex gnus-new-mail-mark
@cindex %
そのグループに最近新着メールが届いている場合は @samp{%}
(@code{gnus-new-mail-mark})。

@item d
最後にいつこのグループを読んだかを示す文字列 (@pxref{Group Timestamp})。

@item u
利用者定義指定。フォーマット文字列中で、この次の文字はアルファベット文字で
なければいけません。Gnus は @code{gnus-user-format-function-}@samp{X} 関数
を呼び出します。ここで @samp{X} は @samp{%u} に続いている文字です。この関
数は引数に、一つのダミーパラメータを渡されます。この関数は、他の各指定文字
の情報と同様に、バッファに挿入される文字列を返さなければなりません。
@end table

@cindex *
全ての「〜の数」の指定で、もしその情報が利用できない場合にはアスタリスク 
(@samp{*}) が埋められます――例えば、起動されていない外部グループや、不正
なネイティブグループの場合です。


@node Group Modeline Specification
@subsection グループモード行の仕様
@cindex group modeline

@vindex gnus-group-mode-line-format
モード行は @code{gnus-group-mode-line-format} (@pxref{Formatting
Variables}) を設定することで変更できます。こいつは指定文字をあん
まりたくさん知ってません。

@table @samp
@item S
ネイティブのニュースサーバ。
@item M
ネイティブの選択メソッド。
@end table


@node Group Highlighting
@subsection グループのハイライト
@cindex highlighting
@cindex group highlighting

@vindex gnus-group-highlight
グループバッファのハイライトは @code{gnus-group-highlight} 変数
によって制御されています。これは @var{(form . face)} のようなも
のを要素に持つ連想リストです。@var{form} が何か @code{nil} 以外
に評価されるものなら、その行に対して @var{face} が使用されます。

以下がこの変数の値の例です。これは背景が暗い設定ではきれいに見え
るかも知れません。

@lisp
(face-spec-set 'my-group-face-1 '((t (:foreground "Red" :bold t))))
(face-spec-set 'my-group-face-2 '((t (:foreground "SeaGreen" :bold t))))
(face-spec-set 'my-group-face-3 '((t (:foreground "SpringGreen" :bold t))))
(face-spec-set 'my-group-face-4 '((t (:foreground "SteelBlue" :bold t))))
(face-spec-set 'my-group-face-5 '((t (:foreground "SkyBlue" :bold t))))

(setq gnus-group-highlight
      '(((> unread 200) . my-group-face-1)
	((and (< level 3) (zerop unread)) . my-group-face-2)
	((< level 3) . my-group-face-3)
	((zerop unread) . my-group-face-4)
	(t . my-group-face-5)))
@end lisp

@pxref{Faces and Fonts} も参照してください。

この form が評価されるときに動的に束縛されている変数には以下のも
のがあります。


@table @code
@item group
グループ名。
@item unread
そのグループの未読記事の数。
@item method
選択メソッド。
@item mailp
そのグループがメールのグループかどうか。
@item level
そのグループのレベル。
@item score
そのグループのスコア。
@item ticked
そのグループ中の印の付いた記事の数。
@item total
そのグループ中の全記事数。もっと正確に言うと、MAX-NUMBER - MIN_NUMBER +
1.
@item topic
トピックマイナーモードを使用している時、この変数は挿入されてい
る現在のトピックに束縛されます。 
@end table

この form が評価 (@code{eval}) されるときは、ポイントは問題のグループの行
頭にあります。従って、通常の gnus の関数のほとんどを使ってそのグループの情
報を取ってくることができます。

@vindex gnus-group-update-hook
@findex gnus-group-highlight-line
@code{gnus-group-update-hook} はグループ行が変更されたときに呼び
出されます。これは @code{gnus-visual} が @code{nil} のときは呼び
出されません。このフックはデフォルトでは
@code{gnus-group-highlight-line} を呼び出します。

@node Group Maneuvering
@section グループ操作
@cindex group movement

全ての移動コマンドは数字プレフィックスを理解するので、期待する通
りの動作をします。たぶんね。

@table @kbd

@item n
@kindex n (Group)
@findex gnus-group-next-unread-group
次の未読記事のあるグループに移動します
(@code{gnus-group-next-unread-group})。

@item p
@itemx DEL
@kindex DEL (Group)
@kindex p (Group)
@findex gnus-group-prev-unread-group
一つ前の未読記事のあるグループに移動します
(@code{gnus-group-prev-unread-group})。

@item N
@kindex N (Group)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item P
@kindex P (Group)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item M-n
@kindex M-n (Group)
@findex gnus-group-prev-unread-group-same-level
一つ前の同じレベル（もしくはそれより小さいレベル）の未読グループに移動しま
す(@code{gnus-group-prev-unread-group-same-level})。

@item M-p
@kindex M-p (Group)
@findex gnus-group-next-unread-group-same-level
次の同じレベル(もしくはそれより小さいレベル)の未読グループに移動します
(@code{gnus-group-next-unread-group-same-level})。
@end table

次の３つの命令はグループにジャンプするためのものです：

@table @kbd

@item j
@kindex j (Group)
@findex gnus-group-jump-to-group
グループにジャンプします（それが見えるようになっていなかったら見えるように
します）(@code{gnus-group-jump-to-group})。kill されているグループも、生き
ているグループと同様にジャンプできます。

@item ,
@kindex , (Group)
@findex gnus-group-best-unread-group
最も小さいレベルの未読グループにジャンプします
(@code{gnus-group-best-unread-group})。

@item .
@kindex . (Group)
@findex gnus-group-first-unread-group
最初の未読記事のあるグループにジャンプします
(@code{gnus-group-first-unread-group})。
@end table

@vindex gnus-group-goto-unread
@code{gnus-group-goto-unread} が @code{nil} にすると、全ての移動
コマンドは、次の未読グループではなく次のグループに移動するように
なります。そのコマンドが次の未読グループに移動する、と言い張って
いても、です。デフォルトは @code{t} です。


@node Selecting a Group
@section グループの選択
@cindex group selection

@table @kbd

@item SPACE
@kindex SPACE (Group)
@findex gnus-group-read-group
現在のグループを選択し、サマリバッファに切り替えて最初の未読記事を表示しま
す (@code{gnus-group-read-group})。もしそのグループに未読記事が無い、もし
くはこのコマンドに数字以外のプレフィックスを与えると、gnus はサーバからこ
のグループの全ての古い記事を取得しようとします。@var{N} の数字プレフィック
スを与えると、gnus の取得する記事数は @var{N} になります。@var{N} が正の数
であれば gnusは新しい方から @var{N} 個の記事を取得し、 @var{N} が負の数で
あれば gnus は古い方から @var{N} 個の記事を取得します。

@item RET
@kindex RET (Group)
@findex gnus-group-select-group
現在のグループを選択し、サマリバッファに切り替えます
(@code{gnus-group-select-group})。@code{gnus-group-read-group} と同じ引数
を取ります――唯一の違いは、グループに入ったときに最初の未読記事を表示しな
い、ということです。

@item M-RET
@kindex M-RET (Group)
@findex gnus-group-quick-select-group
これは上記のコマンドと同じ動作をしますが、「ゴタゴタ」は最低限にしようとし
ます (@code{gnus-group-quick-select-group})。スコア・kill の処理は行われず、
ハイライトも記事消去もしません。これは、あなたが本当に急いでいて、どっかの
やたらでっかいグループに入らなければいけないときに役に立つかもしれません。
また、プレフィックスに 0 を与えれば（すなわち @kbd{0 M-RET}）、gnus はサマ
リバッファを作ろうとさえしません。これはサマリバッファを作る前にスレッド表
示を切り替えたいとき役に立ちます (@pxref{Summary Generation Commands})。

@item M-SPACE
@kindex M-SPACE (Group)
@findex gnus-group-visible-select-group
これは @kbd{RET} コマンドと同じ動作をするさらにもう一つのコマン
ドですが、このコマンドは記事消去と保留記事を隠す処理を行いません
(@code{gnus-group-visible-select-group})。

@item M-C-RET
@kindex M-C-RET (Group)
@findex gnus-group-select-group-ephemerally
最後にこのコマンドは、現在のグループを一度限り、その内容に一切の
処理をすることのないように選択します
(@code{gnus-group-select-group-ephemerally})。 スレッド表示さ
えも行われません。この方法で選択した後にこのグループに対して行っ
たことは全て、その後に影響を与えることはありません。

@end table

@vindex gnus-large-newsgroup
@code{gnus-large-newsgroup} 変数は、何を大きなグループと考えるべきか、を 
gnus に与えます。これは デフォルトでは 200 です。グループに（未読と印付き
の）記事がこの数以上あれば、gnus はそのグループに入る前に利用者に確認を求
めます。利用者はサーバからいくつの記事を取得するかを指定できます。もし利用
者が負の数 (@code{-n}) を指定すれば、古い方から @code{n} 個の記事を取得し
ます。正の数であれば、新しく到着した方から @code{n} 個の記事を取得します。

@vindex gnus-select-group-hook
@vindex gnus-auto-select-first
@code{gnus-auto-select-first} は、@kbd{SPACE} コマンドでグループ
に入ったときに、自動的に記事を選択するかどうかを制御します。

@table @code

@item nil
グループに入ったときにどの記事も選択しない。ただサマリバッファを
表示するだけ。

@item t
グループに入ったときに、最初の未読記事を選択する。

@item best
グループに入ったときに、そのグループで最も高いスコアの記事を選択
する。 
@end table

もしあるグループで自動記事選択をやめたいのであれば（例えばでっかい記事のあ
るバイナリグループでは、とか）、グループが選択されたときに呼び出される
@code{gnus-select-group-hook} の中でこの変数を @code{nil} に設定することが
できます。


@node Subscription Commands
@section 購読制御コマンド
@cindex subscription

@table @kbd

@item S t
@itemx u
@kindex S t (Group)
@kindex u (Group)
@findex gnus-group-unsubscribe-current-group
@c @icon{gnus-group-unsubscribe}
現在のグループの購読を切り替えます
(@code{gnus-group-unsubscribe-current-group})。

@item S s
@itemx U
@kindex S s (Group)
@kindex U (Group)
@findex gnus-group-unsubscribe-group
グループを購読するかどうかを確認し、購読します。すでに購読するよ
うになっている場合には、購読を止めます
(@code{gnus-group-unsubscribe-group})。

@item S k
@itemx C-k
@kindex S k (Group)
@kindex C-k (Group)
@findex gnus-group-kill-group
@c @icon{gnus-group-kill-group}
現在のグループを kill します (@code{gnus-group-kill-group})。

@item S y
@itemx C-y
@kindex S y (Group)
@kindex C-y (Group)
@findex gnus-group-yank-group
最後に kill したグループを yank します
(@code{gnus-group-yank-group})。

@item C-x C-t
@kindex C-x C-t (Group)
@findex gnus-group-transpose-groups
二つのグループの順序を置き換えます
(@code{gnus-group-transpose-groups})。 これはホントは購読コマン
ドではありませんが、kill と yank を何度か続ける代わりにこのコマ
ンドが使えます。

@item S w
@itemx C-w
@kindex S w (Group)
@kindex C-w (Group)
@findex gnus-group-kill-region
リージョン内の全てのグループを kill します
(@code{gnus-group-kill-region})。

@item S z
@kindex S z (Group)
@findex gnus-group-kill-all-zombies
全てのゾンビグループを kill します
(@code{gnus-group-kill-all-zombies})。

@item S C-k
@kindex S C-k (Group)
@findex gnus-group-kill-level
あるレベルのグループを全て kill します
(@code{gnus-group-kill-level})。 kill した後、これらのグループを
yank で戻すことはできないので、このコマンドはいくらか注意して使っ
てください。このコマンドが本当に便利になるのは、@file{.newsrc} 
に捨てちゃいたい未購読のグループがたくさんあるときだけです。レベ
ル 7で @kbd{S C-k} を行うと、@file{.newsrc} ファイル中にメッセー
ジ番号がない未購読グループを全て kill します。

@end table

@pxref{Group Levels} も参照してくください。


@node Group Data
@section グループデータ

@table @kbd

@item c
@kindex c (Group)
@findex gnus-group-catchup-current
@vindex gnus-group-catchup-group-hook
@c @icon{gnus-group-catchup-current}
そのグループ内の全ての無印の記事を既読にする
(@code{gnus-group-catchup-current})。グループバッファから既読にした場合は
@code{gnus-group-catchup-group-hook} が呼び出されます。

@item C
@kindex C (Group)
@findex gnus-group-catchup-current-all
そのグループの全記事を、印付きの記事も含めて既読にします
(@code{gnus-group-catchup-current-all})。

@item M-c
@kindex M-c (Group)
@findex gnus-group-clear-data
現在のグループの全てのデータをクリアします――マークと既読記事のリストを消
し去ります (@code{gnus-group-clear-data})。

@item M-x gnus-group-clear-data-on-native-groups
@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
もし @sc{nntp} サーバを別のものに切り替えたとすると、全てのマークと既読情
報はもう役には立ちません。このコマンドを使ってネイティブグループの全てのデー
タをクリアすることができます。注意して使ってね。

@end table


@node Group Levels
@section グループレベル
@cindex group level
@cindex level

全てのグループは購読度 @dfn{subscribedness} のレベルを持ちます。
例えば、あるグループがレベル 2 だとすれば、それはレベル 5 のグルー
プよりも「より購読している」ということです。Gnus に対して、ある
レベルかそれより小さいレベルのグループのみ一覧表示するように頼む
こともできるし (@pxref{Listing Groups})、あるレベルかそれより小
さいレベルのグループの新着記事のみを確認することもできます
(@pxref{Scanning New Messages})。

忘れないで: グループのレベルが大きいほど、重要度は低くなるということ。

@table @kbd

@item S l
@kindex S l (Group)
@findex gnus-group-set-current-level
現在のグループのレベルを設定する。数字プレフィックスが与えられる
と、そこから @var{n} 個のグループのレベルが設定されます。レベル
を入力するためのプロンプトが出ます。

@end table

@vindex gnus-level-killed
@vindex gnus-level-zombie
@vindex gnus-level-unsubscribed
@vindex gnus-level-subscribed
Gnus はレベル 1 から @code{gnus-level-subscribed}（この値を含む）（デフォ
ルトは 5）までのグループを購読、@code{gnus-level-subscribed}（この値を含ま
ない）から@code{gnus-level-unsubscribed}（この値を含む）（デフォルトは 7）
までのグループを非購読、@code{gnus-level-zombie} をゾンビ（歩く屍）（デフォ
ルトは 8）、@code{gnus-level-killed} を kill されている（完全に死んでる）
（デフォルトは 9）と判断します。Gnus は購読と非購読のグループは全く同様に
扱いますが、ゾンビと kill グループは、どの記事を読んだか、存在するかなどの
情報を一切持ちません。この死んでるグループと生きてるグループの区別は、別に
それがきれいだからとか賢いからというわけではなく、純粋に効率的な理由のため
です。

メール用のグループは（もしあれば）非常に小さいレベル（例えば 1 か 2）にし
ておくことをお勧めします。

もしレベル変数で遊びたいのであれば、多少注意をしてまわる必要があ
ります。一旦それを設定したら、二度とそれに触らないでください。さ
らに言えば、自分で何をやっているかを正確に理解していない限り、一
切触らないでください。

@vindex gnus-level-default-unsubscribed
@vindex gnus-level-default-subscribed
身近に関係する2つの変数は @code{gnus-level-default-subscribed}（デフォルト
は 3）と @code{gnus-level-default-unsubscribed}（デフォルトは 6）です。こ
れらは新しいグループが（非）購読されたときのレベルです。もちろ
ん、これら２つの変数の値は、意味のある正しい範囲でなくてはなりません。

@vindex gnus-keep-same-level
@code{gnus-keep-same-level} が @code{nil} 以外であれば、移動コマンドのいく
つかは同一（あるいはそれより小さい）レベルのグループのみの移動になります。
特に、あるグループの最後の記事から次のグループに移るとき、次の同一（あるい
はそれより小さい）レベルのグループに移動します。これは残りのグループを読む
より先に、より重要なグループを読んでおきたいときには便利かもしれません。

@vindex gnus-group-default-list-level
デフォルトでは @code{gnus-group-default-list-level} と同じかそれ
より小さいレベルのグループが、グループバッファに一覧表示されます。

@vindex gnus-group-list-inactive-groups
@code{gnus-group-list-inactive-groups} が @code{nil} 以外であれ
ば、未読のグループに一緒にアクティブでないグループも表示します。
この変数はデフォルトで @code{t} です。もしこれが @code{nil} であ
れば、アクティブでないグループは表示されません。

@vindex gnus-group-use-permanent-levels
@code{gnus-group-use-permanent-levels} が @code{nil} 以外であれ
ば、一旦レベルを @kbd{g} や @kbd{l} のプレフィックスに与えると、
その後の全てのコマンドにおいてそのレベルが「作用する」レベルにな
ります。


@vindex gnus-activate-level
Gnus は通常、@code{gnus-activate-level} かそれより小さいレベルのグループの
みを起動します（つまりサーバに問い合わせをする）。購読していないグループを
起動したくなければ、この変数を例えば 5 に設定するとよいかもしれません。デ
フォルトは 6 です。

@node Group Score
@section グループのスコア
@cindex group score
@cindex group rank
@cindex rank

普通は重要なグループは高レベルにしておくでしょうけれども、この方
法では少々制限がきついですよね。ひょっとしたら、グループをどれく
らい頻繁に読むかによってグループバッファをソートしたいなあ、なん
て思わない？理にかなってるでしょ？

グループスコア @dfn{group score} はそのためのものです。それぞれのグループ
に対してスコアを指定することができます。そしてグループバッファをこのスコア
を基にソートすることができます。あるいは、スコア順でソートしてその後レベル
でソートすることもできます。（レベルとスコアをひとまとめにして、グループの
ランク @dfn{rank} と呼びます。レベルが 4 でスコアが 1 のグループは、レベル
が 5 でスコアが 300 のグループよりも高いランクとなります。（レベルの方が重
要度が高く、スコアの方は重要度が低くなります。））

@findex gnus-summary-bubble-group
頻繁に読むグループに、めったに読まないグループよりも高いスコアを与えたいと
きは、@code{gnus-summary-exit-hook} フックに
@code{gnus-summary-bubble-group} 関数を追加することができます。これでバブ
ルソートの実行結果が（ソートの後で）得られるでしょう。サマリモードを終了す
るたびにこの活動をさせたいのであれば、同じフックに 
@code{gnus-group-sort-groups-by-rank} か
@code{gnus-group-sort-groups-by-score} を追加できますが、いくらか遅くなる
でしょう。


@node Marking Groups
@section グループへのマーク
@cindex marking groups

もしいくつかのグループに対して何らかの命令を実行したい場合で、それらがグルー
プバッファに連続してある場合には、通常通り命令に対して数字プレフィックスを
与えるだけです。そうすればほとんどのグループコマンドは、これらのグループに
対してあなたの命令に従います。

しかしそれらのグループが順番に並んでいない場合においても、いくつかのグルー
プに対して命令を実行することができます。単に始めにプロセスマークでグループ
にマークをつけておき、そして命令を実行するだけです。

@table @kbd

@item #
@kindex # (Group)
@itemx M m
@kindex M m (Group)
@findex gnus-group-mark-group
現在のグループにマークをつける (@code{gnus-group-mark-group})。

@item M-#
@kindex M-# (Group)
@itemx M u
@kindex M u (Group)
@findex gnus-group-unmark-group
現在のグループからマークを削除する (@code{gnus-group-unmark-group})。

@item M U
@kindex M U (Group)
@findex gnus-group-unmark-all-groups
全てのグループからマークを削除する (@code{gnus-group-unmark-all-groups})。

@item M w
@kindex M w (Group)
@findex gnus-group-mark-region
ポイントとマークに間の全てのグループにマークをつける
(@code{gnus-group-mark-region})。

@item M b
@kindex M b (Group)
@findex gnus-group-mark-buffer
バッファ内の全てのグループにマークをつける
(@code{gnus-group-mark-buffer})。

@item M r
@kindex M r (Group)
@findex gnus-group-mark-regexp
ある正規表現にマッチする全てのグループにマークをつける
(@code{gnus-group-mark-regexp})。
@end table

@pxref{Process/Prefix} も参照してください。

@findex gnus-group-universal-argument
プロセスマークが付けられている全てのグループに対して何かの命令を実行したい
ときは、@kbd{M-&} (@code{gnus-group-universal-argument}) 命令を使うことが
できます。プロンプトから実行したい命令を入力します。


@node Foreign Groups
@section 外部グループ
@cindex foreign groups

以下では、一般的な外部グループの作成、変更を行うグループモードの命令をいく
つか、および特別な目的のグループの簡単に作成する命令を紹介します。これらの
命令は全て、新規に作成したグループをポイント位置に挿入します――
@code{gnus-subscribe-newsgroup-method} は参照されません。

@table @kbd

@item G m
@kindex G m (Group)
@findex gnus-group-make-group
@cindex making groups
新しいグループを作成します (@code{gnus-group-make-group})。Gnus はプロン
プトを表示して、名前とメソッドと、場合によっては @dfn{address} の入力を
求めてきます。より簡単に @sc{nntp} グループを購読する方法は、 
@pxref{Browse Foreign Server} を参照してください。

@item G r
@kindex G r (Group)
@findex gnus-group-rename-group
@cindex renaming groups
現在のグループの名前を、何か別のものに変更します
(@code{gnus-group-rename-group})。これはある種のグループ――主にメールグルー
プに対してのみ有効です。このコマンドはバックエンドによっては非常に遅いこと
も有り得ます。

@item G c
@kindex G c (Group)
@cindex customizing
@findex gnus-group-customize
グループパラメータをカスタマイズする (@code{gnus-group-customize})。

@item G e
@kindex G e (Group)
@findex gnus-group-edit-group-method
@cindex renaming groups
現在のグループの選択メソッドを修正するためのバッファに移動します
(@code{gnus-group-edit-group-method})。

@item G p
@kindex G p (Group)
@findex gnus-group-edit-group-parameters
グループパラメータを修正するためのバッファに移動します
(@code{gnus-group-edit-group-parameters})。

@item G E
@kindex G E (Group)
@findex gnus-group-edit-group
グループ情報を修正するためのバッファに移動します
(@code{gnus-group-edit-group})。

@item G d
@kindex G d (Group)
@findex gnus-group-make-directory-group
@cindex nndir
ディレクトリグループを作成します (@pxref{Directory Groups})。ディレクトリ
名をプロンプト入力します (@code{gnus-group-make-directory-group})。

@item G h
@kindex G h (Group)
@cindex help group
@findex gnus-group-make-help-group

Gnus ヘルプグループを作成します (@code{gnus-group-make-help-group})。

@item G a
@kindex G a (Group)
@cindex (ding) archive
@cindex archive group
@findex gnus-group-make-archive-group
@vindex gnus-group-archive-directory
@vindex gnus-group-recent-archive-directory
Gnus アーカイブグループを作成します
(@code{gnus-group-make-archive-group})。デフォルトでは最も最近の記事を指
しているグループが作成されますが
(@code{gnus-group-recent-archive-directory})、プレフィックスを与えると全
ての記事を含むグループが @code{gnus-group-archive-directory} を基に作成
されます。

@item G k
@kindex G k (Group)
@findex gnus-group-make-kiboze-group
@cindex nnkiboze
kiboze グループを作成します。プロンプトで名前と、kiboze グループに「含めた
い」グループにマッチする正規表現と、ヘッダとマッチする文字列の組を入力し
ます (@code{gnus-group-make-kiboze-group})。@xref{Kibozed Groups}。

@item G D
@kindex G D (Group)
@findex gnus-group-enter-directory
@cindex nneething
任意のディレクトリを @code{nneething} バックエンドニューズグループである
かのように読み込みます (@code{gnus-group-enter-directory})。
@xref{Anything Groups}.

@item G f
@kindex G f (Group)
@findex gnus-group-make-doc-group
@cindex ClariNet Briefs
@cindex nndoc
ファイルなどをもとにグループを作成します
(@code{gnus-group-make-doc-group})。このコマンドにプレフィックスを与えた場
合、ファイル名とファイルタイプをプロンプトで入力します。現在サポートされて
いるファイルタイプは、@code{babyl}, @code{mbox}, @code{digest},
@code{mmdf}, @code{news}, @code{rnews}, @code{clari-briefs},
@code{rfc934}, @code{rfc822-forward}, @code{forward} です。プレフィックス
なしでこのコマンドを実行すると、gnus はファイルタイプを推測します。
@xref{Document Groups}。

@item G w
@kindex G w (Group)
@findex gnus-group-make-web-group
@cindex DejaNews
@cindex Alta Vista
@cindex InReference
@cindex nnweb
ウェブ検索結果をもとに一時的なグループを作成します
(@code{gnus-group-make-web-group})。このコマンドにプレフィックスを与えると、
一時的ではなく固定したグループを作成します。プロンプトで検索機関の種類 
(search engine type) と検索文字列を入力します。有効な検索機関の種類には
@code{dejanews}, @code{altavista}, @code{reference} があります。
@xref{Web Searches}.

もし、@code{dejanews} 検索機関を用いる場合には、@samp{~g
alt.sysadmin.recovery shaving} のようなマッチする文字列を用いることによっ
て、検索対象を特定のグループに限定することが可能です。

@item G DEL
@kindex G DEL (Group)
@findex gnus-group-delete-group
この関数は現在のグループを削除します (@code{gnus-group-delete-group})。プ
レフィックスが与えられると、この関数はそのグループ内の全記事を本当に削除し、
グループ自身をこの世から強制的に抹殺してしまいます。プレフィックスは、あな
たが何をやろうとしているか、本当に自信があるときにのみ使ってください。まあ、
このコマンドは（@code{nntp} グループのような）読み出し専用グループには使え
ませんけど。

@item G V
@kindex G V (Group)
@findex gnus-group-make-empty-virtual
新しい、新鮮な、空の @code{nnvirtual} グループを作成します
(@code{gnus-group-make-empty-virtual})。@xref{Virtual Groups}.

@item G v
@kindex G v (Group)
@findex gnus-group-add-to-virtual
現在のグループを @code{nnvirtual} グループに追加します
(@code{gnus-group-add-to-virtual})。これはプロセスマーク・プレフィックスルー
ルに従います。

@end table

さまざまな選択メソッドに関するさらなる情報は @xref{Select Methods} を参
照してください。

@vindex gnus-activate-foreign-newsgroups
もし @code{gnus-activate-foreign-newsgroups} が正の数であれば、gnus は起
動時に、この数かそれよりも小さいレベルの外部グループを全てチェックします。
これは特に違った @sc{nntp} サーバからたくさんのグループを購読している場
合など、しばらく時間がかかるかもしれません。


@node Group Parameters
@section グループパラメータ
@cindex group parameters

グループパラメータは、ある特定のグループローカルな情報を格納します。以下は
グループパラメータリストの例です：

@example
((to-address . "ding@@gnus.org")
 (auto-expire . t))
@end example

それぞれの要素は『点対』(dotted pair)――つまり点 (dot) の前に鍵、点の後ろ
に値があるもの、で構成されます。全てのパラメータはこの形式を取りますが、
@emph{例外}として局所変数の指定は点対ではなく通常のリストになります。

以下は利用可能なグループパラメータです：

@table @code
@item to-address
@cindex to-address
フォローアップとニューズへの投稿をするときに使用されるアドレス。

@example
(to-address .  "some@@where.com")
@end example

これは主に、クローズドなメーリングリストを表わすメールグループにおいて便利
なものです――すなわちメーリングリストに投稿する人は全てそれを購読している
はず、というメーリングリストのことです。このパラメータを使用すると、メール
はそのメーリングリストにしか投稿されないことが保証されるので、参加者はあな
たのフォローアップ記事を２通受け取ることはありません。

@code{to-address} を指定すると、そのグループが外部グループであるかどうか
に関わらず有効になります。例えば @samp{fa.4ad-l} というグループがサーバ
上にあったとしましょう。これは本当のニューズグループですが、サーバはメー
ルニューズゲートウェイを通して記事を受け付けます。つまりこのグループに対
して直接投稿することは不可能で、代わりにそのメーリングリストにメールを送
信しなければなりません。

@item to-list
@cindex to-list
そのグループで @kbd{a} を押したときに使用されるアドレス。

@example
(to-list . "some@@where.com")
@end example

これはフォローアップをしたときは完全に無視されます――例外はそれがニューズ
グループを表わしているときは、@kbd{f} を押したときにメールグループのルール
が適用されるということです。

もし @kbd{a} コマンドをメールグループで実行したときに、@code{to-list} グ
ループパラメータも @code{to-address} もグループパラメータも無ければ、
@code{to-list} グループパラメータは、@code{gnus-add-to-list} が @code{t}
に設定されていればメッセージ送信時に自動的に付加されます。
@vindex gnus-add-to-list

もし @kbd{a} コマンドをメールグループで実行したとき、@code{to-list} グルー
プパラメータがなければ、送信時に自動的に付加されます。


@item visible
@cindex visible
グループパラメータのリスト中に @code{(visible . t)} という要素があれば、
そのグループはグループバッファにおいて、未読記事があるかどうかに関わらず、
常に表示されます。

@item broken-reply-to
@cindex broken-reply-to
@code{(broken-reply-to . t)} という要素があれば、そのグループでは
@code{Reply-To} は無視される、という意味です。これはある listserv によるメー
リングリストを購読していて、それが @code{Reply-To} 欄を listserv 自身に返
すようにつけられている場合に有効でしょう。これはおかしな振る舞いです。だか
らこれが要るんです！

@item to-group
@cindex to-group
@code{(to-group . "some.group.name")} という要素は、そのグループへの投稿
は全て @code{some.group.name} に送られる、という意味です。

@item newsgroup
@cindex newsgroup
グループパラメータリストに @code{(newsgroup . t)} があれば、gnus は全ての
レスポンスをニューズ記事に対するレスポンスであるかのように扱います。これは
実際にはニューズグループのミラーであるメールグループに対して有効です。

@item gcc-self
@cindex gcc-self
グループパラメータリストに @code{(gcc-self . t)} があれば、新しく作成する
メッセージは現在のグループに @code{Gcc} されます。もし @code{(gcc-self
. none)} があれば、@code{Gcc:} 欄は生成されず、@code{(gcc-self
. "string")} があればこの文字列はそのまま @code{gcc} 欄に挿入されます。こ
のパラメータは以下で説明する全ての @code{Gcc} のデフォルトルールよりも優先
されます (@pxref{Archived Messages})。

@item auto-expire
@cindex auto-expire
グループパラメータに @code{(auto-expire . t)} のような要素があれば、全て
の既読記事はエクスパイアされるようにマークされます。他の方法については
@pxref{Expiring Mail} を参照してください。

@item total-expire
@cindex total-expire
グループパラメータに @code{(total-expire . t)} のような要素があれば、既
読記事は、エクスパイアのマークがついていなくとも全てエクスパイア処理を施
されます。注意して使用してください。未読記事、印付き記事、保留記事はエク
スパイアされません。

@item expiry-wait
@cindex expiry-wait
@vindex nnmail-expiry-wait-function
グループパラメータに @code{(expiry-wait . 10)} のような要素があれば、この
値は記事をエクスパイアするときに @code{nnmail-expiry-wait} と
@code{nnmail-expiry-wait-function} の設定よりも優先されます。この値はエク
スパイアの日数（整数である必要はない）かもしくは @code{never} か
@code{immediate} のシンボルを指定できます。

@item score-file
@cindex score file group parameter
@code{(score-file . "file")} のような要素は、@file{file} を現在のグループ
に適用されるスコアファイルにします。適用されるスコアエントリは全てこのファ
イルに入ります。

@item adapt-file
@cindex adapt file group parameter
@code{(adapt-file . "file")} のような要素は、@file{file} を現在のグループ
の適用ファイルにします。全ての適用スコアエントリはこのファイルに入ります。

@item admin-address
メーリングリストから脱会するときは、脱会通知メールをそのメーリングリスト
自身に送信してはいけません。代わりに管理用アドレスにメッセージを送信しま
す。このパラメータにはどこか便利な管理用アドレスを書いておくことができます。

@item display
 @code{(display . MODE)} のような要素は、グループに入るときにどの記事を
表示するかを指定します。有効な値は、

@table @code
@item all
未読、既読記事の両方を全て表示します。

@item default
デフォルトの表示記事を表示します。これは通常は未読記事と印付き記事です。
@end table

@item comment
@code{(comment . "This is a comment")} のような要素は、そのグループに対す
る任意のコメントです。これは現在の gnus では無視されますが、特定のグループ
に対する情報を格納する場所を提供します。

@item @var{(variable form)}
グループに入るときに、そのグループローカルの変数を設定するグループパラメー
タを使用することができます。@samp{news.answers} においてスレッド表示を行
いたくないときは、そのグループにグループパラメータに 
@code{(gnus-show-threads nil)} と書けます。 @code{gnus-show-threads} は、
そのサマリバッファの中のローカル変数になり、form の @code{nil} はそこで
評価されます。

これはもし必要であれば、グループ毎のフック関数としても使用できます。もしあ
るグループに入ったときにビープ音を鳴らしたければ、そのグループのパラメータ
に @code{(dummy-variable (ding))} みたいなものを書いておくこともできます。
@code{dummy-variable} という変数に @code{(ding)} の評価結果が設定されます
が、まあ、誰も気にしないでしょ？

@end table

グループパラメータの修正には @kbd{G p} 命令を使ってください。トピックパラ
メータについて読んでみることも面白いでしょう (@pxref{Topic Parameters})。


@node Listing Groups
@section グループの一覧表示
@cindex group listing

これらのコマンドは、利用できるグループをいろいろに切り分けて表示します。

@table @kbd

@item l
@itemx A s
@kindex A s (Group)
@kindex l (Group)
@findex gnus-group-list-groups
未読記事を持つ全てのグループを表示します (@code{gnus-group-list-groups})。
数字プレフィックスを使うと、このコマンドは引数の数かそれよりも小さいレベル
のグループのみを表示します。デフォルトでは、これはレベル 5（つまり
@code{gnus-group-default-list-level}）かそれより小さいレベル（すなわち購読
しているグループのみ）を表示します。

@item L
@itemx A u
@kindex A u (Group)
@kindex L (Group)
@findex gnus-group-list-all-groups
未読記事のあるなしに関わらず、全てのグループを表示します
(@code{gnus-group-list-all-groups})。数字プレフィックスを使用すると、この
コマンドは引数の数かそれよりも小さいレベルのグループのみを表示します。デフォ
ルトでは 7 かそれよりも小さいレベルのグループ（すなわち購読、非購読のグルー
プのみ）が表示されます。

@item A l
@kindex A l (Group)
@findex gnus-group-list-level
ある特定のレベルの未読記事のあるグループを表示します
(@code{gnus-group-list-level})。プレフィックスを与えると、未読記事のない
グループも含めて表示します。

@item A k
@kindex A k (Group)
@findex gnus-group-list-killed
kill されたグループを全て表示します (@code{gnus-group-list-killed})。プ
レフィックス引数を与えると、現在購読、非購読となっていない全ての利用可能
なグループを表示します。これはサーバからアクティブファイルを読むことにな
るでしょう。

@item A z
@kindex A z (Group)
@findex gnus-group-list-zombies
全てのゾンビグループを表示します (@code{gnus-group-list-zombies})。

@item A m
@kindex A m (Group)
@findex gnus-group-list-matching
正規表現にマッチする名前を持つグループで、未読記事のある購読グループを全
て表示します (@code{gnus-group-list-matching})。

@item A M
@kindex A M (Group)
@findex gnus-group-list-all-matching
正規表現にマッチするグループを表示する
(@code{gnus-group-list-all-matching})。

@item A A
@kindex A A (Group)
@findex gnus-group-list-active
今接続しているサーバのアクティブファイルにあるグループを、本当に全部表示し
ます (@code{gnus-group-list-active})。これはしばらく時間がかかることも有り
得ます。たぶん @kbd{A M} を実行して、マッチさせたい部分を @samp{.} として
全てのマッチするリストを表示させた方が良いでしょう。また、このコマンドは
（まだ）存在しないグループも表示するかも知れません――これは kill されたグ
ループであるかのように表示されます。出力は多少割り引いて受け取ってね。

@item A a
@kindex A a (Group)
@findex gnus-group-apropos
正規表現にマッチする名前を持つグループを全て表示する
(@code{gnus-group-apropos})。

@item A d
@kindex A d (Group)
@findex gnus-group-description-apropos
正規表現にマッチする名前か説明文を持つグループを全て表示する
(@code{gnus-group-description-apropos})。

@end table

@vindex gnus-permanently-visible-groups
@cindex visible group parameter
@code{gnus-permanently-visible-groups} 正規表現にマッチするグループは、
未読記事があるかないかに関わらず常に表示されます。あるいはグループパラメー
タにおいて @code{visible} 要素を追加することでも同様の効果を得ることがで
きます。

@vindex gnus-list-groups-with-ticked-articles
印付きの記事のみを持つグループは通常グループバッファに表示されます。もし
@code{gnus-list-groups-with-ticked-articles} が @code{nil} であれば、そ
のグループは完全に空のグループであるかのように扱われます。デフォルトは
@code{t} です。


@node Sorting Groups
@section グループのソート
@cindex sorting groups

@kindex C-c C-s (Group)
@findex gnus-group-sort-groups
@vindex gnus-group-sort-function
@kbd{C-c C-s} (@code{gnus-group-sort-groups}) 命令は、グループバッファを
@code{gnus-group-sort-function} 変数で与えられる関数に従って並べ替えます。
利用可能な並べ替え関数 (sorting function) には以下のものがあります：

@table @code

@item gnus-group-sort-by-alphabet
@findex gnus-group-sort-by-alphabet
グループ名でアルファベット順に並べ替えます。これが初期設定です。

@item gnus-group-sort-by-real-name
@findex gnus-group-sort-by-real-name
グループを本当の（前に何もついていない）グループ名でアルファベット順に並べ
変えます。

@item gnus-group-sort-by-level
@findex gnus-group-sort-by-level
グループレベルで並べ替えます。

@item gnus-group-sort-by-score
@findex gnus-group-sort-by-score
グループのスコアで並べ替えます。@xref{Group Score}.

@item gnus-group-sort-by-rank
@findex gnus-group-sort-by-rank
グループのスコアで並べ替え、次にグループレベルで並べ替えます。レベルとスコ
アは、ひとまとめにして@dfn{ランク}と呼ばれます。@xref{Group Score}.

@item gnus-group-sort-by-unread
@findex gnus-group-sort-by-unread
未読記事の数で並べ替えます。

@item gnus-group-sort-by-method
@findex gnus-group-sort-by-method
選択メソッドのアルファベット順で並べ替えます。


@end table

@code{gnus-group-sort-function} は並べ替え関数のリストであっても構いません。
この場合、もっとも重要な並べ替えの鍵を持つ関数は最後でなくてはなりません。


ある種の並べ替え用には、直接並べ替える命令もいくつかあります。

@table @kbd
@item G S a
@kindex G S a (Group)
@findex gnus-group-sort-groups-by-alphabet
グループバッファをグループ名のアルファベット順で並べ替えます
(@code{gnus-group-sort-groups-by-alphabet})。

@item G S u
@kindex G S u (Group)
@findex gnus-group-sort-groups-by-unread
グループバッファを未読記事の数で並べ替えます
(@code{gnus-group-sort-groups-by-unread})。

@item G S l
@kindex G S l (Group)
@findex gnus-group-sort-groups-by-level
グループバッファをグループレベルで並べ替えます
(@code{gnus-group-sort-groups-by-level})。

@item G S v
@kindex G S v (Group)
@findex gnus-group-sort-groups-by-score
グループバッファをグループのスコアで並べ替えます
(@code{gnus-group-sort-groups-by-score})。@xref{Group Score}.

@item G S r
@kindex G S r (Group)
@findex gnus-group-sort-groups-by-rank
グループバッファをグループのランクで並べ替えます
(@code{gnus-group-sort-groups-by-rank})。@xref{Group Score}.

@item G S m
@kindex G S m (Group)
@findex gnus-group-sort-groups-by-method
グループバッファをバックエンドの名前でアルファベット順に並べ替えます
(@code{gnus-group-sort-groups-by-method})。

@end table

プレフィックスを与えたときは、これらの命令は全て逆順に並べ替えます。

また、グループの一部を並べ替えることもできます。

@table @kbd
@item G P a
@kindex G P a (Group)
@findex gnus-group-sort-selected-groups-by-alphabet
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループ名のアルファベット順で並べ替えます
(@code{gnus-group-sort-selected-groups-by-alphabet})。

@item G P u
@kindex G P u (Group)
@findex gnus-group-sort-selected-groups-by-unread
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、未
読記事の数で並べ替えます
(@code{gnus-group-sort-selected-groups-by-unread})。

@item G P l
@kindex G P l (Group)
@findex gnus-group-sort-selected-groups-by-level
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループレベルで並べ替えます 
(@code{gnus-group-sort-selected-groups-by-level})。

@item G P v
@kindex G P v (Group)
@findex gnus-group-sort-selected-groups-by-score
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループのスコアで並べ替えます 
(@code{gnus-group-sort-selected-groups-by-score})。@xref{Group Score}.

@item G P r
@kindex G P r (Group)
@findex gnus-group-sort-selected-groups-by-rank
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、グ
ループのランクで並べ替えます
(@code{gnus-group-sort-selected-groups-by-rank})。@xref{Group Score}.

@item G P m
@kindex G P m (Group)
@findex gnus-group-sort-selected-groups-by-method
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、バッ
クエンドの名前でアルファベット順に並べ替えます
(@code{gnus-group-sort-selected-groups-by-method})。

@end table



@node Group Maintenance
@section グループの管理
@cindex bogus groups

@table @kbd
@item b
@kindex b (Group)
@findex gnus-group-check-bogus-groups
不正なグループを見つけて、削除します
(@code{gnus-group-check-bogus-groups})。

@item F
@kindex F (Group)
@findex gnus-group-find-new-groups
新しいグループを見つけて、それらを処理します
(@code{gnus-group-find-new-groups})。プレフィックスを与えると、サーバに
新規グループを問い合わせるのに @code{ask-server} の方法を使用します。

@item C-c C-x
@kindex C-c C-x (Group)
@findex gnus-group-expire-articles
現在のグループのエクスパイア記事に対して（もしあれば）全てエクスパイア処理
を行います (@code{gnus-group-expire-articles})。

@item C-c M-C-x
@kindex C-c M-C-x (Group)
@findex gnus-group-expire-all-groups
全てのグループの全ての記事に対して、エクスパイア処理を行います
(@code{gnus-group-expire-all-groups})。

@end table


@node Browse Foreign Server
@section 外部サーバの閲覧
@cindex foreign servers
@cindex browsing servers

@table @kbd
@item B
@kindex B (Group)
@findex gnus-group-browse-foreign-server
選択メソッドとサーバ名を聞かれます。Gnus はこのサーバに接続し、そこにある
グループを閲覧しようとします (@code{gnus-group-browse-foreign-server})。
@end table

@findex gnus-browse-mode
利用可能なグループのリストを持った新しいバッファが現れます。このバッファ
は @code{gnus-browse-mode} を使用します。このバッファは通常のグループバッ
ファにちょっと（というか、とっても）似ています。

以下が閲覧モード (browse mode) で使用できるキー操作のリストです：

@table @kbd
@item n
@kindex n (Browse)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item p
@kindex p (Browse)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item SPACE
@kindex SPACE (Browse)
@findex gnus-browse-read-group
現在のグループに入り、最初に記事を表示します
(@code{gnus-browse-read-group})。

@item RET
@kindex RET (Browse)
@findex gnus-browse-select-group
現在のグループに入ります (@code{gnus-browse-select-group})。

@item u
@kindex u (Browse)
@findex gnus-browse-unsubscribe-current-group
現在のグループを非購読にする、つまりこの場合は購読することになるのだけれ
ど (@code{gnus-browse-unsubscribe-current-group})。

@item l
@itemx q
@kindex q (Browse)
@kindex l (Browse)
@findex gnus-browse-exit
閲覧モード (browse mode) を終了します (@code{gnus-browse-exit})。

@item ?
@kindex ? (Browse)
@findex gnus-browse-describe-briefly
閲覧モード (browse mode) を簡単に説明します（まあ、大して説明することもな
いんだけどさ）(@code{gnus-browse-describe-briefly})。
@end table


@node Exiting gnus
@section Gnus の終了
@cindex exiting gnus

そう、gnus は最後（サイコー）です（訳注: く、苦しい。原文は ``Yes, gnus
is ex(c)iting.''）。

@table @kbd
@item z
@kindex z (Group)
@findex gnus-group-suspend
Gnus を中断します (@code{gnus-group-suspend})。これは gnus を実際には終了
させず、グループバッファ以外の全てのバッファを消すだけです。僕はこれのうれ
しさがよくわかんないんだけど、誰か分かる人いる？

@item q
@kindex q (Group)
@findex gnus-group-exit
@c @icon{gnus-group-exit}
Gnus を終了します(@code{gnus-group-exit})。

@item Q
@kindex Q (Group)
@findex gnus-group-quit
@file{.newsrc} ファイルをセーブせずに gnus を終了します
(@code{gnus-group-quit})。ドリブルファイルはセーブされますけど
(@pxref{Auto Save})。
@end table

@vindex gnus-exit-gnus-hook
@vindex gnus-suspend-gnus-hook
Gnus を中断するときは @code{gnus-suspend-gnus-hook} が呼び出されます。
Gnusを終了するときは @code{gnus-exit-gnus-hook} が呼び出され、さらに 
gnus を終了するときの最後として @code{gnus-after-exiting-gnus-hook} が呼び
出されます。

@findex gnus-unload
@cindex unloading
もし gnus とそれに関連するものを完全に処分したいのであれば、
@code{gnus-unload} コマンドが使えます。このコマンドは、メタ変数をカスタマ
イズしようとしているときにも便利です。

Note:  

@quotation
ミス Lisa Cannifax は英語の授業中、後ろに座っている少年が彼女の
プラスティックの椅子の背越しに、鉛筆で繰り返し線を描くのにつられ
て、足がしびれて重くなり、意識が朦朧としてきました。
@end quotation


@node Group Topics
@section Group Topics
@cindex topics

もしあなたがたーくさんのグループを読んでいるのであれば、グループをトピック
毎に階層分けできると便利でしょう。Emacs のグループをこっちへ、セックスのグ
ループをあっちへ、で、残りを（え？グループが２つくらいしかないの？）邪魔に
ならないようにその他のセクションに入れましょう。あるいは Emacs セックスの
グループを Emacs グループ、セックスグループのどちらかの副トピックとするこ
とさえもできます――あるいは両方に！すんごいでしょう！

@iftex
@iflatex
\gnusfigure{Group Topics}{400}{
\put(75,50){\epsfig{figure=tmp/group-topic.ps,height=9cm}}
}
@end iflatex
@end iftex

これが例です：

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

@findex gnus-topic-mode
@kindex t (Group)
この@emph{素晴らしい}機能を使うには、@code{gnus-topic} マイナーモードを
（何と！）単にスイッチオンするだけ――グループバッファで、@kbd{t} を押して
ください（これはトグルコマンドです）。

さあやってみよう。とにかく試してみて。君が戻ってくるまで、僕はここで待って
るからさ。ララ、タララン…ん、いい曲だね、これ…ラ、ラ、ラ…え? 戻ってきた？
よし、じゃ次は @kbd{l} を押してみて。ほら。これで全てのグループが 
@samp{misc} の下に表示されました。興奮してクラクラしてこない？アツくって、
いまいましいくらいでしょ？

これをずっと有効にしたければ、グループモードのフックにこのマイナーモード
を追加してください。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@menu
* Topic Variables::    Lisp でトピックをカスタマイズする方法。
* Topic Commands::     超簡単対話型命令。
* Topic Sorting::      トピック毎別々に並べ替える。
* Topic Topology::     全世界の地図。
* Topic Parameters::   あるトピックの全てのグループに適用されるパラメータ。
@end menu


@node Topic Variables
@subsection トピック変数
@cindex topic variables

さて、トピックを選ぶと、トピックは折り畳まれます。これ、とっても
ステキだと思うんだけど。

@vindex gnus-topic-line-format
トピック行は、@code{gnus-topic-line-format} 変数の値に従って作成されます
(@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item i
字下げ。
@item n
トピック名。
@item v
見えるかどうか。
@item l
レベル。
@item g
トピック中のグループの数。
@item a
トピック中の未読記事の数。
@item A
トピックと全ての副トピックの未読記事の数。
@end table

@vindex gnus-topic-indent-level
各副トピック（と副トピック内のグループ）は、トピックレベル数の
@code{gnus-topic-indent-level} 倍の空白分の字下げが行われます。デフォルト
は 2 です。

@vindex gnus-topic-mode-hook
@code{gnus-topic-mode-hook} はトピックマイナーモードバッファで呼び出され
ます。

@vindex gnus-topic-display-empty-topics
@code{gnus-topic-display-empty-topics} はトピックの中に未読記事
が無い場合でもそのトピックを表示するようにします。デフォルトは
@code{t} です。

@node Topic Commands
@subsection トピック命令
@cindex topic commands

トピックマイナーモードが有効であるときは、@kbd{T} サブマップが新
しく利用できるようになります。さらに標準キーの中でも、定義がちょっ
と変わるものが少しあります。

@table @kbd

@item T n
@kindex T n (Topic)
@findex gnus-topic-create-topic
新しいトピックの名前をプロンプト入力し、それを作成します
(@code{gnus-topic-create-topic})。

@item T m
@kindex T m (Topic)
@findex gnus-topic-move-group
現在のグループを、どこか他のトピックに移動させます
(@code{gnus-topic-move-group})。このコマンドはプロセスマーク・プ
レフィックスルールに従います (@pxref{Process/Prefix})。

@item T c
@kindex T c (Topic)
@findex gnus-topic-copy-group
現在のグループを、どこか他のトピックにコピーします
(@code{gnus-topic-copy-group})。このコマンドはプロセスマーク・プ
レフィックスルールに従います (@pxref{Process/Prefix})。

@item T D
@kindex T D (Topic)
@findex gnus-topic-remove-group
グループを現在のトピックから削除します
(@code{gnus-topic-remove-group})。このコマンドはプロセスマーク・
プレフィックスルールに従います (@pxref{Process/Prefix})。

@item T M
@kindex T M (Topic)
@findex gnus-topic-move-matching
正規表現にマッチする全てのグループを、あるトピックに移動させます
(@code{gnus-topic-move-matching})。 

@item T C
@kindex T C (Topic)
@findex gnus-topic-copy-matching
正規表現にマッチする全てのグループを、あるトピックにコピーします
(@code{gnus-topic-copy-matching})。

@item T h
@kindex T h (Topic)
@findex gnus-topic-toggle-display-empty-topics
空のトピックの表示・非表示を切り替えます
(@code{gnus-topic-toggle-display-empty-topics})。

@item T #
@kindex T # (Topic)
@findex gnus-topic-mark-topic
現在のトピックにあるグループ全てにプロセスマークをつけます
(@code{gnus-topic-mark-topic})。

@item T M-#
@kindex T M-# (Topic)
@findex gnus-topic-unmark-topic
現在のトピックにある全てのグループからプロセスマークを消します
(@code{gnus-topic-unmark-topic})。

@item RET
@kindex RET (Topic)
@findex gnus-topic-select-group
@itemx SPACE
グループを選択するか、あるいはトピックを折りたたみます
(@code{gnus-topic-select-group})。グループの上でこのコマンドを実行すると、
通常通りそのグループに入ります。トピック行の上で行うと、そのトピックは（既
に表示されているときは）折りたたまれるか、（既に折りたたまれているときは）
展開されます。つまりトピックに対してはこれはトグルコマンドです。さらに、数
字プレフィックスを与えると、そのレベル（とそれよりも小さいレベル）のグルー
プが表示されます。

@item T TAB
@kindex T TAB (Topic)
@findex gnus-topic-indent
現在のトピックの『字下げ』を行い、その前のトピックの副トピックにします 
(@code{gnus-topic-indent})。プレフィックスを与えると、反対にそのトピックの
字下げを戻します。

@item C-k
@kindex C-k (Topic)
@findex gnus-topic-kill-group
グループあるいはトピックを kill します
(@code{gnus-topic-kill-group})。トピック内にあったグループも全て、
トピックと一緒に削除されます。

@item C-y
@kindex C-y (Topic)
@findex gnus-topic-yank-group
直前の kill されたグループあるいはトピックを yank します
(@code{gnus-topic-yank-group})。全てのトピックは、全てのグループ
の前に yank されることに気をつけてください。

@item T r
@kindex T r (Topic)
@findex gnus-topic-rename
トピックの名前を変更する (@code{gnus-topic-rename})。

@item T DEL
@kindex T DEL (Topic)
@findex gnus-topic-delete
空のトピックを削除する (@code{gnus-topic-delete})。

@item A T
@kindex A T (Topic)
@findex gnus-topic-list-active
Gnus が知っているトピック化されたグループを全て表示します
(@code{gnus-topic-list-active})。

@item G p
@kindex G p (Topic)
@findex gnus-topic-edit-parameters
@cindex group parameters
@cindex topic parameters
@cindex parameters
トピックパラメータを修正します (@code{gnus-topic-edit-parameters})。
@xref{Topic Parameters}.

@end table


@node Topic Sorting
@subsection トピックの並べ替え
@cindex topic sorting

以下に示す命令で、各トピック毎に別々にグループを並べ替えることができます：


@table @kbd
@item T S a
@kindex T S a (Topic)
@findex gnus-topic-sort-groups-by-alphabet
現在のトピックをグループ名のアルファベット順に並べ替えます
(@code{gnus-topic-sort-groups-by-alphabet})。

@item T S u
@kindex T S u (Topic)
@findex gnus-topic-sort-groups-by-unread
現在のトピックを未読記事の数で並べ替えます
(@code{gnus-topic-sort-groups-by-unread})。

@item T S l
@kindex T S l (Topic)
@findex gnus-topic-sort-groups-by-level
現在のトピックをグループのレベルで並べ替えます
(@code{gnus-topic-sort-groups-by-level})。

@item T S v
@kindex T S v (Topic)
@findex gnus-topic-sort-groups-by-score
現在のトピックをグループのスコアで並べ替えます
(@code{gnus-topic-sort-groups-by-score})。@xref{Group Score}.

@item T S r
@kindex T S r (Topic)
@findex gnus-topic-sort-groups-by-rank
現在のトピックをグループのランクで並べ替えます
(@code{gnus-topic-sort-groups-by-rank})。@xref{Group Score}.

@item T S m
@kindex T S m (Topic)
@findex gnus-topic-sort-groups-by-method
現在のトピックをバックエンドの名前でアルファベット順に並べ替えます 
(@code{gnus-topic-sort-groups-by-method})。

@end table

グループのソートについてのさらなる情報は @xref{Sorting Groups} を参照して
ください。


@node Topic Topology
@subsection トピックの位相構造
@cindex topic topology
@cindex topology

それでは、グループバッファの例を見ていきましょう。

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

つまり、ここでは一つのトップレベルのトピック (@samp{Gnus}) があり、その下
に２つのトピックがあり、そのうちの一方の副トピック中に一つ副トピックがあり
ます（トップレベルトピックは常に一つしかありません）。この構造は、以下のよ
うに表現できます：

@lisp
(("Gnus" visible)
 (("Emacs -- こいつはすげーぜ!" visible)
  (("えっちな Emacs" visible)))
 (("その他" visible)))
@end lisp

@vindex gnus-topic-topology
これは実に、上記の表示を行うための、変数 @code{gnus-topic-topology} の値そ
のものなのです。この変数は@file{.newsrc.eld} ファイルに保存され、手でいじ
くり回してはいけません――本当にやりたいときは別ですが。この変数は
@file{.newsrc.eld} ファイルから読み込まれるので、その他のスタートアップファ
イルの設定には全く影響を与えません。

この構造は、どのトピックがどのトピックの副トピックであるかと、どのトピック
が表示されているかを示しています。現在は二つの設定値――@code{visible} と 
@code{invisible} が許されています。


@node Topic Parameters
@subsection トピックパラメータ
@cindex topic parameters

トピック内の全てのグループはグループパラメータを、その親（と先祖）のトピッ
クパラメータから継承します。グループパラメータとして正しいものは全て、トピッ
クパラメータとしても正しいものです(@pxref{Group Parameters})。

グループパラメータは（もちろん）トピックパラメータよりも優先され、副トピッ
クのトピックパラメータは親トピックのトピックパラメータよりも優先されます。
分かるよね。ごく普通の継承ルールです（ルール (@dfn{Rules}) はここでは名詞
であって、動詞の「線を引く」ではありません。このルールには反対したくなるか
も知れないけど、それはご自由に）。

@example
Gnus
  Emacs
     3: comp.emacs
     2: alt.religion.emacs
   452: alt.sex.emacs
    息抜き
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
   452: alt.sex.emacs
@end example

@samp{Emacs} トピックはトピックパラメータ @code{(score-file
. "emacs.SCORE")} を持っています。@samp{息抜き} トピックはトピッ
クパラメータ @code{(score-file . "relief.SCORE")} を持ち、
@samp{その他} トピックはトピックパラメータ @code{(score-file
. "emacs.SCORE")} を持っています。さらに、
@samp{alt.religion.emacs} はグループパラメータ @code{(score-file
. "religion.SCORE")} を持っています。

さて、ここで @samp{息抜き} トピックの @samp{alt.sex.emacs} グルー
プに入ったとき、@file{relief.SCORE} が基本スコアファイルとなりま
す。もし @samp{Emacs} トピックの同じグループに入ると、
@file{emacs.SCORE} が基本スコアファイルになるでしょう。
@samp{alt.religion.emacs} グループに入れば、
@file{religion.SCORE} が基本スコアファイルになるでしょう。

これってとっても簡単で自明のことのように見えるでしょ？まあ、その通りです。
ですが問題がある場合もあります。特に@code{total-expiry} パラメータに関して
です。例えばあるメールグループを二つのトピックの中に、一方は 
@code{total-expiry} ありで、もう一方はそれなしで持っているとしましょう。こ
こで @kbd{M-x gnus-expire-all-expirable-groups} を実行すると、何が起こるで
しょうか？Gnus は、あなたがどちらのトピックから記事をエクスパイアしたいの
かを知る方法がないため、最悪の事態が発生するかもしれません。実際、私はこの
とき何が起こるのかは「未定義 @dfn{undefined}」である、とここに宣言します。
この手のことをやりたい場合には十分注意しなければなりません。


@node Misc Group Stuff
@section その他のグループ関連

@menu
* Scanning New Messages:: Gnus に新しいメッセージが到着したかどうかを聞く。
* Group Information::     グループと gnus に関する情報とヘルプ。
* Group Timestamp::       Gnus に最後にいつグループを読んだかを記録させる。
* File Commands::         Gnus のファイルの読み書き。
@end menu

@table @kbd

@item ^
@kindex ^ (Group)
@findex gnus-group-enter-server-mode
サーババッファモードに入る (@code{gnus-group-enter-server-mode})。
@xref{The Server Buffer}。

@item a
@kindex a (Group)
@findex gnus-group-post-news
あるグループに記事を投稿する (@code{gnus-group-post-news})。プレ
フィックスを与えると、現在のグループ名がデフォルトとして使用されます。

@item m
@kindex m (Group)
@findex gnus-group-mail
メールをどこかに送る (@code{gnus-group-mail})。

@end table

以下はグループバッファのための変数です：

@table @code

@item gnus-group-mode-hook
@vindex gnus-group-mode-hook
グループバッファが作成された時に呼び出されます。

@item gnus-group-prepare-hook
@vindex gnus-group-prepare-hook
グループバッファが生成されたあとに呼び出されます。これはバッファを何か変な、
自然じゃない方法で修正したいときに使われるかもしれません。

@item gnus-group-prepared-hook
@vindex gnus-group-prepare-hook
グループバッファが生成された後の一番最後に呼び出されます。例えば
ポイントをどこかに移動させたいときなどに使えます。

@item gnus-permanently-visible-groups
@vindex gnus-permanently-visible-groups
この正規表現にマッチするグループは、それが空であるかどうかに関わ
らず、常にグループバッファに表示されます。

@end table


@node Scanning New Messages
@subsection 新着メッセージを探す
@cindex new messages
@cindex scanning new news

@table @kbd

@item g
@kindex g (Group)
@findex gnus-group-get-new-news
@c @icon{gnus-group-get-new-news}
サーバの新着記事をチェックします。数字プレフィックスを使用すると、この命令
は引数 @var{arg} かそれより小さいレベルのグループのみをチェックします 
(@code{gnus-group-get-new-news})。数字以外のプレフィックスを与えると、この
命令はそのバックエンドからアクティブファイルを強制的に全部読み直します。

@item M-g
@kindex M-g (Group)
@findex gnus-group-get-new-news-this-group
@vindex gnus-goto-next-group-when-activating
@c @icon{gnus-group-get-new-news-this-group}
現在のグループに新着記事があるかどうかをチェックします
(@code{gnus-group-get-new-news-this-group})。
@code{gnus-goto-next-group-when-activating} はこの命令が次のグループ位置へ
移動するかどうかを決めます。デフォルトは @code{t} です。

@findex gnus-activate-all-groups
@cindex activating groups
@item C-c M-g
@kindex C-c M-g (Group)
無条件に全てのグループを起動します (@code{gnus-activate-all-groups})。

@item R
@kindex R (Group)
@cindex restarting
@findex gnus-group-restart
Gnus をリスタートします (@code{gnus-group-restart})。これは
@file{.newsrc} ファイルをセーブし、全てのサーバの接続を閉じ、全ての gnus 
ランタイム変数をクリアした後、gnus をもう一度最初から開始します。

@end table

@vindex gnus-get-new-news-hook
@code{gnus-get-new-news-hook} は新着ニューズをチェックする直前に
実行されます。

@vindex gnus-after-getting-new-news-hook
@code{gnus-after-getting-new-news-hook} 新着ニューズをチェックし
た後に実行されます。


@node Group Information
@subsection グループ情報
@cindex group information
@cindex information on groups

@table @kbd


@item H f
@kindex H f (Group)
@findex gnus-group-fetch-faq
@vindex gnus-group-faq-directory
@cindex FAQ
@cindex ange-ftp
現在のグループの FAQ を取得しようとします(@code{gnus-group-fetch-faq})。
Gnus は FAQ を@code{gnus-group-faq-directory} から取得しようとします。これ
は通常リモートマシン上のディレクトリです。この変数はディレクトリのリストで
あっても構いません。この場合、このコマンドにプレフィックスを与えることでい
くつかのサイトの中から選ぶことができます。ファイルの取得には 
@code{ange-ftp}（または @code{efs}）が使用されます。

もし最初のサイトからの取得が失敗した場合、gnus は
@code{gnus-group-faq-directory} の値を全て、一つ一つオープンしてみようとし
ます。

@item H d
@itemx C-c C-d
@c @icon{gnus-group-describe-group}
@kindex H d (Group)
@kindex C-c C-d (Group)
@cindex describing groups
@cindex group description
@findex gnus-group-describe-group
現在のグループの説明を表示する
(@code{gnus-group-describe-group})。プレフィックスを与えると、説
明文をサーバから強制的に再読み込みします。

@item M-d
@kindex M-d (Group)
@findex gnus-group-describe-all-groups
全てのグループの説明を表示します
(@code{gnus-group-describe-all-groups})。プレフィックスを与える
と、説明文ファイルをサーバから強制的に再読み込みします。

@item H v
@itemx V
@kindex V (Group)
@kindex H v (Group)
@cindex version
@findex gnus-version
現在の gnus のバージョン番号を表示します (@code{gnus-version})。

@item ?
@kindex ? (Group)
@findex gnus-group-describe-briefly
とても短いヘルプメッセージを与えます (@code{gnus-group-describe-briefly})。

@item C-c C-i
@kindex C-c C-i (Group)
@cindex info
@cindex manual
@findex gnus-info-find-node
Gnus の info ノードに移動します (@code{gnus-info-find-node}).。

@end table


@node Group Timestamp
@subsection グループの日付
@cindex timestamps
@cindex group timestamps

Gnus に、あなたが最後にいつグループを読んだかを記録させると便利
かもしれません。この活動を始めさせるには、
@code{gnus-group-set-timestamp}を @code{gnus-select-group-hook}
に追加してください。

@lisp
(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)
@end lisp

これを行った後、あなたがグループに入るたびにそれが記録されます。

この情報はさまざまな方法で表示できます――もっとも簡単なのは、グループ行フォー
マットで @samp{%d} 指定を使う方法です：

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %d\n")
@end lisp

この結果として、各行は以下のように表示されます：

@example
*        0: mail.ding                                19961002T012943
         0: custom                                   19961002T012713
@end example

見て分かるとおり、日付はコンパクトな ISO 8601 形式で表示されます。
これではちょっとあんまりなので、以下のような感じにすると日付だけ
を表示できます。

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %6,6~(cut 2)d\n")
@end lisp


@node File Commands
@subsection ファイル命令
@cindex file commands

@table @kbd

@item r
@kindex r (Group)
@findex gnus-group-read-init-file
@vindex gnus-init-file
@cindex reading init file
初期化ファイルの再読み込みを行う (@code{gnus-init-file}、このデ
フォルトは @file{~/.gnus}) (@code{gnus-group-read-init-file})。

@item s
@kindex s (Group)
@findex gnus-group-save-newsrc
@cindex saving .newsrc
@file{.newsrc.eld}ファイル（と、もしそうしたければ@file{.newsrc} ファイル）
をセーブする(@code{gnus-group-save-newsrc})。

@c @item Z
@c @kindex Z (Group)
@c @findex gnus-group-clear-dribble
@c ドリブルファイルをクリアする
@c (@code{gnus-group-clear-dribble})。

@end table


@node The Summary Buffer
@chapter 概略バッファ
@cindex summary buffer

概略バッファ (summary buffer) ではそれぞれの記事が一行で表示されます。そ
の中を動き回り、記事を読み、投稿し、返答をすることができます。

概略バッファに移る一番普通の方法は、グループバッファでグループを選択する
ことです (@pxref{Selecting a Group})。

概略バッファは望むだけたくさん開いた状態にしておくことができます。

@menu
* Summary Buffer Format::       概略バッファの外観を決定する。
* Summary Maneuvering::         概略バッファを動き回る。
* Choosing Articles::           記事を読む。
* Paging the Article::          読んでいる記事をスクロールする。
* Reply Followup and Post::     記事を投稿する。
* Canceling and Superseding::   『あぁ、あんなふうに言うんじゃなかった。』
* Marking Articles::            記事に既読や期限切れ削除可能等の印を付ける。
* Limiting::                    概略バッファに制限を加えることができる。
* Threading::                   スレッドがどのように作られるか。
* Sorting::                     スレッドと記事がどのように並びかえられるか。
* Asynchronous Fetching::       Gnus は記事を先に取得することができる。
* Article Caching::             キャッシュに記事を貯めておける。
* Persistent Articles::         記事を期限切れ消去しなくさせる。
* Article Backlog::             既に読んだ記事を残しておく。
* Saving Articles::             記事の保存をカスタマイズする方法。
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える。
* Article Treatment::           記事バッファはお望みどおりに目茶苦茶にできる。
* Article Commands::            記事バッファでいろいろなことをする。
* Summary Sorting::             いろいろな方法で概略バッファを並べ替える。
* Finding the Parent::          子記事に援助が無いって? 親記事を取得しなさい。
* Alternative Approaches::      ディフォルトでない概略を使って読む。
* Tree Display::                もっと視覚的なスレッドの表示。
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる。
* Various Summary Stuff::       他のどの場所にも合わなかったもの。
* Exiting the Summary Buffer::  グループバッファに戻る。
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか。
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段。
@end menu


@node Summary Buffer Format
@section 概略バッファの様式
@cindex summary buffer format

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{180}{
\put(0,0){\epsfig{figure=tmp/summary.ps,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=tmp/summary-article.ps,width=7.5cm}}}
}
@end iflatex
@end iftex

@menu
* Summary Buffer Lines::     概略バッファがどのように見えるべきかを指定できる。
* Summary Buffer Mode Line:: モード行の見え方を決められる。
* Summary Highlighting::     概略バッファをきれいで素敵にする。
@end menu

@findex std11-extract-address-components
@findex mail-extract-address-components
@findex gnus-extract-address-components
@vindex gnus-extract-address-components
Gnus は変数 @code{gnus-extract-address-components} の値を @code{From} ヘッ
ダーの名前とアドレスの部分を手に入れるための関数として使います。すでに定義
されている関数が３つ存在します：@code{gnus-extract-address-components} は
ディフォルトですが、とても簡単に割り切った解決法で、非常に速く動作します。
@code{mail-extract-address-components} は良く動作しますが、やや遅くなりま
す。そして、@code{std11-extract-address-components} はとても良く動作します
が、遅くなります。ディフォルトの関数は 5% の割合で間違って答えます。もしこ
れに我慢ならないのであれば、他の関数を代わりに使うことができます。

@vindex gnus-summary-same-subject
@code{gnus-summary-same-subject} は今読んでいる記事が、その前の記事と同
じ表題 (subject) であることを示す文字列です。この文字列は仕様がこれを要
求するときに使われます。ディフォルトでは @code{""} です。


@node Summary Buffer Lines
@subsection 概略バッファの行

@vindex gnus-summary-line-format
変数 @code{gnus-summary-line-format} の値を変えることによって、概略バッ
ファでの行の様式 (format) を変更することができます。いくつかの拡張 
(@pxref{Formatting Variables}) を除いて、普通の @code{format} 文字列と同
じように動作します。

ディフォルトの文字列は @samp{%U%R%z%I%(%[%4L: %-20,20n%]%) %s\n} です。

以下の様式指示文字を使うことができます:

@table @samp
@item N
記事数。
@item S
表題の文字列。
@item s
スレッド (thread) の基記事であるときか直前の記事が違う表題のときはその題
名で、それ以外は @code{gnus-summary-same-subject}。
(@code{gnus-summary-same-subject} のディフォルトの値は @code{""}。)
@item F
完全な @code{From} 欄。
@item n
名前（@code{From} 欄より）。
@item a
名前（@code{From} 欄より）。これと @code{n} との違いは、これは変数
@code{gnus-extract-address-components} で指定されている関数を使って名前を
取得することです。この方が遅いですが、おそらくより完全に近いでしょう。
@item A
名前（@code{From} 欄より）。これは @code{a} と同じように動作します。
@item L
記事の行数。
@item c
記事の文字数。
@item I
スレッドのレベルによる字下げ (@pxref{Customizing Threading})。
@item T
記事が本記事であれば何も表示せず、そうでない場合はたくさんの空白です（後の
ものをすべて画面の外に追い出してしまいます）。
@item [
開き括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます (@pxref{Customizing Threading})。
@item ]
閉じ括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます。
@item >
それぞれのスレッドのレベルに対して一つの空白。
@item <
二十引くスレッドレベルの空白。
@item U
未読。

@item R
この紛らわしい名前指定子は @dfn{secondary mark} によって定義されます。この
マークは記事が既に返答済みのものか、キャッシュされたものか、あるいは保存さ
れたものかを表します。

@item i
数字としてのスコア (@pxref{Scoring})。
@item z
@vindex gnus-summary-zcore-fuzz
これは、zcore でディフォルトのレベルよりも上であれば @samp{+} で、ディフォ
ルトのレベルよりも下であれば @samp{-} です。
@code{gnus-summary-default-zcore}との差が@code{gnus-summary-zcore-fuzz}
よりも小さいと、この仕様は使われません。
@item V
スレッド全体のスコア。
@item x
@code{Xref}.
@item D
@code{日付} (@code{Date})。
@item d
@code{DD-MM}様式による@code{日付}。
@item o
@var{YYYYMMDD}@code{T}@var{HHMMSS}様式による@code{日付}。
@item M
@code{Message-ID}.
@item r
@code{References}.
@item t
現在の副スレッドの記事の数。この仕様を使うと概略バッファの生成が幾分遅く
なります。
@item e
記事に子記事があると、@samp{=} (@code{gnus-not-empty-thread-mark}) が表
示されます。
@item P
行数。
@item O
ダウンロードの印。
@item u
利用者定義指定子。フォーマット文字列の中の次の文字が英字である必要がありま
す。これにより gnus は関数 @code{gnus-user-format-function-}@samp{X} を呼
び出しますが、ここで @samp{X} は @samp{%U} の次の文字です。関数には現在の
記事のヘッダーが引数として渡されます。関数は文字列を返し、他の概略指定と同
様に概略に挿入されます。
@end table

@samp{%U}（状態）、@samp{%R}（返答済み）、@samp{%z} (zcore) の扱いには気を
付ける必要があります。効率のために、gnus はこれらの文字がどの桁に現れるか
を計算し、『ハード・コード』します。これは、可変長の仕様の後では、これらは
意味を持たないということです。まぁ、さすがに逮捕はされないでしょうが、概略
バッファは変になります。それでも十分悲しいでしょうけど。

賢い選択はこれらの指定をできるだけ左に持ってくることです。（でも、そうい
うことはすべてに当てはまるのではないでしょうか。閑話休題。）

この制限は将来の版では無くなるかも知れません。


@node Summary Buffer Mode Line
@subsection 概略バッファのモード行

@vindex gnus-summary-mode-line-format
概略のモード行の様式も変更することができます。
@code{gnus-summary-mode-line-format} を何でも好きなものに変更してくださ
い。ディフォルトは @samp{Gnus: %%b [%A] %Z} です。

以下があなたが遊ぶことのできるそれぞれの要素です：

@table @samp
@item G
グループ名。
@item p
接頭語を取り除いた名前。
@item A
現在の記事番号。
@item V
Gnus バージョン。
@item U
そのグループでの未読記事の数。
@item e
概略バッファに表示されていない未読記事の数。
@item Z
未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記事があ
る場合は @samp{<%U(+%e) more>} で、未読記事のみの場合は @samp{<%U more>}
です。
@item g
短縮グループ名。例えば、@samp{rec.arts.anime} は @samp{r.a.anime} に短縮
されます。
@item S
現在の記事の表題。
@item u
利用者定義の仕様 (@pxref{User-Defined Specs})。
@item s
現在のスコアファイルの名前 (@pxref{Scoring})。
@item d
保留記事の数 (@pxref{Unread Articles})。
@item t
可視印付き記事の数 (@pxref{Unread Articles})。
@item r
その一連の動作の間に既読として印がついた記事の数。
@item E
スコアファイルによって抹消された記事の数。
@end table


@node Summary Highlighting
@subsection 概略のハイライト

@table @code

@item gnus-visual-mark-article-hook
@vindex gnus-visual-mark-article-hook
このフックは記事を選択した後に実行されます。これは何らかの方法で記事をハ
イライトするように意図されています。もし @code{gnus-visual} が
@code{nil} である場合は実行されません。

@item gnus-summary-update-hook
@vindex gnus-summary-update-hook
このフックは概略行が変更されたときに呼ばれます。もし @code{gnus-visual} が
@code{nil} である場合は実行されません。

@item gnus-summary-selected-face
@vindex gnus-summary-selected-face
これは概略バッファでの現在の記事をハイライトするために使われるフェイス 
(face)（もしくは、いくらかの人々が @dfn{フォント} (font) と呼ぶよ
うなもの）です。

@item gnus-summary-highlight
@vindex gnus-summary-highlight
概略行はこの変数にしたがってハイライトされます。この変数は要素が
@var{(FORM . FACE)} の形式のリストです。例えば、もし印付きの記事をイタリッ
ク、高いスコアの記事をボールドにしたければ、この変数を次のようにできます。
@lisp
(((eq mark gnus-ticked-mark) . italic)
 ((> score default) . bold))
@end lisp
ご想像のとおり、もし @var{FORM} が @code{nil} でない値を返すと、
@var{FACE} がその行に適用されます。
@end table


@node Summary Maneuvering
@section 概略間の移動
@cindex summary movement

すべての直接移動命令は数値接頭引数を受け付け、あなたの期待によくしたがっ
て動作するでしょう。

これらの命令はどれも記事を選択しません。

@table @kbd
@item G M-n
@item M-n
@kindex M-n （概略）
@kindex G M-n （概略）
@findex gnus-summary-next-unread-subject
概略行の次の未読記事に移る (@code{gnus-summary-next-unread-subject})。

@item G M-p
@itemx M-p
@kindex M-p （概略）
@kindex G M-p （概略）
@findex gnus-summary-prev-unread-subject
概略行の前の未読記事に移る
(@code{gnus-summary-prev-unread-subject})。

@item G j
@item j
@kindex j （概略）
@kindex G j （概略）
@findex gnus-summary-goto-article
記事番号か @code{Message-ID} を尋ね、それからその記事に行く。
(@code{gnus-summary-goto-article})。

@item G g
@kindex G g （概略）
@findex gnus-summary-goto-subject
記事番号か @code{Message-ID} を尋ね、それからその記事を表示すること無く、
概略行に行く (@code{gnus-summary-goto-subject})。
@end table

Gnus が次のグループに移動することを確認をするために、キーを押すことを要求
するときがあります。その時は、@kbd{C-n} と @kbd{C-p} を使って、グループバッ
ファに戻ること無く次に読むグループを探すことができます。

概略の移動に関連した変数:

@table @code

@vindex gnus-auto-select-next
@item gnus-auto-select-next
もし移動命令の一つ（@kbd{n} のような）を出し、現在の記事の後に未読が無けれ
ば、gnus は次のグループに移動することを奨めます。この変数が @code{t}で次の
グループが空であると、gnus は概略モードを終了して、グループバッファに戻り
ます。この変数が @code{t} や @code{nil} でないと、次のグループに記事があろ
うが無かろうが、gnus はそれを選択します。特別な場合として、この変数が 
@code{quietly} であると、gnus は確認をせずに、次のグループを選択します。こ
の変数が @code{almost-quietly} であると、グループの一番最後の記事を読んで
いたときに限り同じことが起こります。最後に、もしこの変数が
@code{slightly-quietly} であると、命令 @kbd{Z n} は確認をせずに次のグルー
プに移ります。@pxref{Group Levels} も参照してください。

@item gnus-auto-select-same
@vindex gnus-auto-select-same
@code{nil} でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
しようとします。（@dfn{同じ} はここでは @dfn{大体同じ} という意味かも知
れません。詳細は @code{gnus-summary-gather-subject-limit} を見てください
(@pxref{Customizing Threading} も参照してください)。）この変数は、スレッ
ド表示を行っているときはあまり役に立たないでしょう。

@item gnus-summary-check-current
@vindex gnus-summary-check-current
@code{nil} でないと、すべての『未読』移動命令は、次（もしくは前）の記事に
移動しません。その代わりに、それらは現在の記事を選びます。

@item gnus-auto-center-summary
@vindex gnus-auto-center-summary
@code{nil} でないと、gnus は概略バッファでのポイントを常に真中に保ちます。
これをすると、とてもこぎれいになりますが、遅いネットワーク接続であったり、
単にこの Emacsism でない行為を好きになれないのであれば、普通の Emacs の
スクロールにするために、この変数を @code{nil} にすることができます。これ
は概略バッファの水平方向の真中への再移動も禁止しますので、非常に長いスレッ
ドを読むときは不便かもしれません。

@end table


@node Choosing Articles
@section 記事の選択
@cindex selecting articles

@menu
* Choosing Commands::        記事を選択するための命令。
* Choosing Variables::       これらの命令に影響を及ぼす変数。
@end menu


@node Choosing Commands
@subsection 命令の選択

以下の移動コマンドはどれも数値接頭引数を受け付けず、記事を選択し、表示しま
す。

@table @kbd
@item SPACE
@kindex SPACE （概略）
@findex gnus-summary-next-page
現在の記事か、それが既に読まれている場合は次の未読記事を選択します
(@code{gnus-summary-next-page})。

@item G n
@itemx n
@kindex n（概略）
@kindex G n（概略）
@findex gnus-summary-next-unread-article
@c @icon{gnus-summary-next-unread}
次の未読記事に移動します (@code{gnus-summary-next-unread-article})。

@item G p
@itemx p
@kindex p（概略）
@findex gnus-summary-prev-unread-article
@c @icon{gnus-summary-prev-unread}
前の未読記事に移動します (@code{gnus-summary-prev-unread-article})。

@item G N
@itemx N
@kindex N （概略）
@kindex G N （概略）
@findex gnus-summary-next-article
次の記事に移動します (@code{gnus-summary-next-article})。

@item G P
@itemx P
@kindex P （概略）
@kindex G P （概略）
@findex gnus-summary-prev-article
前の記事に移動します (@code{gnus-summary-prev-article})。

@item G C-n
@kindex G C-n（概略）
@findex gnus-summary-next-same-subject
同じ表題の次の記事に移動します (@code{gnus-summary-next-same-subject})。

@item G C-p
@kindex G C-p（概略）
@findex gnus-summary-prev-same-subject
同じ表題の前の記事に移動します (@code{gnus-summary-prev-same-subject})。

@item G f
@itemx .
@kindex G f （概略）
@kindex . （概略）
@findex gnus-summary-first-unread-article
最初の未読記事に移動します (@code{gnus-summary-first-unread-article})。

@item G b
@item ,
@kindex G b （概略）
@kindex , （概略）
@findex gnus-summary-best-unread-article
最高スコアの記事に移動します (@code{gnus-summary-best-unread-article})。

@item G l
@itemx l
@kindex l （概略）
@kindex G l （概略）
@findex gnus-summary-goto-last-article
直前の記事に移動します (@code{gnus-summary-goto-last-article})。

@item G o
@kindex G o（概略）
@findex gnus-summary-pop-article
概略の履歴 (history) から最後の記事を一つ取り出して選択します。
(@code{gnus-summary-pop-article})。この命令が上の命令と違うのは、@kbd{l} 
が最終2つの記事の間を移動するのに対して、これは好きなだけ前の記事を履歴か
ら選び出すことができる点です。何らかのこれに関係したことは（もしこれらの命
令をたくさん使うのであれば）、@pxref{Article Backlog} を参照してください。
@end table


@node Choosing Variables
@subsection 選ぶための変数

記事を移動し、選択するのに関連したいくつかの変数:

@table @code
@item gnus-auto-extended-newsgroup
@vindex gnus-auto-extend-newsgroup
この変数が @code{nil} でないと、すべての移動命令は、もしその記事が概略バッ
ファに表示されていない場合でも、前（もしくは次）の記事に移動しようとします。
その命令の後で、gnus はサーバーから記事を取得して、記事バッファに表示しま
す。

@item gnus-select-article-hook
@vindex gnus-select-article-hook
このフックは記事が選択されたときに常に呼ばれます。ディフォルトでは、選択
された記事の下に隠れているスレッドを見せるようになっています。

@item gnus-mark-article-hook
@vindex gnus-mark-article-hook
@findex gnus-summary-mark-unread-as-read
@findex gnus-summary-mark-read-and-unread-as-read
@findex gnus-unread-mark
このフックは記事が選択されたときに常に呼ばれます。それは記事に既読の印を付
けるためにあります。ディフォルトの値は
@code{gnus-summary-mark-read-and-unread-as-read} で、ほとんどすべての読ん
だ記事の印を @code{gnus-read-mark} に変更します。この関数に影響されない記
事は、可視、保留、期限切れ削除可能記事だけです。もし、未読に既読の印を付け
たいだけであれば、代わりに @code{gnus-summary-mark-unread-as-read} を使う
ことができます。それは、@code{gnus-low-score-mark} や 
@code{gnus-del-mark}（などなど）の印をそのまま残します。

@end table


@node Paging the Article
@section 記事のスクロール
@cindex article scrolling

@table @kbd

@item SPACE
@kindex SPACE （概略）
@findex gnus-summary-next-page
@kbd{SPACE} は記事を一ページ先にスクロールします。記事の最後にいる場合は
次の記事を選択します (@code{gnus-summary-prev-page})。

@item DEL
@kindex DEL （概略）
@findex gnus-summary-prev-page
現在の記事を一ページ前にスクロールします (code{gnus-summary-prev-page})。

@item RET
@kindex RET （概略）
@findex gnus-summary-scroll-up
現在の記事を一行先にスクロールします (@code{gnus-summary-scroll-up})。

@item A g
@itemx g
@kindex A g （概略）
@kindex g （概略）
@findex gnus-summary-show-article
現在の記事を（再）取得します。もし接頭引数が与えられると、現在の記事を取得
しますが、記事を扱う関数は実行しません。これは、サーバーからきたままの、 
『生の』記事を与えます。

@item A <
@itemx <
@kindex < （概略）
@kindex A < （概略）
@findex gnus-summary-beginning-of-article
記事の最初までスクロールします。
(@code{gnus-summary-beginning-of-article})。

@item A >
@itemx >
@kindex > （概略）
@kindex A > （概略）
@findex gnus-summary-end-of-article
記事の最後までスクロールします (@code{gnus-summary-end-of-article})。

@item A s
@itemx s
@kindex A s （概略）
@kindex s （概略）
@findex gnus-summary-isearch-article
記事バッファでインクリメンタルサーチ (isearch) を行います
(@code{gnus-summary-isearch-article})。

@item h
@kindex h （概略）
@findex gnus-summary-select-article-buffer
記事バッファを選択します (@code{gnus-summary-select-article-buffer})。

@end table


@node Reply Followup and Post
@section 返答、フォローアップ、投稿

@menu
* Summary Mail Commands::            メールを送る。
* Summary Post Commands::            ニューズを送る。
@end menu


@node Summary Mail Commands
@subsection 概略でのメールの命令
@cindex mail
@cindex composing mail

メールメッセージを作成するための命令:

@table @kbd

@item S r
@item r
@kindex S r （概略）
@kindex r （概略）
@findex gnus-summary-reply
@c @icon{gnus-summary-mail-reply}
@c @icon{gnus-summary-reply}
現在の記事を書いた人に返答のメールを送ります (@code{gnus-summary-reply})。

@item S R
@itemx R
@kindex R （概略）
@kindex S R （概略）
@findex gnus-summary-reply-with-original
@c @icon{gnus-summary-reply-with-original}
現在の記事を書いた人に、本記事を含んだ返答のメールを出します
(@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引数の習
慣を使います。

@item S w
@kindex S w （概略）
@findex gnus-summary-wide-reply
現在の記事を書いた人に対して、広い返答 (wide reply) をします
(@code{gnus-summary-wide-reply})。@dfn{広い返答} とはヘッダーの
@code{To}, @code{From},（もしくは @code{Reply-to}) と @code{Cc}）のすべて
の人に返答をすることです。

@item S W
@kindex S W （概略）
@findex gnus-summary-wide-reply-with-original
現在の記事に本記事を含んだ広い返答のメールを送ります
(@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引数の
習慣を使います。

@item S o m
@kindex S o m （概略）
@findex gnus-summary-mail-forward
@c @icon{gnus-summary-mail-forward}
誰か他の人に現在の記事を転送します (@code{gnus-summary-mail-forward})。
接頭引数があると、転送記事の完全なヘッダーを取り込みます。

@item S m
@itemx m
@kindex m （概略）
@kindex S m （概略）
@findex gnus-summary-mail-other-window
@c @icon{gnus-summary-mail-originate}
誰か他の人にメールを送ります (@code{gnus-summary-mail-other-window})。

@item S D b
@kindex S D b （概略）
@findex gnus-summary-resend-bounced-mail
@cindex bouncing mail
メールを送ったのに、何らかの理由（アドレスの間違い、転送の不調）で戻ってき
たときに、この命令を使って戻ってきたメールをもう一回送ることができます 
(@code{gnus-summary-resend-bonced-mail})。もう一度メールを送る前にヘッダー
を編集できるように、メールバッファにそのメールが現れるでしょう。この命令に
接頭引数を与えて、戻ってきたメールが誰かへの返答であった場合、gnus はその
メールを取得して、それのヘッダーの精密調査ができるように画面に表示します。
ま、これはとてもよく失敗しますけど。

@item S D r
@kindex S D r （概略）
@findex gnus-summary-resend-message
上の命令と混同しないように、@code{gnus-summary-resend-message} は現在のメッ
セージを送る先のアドレスの入力を促し、それからその場所にメールを送ります。
メッセージのヘッダーは変更されません――しかし、@code{Resent-To},
@code{Resent-From} 等のヘッダーが付け加えられます。これは、（おそらく）あ
なた自身を @code{To} 欄に書いた本人にもメールを送ってしまうということです。
これは混乱を招くでしょう。ですから、もちろん、本当に 邪悪 な気分のときにだ
けこれを使うでしょう。

この命令は主に、あなたがいくつかのメールアカウント (account) を持ってい
て、自分自身の違ったアカウントにメールを転送したいときに用いられます。
(もしあなたが、@code{ルート} (root) であり、@code{ポストマスター}
(postmaster) でもあり、@code{ルート} に @code{ポストマスター} へのメール
を受け取った場合は、それを @code{ポストマスター} にも再送したいと思うで
しょう。Ordnung mu,A_ sein!)

この命令はプロセス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S O m
@kindex S O m （概略）
@findex gnus-uu-digest-mail-forward
現在の一連の記事 (@pxref{Decoding Articles}) の要約を作り、メールでその結
果を送ります (@code{gnus-uu-digest-mail-forward})。この命令はプロセス/接頭
引数の習慣に従います (@pxref{Process/Prefix})。

@item S M-c
@kindex S M-c （概略）
@findex gnus-summary-mail-crosspost-complaint
@cindex crossposting
@cindex excessive crossposting
現在の記事の書き手に、過剰クロスポストへの苦情のメールを送ります
(@code{gnus-summary-mail-crosspost-complaint})。

@findex gnus-crosspost-complaint
この命令は、現在 Usenet に横行している、クロスポストの世界的流行に対して
反撃を行う手段として提供されています。これは変数
@code{gnus-crosspost-complaint} を序文にして、返答を作成します。この命令
はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) に従い、それぞれのメー
ルを送る前に送信するかどうかの確認をします。

@end table

また @pxref{(message)Header Commands} にさらなる情報があります。


@node Summary Post Commands
@subsection 概略の投稿命令
@cindex post
@cindex composing news

ニュースの記事を投稿するための命令：

@table @kbd
@item S p
@itemx a
@kindex a （概略）
@kindex S p （概略）
@findex gnus-summary-post-news
@c @icon{gnus-summary-post-news}
現在のグループに記事を投稿します (@code{gnus-summary-post-news})。

@item S f
@itemx f
@kindex f （概略）
@kindex S f （概略）
@findex gnus-summary-followup
@c @icon{gnus-summary-followup}
現在の記事のフォローアップを投稿します (@code{gnus-summary-followup})。

@item S F
@itemx F
@kindex S F （概略）
@kindex F （概略）
@c @icon{gnus-summary-followup-with-original}
@findex gnus-summary-followup-with-original
本記事を取り込んで、現在の記事にフォローアップをします
(@code{ggnus-summary-followup-with-original})。この命令はプロセス/接頭引数
の習慣を用います。

@item S n
@kindex S n （概略）
@findex gnus-summary-followup-to-mail
メールのメッセージを受け取っていたとしても、本記事を引用して、現在の記事
のフォローアップをニューズに投稿します
(@code{gnus-summary-followup-to-mail-with-original})。
この命令はプロセス/接頭引数の習慣を用います。

@item S N
@kindex S N (Summary)
@findex gnus-summary-followup-to-mail-with-original
Post a followup to the current article via news, even if you got the
message through mail and include the original message
(@code{gnus-summary-followup-to-mail-with-original}).  
この命令はプロセス/接頭引数の習慣を用います。

@item S o p
@kindex S o p （概略）
@findex gnus-summary-post-forward
現在の記事をニューズグループに転送します
(@code{gnus-summary-post-forward})。接頭引数が与えられたときは、転送記事
のヘッダーを完全に取り込みます。

@item S O p
@kindex S O p （概略）
@findex gnus-uu-digest-summary-post-forward
@cindex digests
@cindex making digests
現在の一連の記事を要約して、その結果をニューズグループに送ります
(@code{gnus-uu-digest-mail-forward})。この命令はプロセス/接頭引数の習慣
を用います。

@item S u
@kindex S u （概略）
@findex gnus-uu-post-news
@c @icon{gnus-uu-post-news}
ファイルを Uuencode し、分割して、組にして投稿します
(@code{gnus-uu-post-news})。(@pxref{Uuencoding and Posting})。
@end table

また @pxref{(message)Header Commands} にさらなる情報があります。


@node Canceling and Superseding
@section 記事を取り消す
@cindex canceling articles
@cindex superseding articles

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなければ
なぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニューズの投稿は取り消す
ことができます。

@findex gnus-summary-cancel-article
@kindex C （概略）
@c @icon{gnus-summary-cancel-article}
取り消したい記事を見つけてください（取り消すことができるのは自分の記事だけ
です。変なことは試さないでください）。それから、 @kbd{C} か @kbd{S c}を押
してください (@code{gnus-summary-cancel-article})。あなたの記事が取り消さ
れます――世界中の機械があなたの記事を取り消します。この命令はプロセス/接
頭引数の習慣を用います (@pxref{Process/Prefix})。

しかし、注意してほしいのはすべてのサイト (site) が取り消しを扱っているわ
けではないことです。ですから、たいていのサイトが問題の記事を取り消しても、
あちこちであなたの記事は生き残るかもしれません。

Gnus は、取り消すときに『現在』の選択方法を使います。標準の投稿方法を使い
たいのであれば、文字接頭引数 @samp{a} を使ってください(@pxref{Symbolic
Prefixes})。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、@dfn{代替}
(@dfn{superseding}) 記事を投稿して本記事を置き換えることができます。

@findex gnus-summary-supersede-article
@kindex S （概略）
本記事のところへ移動して、@kbd{S s} を押してください
(@code{gnus-summary-supersede-article})。普通の方法でそれを送る前に、記事
を好きなように編集することができます。代替に関しても、取り消しと同じことが
当てはまります。こちらの方がもっとよく当てはまるかもしれません：いくつかの
サイトは代替を受け付けません。これらのサイトでは、あなたがほとんど同じ記事
を2回投稿したようになります。

もしさっき記事を投稿したばかりですぐに変更したくなた場合、記事が最初にあ
なたのサイトに現れる前に取り消し/代替をするための巧妙な手段があります。
まず、投稿バッファ（@code{*sent ... *} のようになっています）に戻ります。
そこにはあなたがちょうど投稿した記事があり、すべてのヘッダーがそのままあ
ります。それらの中の @code{Message-ID} という語のところを変更することに
よって @code{Message-ID} ヘッダーを @code{Cancel} もしくは
@code{Supersedes} に変更してください。

ちょっと覚えておいてください：`supersede'（代替）という語の中に `c' は無い
ということを。


@node Marking Articles
@section 記事に印を付ける
@cindex article marking
@cindex article ticking
@cindex marks

記事に付けられる印はいくつかあります。

記事の @dfn{購読度}（おぉ、ニート・キーノ新語句だ！）を決定する印がありま
す。英字の印は一般的には@dfn{既読}を意味し、英字でない文字は一般的に
@dfn{未読}を意味します。

加えて、購読度に影響しない印もあります。

@menu
* Unread Articles::      未読記事への印
* Read Articles::        既読記事への印
* Other Marks::          購読度に影響しない印
@end menu

@ifinfo
これらの印を操作する過剰なくらいの命令があります：
@end ifinfo

@menu
* Setting Marks::           印の付け方と消し方
* Setting Process Marks::   後の実行のための記事の印の付け方
@end menu


@node Unread Articles
@subsection 未読記事

以下の印はいろいろな方法で記事に未読の（ような）印を付けます。

@table @samp
@item !
@vindex gnus-ticked-mark
可視記事 (Ticked) として印をつけます (@code{gnus-ticked-mark})。

@dfn{可視記事}とは、常に可視状態である記事のことです。おもしろいと思う記事
があった場合や、単に読むのを先に延ばしたいときや、後で返答をしたいときに、
普通は可視印を付けます。しかし、記事は期限切れ消去されることもありますので、
永遠に記事を保存しておきたい場合は、その記事を永続にする必要があります 
(@pxref{Persistent Articles})。

@item ?
@vindex gnus-dormant-mark
保留として印を付けます (@code{gnus-dormant-mark})。

@dfn{保留記事}はフォローアップがあったときにだけ概略バッファに現れます。フォ
ローアップが無いときも表示させたいときは、命令 @kbd{/ D} を使うことができ
ます。

@item SPACE
@vindex gnus-unread-mark
未読として印を付けます (@code{gnus-unread-mark})。

@dfn{未読記事}は今まで全く読まれていない記事のことです。
@end table


@node Read Articles
@subsection 既読記事
@cindex expirable mark

以下のすべての印は記事に既読の印を付けます。

@table @samp

@item r
@vindex gnus-del-mark
利用者が手動やそのようなもので命令 @kbd{d} によって既読の印を付けた記事
です (@code{gnus-del-mark})。

@item R
@vindex gnus-read-mark
実際に読まれた記事 (@code{gnus-read-mark})。

@item O
@vindex gnus-ancient-mark
前回のセッションで既読の印を付けて、今は@dfn{古く}なってしまった記事。

@item K
@vindex gnus-killed-mark
削除の印 (@code{gnus-killed-mark})。

@item X
@vindex gnus-kill-file-mark
削除ファイルによって削除の印がついた記事
(@code{gnus-kill-file-mark})。

@item Y
@vindex gnus-low-score-mark
低すぎるスコアのために既読の印がついた記事
(@code{gnus-low-score-mark})。

@item C
@vindex gnus-catchup-mark
キャッチアップによって既読の印がついた記事
(@code{gnus-catchup-mark})。

@item G
@vindex gnus-canceled-mark
取り消された記事 (@code{gnus-canceled-mark})。

@item F
@vindex gnus-souped-mark
@sc{SOUP} されている記事 (@code{gnus-souped-mark})。 @xref{SOUP}.

@item Q
@vindex gnus-sparse-mark
まばらに参照された記事 (@code{gnus-sparse-mark})。
@xref{Customizing Threading}.

@item M
@vindex gnus-duplicate-mark
重複抑制により既読の印のついた記事 (@code{gnus-duplicated-mark})。
@xref{Duplicate Suppression}.

@end table

これらのすべての印は、本当はただ記事が既読として印がついていることを意味
するだけです。適応スコアリングをしたときには違ったように解釈されますけれ
ど。

もう一つ、特別な印があります：

@table @samp
@item E
@vindex gnus-expirable-mark
期限切れ削除可能として印のついた記事 (@code{gnus-expirable-mark})。

記事を@dfn{期限切れ削除可能}として印を付ける（もしくは、自動的にそのように
印を付ける）ことは、普通のグループではあまり意味がありません――利用者はニュー
ズ記事の期限による削除を制御していません。しかし、例えばメールグループでは、
@dfn{期限切れ削除可能}として印のついた記事は、いつでも gnus によって削除さ
れることがあります。
@end table


@node Other Marks
@subsection 他の印
@cindex process mark
@cindex bookmarks

記事が読まれたかどうかには関係しない印がいくつかあります。

@itemize @bullet

@item
現在の記事にしおりを挟むことができます。あなたは猫の尿の習慣に関する長い
論文を読んでいて、それを読み終わる前に夕食を食べるために家に帰らなければ
ならなかったとしましょう。そのときに、記事にしおりを挟むことができ、次に
その記事に出くわしたときに、gnus はそのしおりのところへ移動するでしょう。
@xref{Setting Marks}

@item
@vindex gnus-replied-mark
返答をしたか、フォローアップをした（例えば、答えた）記事はすべて２桁目に
@samp{A} の印がつきます (@code{gnus-replied-mark})。

@item
@vindex gnus-cached-mark
記事キャッシュに貯められている記事は２桁目に @samp{*} の印がつきます
(@code{gnus-replied-mark})。 @xref{Article Caching}

@item
@vindex gnus-saved-mark
（何らかの方法によって；必ずしも宗教的というわけではなく）『保存された』記
事は２桁目に @samp{S} の印がつきます (@code{gnus-saved-mark})。

@item
@vindex gnus-not-empty-thread-mark
@vindex gnus-empty-thread-mark
もし @samp{%e} の仕様が使われると、スレッドがあるかどうかは、３桁目に
@code{gnus-not-empty-thread-mark} と @code{gnus-empty-thread-mark} のそれ
ぞれによって印がつきます。

@item
@vindex gnus-process-mark
最後に @dfn{プロセス印} があります(@code{gnus-process-mark})。いろいろな種
類の命令がプロセス印があるとそれに対して実行されます。例えば、@kbd{X u}
(@code{gnus-uu-decode-uu}) はプロセス印の付いたすべての記事を uudecode し
て、表示します。プロセス印の付いた記事は２桁目に @samp{#} があります。

@end itemize

これらの『非購読度』の印はディフォルトではたいてい２桁目に現れるということ
に気付いたかもしれません。ですから、キャッシュされていて、保存されていて、
返答をした記事にプロセス印が付いている場合、どのようになるのでしょう？

たいしたことはありません。優先順位は次のようになっています： プロセス → 
キャッシュ → 返答済み → 保存。ですから、ある記事がキャッシュに入っていて、
返答されていた場合、キャッシュ印があるだけで、返答済み印はありません。


@node Setting Marks
@subsection 印を付ける
@cindex setting marks

すべての印つけ命令は数値接頭引数を受け付けます。

@table @kbd
@item M c
@itemx M-u
@kindex M c （概略）
@kindex M-u （概略）
@findex gnus-summary-clear-mark-forward
@cindex mark as read
現在の記事から、すべての購読度印を消去します
(@code{gnus-summary-clear-mark-forward})。要するに、記事に未読の印を付け
ます。

@item M t
@itemx !
@kindex ! （概略）
@kindex M t （概略）
@findex gnus-summary-tick-article-forward
現在の記事に可視記事印を付けます
(@code{gnus-summary-tick-article-forward})。 @xref{Article Caching}

@item M ?
@itemx ?
@kindex ? （概略）
@kindex M ? （概略）
@findex gnus-summary-mark-as-dormant
現在の記事に保留記事印を付けます
(@code{gnus-summary-mark-as-read-forward})。

@item D
@kindex D （概略）
@findex gnus-summary-mark-as-read-backward
現在の記事に既読の印を付け、前の行にポイントを移動します
(@code{gnus-summary-mark-as-read-backward})。

@item M k
@itemx k
@kindex k （概略）
@kindex M k （概略）
@findex gnus-summary-kill-same-subject-and-select
現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未読記事
を選択します (@code{gnus-summary-kill-same-subject-and-select})。

@item M K
@itemx C-k
@kindex M K （概略）
@kindex C-k （概略）
@findex gnus-summary-kill-same-subject
現在の記事と同じ表題を持つすべての記事を既読として印を付けます
(@code{gnus-summary-kill-same-subject})。

@item M C
@kindex M C （概略）
@findex gnus-summary-catchup
@c @icon{gnus-summary-catchup}
すべての未読記事に既読の印を付けます (@code{gnus-summary-catchup})。

@item M C-c
@kindex M C-c （概略）
@findex gnus-summary-catchup-all
グループのすべての記事に――可視記事や保留記事でさえも、既読の印を付けます 
(@code{gnus-summary-catchup-all})。

@item M H
@kindex M H （概略）
@findex gnus-summary-catchup-to-here
現在のグループのポイントまでを既読として印を付けます
(@code{gnus-summary-catchup-to-here})。

@item C-w
@kindex C-w （概略）
@findex gnus-summary-mark-region-as-read
ポイントとマークの間の記事に既読の印を付けます
(@code{gnus-summary-mark-region-as-read})。

@item M V k
@kindex M V k （概略）
@findex gnus-summary-kill-below
ディフォルトのスコア（もしくは数値接頭引数）よりも低いスコアの記事を削除し
ます。

@item M e
@itemx E
@kindex M e （概略）
@kindex E （概略）
@findex gnus-summary-mark-as-expirable
現在の記事を期限切れ削除可能として印を付けます
(@code{gnus-summary-mark-as-expirable})。

@item M b
@kindex M b （概略）
@findex gnus-summary-set-bookmark
現在の記事にしおりを設定します (@code{gnus-summary-set-bookmark})。

@item M B
@kindex M B （概略）
@findex gnus-summary-remove-bookmark
現在の記事のしおりを削除します (@code{gnus-summary-remobe-bookmark})。

@item M V c
@kindex M V c （概略）
@findex gnus-summary-clear-above
ディフォルトのスコア（もしくは数値接頭引数）よりも大きいスコアを持つ記事の
すべての印を消去します (@code{gnus-summary-clar-above})。

@item M V u
@kindex M V u （概略）
@findex gnus-summary-tick-above
ディフォルトのスコア（もしくは数値接頭引数）よりも大きいスコアを持つすべて
の記事に可視印を付けます (@code{gnus-summary-tick-above})。

@item M V m
@kindex M V m （概略）
@findex gnus-summary-mark-above
印の入力を促し、ディフォルトのスコア（もしくは数値接頭引数）よりも大きなス
コアを持つすべての記事にその印を付けます(@code{gnus-summary-mark-above})。
@end table

@vindex gnus-summary-goto-unread
変数 @code{gnus-summary-goto-unread} は印が付けられた後にどのような動作が
なされるかを決定します。もし @code{nil} でないと、ポイントは次/前の未読記
事に移動します。もし @code{nil} であると、ポイントは一行上か下に行くだけで
す。特別な場合として、この変数が @code{never} であると、すべての印を付ける
命令と（@kbd{SPACE} のような）他の命令は次の記事が未読であろうが無かろうが
その記事に移動します。ディフォルトは @code{t} です。


@node Setting Process Marks
@subsection プロセス印を付ける
@cindex setting process marks

@table @kbd

@item M P p
@itemx #
@kindex # （概略）
@kindex M P p （概略）
@findex gnus-symmary-mark-as-processable
現在の記事にプロセス印を付けます
(@code{gnus-summary-mark-as-processable})。
@findex gnus-summary-unmark-as-processable

@item M P u
@itemx M-#
@kindex M P u （概略）
@kindex M-# （概略）
もし現在の記事にプロセス印があれば取り除きます
(@code{gnus-summary-unmark-as-processable})。

@item M P U
@kindex M P U （概略）
@findex gnus-summary-unmark-all-processable
すべての記事からプロセス印を取り除きます
(@code{gnus-summary-unmark-all-processable})。

@item M P i
@kindex M P i （概略）
@findex gnus-uu-invert-processable
プロセス印の付いている記事とそうでない記事を逆にします
(@code{gnus-uu-mark-by-regexp})。

@item M P R
@kindex M P R （概略）
@findex gnus-uu-mark-by-regexp
正規表現によって記事に印を付けます (@code{gnus-uu-mark-by-regexp})。

@item M P r
@kindex M P r （概略）
@findex gnus-uu-mark-region
リージョンの記事に印を付けます (@code{gnus-uu-mark-region})。

@item M P t
@kindex M P t （概略）
@findex gnus-uu-mark-thread
現在の（副）スレッドのすべての記事に印を付けます
(@code{gnus-uu-mark-thread})。

@item M P T
@kindex M P T （概略）
@findex gnus-uu-unmark-thread
現在の（副）スレッドのすべての記事から印を取り除きます
(@code{gnus-uu-unamrk-thread})。

@item M P v
@kindex M P v （概略）
@findex gnus-uu-mark-over
接頭引数よりも大きなスコアを持つすべての記事に印を付けます
(@code{gnus-uu-mark-over})。

@item M P s
@kindex M P s （概略）
@findex gnus-uu-mark-series
現在の一連の記事に印を付けます (@code{gnus-uu-mark-series})。

@item M P S
@kindex M P S （概略）
@findex gnus-uu-mark-sparse
既にいくつか印の付いた記事を持つ一連の記事群全てに印を付けます
(@code{gnus-uu-mark-sparse})。

@item M P a
@kindex M P a （概略）
@findex gnus-uu-mark-all
一連の記事が出てくる順番にそれに属するすべての記事に印を付けます
(@code{gnus-uu-mark-all})。

@item M P b
@kindex M P b （概略）
@findex gnus-uu-mark-buffer
バッファのすべての記事を現れている順番に印を付けます
(@code{gnus-uu-mark-buffer})。

@item M P k
@kindex M P k （概略）
@findex gnus-summary-kill-process-mark
現在のプロセス印をスタックに積んで、すべての記事を無印にします
(@code{gnus-summary-kill-process-mark})。

@item M P y
@kindex M P y （概略）
@findex gnus-summary-yank-process-mark
スタックから前回のプロセス印を取り出して、それを復元します
(@code{gnus-summary-yank-process-mark})。

@item M P w
@kindex M P w （概略）
@findex gnus-summary-save-process-mark
現在のプロセス印をスタックに積みます
(@code{gnus-summary-save-process-mark})。

@end table


@node Limiting
@section 制限をする
@cindex  limiting

概略バッファが現在グループにある記事の一部だけを表示するように制限できれば
便利なことがあります。多くの制限命令が持つ効果は概略バッファから少し（もし
くは多く）の記事を概略バッファから削除することです。

すべての制限命令はサーバーから既に取得された記事の一部分に作用します。こ
れらの命令はどれもサーバーに追加の記事を要求しません。

@table @kbd

@item / /
@itemx / s
@kindex / / （概略）
@findex gnus-summary-limit-to-subject
概略バッファをいくつかの表題と合致するものだけに制限します
(@code{gnus-summary-limit-to-subject})。

@item / a
@kindex / a （概略）
@findex gnus-summary-limit-to-author
概略バッファを何人かの著者に合致するものだけに制限します
(@code{gnus-summary-limit-to-author})。

@item / u
@itemx x
@kindex / u （概略）
@kindex x （概略）
@findex gnus-summary-limit-to-unread
概略バッファを既読の印が付いていない記事に制限します
(@code{gnus-summary-limit-to-unread})。もし接頭引数が与えられれば、バッ
ファを厳密に未読記事のみに制限します。これは、可視と保留の記事は含まれな
いということです。

@item / m
@kindex / m （概略）
@findex gnus-summary-limit-to-marks
印を尋ねて、その印が付いていない記事に制限します
(@code{gnus-summary-limit-to-marks})。

@item / t
@kindex / t （概略）
@findex gnus-summary-limit-to-age
数字を尋ねて、概略バッファをその数字の日より古い（もしくは同じ）記事に制限
します (@code{gnus-summary-limit-to-marks})。もし接頭引数が与えられれば、
その数字の日よりも新しい記事に制限します。

@item / n
@kindex / n （概略）
@findex gnus-summary-limit-to-articles
概略バッファを現在の記事に制限します
(@code{gnus-summary-limit-to-articles})。プロセス/接頭引数の習慣を使いま
す (@pxref{Process/Prefix})。

@item / w
@kindex / w （概略）
@findex gnus-summary-pop-limit
前の制限をスタックから取り出して、復元します
(@code{gnus-summary-pop-limit})。もし接頭引数を与えられれば、すべての制
限をスタックから取り出します。

@item / v
@kindex / v （概略）
@findex gnus-summary-limit-to-score
概略バッファをあるスコアと同じか、それより大きなスコアを持つ記事に制限し
ます (@code{gnus-summary-limit-to-score})。

@item / E
@itemx M S
@kindex M S （概略）
@kindex / E （概略）
@findex gnus-summary-limit-include-expunged
すべての消去された記事を表示します
(@code{gnus-summary-limit-include-expunged})。

@item / D
@kindex / D （概略）
@findex gnus-summary-limit-include-dormant
すべての保留記事を表示します (@code{gnus-summary-limit-include-dormant})。

@item / *
@kindex / * （概略）
@findex gnus-summary-limit-include-cached
すべてのキャッシュに入っている記事を表示します
(@code{gnus-summary-limit-include-cached})。

@item / d
@kindex / d （概略）
@findex gnus-summary-limit-exclude-dormant
すべての保留記事を隠します (@code{gnus-summary-limit-exclude-dormant})。

@item / T
@kindex / T （概略）
@findex gnus-summary-limit-include-thread
現在のスレッドのすべての記事を表示します
(@code{gnus-summary-limit-include-thread})。

@item / c
@kindex / c （概略）
@findex gnus-summary-limit-exclude-childless-dormant
子記事の無いすべての保留記事を隠します
(@code{gnus-summary-limit-exclude-childless-dormant})。


@item / C
@kindex / C （概略）
@findex gnus-summary-limit-mark-excluded-as-read
すべての未読のみの印の記事を既読として印を付けます
(@code{gnus-summary-limit-mark-excluded-as-read})。もし接頭引数が与えら
れれば、可視と保留のみの印の記事も既読として印を付けます。

@end table


@node Threading
@section スレッド
@cindex threading
@cindex article threading

Gnus はディフォルトで記事をスレッドにします。@dfn{スレッドにする} とは、あ
る記事への応答を応答した記事の直後に置く――階層的流儀で ということです。

スレッドは記事の @code{References} 欄を調べることによって行われます。完全
な世界では、これだけで良い木を作り上げるのに十分なのですが、不運なことに、
@code{References} 欄はしばしば壊れているか、時には単にないということがあり
ます。不思議なニュースの増殖が問題を増やしますので、喜ばしい結果を得るため
には他の発見法を採用しなければなりません。過剰な対策法は存在していて、その
恐るべき詳細は @pxref{Customizing Threading} に詳しく書いてあります。

まず、概念の概観です：

@table @dfn
@item 根本 (root)
スレッドで一番頂点にある記事です；スレッドの最初の記事です。

@item スレッド (thread)
木のような記事の構成です。

@item 部分スレッド (sub-thread)
木のような構造の（より）小さな部分です。

@item 無束縛スレッド (loose threads)
記事の期限切れ削除や、根本が既に前回のセッションで読まれたことにより概略バッ
ファに表示されない、等の理由により、スレッドはしばしば根本を失います。その
ようなときには、普通は多くの部分スレッドがあって、本当は１つのスレッドに属
しているのですが、根本にはつながっていない、ということになります。こういう
スレッドが無束縛スレッドと呼ばれています。

@item スレッド集め (thread gathering)
まばらスレッドを大きなスレッドに集めようとする試みです。

@item まばらスレッド (sparse threads)
無い記事が『推測された』スレッドで、概略バッファに空行で表示されます。

@end table


@menu
* Customizing Threading::     変更可能なスレッドに影響する変数
* Thread Commands::           概略バッファでのスレッドに基づいた命令
@end menu


@node Customizing Threading
@subsection スレッドをカスタマイズする
@cindex customizing threading

@menu
* Loose Threads::        Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::   スレッドを埋める
* More Threading::       スレッドをいじくるさらに多くの変数
* Low-Level Threading::  これで終わったと思ったでしょう... でもあなたは間違っていた！
@end menu


@node Loose Threads
@subsection 無束縛スレッド
@cindex <
@cindex >
@cindex loose threads

@table @code
@item gnus-summary-make-false-root
@vindex gnus-summary-make-false-root
もし @code{nil} でないと、gnus は全てのつながっていない部分木を１つの大き
な木にして、頂上にみせかけの根本を作ります。（ちょっと待ってください。頂
上に根元 (root) ですって？ええ、そうなのです。）つながっていない部分木は本
当の根本が期限切れ削除されたか、前回のセッションで根本を読んだり削除し
たときにできます。

本当のスレッドが無いときは、gnus は何かでっち上げをする必要があります。こ
の変数は gnus が使うべきごまかしの方法を示しています。値としてとることがで
きる４つの候補があります。

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{390}{
\put(0,0){\epsfig{figure=tmp/summary-adopt.ps,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=tmp/summary-empty.ps,width=7.5cm}}}
\put(0,400){\makebox(0,0)[tl]{\epsfig{figure=tmp/summary-none.ps,width=7.5cm}}}
\put(445,400){\makebox(0,0)[tr]{\epsfig{figure=tmp/summary-dummy.ps,width=7.5cm}}}
}
@end iflatex
@end iftex

@cindex adopting articles

@table @code

@item 養子 (adopt)
Gnus は最初の孤児を親にします。この親はすべての他の記事を養子にします。
この養子記事は、標準の角括弧 (@samp{[]}) の代わりに、先の尖った括弧
(@samp{<>}) で印付けられます。これがディフォルトの方法です。

@item みせかけ (dummy)
@vindex gnus-summary-dummy-line-format
Gnus は親のふりをするみせかけの概略行をつくります。みせかけの行はどの本
当の記事にも対応しませんので、それを選択することは、みせかけの記事の後の
最初の本当の記事を選択をするだけになります。みせかけの根本の様式を指定
するために、 @code{gnus-summary-dummy-line-format} が使われます。これは
たった一つだけのフォーマットの仕様を受け付けます: @samp{S} で、これは記
事の表題です。 @xref{Formatting Variables}.

@item 空 (empty)
Gnus は実際にはどの記事も親にはせず、単に最初の孤児を除いてすべての孤児の
表題欄を空のままにします。（実際は、@code{gnus-summary-same-subject} を表
題として使います。 (@pxref{Summary Buffer Format}).）

@item none
全くどの記事も親にしません。スレッドを集めて、一つの記事の後に他の記事を
表示するだけです。

@item nil
無束縛スレッドを集めません。
@end table

@item gnus-summary-gather-subject-limit
@vindex gnus-summary-gather-subject-limit
無束縛スレッドは記事の表題を比較することによって集められます。もしこの変数
が @code{nil} であると、gnus は無束縛スレッドを一つの大きな超スレッドに集
める前に、無束縛スレッドの表題が完全に一致することを要求します。これは、長
い表題の行を切り落としてしまう間抜けなニューズリーダーが存在する現在では、
あまりに厳しい要求かも知れません。もしそう思うのなら、この変数を例えば 
20 に設定して、表題の最初の 20 文字だけが一致することを要求するようにする
ことができます。この変数を本当に低い数字に設定すると、gnus が目に入る全て
を一つのスレッドに集めるのを見ることができるでしょう。そして、それはあまり
有用ではありません。

@cindex fuzzy article gathering
この変数を特別な値 @code{fuzzy} に設定すれば、gnus は表題にあいまいな文
字列比較アルゴリズムを使います (@pxref{Fuzzy Matching})。

@item gnus-sumplify-subject-fuzzy-regexp
@vindex gnus-simplify-subject-fuzzy-regexp
これは正規表現か、あいまい表題指定が使われているときに表題から合致したも
のが取り除かれる、正規表現のリストであることができます。

@item gnus-simplify-ignored-prefixes
@vindex gnus-simplify-igonored-prefixes
もし @code{gnus-summary-gather-subject-limit} を 10 くらいに低く設定したな
らば、この変数を何か意味のあるものに設定することを考えるでしょう：

@c Written by Michael Ernst <mernst@cs.rice.edu>
@lisp
(setq gnus-simplify-ignored-prefixes
      (concat
       "\\`\\[?\\("
       (mapconcat
        'identity
        '("looking"
          "wanted" "followup" "summary\\( of\\)?"
          "help" "query" "problem" "question"
          "answer" "reference" "announce"
          "How can I" "How to" "Comparison of"
          ;; ...
          )
        "\\|")
       "\\)\\s *\\("
       (mapconcat 'identity
                  '("for" "for reference" "with" "about")
                  "\\|")
       "\\)?\\]?:?[ \t]*"))
@end lisp

この正規表現に合致するすべての語は、２つの表題を比較する前に取り除かれます。

@item gnus-simplify-subject-functions
@vindex gnus-simplify-subject-functions
@code{nil} でないと、この変数は @code{gnus-summary-gather-subject-limit} 
を上書きします。この変数は文字列 @code{Subject} を反復して簡単な形にたど
り着くために適用する関数のリストである必要があります。

このリストに入れて役に立つような関数は次のようなものです：

@table @code
@item gnus-simplify-subject-re
@findex gnus-simplify-subject-re
前の方にある @samp{Re:} を取り除きます。

@item gnus-simplify-subject-fuzzy
@findex gnus-simplify-subject-fuzzy
あいまいに簡単にします。

@item gnus-simplify-whitespace
@findex gnus-simplify-whitespace
余分な空白 (whitespace) を取り除きます。
@end table

もちろん、あなた自身の関数を書くこともできます。


@item gnus-summary-gather-exclude-subject
@vindex gnus-summary-gather-exclude-subject
無束縛スレッド集めは表題のみに行われますので、特に @samp{} や 
@samp{(none)}のような良くある表題のときは、多くの間違いを起こす可能性が
あります。この状況を少しよくするために、どの表題が集める過程から除かれる
かを決める正規表現 @code{gnus-summary-gather-exclude-subject} を使うこと
ができます。ディフォルトは @samp{^ *$\\|^(none)$} です。

@item gnus-summary-thread-gathering-function
@vindex gnus-summmary-thread-gathering-function
Gnus は @code{Subject} 欄を見ることによってスレッドを集めます。これは、結
果的に全く関係の無い記事が同じ『スレッド』に含まれることがあるということで、
これは混乱の元です。代替手段は、合致するものを見つけるために 
@code{References} 欄にある @code{Message-ID} をすべて探すことです。これは
関係の無い記事が集められたスレッドに含まれることは全く無いことを保証します
が、こわれたニューズリーダーで投稿した記事は適切に集められないということで
もあります。選択権はあなたにあります――疫病かコレラか。

@table @code
@item gnus-gather-threads-by-subject
@findex gnus-gather-threads-by-subject
この関数はディフォルトの収集関数で、排他的に @code{Subject} を見ます。

@item gnus-gather-threads-by-references
この関数は排他的に @code{References} 欄を見ます。
@end table

@code{References} によって集めることを試してみたいのであれば、次のように
することができます：

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp

@end table


@node Filling In Threads
@subsubsection スレッドを埋める

@table @code
@item gnus-fetch-old-headers
@vindex gnus-fetch-old-headers
もし @code{nil} でないと、gnus は古いスレッドをもっと古いヘッダー――既読
印の付いている記事のヘッダー を取得することで大きくしようとします。もしで
きるだけ少ない概略行を表示したいけれど、できるだけたくさんの非密スレッドに
接続しておきたいときは、この変数を @code{some} か数字に設定することができ
ます。もし数字に設定したときは、それより多い追加のヘッダーは取得されません。
どちらの場合でも、古いヘッダーの取得が動作するのは、使っているバックエンド 
(backend) が overview ファイルを使っているかどうかです――これは普通は 
@code{nntp}, @code{nnspool} と @code{nnml} です。スレッドのルートがサーバー
によって期限切れ削除されたときは、gnus はどうしようもないことを覚えておい
てください。

この変数は @code{invisible} に設定することもできます。これは視覚的な効果
は何もありませんが、命令 @kbd{A T} をよく使うのであれば役に立つでしょう
(@pxref{Finding the Parent})。

@item gnus-build-sparse-threads
@vindex gnus-build-sparse-threads
古いヘッダーを取得すると遅くなることがあります。同じような低賃金の効果を得
るために、この変数を @code{some} に設定することができます。そうすると、
gnus は全ての記事の完全な @code{References} 欄を見て、同じスレッドに属する
記事をつなごうとします。これは gnus が記事がスレッドから失われていると推測
したところのスレッド表示に@dfn{ずれ}を残すでしょう。（これらのずれは普通の
概略行のように現れます。もしずれを選択したときは、gnus はその当の記事を取
得しようとします。）この変数が @code{t} であると、gnusは全ての『ずれ』をス
レッドを補完するのに役に立つかを考慮せずに表示します。最後に、この変数が 
@code{more} であると、 gnus はどこにもつながっていない枝葉のまばらな節を切
り落としません。この変数はディフォルトでは @code{nil} です。

@end table


@node More Threading
@subsection もっとスレッドを

@table @code
@item gnus-show-threads
@vindex gnus-show-threads
この変数が @code{nil} であると、スレッドは作られず、ここにある残りのすべ
ての変数は全く効果が無くなります。スレッド作りを止めるとグループの選択が
少し速くなりますが、記事を読むのがもっと遅く、不便になることは確実です。

@item gnus-thread-hide-subtree
@vindex gnus-thread-hide-subtree
これが @code{nil} でないと、すべてのスレッドは概略バッファが生成されたと
きに隠れます。

@item gnus-thread-expunge-below
@vindex gnus-thread-expunge-below
この数字より少ない総合的スコア (@code{gnus-thread-score-function}) を持
つすべてのスレッドは消去されます。この変数はディフォルトでは @code{nil}
で、これはどのスレッドも消去されないということです。

@item gnus-thread-hide-killed
@vindex gnus-thread-hide-killed
もしスレッドを削除して、この変数が @code{nil} でないと、部分木は隠されます。

@item gnus-thread-ignore-subject
@vindex gnus-thread-ignore-subject
時々、誰かがスレッドの真中で表題を変更することがあります。もしこの変数が
@code{nil} でないと、表題の変更は無視されます。もし @code{nil} だと、こ
れがディフォルトですが、表題の変更をすると別のスレッドになります。

@item gnus-thread-indent-level
@vindex gnus-thread-indent-level
この数字は部分スレッドがどれくらい字下げ (indent) されるべきかを決めます。
ディフォルトは 4 です。

@end table


@node Low-Level Threading
@subsection 低レベルにおけるスレッド作成

@table @code

@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
すべてのヘッダーを解析する前に実行されるフックです。ディフォルトの値は
@code{(gnus-set-summary-default-charset)} です。これは変数 
@code{gnus-newsgroup-default-charset-alist} で指定されている値から概略バッ
ファの @code{default-mime-charset} を設定します。

@item gnus-alter-header-function
@vindex gnus-alter-header-function
これが @code{nil} でないと、ヘッダー構造の交換を可能にするようにこの関数が
呼ばれます。関数は一つの引数、記事ヘッダーのベクトル、とともに呼ばれ、それ
が何らかの方法で交換されます。例えば、（接頭語やその他のものを付け加えるこ
とによる）体系的な方法で @code{Message-ID} を交換するメールからニュースへ
のゲートウェイがある場合、@code{Message-ID} がもっと意味のあるものにするた
めに、この変数を設定して元に戻すことができます。これは一つの例です：

@lisp
(setq gnus-alter-header-function 'my-alter-message-id)

(defun my-alter-message-id (header)
  (let ((id (mail-header-id header)))
    (when (string-match
           "\\(<[^<>@@]*\\)\\.?cygnus\\..*@@\\([^<>@@]*>\\)" id)
      (mail-header-set-id
       (concat (match-string 1 id) "@@" (match-string 2 id))
       header))))
@end lisp

@end table


@node Thread Commands
@subsection スレッドの命令
@cindex thread commands

@table @kbd

@item T k
@itemx M-C-k
@kindex T k （概略）
@kindex M-C-k （概略）
@findex gnus-summary-kill-thread
現在の（部分）スレッドに既読の印を付けます
(@code{gnus-summary-kill-thread})。もし接頭引数が正であると、代わりにすべ
ての印を取り除きます。接頭引数が負であると、代わりに記事を可視にします。

@item T l
@itemx M-C-l
@kindex T l （概略）
@kindex M-C-l （概略）
@findex gnus-summary-lower-thread
現在の（部分）スレッドのスコアを下げます
(@code{gnus-summary-lower-thread})。

@item T i
@kindex T i （概略）
@kindex gnus-summary-raise-thread
現在の（部分）スレッドのスコアを上げます
(@code{gnus-summary-raise-thread})。

@item T #
@kindex T # （概略）
@findex gnus-uu-mark-thread
プロセス印を現在の（部分）スレッドに付けます 
(@code{gnus-uu-mark-thread})。

@item T M-#
@kindex T M-# （概略）
@findex gnus-uu-unmark-thread
現在の（部分）スレッドからプロセス印を取り除きます
(@code{gnus-uu-unmark-thread})。

@item T T
@kindex T T （概略）
@findex gnus-summary-toggle-threads
スレッド表示を切り替えます (@code{gnus-summary-toggle-threads})。

@item T s
@kindex T s （概略）
@findex gnus-summary-show-thread
もしあれば、現在の記事の下に隠れているスレッドを表示します
(@code{gnus-summary-show-thread})。

@item T h
@kindex T h （概略）
@findex gnus-summary-hide-thread
現在の（部分）スレッドを隠します (@code{gnus-summary-hide-thread})。

@item T S
@kindex T S （概略）
@findex gnus-summary-show-all-threads
すべての隠されているスレッドを表示します
(@code{gnus-summary-show-all-threads})。

@item T H
@kindex T H （概略）
@findex gnus-summary-hide-all-threads
すべてのスレッドを隠します (@code{gnus-summary-hide-all-threads})。

@item T t
@kindex T t （概略）
@findex gnus-summary-rethread-current
現在の記事のスレッドをもう一度作り直します
(@code{gnus-summary-rethread-current})。これは概略バッファがスレッド表示さ
れていないときでも動作します。

@item T ^
@kindex T ^ （概略）
@findex gnus-summary-reparent-thread
現在の記事を印付き（もしくは前の）記事の子記事にします
(@code{gnus-summary-reparent-thread})。

@end table

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付けま
す。

@table @kbd

@item T n
@kindex T n （概略）
@findex gnus-summary-next-thread
次のスレッドに移動します (@code{gnus-summary-next-thread})。

@item T p
@kindex T p （概略）
@findex gnus-summary-prev-thread
前のスレッドに移動します (@code{gnus-summary-prev-thread})。

@item T d
@kindex T d （概略）
@findex gnus-summary-down-thread
スレッドを降下します (@code{gnus-summary-down-thread})。

@item T u
@kindex T u （概略）
@findex gnus-summary-up-thread
スレッドを上昇します (@code{gnus-summary-up-thread})。

@item T o
@kindex T o （概略）
@findex gnus-summary-top-thread
スレッドの頂上に移動します (@code{gnus-summary-top-thread})。
@end table

@vindex gnus-thread-operation-ignore-subject
スレッドを作成するときに表題を無視すると、自然にスレッドにはいくつかの違っ
た表題があることになります。それから `T k'
(@code{gnus-summary-kill-thread}) のような命令を発するときに、全体のスレッ
ドを削除するのではなく、現在の記事と同じ表題を持つ部分だけを削除したいとき
があるかもしれません。もしこの発想が良いと思うのであれば、
@code{gnus-thread-operation-ignore-subject} をいじくることができます。これ
が @code{nil} でないと（これがディフォルトですが）、スレッドの命令を実行し
ているときに表題は無視されます。この変数が @code{fuzzy} であると、あいまい
に等しい表題を持つ記事だけが含まれます (@pxref{Fuzzy Matching})。


@node Sorting
@section 並び替え

@findex gnus-thread-sort-by-total-score
@findex gnus-thread-sort-by-date
@findex gnus-thread-sort-by-score
@findex gnus-thread-sort-by-subject
@findex gnus-thread-sort-by-author
@findex gnus-thread-sort-by-number
@vindex gnus-thread-sort-functions
もしスレッドの概略表示を使っているのであれば、関数のリストである
@code{gnus-thread-sort-functions} を設定することでスレッドを並び替えること
ができます。ディフォルトでは、並び替えは記事番号によってなされます。既に作
られている並び替え述語関数は @code{gnus-thread-sort-by-number},
@code{gnus-thread-sort-by-author}, @code{gnus-thread-sort-by-subject},
@code{gnus-thread-sort-by-date}, @code{gnus-thread-sort-by-score} と 
@code{gnus-thread-sort-by-total-score} です。


各関数は２つのスレッドをとり、最初のスレッドが他のスレッドより先に並び替え
られるべきであれば、@code{nil} でない値をかえします。普通、並び替えは本当
はそれぞれのスレッドの根本を見るだけによりなされることに気を付けてください。
もし２つ以上の関数を使う場合、優先的並び替えキーはリストの最後の関数です。
おそらくいつも @code{gnus-thread-sort-by-number} を並び替え関数のリスト――
最初が好ましい に入れておくべきでしょう。これは他の並び替え基準に関して等
しいスレッドは記事が上がっていく順番に表示されることを保証します。

スコア、表題、そして最後に番号、の順に並び替えたいのであれば、次のように
できます：

@lisp
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-number
        gnus-thread-sort-by-subject
        gnus-thread-sort-by-total-score))
@end lisp

最高スコアのスレッドが概略バッファの最初に表示されます。スレッドが同じス
コアの場合は、英字順に並びかえられます。スコアと表題が同じスレッドは番号
で並び替えられ、（普通は）記事が到着した順番になります。

スコア、到着の逆順に並び替えたいのであれば、次のようにできます：

@lisp
(setq gnus-thread-sort-functions
      '((lambda (t1 t2)
          (not (gnus-thread-sort-by-number t1 t2)))
        gnus-thread-sort-by-score))
@end lisp

@vindex gnus-thread-score-function
変数 @code{gnus-thread-score-function}（ディフォルトは @code{+}）に入って
いる関数はスレッドの総合のスコアを計算するために用いられます。役に立つ関数
は、@code{max}, @code{min}, もしくは２乗、もしくはあなたの好奇心をくすぐる
ような何かでしょう。

@findex gnus-article-sort-functions
@findex gnus-article-sort-by-date
@findex gnus-article-sort-by-score
@findex gnus-article-sort-by-subject
@findex gnus-article-sort-by-author
@findex gnus-article-sort-by-number
何か奇妙な理由などでスレッド表示を使っていないのなら、変数
@code{gnus-article-sort-functions} をいじくる必要があります。これは
@code{gnus-thread-sort-functions} と非常に似ていますが、記事の比較には少々
違った関数を使います。使用可能な並び替え述語関数は
@code{gnus-article-sort-by-number}, @code{gnus-article-sort-by-author},
@code{gnus-article-sort-by-subject}, @code{gnus-article-sort-by-date} およ
び @code{gnus-article-sort-by-score} です。

スレッドを使っていない表題の概略表示を並び替えたいのであれば、次のような
ことをすることができます：

@lisp
(setq gnus-article-sort-functions
      '(gnus-article-sort-by-number
        gnus-article-sort-by-subject))
@end lisp



@node Asynchronous Fetching
@section 非同期記事取得
@cindex asynchronous article fetching
@cindex article pre-fetch
@cindex pre-fetch

もしニュースを遠くの @sc{nntp} サーバーから取得しているのであれば、ネット
ワークの待ち時間が記事を読むことは骨の折れることにしてしまうかもしれません。
@kbd{n} を押して次の記事が現れるまで、しばらく待たなければなりません。どう
して前の記事を読んでいる間に gnus が先に行って記事を取得しないのでしょう？
本当に、そうした方が良いのではないのでしょうか。

まず、いくつかの警告です。非同期記事取得、特に gnus がそれを行っている方
法にはいくつかの落とし穴があります。

例えば、あなたは短い記事 1 を読んでいて、記事 2 はとても長くあなたはそれを
読むことには興味が無いとしましょう。Gnus はこのことはわからないので、先に
行って記事 2 を取得します。あなたは記事 3 を読むことにしますが、gnus は記
事 2 を取得している最中なので、接続は封鎖されています。

この状況を避けるために、gnus はサーバーに２つの（それは２と数えてください）
接続を張ることができます。これはあまりして良いことではないと考える人もいる
でしょうが、私には実際の代替手段が見つからないのです。余分な接続をするため
には何らかの時間がかかりますので、gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先-取得を使わないときよりも、あなたのマシンと @sc{nntp} サーバー間
にもっと負荷がかかるということになるでしょう。サーバー自身ももっと負荷が
かかるようになります――余分な記事の要求と、余分な接続で。

はい、これで本当はこのようなことをすべきで無い事が分かったでしょう... 本
当にそうしたいと思わない限りは。

@vindex gnus-asynchronous
これが方法です： @code{gnus-asynchronous} を @code{t} に設定してください。
残りのことは自動的に起こります。

@vindex gnus-use-article-prefetch
@code{gnus-use-article-prefetch} を設定することにより、どれくらいの記事が
先に取得されるべきかを操作することができます。これはディフォルトでは 30で、
グループの記事を読んでいるときに、バックエンドが次の 30 記事を先-取得する
ということです。この変数が @code{t} であると、バックエンドは制限無く取得で
きるすべての記事を先-取得しようとします。これが @code{nil} であると、先-取
得は行われません。

@vindex gnus-async-prefetch-article-p
@findex gnus-async-read-p
おそらく、先-取得をしたくない記事がいくつかあるでしょう――例えば、既読記
事。変数 @code{gnus-async-prefetch-article-p} は記事が先に取得されるべきか
どうかを制御します。この関数は問題の記事が先-取得されるべきであれば
@code{nil} でない値をかえすべきです。ディフォルトは
@code{gnus-async-read-p} で、それは既読記事には @code{nil} をかえします。
この関数は記事のデータ構造を唯一の引数として呼ばれます。

例えば、もし 100 行よりも短い未読記事のみを先に取得したいのであれば、次の
ようにできます：

@lisp
(defun my-async-short-unread-p (data)
  "Return non-nil for short, unread articles."
  (and (gnus-data-unread-p data)
       (< (mail-header-lines (gnus-data-header data))
          100)))

(setq gnus-async-prefetch-article-p 'my-async-short-unread-p)
@end lisp

これらの関数は何度も何度も呼ばれますので、gnus を遅くしすぎないように、
短く甘美であるのが好ましいです。おそらく、このようなものをバイトコンパイ
ル (byte-compile) するのは良い着想でしょう。

@vindex gnus-prefetched-article-deletion-strategy
記事は非同期バッファから遅かれ早かれ削除されなければなりません。
@code{gnus-prefetched-article-deletion-strategy} はいつ記事を削除するか
を指定しています。これは以下の要素を含むようなリストです：

@table @code
@item read
記事が読まれたときに削除します。

@item exit
グループを抜けたときに記事を削除します。
@end table

ディフォルトの値は @code{(read exit)} です。

@vindex gnus-use-header-prefetch
@code{gnus-use-header-prefetch} が @code{nil} でないと、次のグループから
記事を先に取得します。


@node Article Caching
@section 記事のキャッシュ
@cindex article caching
@cindex caching

もし@emph{非常に}遅い @sc{nntp} 接続であるならば、記事キャッシュをすること
を考えるかもしれません。そうすると、それぞれの記事はあなたのホームディレク
トリの下にローカルに溜めらます。既に推測されているかも知れませんが、これは 
@emph{巨大な}ディスクスペースを食い、iノードも非常に速く食いつぶす可能性が
あるため、それはあなたの頭を泳がせる事になるかもしれません。ウォッカの中で。

でも注意深く使われれば、それは記事を保存する簡単な方法になり得ます。

@vindex gnus-use-long-file-name
@vindex gnus-cache-directory
@vindex gnus-use-cache
キャッシュを実行するためには、@code{gnus-use-cache} を @code{t} に設定し
ます。ディフォルトでは、すべての可視または保留として印の付いている記事は
ローカルのキャッシュに複写されます。このキャッシュが平らな構造か階層的で
あるかは、いつもどおり、変数 @code{gnus-use-long-file-name} で制御されま
す。

可視か保留記事を再選択した場合は、サーバーの代わりにキャッシュから取得さ
れます。キャッシュにある記事は期限切れ削除されませんので、記事が属してい
るところに残したままで記事を保存する方法として使う事ができるかもしれませ
ん。保存したい記事をすべて保留の印を付けて、後は心配は要りません。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょうか。

@vindex gnus-cache-remove-articles
@vindex gnus-cache-enter-articles
キャッシュ へ入る/から削除される は変数 @code{gnus-cache-enter-articles}と 
@code{gnus-cache-remove-articles} によって制御されます。これらは両方ともシ
ンボルのリストです。前者はディフォルトでは @code{(ticked dormant)} で、可
視と保留記事はキャッシュに入れられるという事です。後者はディフォルトでは 
@code{(read)} で、既読の印が付いた記事はキャッシュから削除されるという事で
す。おそらくこれらの２つのリストは @code{ticked}, @code{dormant},
@code{unread} および @code{read} からなるでしょう。

@findex gnus-jog-cache
それで、どうやって大量の記事取得と貯蓄実現されるのでしょうか。命令
@code{gnus-jog-cache} は全ての購読グループに対して、すべての未読記事を要求
し、スコアを付け、キャッシュに保存します。この命令を実際に、実際に実際に実
際に、使うのは、 1) @sc{nntp} サーバーとの接続が本当に、本当に、本当に遅く 
2) 本当に、本当に、本当に巨大なディスクを持っているときだけにするべきです。
これは真面目にいっています。ダウンロードされる記事の数を少なくする一つの方
法は、欲しくない記事のスコアを低くし、既読の印を付ける事です。そうした場合、
それらはこの命令ではダウンロードされません。

@vindex gnus-uncacheable-groups
いくつかのグループではキャッシュをしたくないというのは良くある事です。例え
ば、@code{nnml} メールディレクトリーがホームディレクトリーの下にあれば、そ
れをあなたのホームディレクトリーの下の別の場所にキャッシュするのは意味の無
い事です。あなたが２倍の容量を使う事が良いと感じない限りは。キャッシュを制
限するために、正規表現 @code{gnus-uncacheable-groups} を例えば
@samp{^nnml} と設定してください。この変数はディフォルトでは @code{nil} で
す。

@findex gnus-cache-generate-nov-databases
@findex gnus-cache-generate-active
@vindex gnus-cache-active-file
キャッシュはどの記事が含まれているかの情報を現状ファイル (active file)
(@code{gnus-cache-active-file}) に溜めます。このファイル（もしくはキャッシュ
の他の部分）が何らかの理由でぐちゃぐちゃになってしまった場合、gnus は物事
を正しくするために２つの関数をお勧めします。@kbd{M-x
gnus-cache-generate-nov-databases} はすべての @sc{nov} ファイルを（再）作
成し、@kbd{gnus-cache-generate-active} は 現状ファイルを（再）作成します。


@node Persistent Articles
@section 永続記事
@cindex persistent articles
記事のキャッシュと近い関係にあるもに、@dfn{永続記事}があります。実際、それ
はキャッシュの別の見方で、私の意見ではその方がもっと役に立ちます。

例えば、ニューズグループを読んでいて、そのまま永遠に保存して秘蔵したい、い
くつかの価値ある宝石に出会ったとしましょう。普通はそれをファイルに保存しま
す（多くの保存命令の一つを使って）。それの問題は、単にあの、嫌なだけです。
理想的には、記事はグループであなたが見つけた場所に永遠に残っているべきでしょ
う。ニューズサーバーにおける期限削除には影響されないで。

これが@dfn{永続記事}です――記事は削除されません。それは普通のキャッシュ命
令を使って実装されていますが、永続記事の管理をするために２つの明示的な命令
を使います：

@table @kbd

@item *
@kindex * （概略）
@findex gnus-cache-enter-article
現在の記事を永続にします (@code{gnus-cache-enter-article})。

@item M-*
@kindex M-* （概略）
@findex gnus-cache-remove-article
現在の記事を永続記事から取り除きます (@code{gnus-cache-remove-articles})。
これは普通は記事を削除します。
@end table

この命令は両方ともプロセス/接頭引数の習慣を理解します。

もし永続記事にだけ興味があるのでしたら、可視記事（やその他のもの）がキャッ
シュに入るのを避けるために、@code{gnus-use-cache} を @code{passive} に設定
するのが良いでしょう：

@lisp
(setq gnus-use-cache 'passive)
@end lisp


@node Article Backlog
@section 記事のバックログ
@cindex backlog
@cindex article backlog
もし遅い接続しかない場合で、キャッシュを使うという発想はあまり魅力的ではな
いとき（実際そうなのですが）、@dfn{バックログ}に切り替える事によって状況を
何とかすることができます。これは既に読んだ記事を再取得しなくて良いように、
gnus が既に読んだ記事を一時保存しておくところです。これはもちろん、あなた
に最近読んだ記事を再び選択する癖があるときだけに役立ちます。もし絶対にそれ
をしないのであれば、バックログをすることは gnus を少し遅くし、メモリーの使
用量をいくらか増やします。

@vindex gnus-keep-backlog
もし @code{gnus-keep-backlog} を数字 @var{n} に設定すると、gnus は最大で 
@var{n} の古い記事を後の再取得のためにバッファに溜めておきます。この変数が 
@code{nil} ではなく、数字でもない場合、gnus は@emph{全て}の既読記事をたく
わえます。これはあなたの Emacs が、暴発してあなたのマシンが落ちるまで制限
なく膨れ上がるということです。私はあなた方全てが元気でいられるようにここに
書き加えました。

この変数はディフォルトでは @code{nil} です。


@node Saving Articles
@section 記事の保存
@cindex saving articles

Gnus はたくさんの方法で記事を保存する事ができます。以下のものは非常に率直
な方法（例えば、記事が保存する前にほとんど何もなされない）で記事を保存する
ための説明です。違った手段（uudecodeする、shar ファイルを展開する）につい
ては@code{gnus-uu} を使うのが良いでしょう (@pxref{Decoding Articles})。

@vindex gnus-save-all-headers
@code{gnus-save-all-headers} が @code{nil} でないと、gnus は記事を保存す
る前に望ましくないヘッダーを消去しません。

@vindex gnus-saved-headers
もし上の変数が @code{nil} であると、正規表現 @code{gnus-saved-headers}
に合致するすべてのヘッダーは残され、残りのものは保存する前に削除されます。

@table @kbd

@item O o
@itemx o
@kindex O o （概略）
@kindex o （概略）
@findex gnus-summary-save-article
@c @icon{gnus-summary-save-article}
ディフォルトの記事保存を用いて現在の記事を保存します
(@code{gnus-summary-save-article})。

@item O m
@kindex O m （概略）
@findex gnus-summary-save-article-mail
現在の記事をメールの様式で保存します
(@code{gnus-summary-save-article-mail})。

@item O r
@kindex O r （概略）
@findex gnus-summary-save-article-rmail
現在の記事を rmail の様式で保存します
(@code{gnus-summary-save-article-rmail})。

@item O f
@kindex O f （概略）
@findex gnus-summary-save-article-file
@c @icon{gnus-summary-save-article-file}
現在の記事を普通のファイル (plain file) 様式で保存します
(@code{gnus-summary-save-article-file})。

@item O F
@kindex O F （概略）
@findex gnus-summary-write-article-file
現在の記事を普通のファイル様式で保存し、以前のファイルの内容を上書きしま
す (@code{gnus-summary-write-article-file})。

@item O b
@kindex O b （概略）
@findex gnus-summary-save-article-body-file
現在の記事の本文 (body) を普通のファイル様式で保存します
(@code{gnus-summary-save-article-body-file})。

@item O h
@kindex O h （概略）
@findex gnus-summary-save-article-folder
現在の記事を mh のフォルダーの様式で保存します
(@code{gnus-summary-save-article-folder})。

@item O v
@kindex O v （概略）
@findex gnus-summary-save-article-vm
現在の記事を VM フォルダーに保存します
(@code{gnus-summary-save-article-vm})。

@item O p
@kindex O p （概略）
@findex gnus-summary-pipe-output
現在の記事をパイプに保存します。うーんと、あのぉ、私が言おうとしている事は――
現在の記事をプロセスにパイプするということです
(@code{gnus-summary-pipe-output})。
@end table

@vindex gnus-prompt-before-saving
すべてのこれらの命令はプロセス/接頭引数の習慣を使います
(@pxref{Process/Prefix})。もしこれらの関数を使ってたくさんの記事を保存し
た場合、それぞれのすべての記事に対してファイル名の入力を要求される事に飽
き飽きするでしょう。入力促進動作は変数 @code{gnus-prompt-before-saving} 
によって制御されます。これはディフォルトでは @code{always} で、あなたが
知っていて嫌がっている、過剰な促進動作をします。代わりにこの変数を
@code{t} に設定すると、あなたが保存するそれぞれの一連の記事に対して一回
だけ促されます。本当に gnus にすべての思考をさせたいのであれば、この変数
を@code{nil} にすることさえできます。そして、記事を保存するためのファイ
ルを促される事はありません。Gnus は単純にすべての記事をディフォルトのファ
イルに保存します。


@vindex gnus-default-article-saver
Gnus があなたの望むとおりになるように、変数 
@code{gnus-default-article-saver} をカスタマイズする事ができます。下の４つ
の既製関数を使う事ができますし、自分自身の関数を作る事もできます。

@table @code

@item gnus-summary-save-in-rmail
@findex gnus-summary-save-in-rmail
@vindex gnus-rmail-save-name
@findex gnus-plain-save-name
これはディフォルトの様式、@dfn{babyl} です。変数
@code{gnus-ramil-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルトは 
@code{gnus-plain-save-name} です。


@item gnus-summary-save-in-mail
@findex gnus-summary-save-in-mail
@vindex gnus-mail-save-name
Unix メール (mbox) ファイルに保存します。変数 @code{gnus-mail-save-name}
に入っている関数を、記事を保存するためのファイル名を取得するために使用し
ます。ディフォルトは @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-file
@findex gnus-summary-save-in-file
@vindex gnus-file-save-name
@findex gnus-numeric-save-name
記事を通常のファイルの後に追加します。変数 @code{gnus-file-save-name} に
入っている関数を、記事を保存するためのファイル名を取得するために使用しま
す。ディフォルトは @code{gnus-numeric-save-name} です。

@item gnus-summary-save-body-in-file
@findex gnus-summary-save-body-in-file
記事の本体を通常のファイルの後に追加します。変数
@code{gnus-file-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルトは 
@code{gnus-numeric-save-name} です。


@item gnus-summary-save-in-folder
@findex gnus-summary-save-in-folder
@findex gnus-folder-save-name
@findex gnus-Folder-save-name
@vindex gnus-folder-save-name
@cindex rcvstore
@cindex MH folders
MH ライブラリーの @code{rcvstore} を用いる事によって記事を MH フォルダー
に保存します。変数 @code{gnus-folder-save-name} に入っている関数を、記事
を保存するファイル名を取得するために使用します。ディフォルトは
@code{gnus-folder-save-name} ですが、@code{gnus-Folder-save-name} も使う
事ができて、こちらは先頭が大文字、残りが小文字になった名前をつくります。

@item gnus-summary-save-in-vm
@findex gnus-summary-save-in-vm
記事を VM フォルダーに保存します。この設定を使うためには VM メールリーダー
が必要です。
@end table

@vindex gnus-article-save-directory
これらの全ての関数は最後の一つを除いて、環境変数 @code{SAVEDIR} によって
初期化される @code{gnus-article-save-directory} に記事を保存します。これ
はディフォルトでは @file{~/News/} です。

上にあるように、記事を保存するためのファイルの適切な名前を見つけるために、
関数は違った関数を用います。以下は名前を生成するために使用可能な関数のリス
トです：

@table @code

@item gnus-Numeric-save-name
@findex gnus-Numeric-save-name
@file{~/News/Alt.andera-dworkin/45} のようなファイル名。

@item gnus-numeric-save-name
@findex gnus-numeric-save-name
@file{~/News/alt.andera-dworkin/45} のようなファイル名。

@item gnus-Plain-save-name
@findex gnus-Plain-save-name
@file{~/News/Alt.andera-dworkin} のようなファイル名。

@item gnus-plain-save-name
@findex gnus-plain-save-name
@file{~/News/alt.andera-dworkin} のようなファイル名。
@end table

@vindex gnus-split-methods
連想リスト @code{gnus-split-methods} に正規表現を放り込む事によって、
gnus に記事を保存する場所を提案する事ができます。例えば、gnus に関連した記
事をファイル @file{gnus-stuff} に、VM に関連した記事を @code{vm-stuff} 保
存したければ、この変数を以下のようにする事ができます：

@lisp
(("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
 ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
 (my-choosing-function "../other-dir/my-stuff")
 ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))
@end lisp

これはそれぞれの要素が、２つの要素――@dfn{合致} と @dfn{ファイル} を持つ
リストであるリストであるという事がわかります。合致は文字列（この場合は記事
のヘッダーに合致する正規表現として使われます）および、シンボル（グループ名
を引数として、関数として呼ばれます）および、リスト（これは評価 
(@code{eval}) されます）であることができます。もしこれらの動作の一つでも 
@code{nil} でない結果を返すと、@dfn{ファイル}がディフォルトの促進として使
われます。加えて、呼ばれた関数か式が文字列か文字列のリストを返したときは、
演算の結果自体が使われます。

基本的には、現在の記事を保存するのに使われる可能性のあるファイル名のリスト
を手に入れる事になります。（すべての『合致』が使われます。）それから本当に
名前として使いたいものを促され、この変数を適用する事により得られた結果から
ファイル名補完をして入力します。

この変数はディフォルトでは @code{((gnus-article-archive-name))} で、gnus
保存する記事の @code{Archive-name} 行を調べて、それをファイル名の提案と
して使うという事です。

これはファイル名を少しきれいにする関数の例です。
@samp{nnml:mail.whatever} のようなメールグループがたくさんあるのであれば、
保存するためのファイル名を作る前にこれらのグループ名の最初を切り落とした
いかもしれません。次の物はちょうどそれをします：

@lisp
(defun my-save-name (group)
  (when (string-match "^nnml:mail." group)
    (substring group (match-end 0))))

(setq gnus-split-methods
      '((gnus-article-archive-name)
        (my-save-name)))
@end lisp


@vindex gnus-use-long-file-name
最後に @code{gnus-use-long-file-name} という変数があります。これが
@code{nil} であると、すべての上記の関数はグループ名のすべてのピリオド
(@samp{.}) をスラッシュ (@samp{/}) で置き換えます――これは関数はすべての
ファイルを一番上のディレクトリーに置くのではなく、階層的なディレクトリーを
作るという事です（@file{~/News/alt.andrea-dworkin} の代わりに
@file{~/News/alt/andrea-dworkin}。）この変数はたいていのシステムにおいてディ
フォルトで @code{t} です。しかし、歴史的な理由から Xenix と usg-unix-v マ
シンではディフォルトで @code{nil} です。

この関数は削除とスコアのファイル名に影響します。この変数がリストで、リス
トに要素 @code{not-score} があると、長いファイル名はスコアファイルには使
われず、リストに要素 @code{not-save} があると、長いファイル名は保存には
使われず、要素 @code{not-kill} があると、長いファイル名は削除ファイルに
は使われません。

もし記事をスプールのような階層に保存したいのであれば、次のようにできます

@lisp
(setq gnus-use-long-file-name '(not-save)) ; to get a hierarchy
(setq gnus-default-article-saver 'gnus-summary-save-in-file) ; no encoding
@end lisp

それから @kbd{o} によって記事を保存するだけです。それからこの階層を短命な 
@code{nneething} グループによって読む事ができます――グループバッファで 
@kbd{G D} とし、一番上のディレクトリーを引数 (@file{~/News/}) として渡しま
す。


@node Decoding Articles
@section 記事の復号化
@cindex decoding articles

ときどき利用者は何らかの方法で符号化された記事（もしくは記事群）を投稿し
ます。Gnus はあなたのためにそれらを復号化する事ができます。

@menu
* Uuencoded Articles::    記事を uuencode する。
* Shell Archives::        shar 記事を解凍する。
* PostScript Files::      ポストスクリプトを分割する。
* Other Files::           普通の保存と binhex.
* Decoding Variables::    幸せな復号化のための変数。
* Viewing Files::         復号化の結果を見たい？
@end menu

@cindex series
@cindex article series
これらすべての関数はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) を、 
『一つの記事』を『一つの群』と解釈する拡張をして、どの記事に操作をするかを
見つけるために使います。Gnus は自分自身でどの記事がその群に属しているかを
判断し、すべての記事を復号化して、その結果のファイルを 展開/閲覧/保存 する
ことができます。

Gnus は以下の簡単な規則に則ってどの記事が群に属するのかを推測します： 表題
は行の最後の２つの数字を除いて（ほとんど）同じである必要があります。（空白
は大体無視されますが。）

例えば： @samp{cat.gif (2/3)} というような表題を選ぶと、gnus は正規表現
@samp{^cat.gif ([0-9]+/[0-9]+).*$} に合致するすべての記事を見つけようとし
ます。

@samp{cat.gif (2/3) Part 6 of a series} のような標準でない表題はどの自動
閲覧命令によっても適切に認識されないため、手で記事に @kbd{#} の印を付け
なければなりません。


@node Uuencoded Articles
@subsection uuencode された記事
@cindex uudecode
@cindex uuencoded articles

@table @kbd

@item X u
@kindex X u （概略）
@findex gnus-uu-decode-uu
@c @icon{gnus-uu-decode-uu}
現在の群を uudecode します (@code{gnus-uu-decode-uu})。

@item X U
@kindex X U （概略）
@findex gnus-uu-decode-uu-and-save
現在の群を uudecode して保存します (@code{gnus-uu-decode-uu-and-save})。

@item X v u
@kindex X v u （概略）
@findex gnus-uu-decode-uu-view
現在の群を uudecode して、表示します (@code{gnus-uu-decode-uu-view})。

@item X v U
@kindex X v U （概略）
@findex gnus-uu-decode-uu-and-save-view
現在の記事を uudecode して、表示して保存します
(@code{gnus-uu-decode-uu-and-save-view})。

@end table

これらすべてはプロセス印によって印付けられた記事の存在に対して反応すると
いうことを覚えておいてください。例えば、もしニューズグループ全体を復号化
して保存したいのであれば、普通は @kbd{M P a} (@code{gnus-uu-mark-all})
とし、それから @kbd{X U} (@code{gnus-uu-decode-uu-and-save}) とします。

この全ては、白日の下に明白にキーを打っていた @sc{GNUS 4.1} のときとは
@code{gnus-uu} の動作が全く違っています。この版の @code{gnus-uu} は普通
は何かの方法 (@pxref{Setting Process Marks}) で記事に印を付けて、それか
ら @kbd{X u} を押す事を前提としています。

@vindex gnus-uu-notify-files
注意： @code{gnus-uu-notify-files} に合致する名前、
@samp{[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)} にハードコードされる、を
持つ記事を復号化しようとしたときは、@code{gnus-uu} は問題の記事をちょうど
閲覧した事を知らせるために、自動的に @samp{comp.unix.wizards} に記事を投稿
します。この機能を使わないようにする事はできません。


@node Shell Archives
@subsection シェルアーカイブ
@cindex unshar
@cindex shell archives
@cindex shared articles

シェルアーカイブ（『shar ファイル』）はソースを配布するための人気のある方
法でしたが、今日ではそんなに使われていません。とにかくこれらを扱うための命
令があります：

@table @kbd

@item X s
@kindex X s （概略）
@findex gnus-uu-decode-unshar
現在の群を解凍します (@code{gnus-uu-decode-unshar})。

@item X S
@kindex X S （概略）
@findex gnus-uu-decode-unshar-and-save
現在の群を解凍し保存します (@code{gnus-uu-decode-unshar-and-save})。

@item X v s
@kindex X v s （概略）
@findex gnus-uu-decode-unshar-view
現在の群を解凍し表示します (@code{gnus-uu-decode-unshar-view})。

@item X v S
@kindex X v S （概略）
@findex gnus-uu-decode-unshar-and-save-view
現在の群を解凍し、表示して保存します
(@code{gnus-uu-decode-unshar-and-save-view})。
@end table


@node PostScript Files
@subsection ポストスクリプトファイル
@cindex PostScript

@table @kbd

@item X p
@kindex X p （概略）
@findex gnus-uu-decode-postscript
現在のポストスクリプト群を展開します (@code{gnus-uu-decode-postscript})。

@item X P
@kindex X P （概略）
@findex gnus-uu-decode-postscript-and-save
現在のポストスクリプト群を展開して保存します
(@code{gnus-uu-decode-postscript-and-save})。

@item X v p
@kindex X v p （概略）
@findex gnus-uu-decode-postscript-view
現在のポストスクリプト群を表示します
(@code{gnus-uu-decode-postscript-view})。

@item X v P
@kindex X v P （概略）
@findex gnus-uu-decode-ostscript-and-save-view
現在のポストスクリプト群を表示し保存します
(@code{gnus-uu-decode-postscript-and-save-view})。
@end table


@node Other Files
@subsection 他のファイル

@table @kbd
@item X o
@kindex X o （概略）
@findex gnus-uu-decode-save
現在の群を保存します (@code{gnus-uu-decode-save})。

@item X b
@kindex X b （概略）
@findex gnus-uu-decode-binhex
現在の記事を binhex 解凍します (@code{gnus-uu-decode-binhex})。これは本
当は動作しません。
@end table


@node Decoding Variables
@subsection 復号化のための変数

形容詞です。動詞ではありません。

@menu
* Rule Variables::          ファイルがどのように表示されるかを決める変数。
* Other Decode Variables::  他の復号化の変数。
* Uuencoding and Posting::  uuencode するのをカスタマイズする変数。
@end menu


@node Rule Variables
@subsubsection 規則変数
@cindex rule variables

Gnus はファイルを閲覧するのを決定するのに@dfn{規則変数}を用います。これら
の変数はすべて以下のような様式です

@lisp
      (list '(regexp1 command2)
            '(regexp2 command2)
            ...)
@end lisp

@table @code

@item gnus-uu-user-view-rules
@vindex gnus-uu-user-view-rules
@cindex sox
この変数はファイルを閲覧するときに最初に調べられます。例えば、もし
@samp{.au} 音ファイルを変換するために @code{sox} を使いたいときは、次の
ようにできます：
@lisp
(setq gnus-uu-user-view-rules
      (list '(\"\\\\.au$\" \"sox %s -t .aiff > /dev/audio\")))
@end lisp

@item gnus-uu-user-view-rules-end
@vindex gnus-uu-user-view-rules-end
この変数は gnus が利用者とディフォルトの閲覧規則から合致するものを見つけ
られなかったときに調べられます。

@item gnus-uu-user-archive-rules
@vindex gnus-uu-user-archive-rules
この変数はアーカイブを展開するときにどの命令が使われるべきかを決めるため
に使う事ができます。
@end table


@node Other Decode Variables
@subsection 他の復号化の変数

@table @code
@vindex gnus-uu-grabbed-file-functions

@item gnus-uu-grabbed-file-functions
このリストのすべての関数はそれぞれのファイルが上手く復号化された直後に呼ば
れます――ですから、すぐにファイルを移動や閲覧したりすることができ、何かを
する前にすべてのファイルが復号化されるのを待つ必要はありません。このリスト
に入れる事のできる既製関数は：

@table @code

@item gnus-uu-grab-view
@findex gnus-uu-grab-view
ファイルを閲覧します。

@item gnus-uu-grab-move
@findex gnus-uu-grab-move
ファイルを移動します（もし保存関数を使っているのであれば）。
@end table

@item gnus-uu-be-dangerous
@vindex gnus-uu-be-dangerous
復号化の最中に変な状況が起こったときに何をするかを指定します。もし
@code{nil} であると、できるだけ保守的になります。もし @code{t} であると、
動作しないものは無視して、現存するファイルを上書きします。その他の場合は、
それぞれのときに尋ねます。

@item gnus-uu-ignore-files-by-name
@vindex gnus-uu-ignore-files-by-name
この正規表現に合致する名前のファイルは閲覧されません。

@item gnus-uu-ignore-files-by-type
@vindex gnus-uu-ignore-files-by-type
この変数に合致する @sc{mime} の型を持つファイルは閲覧されません。Gnus はファ
イル名に基づいて型を推測している事に注意してください。@code{gnus-uu} は
（まだ）@sc{mime} パッケージではありませんので、これは少し変です。

@item gnus-uu-tmp-dir
@vindex gnus-uu-tmp-dir
@code{gnus-uu} がその仕事をする場所です。

@item gnus-uu-do-not-unpack-archives
@vindex gnus-uu-do-not-unpack-archives
@code{nil} でないのは、@code{gnus-uu} は表示するためのファイルを探すため
にアーカイブの中までは入っていかないという事です。

@item gnus-uu-view-and-save
@vindex gnus-uu-view-and-save
@code{nil} でないのは、利用者はファイルを閲覧した後に常に保存するかどう
かを尋ねられるという事です。

@item gnus-uu-ignore-default-view-rules
@vindex gnus-uu-ignore-default-view-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトの閲覧規則を無視する
という事です。

@item gnus-uu-ignore-default-archive-rules
@vindex gnus-uu-ignore-default-archive-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトのアーカイブ展開命令
を無視するという事です。

@item gnus-uu-kill-carriage-return
@vindex gnus-uu-kill-carriage-return
@code{nil} でないのは、@code{gnus-uu} は記事からすべてのキャリッジリター
ン (carriage return) を取り去るという事です。

@item gnus-uu-unmark-articles-not-decoded
@vindex gnus-uu-unmark-articles-not-decoded
@code{nil} でないのは、@code{gnus-uu} は復号化に失敗した記事に未読の印を
付けるという事です。

@item gnus-uu-correct-stripped-uucode
@vindex gnus-uu-correct-stripped-uucode
@code{nil} でないというのは、@code{gnus-uu} は続く空白が削除されてしまって
いる uuencode されたファイルを修復しようと@emph{試す}という事です。

@item gnus-uu-pre-uudecode-hook
@vindex gnus-uu-pre-uudecode-hook
@code{uudecode} にメッセージを送る前に実行されるフックです。

@item gnus-uu-view-with-metamail
@vindex gnus-uu-view-with-metamail
@cindex metamail
@code{nil} でないのは、@code{gnus-uu} は規則変数で定義された閲覧命令を無
視して、ファイル名に基づいた @sc{mime} 内容の型に取り替えるという事です。
その結果は閲覧のために @code{metamail} にかけられます。

@item gnus-uu-save-in-digest
@vindex gnus-uu-save-in-digest
@code{nil} でないのは、@code{gnus-uu} が復号化をしないで保存をするように
言われたときに、要約を保存するという事です。この変数が @code{nil} である
と、@code{gnus-uu} は 何も飾りをしないで全てをファイルに保存します。要約
は RFC1153 準じています――意味のある量を指定して、番号を発行する簡単な方
法が見つからなかったので、単純にそれらは切り落としています。

@end table


@node Uuencoding and Posting
@subsection uuencode と投稿

@table @code

@item gnus-uu-post-include-before-composing
@vindex gnus-uu-post-include-before-composing
@code{nil} でないのは、@code{gnus-uu} が記事を作成する前に符号化するファ
イルを尋ねるという事です。この変数が @code{t} であると、@kbd{C-c C-i} に
よって符号化されたファイルを取り込むか、記事を投稿するときに取り込むか、
どちらかをする事ができます。

@item gnus-uu-post-length
@vindex gnus-uu-post-length
記事の最大の長さです。符号化されたファイルは全体のファイルを投稿するのに
必要な量のファイルに分割されます。

@item gnus-uu-post-threaded
@vindex gnus-uu-post-threaded
@code{nil} でないのは、@code{gnus-uu} が符号化されたファイルをスレッドで投
稿するという事です。これはあまり賢い方法ではないかも知れません。というのは、
今まで私が見た中で uuencode された記事を集めるのに、スレッドを追っていく事
のできる他の復号装置が存在しないからです。（えーと、私はそれをする一つのパッ
ケージを見た事があります――@code{gnus-uu} です。しかしなぜか、それが数の
うちに入るとは思えないのです...）ディフォルトは @code{nil} です。

@item gnus-uu-post-separate-description
@vindex gnus-uu-post-separate-description
@code{nil} でないのは、記述は別の記事で投稿されるという事です。最初の記
事は普通は (0/x) のように番号が付けられます。もしこの変数が @code{nil}
であると、利用者の書いた記述は最初のファイルの始めに取り込まれ、(1/x) の
番号が付けられます。ディフォルトは @code{t} です。

@end table


@node Viewing Files
@subsection ファイルの閲覧
@cindex viewing files
@cindex pseudo-articles

復号化した後でファイルが何らかのアーカイブである場合、gnus はアーカイブを
展開しようと試み、アーカイブの中に閲覧できるファイルがあるかを調べます。例
えば、gzip された tar ファイル @file{pics.tar.gz} があって、ファイル 
@file{pic1.jpg} と @file{pic2.gif} を含んでいる場合、gnus は主ファイルを解
凍して tar を展開し、それから２つの絵を閲覧します。この展開の過程は再帰的
なので、アーカイブにアーカイブのアーカイブがあると、それはすべて展開されま
す。

最後に、gnus は普通はそれぞれの抽出された記事ごとに@dfn{疑似記事}を概略バッ
ファに挿入します。これらの『記事』に移動した場合は、実行する命令（普通は 
gnus が提案をします）を入力するように促され、それから命令が実行されます。

@vindex gnus-view-pseudo-asynchronously
@code{gnus-view-pseudo-asynchronously} が @code{nil} であると、Emacs は
先へ進む前に閲覧が終わるまで待ちます。

@vindex gnus-view-pseudos
@code{gnus-view-pseudos} が @code{automatic} であると、gnus は概略バッファ
に疑似記事を挿入しませんが、それらをすぐに閲覧します。この変数が
@code{not-confirm} であると、利用者は閲覧が済む前に確認さえも求められま
せん。

@vindex gnus-view-pseudos-separately
@code{gnus-view-pseudos-separately} が @code{nil} でないと、一つの疑似記
事が閲覧されるそれぞれのファイルに対して作成されます。@code{nil} である
と、同じ閲覧命令を使うすべての命令がその命令の引数のリストとして渡されま
す。

@vindex gnus-insert-pseudo-articles
@code{gnus-insert-pseudo-articles} が @code{nil} でないと、復号化のとき
に疑似記事を挿入します。ディフォルトでは @code{t}です。

それで、そのような感じです。@emph{実質サーバー}からの@emph{実質グループ}の
@emph{疑似記事} 読んでいます。そして考えます： どうして全てが現実ではなく
なってしまったのだろうか？どうしてここに来てしまったのだろうか？


@node Article Treatment
@section 記事の扱い

この巨大な説明文書を読んできて、人々が書いた事を読む、といったようなニュー
ズリーダーの本当の目的を完全に忘れてしまったかも知れません。記事を読む事
です。残念な事に、人々は書く事は非常に苦手としていますので、記事を読みや
すくするための関数と変数が山のようにあります。

@menu
* Article Highlighting::    記事を果物サラダのように見えるようにしたい。
* Article Fontisizing::     強調された文を素敵にする。
* Article Hiding::          特定の情報は消し去りたいとも思う。
* Article Washing::         人生をもっとよくするたくさんの気の利いた関数。
* Article Buttons::         URL や Message-ID や アドレスなどをクリックする。
* Article Date::            ぐずぐず言うな、世界時だ！
* Article Signature::       署名って何？
@end menu


@node Article Highlighting
@subsection 記事のハイライト
@cindex highlight

記事バッファを果物サラダのようにしたいだけでなく、華やかな果物サラダのよ
うに見えるようにしたいでしょう。

@table @kbd

@item W H a
@kindex W H a （概略）
@findex gnus-article-highlight
現在の記事をハイライト (highlight) します
(@code{gnus-article-highlight})。

@item W H h
@kindex W H h （概略）
@findex gnus-article-highlight-headers
@vindex gnus-header-face-alist
ヘッダーをハイライトします (@code{gnus-article-highlight-headers})。ハイラ
イトは変数 @code{gnus-header-face-alist} にしたがってなされ、それはそれぞ
れの要素が @var{(正規表現 名前 内容)} という様式のリストです。 @var{正規表
現}はヘッダーに合致する正規表現、@var{名前}はヘッダーの名前をハイライトす
るのに使われるフェイス (face) (@pxref{FacesandFonts})、@var{内容}はヘッダー
の値をハイライトするフェイスです。最初に合致したものが使われます。@var{正
規表現}は @samp{^} が付けられるべきではない事に注意してください――gnus が
それを付け加えます。

@item W H c
@kindex W H c （概略）
@findex gnus-article-highlight-citation
引用された文をハイライトします (@code{gnus-article-highlight-citation})。

引用ハイライトをカスタマイズするいくつかの変数は：

@table @code
@vindex gnus-cite-parse-max-size

@item gnus-cite-parse-max-size
記事の大きさがこの変数（ディフォルトでは 25000）より大きい記事は、引用ハイ
ライトは行われません。

@item gnus-cite-prefix-regexp
@vindex gnus-cite-prefix-regexp
ある行が取り得る最大の引用接頭語に合致する正規表現です。

@item gnus-cite-max-prefix
@vindex gnus-cite-max-prefix
引用接頭語の最大の長さです（ディフォルトでは 20 です）。

@item gnus-cite-face-list
@vindex gnus-cite-face-list
引用をハイライトするために使われるフェイスのリストです (@pxref{Faces and
Fonts})。同じメッセージの中に複数の記事からの引用があると、gnus はそれぞ
れの記事からの引用をそれ用のフェイスで表示しようとします。これにより、誰
が何を書いたかが分かりやすくなるでしょう。

@item gnus-supercite-regexp
@vindex gnus-supercite-regexp
普通の Supercite 属性行に合致する正規表現です。

@item gnus-supercite-secondary-regexp
@vindex gnus-supercite-secondary-regexp
引き裂かれた Supercite 属性行に合致する正規表現です。

@item gnus-cite-minimum-match-count
@vindex gnus-cite-minimum-match-count
それが引用であると決定する前に調べなければならない最小の同一接頭語です。

@item gnus-cite-attribution-prefix
@vindex gnus-cite-attribution-prefix
属性行の始まりに合致する正規表現です。

@item gnus-cite-attribution-suffix
@vindex gnus-cite-attribution-suffix
属性行の最後に合致する正規表現です。

@item gnus-cite-attribution-face
@vindex gnus-cite-attribution-face
属性行に使われるフェイスです。その属性に属する文のためのフェイスと融合さ
れます。

@end table


@item W H s
@kindex W H s （概略）
@vindex gnus-signature-separator
@vindex gnus-signature-face
@findex gnus-article-highlight-signature
署名 (signature) をハイライトします
(@code{gnus-article-highlight-signature})。
@code{gnus-signature-separator} (@pxref{Article Signature}) の後の全ての
ものは署名と考えられ、@code{gnus-signature-face} でハイライトされます。
それはディフォルトでは @code{italic} です。

@end table


@node Article Fontisizing
@subsection 記事のフォント変更
@cindex emphasis
@cindex article emphasis

@cindex gnus-article-emphasize
@kindex W e （概略）
人々はよくニューズの記事で @samp{_これ_} や @samp{*これ*} のようなものを
使って単語を強調します。Gnus は 記事を命令 @kbd{W e}
(@code{gnus-article-emphasize}) にかける事によって素敵に見えるようにでき
ます。

@vindex gnus-article-emphasis
強調がどのように演算されるかは変数 @code{gnus-article-emphasis} によって制
御されます。これは最初の要素が合致するべき正規表現である連想リストです。２
番目の要素はどの正規表現のグループが強調語全体を見つけるために使われるかを
示す数字です。３番目はどの正規表現のグループが表示されハイライトされるかを
決める数字です。（この２つのグループの間の記事は隠されます。）４番目はハイ
ライトのフェイスです。

@lisp
(setq gnus-article-emphasis
      '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
        ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))
@end lisp

@vindex gnus-emphasis-underline
@vindex gnus-emphasis-bold
@vindex gnus-emphasis-italic
@vindex gnus-emphasis-underline-bold
@vindex gnus-emphasis-underline-italic
@vindex gnus-emphasis-bold-italic
@vindex gnus-emphasis-underline-bold-italic
ディフォルトでは７つの規則があり、それらは以下のフェイスを用います：
@code{gnus-emphasis-bold}, @code{gnus-emphasis-italic},
@code{gnus-emphasis-underline}, @code{gnus-emphasis-bold-italic},
@code{gnus-emphasis-underline-italic},
@code{gnus-emphasis-underline-bold},
@code{gnus-emphasis-underline-bold-italic}.

これらのフェイスを変更したいのであれば、@kbd{M-x customize} か
@code{copy-face} を使う事ができます。例えば、@code{gnus-emphasis-italic}
に代わりに赤のフェイスを使うようにしたいときは、次のようにできます：

@lisp
(copy-face 'red 'gnus-emphasis-italic)
@end lisp


@node Article Hiding
@subsection 記事を隠す
@cindex article hiding

もしくは、それぞれの記事の特定のものを隠したいかもしれません。たいていの
記事には普通はありすぎるくらい作りかえるものがあります。

@table @kbd

@item W W a
@kindex W W a （概略）
@findex gnus-article-hide
概略バッファで最大限隠します (@kbd{gnus-article-hide})。

@item W W h
@kindex W W h （概略）
@findex gnus-article-hide-headers
ヘッダーを隠します (@code{gnus-article-hide-headers})。 @xref{Hiding
Headers}.

@item W W b
@kindex W W b （概略）
@findex gnus-article-hide-boring-headers
あまり興味のもてないヘッダーを隠します
(@code{gnus-article-hide-boring-headers})。 @xref{Hiding Headers}.

@item W W s
@kindex W W s （概略）
@findex gnus-article-hide-signature
署名を隠します (@code{gnus-article-hide-signature})。 @xref{Article
Signature}.

@item W W p
@kindex W W p （概略）
@findex gnus-article-hide-pgp
@vindex gnus-article-hide-pgp-hook
@sc{pgp} 署名を隠します (@code{gnus-article-hide-pgp})。 @sc{pgp} 署名が
隠された後にフック @code{gnus-article-hide-pgp-hook} が実行されます。

@item W W P
@kindex W W P （概略）
@findex gnus-article-hide-pem
@sc{pem} (privacy enhanced messages（プライバシー拡張メッセージ）) 部分を
隠します (@code{gnus-article-hide-pem})。

@item W W c
@kindex W W c （概略）
@findex gnus-article-hide-citation
引用を隠します (@code{gnus-article-hide-citation})。隠蔽をカスタマイズする
いくつかの変数は：

@table @code

@item gnus-cite-hide-percentage
@vindex gnus-cite-hide-percentage
引用された文がこの変数（ディフォルトでは 50）より大きい割合のときは、引用
された分を隠します。

@item gnus-cite-hide-absolute
@vindex gnus-cite-hide-absolute
引用された文は少なくともこの長さ（ディフォルトでは 10）でなければ隠されま
せん。

@item gnus-cited-text-button-line-format
@vindex gnus-cited-text-button-line-format
Gnus はどこの引用文が隠されているかを示すためにボタンを付け加え、文章の
隠蔽を切り替えられるようにします。この変数の様式はこれらのフォーマットの
ような変数によって指定されます (@pxref{Formatting Variables})。次の指定
は有効です：

@table @samp
@item b
隠された文の最初のポイントです。
@item e
隠された文の最後のポイントです。
@item l
隠された文の長さです。
@end table

@item gnus-cited-lines-visible
@vindex gnus-cited-lines-visible
引用文の最初からの表示される行数です。

@end table

@item W W C
@kindex W W C （概略）
@findex gnus-article-hide-citation-in-followups
根本でない記事の引用文を隠します
(@code{gnus-article-hide-citation-in-followups})。これは対話的命令として
はあまり役に立たないかもしれませんが、@code{gnus-article-display-hook}
に入れる事のできる手軽な関数であるでしょう (@pxref{Customizing
Articles})。

@end table

これらの全ての『隠蔽』命令は切り替え命令ですが、これらの命令に負の接頭引数
を与えると、それらは前に隠されていたものを表示します。正の接頭引数を与えれ
ば、それらは常に隠します。

引用カスタマイズのための他の変数の情報のために @pxref{Article
Highlighting} も参照してください。


@node Article Washing
@subsection 記事洗濯
@cindex washing
@cindex article washing

私たちはこれをもっともな理由の下で『記事洗濯』(article washing) と呼んでい
ます。すなわち、キー @kbd{A} は使われているので、代わりにキー @kbd{W} を使
う必要があるのです。

私たちは@dfn{洗濯}を『何かの何かを何か別のものに変換する』と定義しています
が、普通はもっと良く見える何かに落ち着きます。それにもっときれいです、たぶ
ん。

@table @kbd

@item W l
@kindex W l （概略）
@findex gnus-summary-stop-page-breaking
ページの区切りを現在の記事から取り除きます
(@code{gnus-summary-stop-page-breaking})。

@item W r
@kindex W r （概略）
@findex gnus-summary-caesar-message
@c @icon{gnus-summary-caesar-message}
記事バッファでカエサル変換 (Caesar rotate) (rot13) をします
(@code{gnus-summary-caesar-message})。カエサル変換か rot13 を用いて読む事
のできる、判読不可能な記事です（典型的には、攻撃的な冗談などです。）

普通は ``rot13'' と呼ばれています。それはアルファベットの位置が 13 個回転
するからです。例えば、@samp{B}（２番目の文字） → @samp{O}（15番目の文字）。
これは時々『カエサル変換』と呼ばれる事もあります。というのは、カエサルがこ
の形式の、えーと、ちょっと簡単な暗号化を採用したという噂があるからです。

@item W t
@kindex W t （概略）
@findex gnus-summary-toggle-header
記事バッファにすべてのヘッダーを表示するかどうかを切り替えます
(@code{gnus-summary-toggle-header})。

@item W v
@kindex W v （概略）
@findex gnus-summary-verbose-header
記事バッファにすべてのヘッダーを永遠に表示するかどうかを切り替えます
(@code{gnus-summary-verbose-header})。

@item W m
@kindex W m （概略）
@findex gnus-summary-toggle-mime
記事を @sc{mime} 記事として表示するかどうかを切り替えます
(@code{gnus-summary-toggle-mime})。

@item W o
@kindex W o （概略）
@findex gnus-article-treat-overstrike
オーバーストライクを処理します (@code{gnus-article-treat-overstrike})。

@item W d
@kindex W d （概略）
@findex gnus-article-treat-dumbquotes
M******** sm*rtq**t*s を処理します
(@code{gnus-article-treat-dumbquotes})。

@item W w
@kindex W w （概略）
@findex gnus-article-fill-cited-article
語の折り返しをします (@code{gnus-article-fill-cited-articles})。もしこの
関数を @code{gnus-article-display-hook} の中で使った場合、それはかなり後
の方で実行されるべきで、当然すべてのハイライトの後になります。

折り返しをするときに、幅を指定するために命令に数値接頭引数を与える事がで
きます。

@item W c
@kindex W c （概略）
@findex gnus-article-remove-cr
キャリッジリターン (CR) (すなわち、行の最後の @samp{^M}) を取り除きます
(@code{gnus-article-remove-cr})。

@item W f
@kindex W f （概略）
@cindex x-face
@findex gnus-article-display-x-face
@findex gnus-article-x-face-command
@vindex gnus-article-x-face-command
@vindex gnus-article-x-face-too-ugly
@iftex
@iflatex
\include{xface}
@end iflatex
@end iftex
すべての X-Face 欄を探して表示します(@code{gnus-article-display-x-face})。
この命令は変数 @code{gnus-article-x-face-command} によって与えられた関数に
よって実行されます。この変数が文字列ならば、この文字列がサブシェルで実行さ
れます。関数ならば、この関数が顔を引数として呼ばれます。もし
@code{gnus-article-x-face-too-ugly}（これは正規表現です）が @code{From} 欄
に合致すれば、顔は表示されません。Emacs でのディフォルトの動作は
@code{xv} をフォークして見ようとします。XEmacs でのディフォルトの動作は
@code{From} 欄の前に顔を表示します。（XEmacs が X-Face 機能付きでコンパイ
ルされていると良いでしょう――それは表示を少し早くします。もし根本的 
X-Face 機能がないのであれば、gnus は @code{pbmplus} やその仲間の外部プログ
ラムを使って @code{X-Face} 欄を変換しようと試みます。）この関数を表示フッ
クに入れたいのであれば、おそらくそれあ最後になるべきでしょう。

@item W b
@kindex W b （概略）
@findex gnus-article-add-buttons
クリックできるボタンを記事に加えます (@code{gnus-article-add-buttons})。
@xref{Article Buttons}

@item W B
@kindex W B （概略）
@findex gnus-article-add-buttons-to-head
クリックできるボタンを記事のヘッダーに加えます
(@code{gnus-article-add-buttons-to-head})。

@item W E l
@kindex W E l （概略）
@findex gnus-article-strip-leading-blank-lines
記事の始めからのすべての空白行を取り除きます
(@code{gnus-article-strip-leading-blank-lines})。

@item W E m
@kindex W E m （概略）
@findex gnus-article-strip-multiple-blank-lines
すべての空白行を空行で置き換え、すべての複数の空行を一つの空行で置き換え
ます (@code{gnus-article-strip-multiple-blank-lines})。

@item W E t
@kindex W E t （概略）
@findex gnus-article-remove-trailing-blank-lines
記事の最後のすべての空白行を取り除きます
(@code{gnus-article-remove-trailing-blank-lines})。

@item W E a
@kindex W E a （概略）
@findex gnus-article-strip-blank-lines
上の３つの命令をすべて行います (@code{gnus-article-strip-blank-lines})。

@item W E A
@kindex W E A （概略）
@findex gnus-article-strip-all-blank-lines
すべての空白行を取り除きます (@code{gnus-article-strip-all-blank-lines})。

@item W E s
@kindex W E s （概略）
@findex gnus-article-strip-leading-space
記事の本体のすべての行の始めからのすべての空白を取り除きます
(@code{gnus-article-strip-leading-space})。

@end table


@node Article Buttons
@subsection 記事のボタン
@cindex buttons

よく記事の中に他のものへの参照が入れられる事があります。そして、gnus が
それに関する事を、それらの参照の上で @kbd{RET} を打つか、マウスの真中の
ボタンを使う事によって、最小限の努力で取得する事ができれば素敵でしょう。

Gnus はディフォルトで特定の標準の参照に@dfn{ボタン}を付けます： ちゃんとし
た URL、メールアドレス、Message-ID です。これは２つの変数によって制御され
ていて、その一つは記事の本体を扱い、もう一つは記事のヘッダーを扱います。

@table @code

@item gnus-button-alist
@vindex gnus-button-alist
それぞれの入力要素が次のような様式の連想リストです：

@lisp
(REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@table @var

@item regexp
この正規表現 (regexp) に合致するすべての文は外部参照であるとみなされます。
これは埋め込まれた URL に合致する典型的な正規表現です
@samp{<URL:\\([^\n\r>]*\\)>}。

@item button-par
Gnus は合致したもののどの部分がハイライトされるのかを知らなければなりま
せん。これは正規表現のどの副表現がハイライトされるかを指定する番号です。
全てをハイライトしたいのなら、ここで 0 を使ってください。

@item use-p
この式は @code{評価} され、結果が @code{nil} でなければ、これは合致であ
るとみなされます。これは間違った合致を避けるために特別な選別をしたいとき
に役に立ちます。

@item function
この関数 (function) はこのボタンをクリックしたときに呼ばれます。

@item data-par
@var{button-par} のように、これは部分表現の番号ですが、これは合致のどの部
分が @var{function} にデータとして送られるかを指定します。

@end table

ですから、URL をボタンにする完全な入力要素は

@lisp
("<URL:\\([^\n\r>]*\\)>" 0 t gnus-button-url 1)
@end lisp

@item gnus-header-button-alist
@vindex gnus-header-button-alist
それが記事のヘッダーだけに適用され、それぞれの入力要素がどのヘッダーにボ
タン化を適用するかを示す追加の要素がある事を除き、これは他の連想リストと
同じようなものです：

@lisp
(HEADER REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@var{HEADER} は正規表現です。

@item gnus-button-url-regexp
@vindex gnus-button-url-regexp
埋め込まれた URL に合致する正規表現です。それは上の変数のディフォルトの
値で使われます。

@item gnus-article-button-face
@vindex gnus-article-button-face
ボタンに使われるフェイスです。

@item gnus-article-mouse-face
@vindex gnus-article-mouse-face
マウスのカーソルがボタンの上にあるときに使われるフェイスです。

@end table


@node Article Date
@subsection 記事の日付

日付は聞いた事の無い何か辺鄙な時間帯 (timezone) で作成されている事が良くあ
るので、記事が送られたときに何時であったかを知る事ができるのは非常に良い事
でしょう。

@table @kbd

@item W T u
@kindex W T u （概略）
@findex gnus-article-date-ut
UT (別名 GMT, ZULU) で日付を表示します (@code{gnus-article-date-ut})。

@item W T i
@kindex W T i （概略）
@findex gnus-article-date-iso-8601
@cindex ISO 8601
日付を国際的な形式、ISO 8601 で表示します
(@code{gnus-article-date-iso8601})。

@item W T l
@kindex W T l （概略）
@findex gnus-article-date-local
日付をその地域の時間帯で表示します (@code{gnus-article-date-local})。

@item W T s
@kindex W T s （概略）
@vindex gnus-article-time-format
@findex gnus-article-date-user
@findex format-time-string
日付を利用者定義の様式を使って表示します (@code{gnus-article-date-user})。
その様式は変数 @code{gnus-article-time-format} で指定され、
@code{format-time-string} に渡される文字列です。様式指定をする事ができる
一覧は変数の説明文を見てください。

@item W T e
@kindex W T e （概略）
@findex gnus-article-date-lapsed
@findex gnus-start-date-timer
@findex gnus-stop-date-timer
記事が投稿されてから今までどれくらいの時間が経過したかを表示します
(@code{gnus-article-date-lapsed})。この行が連続して更新されるようにした
いのであれば、

@lisp
(gnus-start-date-timer)
@end lisp

をあなたの @file{.gnus.el} ファイルに入れるか、何かのフックで実行するよ
うにする事ができます。タイマーを止めたいのであれば、命令
@code{gnus-stop-date-timer} を使う事ができます。

@item W T o
@kindex W T o （概略）
@findex gnus-article-date-original
本来の日付を表示します (@code{gnus-article-date-original})。これはあなたが
普通は他の変換関数を使っていて、それが完全に間違った事をしているのではない
かと心配しているときに役に立ちます。例えば、記事が 1854 年に投稿されたとなっ
ているとしましょう。しかし、そのような事は@emph{完全に}不可能です。私が
信用できませんか？ *くすくす(笑)*

@end table


@node Article Signature
@subsection 記事の署名
@cindex signatures
@cindex article signature

@vindex gnus-signature-separator
それぞれの記事は２つの部分に分けられます――見出し (header) と本体 
(body) です。本体は署名部分と文章部分に分けられます。どれが署名とみなされ
るかを決める変数は @code{gnus-signature-separator} です。これは普通は 
son-of-RFC 1036 で指示されている標準の @samp{^-- $} です。しかし、多くの人
が標準でない署名分離を用いますので、この変数は一つ一つ試される、正規表現の
リストであることもできます。（探索は本体の最後から始めへとなされます。）よ
くありそうな値は：

@lisp
(setq gnus-signature-separator
      '("^-- $"         ; 標準
        "^-- *$"        ; 普通の壊し方
        "^-------*$"    ; 多くの人は長ーーい横棒の
                        ; 行を使います。あぁ！
        "^ *--------*$" ; ２倍のあぁぁ！
        "^________*$"   ; 下線も人気があります
        "^========*$")) ; 邪道！
@end lisp

あなたが寛容であればあるほど、間違った結果を得る事になるでしょう。

@vindex gnus-signature-limit
@code{gnus-signature-limit} はどれが署名とみなされるかへの制限を提供しま
す。

@enumerate
@item
これが整数であれば、署名はこの整数より（文字で）長くなっていてはいけません。
@item
これが浮動小数点数であれば、署名はその数字より（行で）長くなっていてはいけ
ません。
@item
これが関数であれば、その関数は引数なしで呼ばれ、それが @code{nil} を返せ
ば、バッファには署名がありません。
@item
これが文字列であれば、それは正規表現として使われます。もしそれが合致すれ
ば、その当の文字列は署名ではありません。
@end enumerate

この変数は要素が上に挙げられた型のリストである事もできます。これは例です：

@lisp
(setq gnus-signature-limit
      '(200.0 "^---*Forwarded article"))
@end lisp

これは署名分離物の後に 200 を超える行か、署名分離物の後の文章が正規表現
@samp{^---*Forwarded article} に合致すれば、結局それは署名ではないという事
です。


@node Article Commands
@section 記事命令

@table @kbd

@item A P
@cindex PostScript
@cindex printing
@kindex A P （概略）
@vindex gnus-ps-print-article
@findex gnus-summary-print-article
記事バッファのポストスクリプト (PostScript) イメージを作成して印刷します 
(@code{gnus-summary-print-article})。@code{gnus-ps-print-hook} がバッファ
を印刷する直前に実行されるでしょう。

@end table


@node Summary Sorting
@section 概略の並び替え
@cindex summary sorting

私はどうしてあなたがそうしたいのかはわからないのですが、それでもあなたは
たくさんの方法で概略バッファを並び替える事ができます。

@table @kbd

@item C-c C-s C-n
@kindex C-c C-s C-n （概略）
@findex gnus-summary-sort-by-number
記事番号によって並び替えます (@code{gnus-summary-sort-by-number})。

@item C-c C-s C-a
@kindex C-c C-s C-a （概略）
@findex gnus-summary-sort-by-author
著者によって並び替えます (@code{gnus-summary-sort-by-author})。

@item C-c C-s C-s
@kindex C-c C-s C-s （概略）
@findex gnus-summary-sort-by-subject
表題によって並び替えます (@code{gnus-summary-sort-by-subject})。

@item C-c C-s C-d
@kindex C-c C-s C-d （概略）
@findex gnus-summary-sort-by-date
日付によって並び替えます (@code{gnus-summary-sort-by-date})。

@item C-c C-s C-l
@kindex C-c C-s C-l （概略）
@findex gnus-summary-sort-by-lines
行によって並び替えます (@code{gnus-summary-sort-by-lines})。

@item C-c C-s C-i
@kindex C-c C-s C-i （概略）
@findex gnus-summary-sort-by-score
スコアによって並び替えます (@code{gnus-summary-sort-by-score})。
@end table

これらの関数はスレッドを使っているときと使っていないときの両方で動作しま
す。後者の場合は、すべての概略行が一行一行並び替えられます。前者の場合は、
根本と根本を基本として並び替えられ、それはあなたが求めている事とは異
なっているかもしれません。スレッドを使う事を切り替えるには @kbd{T T} を
打ってください (@pxref{Thread Commands})。


@node Finding the Parent
@section 親記事を探す
@cindex parent articles
@cindex referring articles

@table @kbd
@item ^
@kindex ^ （概略）
@findex gnus-summary-refer-parent-article
現在の記事の親記事を読みたくて、それが概略バッファに表示されていないくて
も、おそらくそれは可能でしょう。というのは、現在のグループが @sc{nntp}
で取得されていて、親がまだ期限消去されていない上、現在の記事の
@code{References} がぶち壊されていなければ、ただ、@kbd{^} か @kbd{A r}
を押せば良いだけです (@code{gnus-summary-refer-parent-article})。もし全
てが上手く行けば、親記事を取得できるでしょう。もし親記事が既に概略バッファ
に表示されているのであれば、ポイントがその記事に移動するでしょう。

正の数値接頭引数を与えられれば、祖先まで多くの記事を戻って取得します。負
の数字接頭引数が与えられれば、その祖先の記事だけを取得します。ですから、
@kbd{3 ^} とすれば、gnus は現在の記事の親と、祖父母と、曾祖父母を取得し
ます。 @kbd{-3 ^} とすれば、gnus は現在の記事の曾祖父母だけを取得します。

@item A R （概略）
@findex gnus-summary-refer-references
@kindex A R （概略）
記事の @code{References} 欄にある全ての記事を取得します
(@code{gnus-summary-refer-references})。

@item A T （概略）
@findex gnus-summary-refer-thread
@kindex A T （概略）
現在の記事が出てきているスレッドの、完全なスレッドを表示します
(@code{gnus-summary-refer-thread})。この命令は動作するために現在のグルー
プのすべてのヘッダーを取得しなければなりませんので、普通は少し時間がかか
ります。もし、これをしばしば行うのであれば、
@code{gnus-fetch-old-headers} を @code{invisible} に設定することを考えた
ほうが良いでしょう (@pxref{Filling In Threads})。これは普通は視覚的な効
果はありませんが、この命令の動作をかなり速くするでしょう。もちろん、グルー
プに入るのは少し遅くなります。

@vindex gnus-refer-thread-limit
変数 @code{gnus-refer-thread-limit} はこの命令を実行するときにどのくらい古
い（すなわち、現在の記事で最初に表示されたよりも前の記事）ヘッダーを取得す
るかを指定します。ディフォルトは 200 です。もし @code{t} であれば、取得可
能なすべてのヘッダーを取得します。この変数は命令 @code{A T} に数値接頭引数
を与える事により上書きする事ができます。

@item M-^ （概略）
@findex gnus-summary-refer-article
@kindex M-^ （概略）
@cindex Message-ID
@cindex fetching by Message-ID
どのグループに属しているかに関わらず、任意の記事を @sc{nntp} サーバーに
尋ねる事ができます。@kbd{M-^} (@code{gnus-summary-refer-article}) は
@code{Message-ID}、それはあの長く、なかなか読む事のできない
@samp{<38o6up$6f2@@hymir.ifi.uio.no>} のような参照をあなたに尋ねます。
あなたはすべてを正確に打ち込まなければなりません。残念ながら、あいまいな
検索はできないのです。
@end table

ニュースでない選択方法から @code{Message-ID} で取得するときには現在の選択
方法が使われますが、この命令に接頭引数を与える事でこれを上書きする事ができ
ます。

@vindex gnus-refer-article-method
もしあなたの読んでいるグループが @code{Message-ID} での取得があまり良くで
きないようなグループ（@code{nnspool} など）である場合、
@code{gnus-refer-article-method} を @sc{nntp} に設定する事ができます。おそ
らく、あなたが会話している @sc{nntp} サーバーがあなたの読んでいるスプール
を更新していると非常に良いでしょう。しかし、それはどうしても必要なわけでは
ありません。

ほとんどのメールバックエンドは @code{Message-ID} での取得が可能ですが、
あまり優雅な方法でやっているわけではありません。@code{nnmbox} と
@code{nnbabyl} はどのグループからの記事も位置を得ることができますが、
@code{nnml} と @code{nnfolder} は現在のグループに投稿した記事の位置しか
得る事ができません。（その他のものは時間がかかりすぎます。）@code{nnmh}
では全く不可能です。

@node Alternative Approaches
@section 代替手段

違った人は違った方法を使ってニューズを読もうとします。これは gnus でもそ
うであるので、我々は概略バッファーのためのマイナーモード (minor mode) に
少しの選択肢を与えてあります。

@menu
* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動-復号化する
@end menu


@node Pick and Read
@subsection 選んで読む
@cindex pick and read

いくつかのニュースリーダー（@code{nn} や、あのぉ、VM/CMS での
@code{Netnews} など）は２相の読むための界面を使います。利用者はまず概略バッ
ファで読みたい記事に印を付けます。それから、記事バッファだけを表示して記事
を読みます。

@vindex gnus-pick-mode
@kindex M-x gnus-pick-mode
Gnus はこれをするための概略バッファマイナーモードを提供します――
@code{gnus-pick-mode} です。これは基本的には簡単に印を付けられるように少し
のプロセス印命令が１打鍵命令になり、概略バッファへ切り替えるための追加命令
を1つ提供します。

これが pick mode を使ったときに使用可能なキーです：

@table @kbd
@item .
@kindex . （選択）
@findex gnus-summary-mark-as-processable
現在の行の記事を選択します (@code{gnus-summary-mark-as-processable})。数値
接頭引数を与えられれば、その行に移動して選択します。（行数は普通は概略選択
行の最初に表示されています。）

@item SPACE
@kindex SPACE（選択）
@findex gnus-pick-next-page
概略バッファを一ページ次にスクロールします (@code{gnus-pick-next-page})。
もしバッファの最後であれば、選択記事を読み始めます。

@item u
@kindex u （選択）
@findex gnus-summary-unmark-as-processable
記事を未選択にします (@code{gnus-summary-unmark-as-processable})。

@item U
@kindex U （選択）
@findex gnus-summary-unmark-all-processable
すべての記事を未選択にします
(@code{gnus-summary-unmark-all-processable})。

@item t
@kindex t （選択）
@findex gnus-uu-mark-thread
スレッドを選択します (@code{gnus-uu-mark-thread})。

@item T
@kindex T （選択）
@findex gnus-uu-unmark-thread
スレッドを未選択にします (@code{gnus-uu-unmark-thread})。

@item r
@kindex r （選択）
@findex gnus-uu-mark-region
領域を選択します (@code{gnus-uu-mark-region})。

@item R
@kindex R （選択）
@findex gnus-uu-unmark-region
領域を未選択にします (@code{gnus-uu-unmark-region})。

@item e
@kindex e （選択）
@findex gnus-uu-mark-by-regexp
正規表現に合致する記事を選択します (@code{gnus-uu-mark-by-regexp})。

@item E
@kindex E （選択）
@findex gnus-uu-unmrak-by-regexp
正規表現に合致する記事を未選択にします (@code{gnus-uu-unmark-by-regexp})。

@item b
@kindex b （選択）
@findex gnus-uu-mark-buffer
バッファを選択します (@code{gnus-uu-mark-buffer})。

@item B
@kindex B （選択）
@findex gnus-uu-unmark-buffer
バッファを未選択にします (@code{gnus-uu-unmark-buffer})。

@item RET
@kindex RET （選択）
@findex gnus-pick-start-reading
@vindex gnus-pick-display-summary
選択された記事を読み始めます (@code{gnus-pick-start-reading})。接頭引数
を与えられれば、まずすべての未選択記事に既読の印を付けます。
@code{gnus-pick-display-summary} が @code{nil} でないと、概略バッファは
読んでいる間も表示されます。

@end table

これが良い考えだと思うのであれば、次のようにする事ができます：

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@vindex gnus-pick-mode-hook
@code{gnus-pick-minor-mode-hook} は pick マイナーモードバッファで実行さ
れます。

@vindex gnus-summary-pick-line-format
pick モードでの概略行の様式は標準の様式とは少し違います。それぞれの行の
最初に行数が表示されます。 Pick モードの行の様式は変数
@code{gnus-summary-pick-line-format} で制御されます (@pxref{Formatting
Variables})。これは @code{gnus-summary-line-format} と同じ様式指定を受け
付けます (@pxref{Summary Buffer Lines})。


@node Binary Groups
@subsection バイナリーグループ
@cindex binary groups

@findex gnus-binary-mode
@kindex M-x gnus-binary-mode
もし多くの時間をバイナリーグループ (binary group) で過ごしているのなら、い
つも @kbd{X u}, @kbd{n}, @kbd{RET} を叩くのが嫌になっているでしょう。
@kbd{M-x gnus-binary-mode} は記事を普通の方法で表示する代わりに、普通の
gnus の記事選択関数を記事群を uudecode しその結果を表示するように変更する、
概略バッファのためのマイナーモードです。

@kindex g (バイナリー)
@findex gnus-binary-show-article
実際は、このモードにしたときに、現実の記事を見るための唯一の命令が 
@kbd{g} です (@code{gnus-binary-show-article})。

@vindex gnus-binary-mode-hook
@code{gnus-binary-mode-hook} がバイナリーマイナーモードバッファで呼ばれ
ます。


@node Tree Display
@section 木表示
@cindex trees

@vindex gnus-use-trees
もし普通の gnus の概略表示を好きでないならば、@code{gnus-use-trees} を
@code{t} に設定してみると良いかもしれません。これは（ディフォルトで）追加
の @dfn{木バッファ} (tree buffer) を作成します。木バッファではすべての概略
モード命令を実行する事ができます。

もちろん、木表示をカスタマイズする変数が少しあります：

@table @code
@item gnus-tree-mode-hook
@vindex gnus-tree-mode-hook
すべての木モードバッファで実行されるフックです。

@item gnus-tree-mode-line-format
@vindex gnus-tree-mode-line-format
木モードバッファでのモード行のためのフォーマット文字列です。ディフォルト
は @samp{Gnus: %%b %S %Z} です。使用可能な指定は 
@pxref{Summary Buffer ModeLine} を参照してください。

@item gnus-selected-tree-face
@vindex gnus-selected-tree-face
木バッファで選択された記事をハイライトするために使われるフェイスです。ディ
フォルトでは @code{modeline} です。

@item gnus-tree-line-format
@vindex gnus-tree-line-format
木の節のためのフォーマット文字列です。でもこの名前は少し誤った名称です――
それは行ではなく、ただ節を定義するだけです。ディフォルトの値は
@samp{%(%[%3,3n%]%)} で、それは投稿者の名前の最初の３文字を表示します。す
べての節が同じ長さであるのは重要ですので、@samp{%4,4n} のような指定を 
@emph{使わなければならない} のです。

有効な指定は：

@table @samp
@item n
投稿者の名前。
@item f
@code{From} 欄。
@item N
記事の番号。
@item [
開き括弧。
@item ]
閉じ括弧。
@item s
表題。
@end table

@xref{Formatting Variables}。

表示に関連した変数は：

@table @code
@item gnus-tree-brackets
@vindex gnus-tree-brackets
これは『本当の』記事と『まばら記事』に違いを付けるために使われます。
様式は 
@var{((本当の開 . 本当の閉) (まばら開 . まばら閉) (偽の開 . 偽の閉))}
となっていて、ディフォルトは 
@code{((?[ . ?]) (?( . ?)) (?@{ . ?@}) (?< . ?>))} です。

@item gnus-tree-parent-child-edges
@vindex gnus-tree-parent-child-edges
これは親の節を子に接続するために使われる文字を含んだリストです。ディフォ
ルトは @code{(?- ?\\ ?|)} です。

@end table

@item gnus-tree-minimize-window
@vindex gnus-tree-minimize-winodw
もしこの変数が @code{nil} でないと、他の gnus ウィンドウがもっと場所を取
れるように gnus は木バッファをできるだけ小さくします。もしこの変数が数字
であると、木バッファはその数字より大きくなる事はありません。ディフォルト
は @code{t} です。フレームでいくつかのウィンドウが横に並んで表示されてい
て、木バッファがそのうちの一つである場合、木ウィンドウを最小化することは
その隣に表示されているすべてのウィンドウの大きさを変更する事に注意してく
ださい。

@item gnus-generate-tree-function
@vindex gnus-generate-tree-function
@findex gnus-generate-horizontal-tree
@findex gnus-generate-vertical-tree
実際にスレッドの木を作成する関数です。２つの既定義の使用可能な関数は：
@code{gnus-generate-horizontal-tree} と
@code{gnus-generate-vertical-tree}（これがディフォルトです）です。

@end table

水平木バッファ (horizontal tree buffer) の例です：

@example
@{***@}-(***)-[odd]-[Gun]
     |      \[Jan]
     |      \[odd]-[Eri]
     |      \(***)-[Eri]
     |            \[odd]-[Paa]
     \[Bjo]
     \[Gun]
     \[Gun]-[Jor]
@end example

同じスレッドが垂直木バッファ (vertical tree buffer) で表示されたものです：

@example
@{***@}
  |--------------------------\-----\-----\
(***)                         [Bjo] [Gun] [Gun]
  |--\-----\-----\                          |
[odd] [Jan] [odd] (***)                   [Jor]
  |           |     |--\
[Gun]       [Eri] [Eri] [odd]
                          |
                        [Paa]
@end example

もし水平木を使っているのなら、概略バッファで木を隣り合わせで表示できれば
嬉しいでしょう。次のようなものをファイル @file{.gnus.el} に加える事がで
きます：

@lisp
(setq gnus-use-trees t
      gnus-generate-tree-function 'gnus-generate-horizontal-tree
      gnus-tree-minimize-window nil)
(gnus-add-configuration
 '(article
   (vertical 1.0
             (horizontal 0.25
                         (summary 0.75 point)
                         (tree 1.0))
             (article 1.0))))
@end lisp

@xref{Windows Configuration}。


@node Mail Group Commands
@section メールグループ命令
@cindex mail group commands

いくつかの命令はメールグループのみで意味を持ちます。これらの命令が現在の
グループで有効でないなら、それらは大騒ぎをしてあなたに知らせるでしょう。

すべてのこれらの命令は（期限削除と編集命令は除く）プロセス/接頭引数の習慣
を使います (@pxref{Process/Prefix})。

@table @kbd

@item B e
@kindex B e （概略）
@findex gnus-summary-expire-articles
グループのすべての期限削除可能な記事を期限切れ削除します
(@code{gnus-summary-expire-articles})。

@item B M-C-e
@kindex B M-C-e （概略）
@findex gnus-summary-expire-articles-now
グループのすべての期限削除可能な記事削除します
(@code{gnus-summay-expire-articles-now})。これは現在のグループの該当する
@strong{全て}の期限削除記事は永遠に空の大きな @file{/dev/null} へ消え去る
という事です。

@item B DEL
@kindex B DEL （概略）
@findex gnus-summary-delete-article
@c @icon{gnus-summary-mail-delete}
メール記事を削除します。これは『あなたのディスクから今から永遠に削除して、
二度と戻らない』の『削除』です。注意して使ってください 
(@code{gnus-summary-delete-article})。

@item B m
@kindex B m （概略）
@cindex move mail
@findex gnus-summary-move-article
あるメールグループから別のところへ記事を移動します
(@code{gnus-summary-move-article})。

@item B c
@kindex B c （概略）
@cindex copy mail
@findex gnus-summary-copy-article
@c @icon{gnus-summary-mail-copy}
あるグループ（メールグループや他のもの）からメールグループに記事を複製しま
す (@code{gnus-summary-copy-article})。

@item B B
@kindex B B （概略）
@cindex crosspost mail
@findex gnus-summary-crosspost-article
現在の記事を他のグループにクロスポストします
(@code{gnus-summary-crosspost-article})。これは他のグループ記事の新しい複
製を作成し、記事の Xref 欄も適切に更新されます。

@item B i
@kindex B i （概略）
@findex gnus-summary-import-article
任意のファイルを現在のメールグループに取り込みます
(@code{gnus-summary-import-article})。あなたはファイル名と、@code{From} 欄
と @code{Subject} 欄の入力を促されます。

@item B r
@kindex B r （概略）
@findex gnus-summary-respool-article
メール記事をスプールし直します (@code{gnus-summary-move-article})。
@code{gnus-summary-respool-default-method} が再スプールするときのディフォ
ルトの選択方法として使用されます。この変数はディフォルトで @code{nil} で、
これは現在のグループの選択方法が代わりに使われるという事です。

@item B w
@itemx e
@kindex B w （概略）
@kindex e （概略）
@findex gnus-summary-edit-article
@kindex C-c C-c （記事）
現在の記事を編集します (@code{gnus-summary-edit-article})。編集を終了し
て変更を永遠にするために、@kbd{C-c C-c} を打ちます。もし命令 
@kbd{C-c C-c} に数値接頭引数を与えると、gnus は記事を再ハイライトしませ
ん。

@item B q
@kindex B q （概略）
@findex gnus-summary-respool-query
もし記事を再スプールしたいときは、再スプールをする前にどのグループに記事
が移るかに興味があるでしょう。この命令でそれがわかります
(@code{gnus-summary-respool-query})。

@item B p
@kindex B p （概略）
@findex gnus-summary-article-posted-p
一部の人はあなたの投稿へのフォローアップをするときに、『親切な』複製を送る
傾向があります。これらは普通はそこに @code{Newsgroups} 欄が付いているので
すが、いつもそうであるとは限りません。この命令
(@code{gnus-summary-article-posted-p}) は現在の記事をあなたのニュースサー
バーから（というよりは、むしろ @code{gnus-refer-article-method} や
@code{gnus-select-method} から）取得しようとし、記事を発見できたかどうかを
報告します。それが記事を発見しなかったとしても、それはとにかく投稿されてい
るかもしれません――メールの伝達はニュースの伝達よりもずっと速く、ニュース
の複製がまだ到着していないだけかもしれないのです。

@end table

@vindex gnus-move-split-methods
@cindex moving articles
もし、規則的に記事を移動（もしくは複製）するのであれば、gnus に記事をどこ
に入れれば良いか提案させたいと思うでしょう。
@code{gnus-move-split-methods} は @code{gnus-split-methods} と同じ構文を使
う変数です (@pxref{Saving Articles})。あなたが妥当だと思うような提案をする
ようにその変数をカスタマイズする事ができます。

@lisp
(setq gnus-move-split-methods
      '(("^From:.*Lars Magne" "nnml:junk")
        ("^Subject:.*gnus" "nnfolder:important")
        (".*" "nnml:misc")))
@end lisp


@node Various Summary Stuff
@section いろいろな概略の物件

@menu
* Summary Group Information::         情報指向の命令。
* Searching for Articles::            複数記事命令。
* Summary Generation Commands::       概略バッファの（再）作成。
* Really Various Summary Commands::   あのやっかいな他に適合しない命令。
@end menu

@table @code
@vindex gnus-summary-mode-hook
@item gnus-summary-mode-hook
概略モードバッファを作成するときにこのフックが呼ばれます。

@vindex gnus-summary-generate-hook
@item gnus-summary-generate-hook
これはスレッド作成と概略バッファ作成の前に実行する最後のものとして呼ばれ
ます。これはニューズグループの持っているデータに基づいてスレッドの変数を
カスタマイズするために非常に便利です。このフックはほとんどの概略バッファ
変数が設定された後に呼ばれます。

@vindex gnus-summary-prepare-hook
@item gnus-summary-prepare-hook
それは概略バッファが作成された後に呼ばれます。例えば、それは何か他の邪悪
な方法で行をハイライトしたり、バッファの見え方を修正したりするのに使った
りするかも知れません。

@vindex gnus-summary-ignore-duplicates
@item gnus-summary-ignore-duplicates
Gnus が同じ @code{Message-ID} を持つ２つの記事を発見したときは、何か思い切っ
た事をしなければなりません。別の記事が同じ @code{Message-ID} を持つ事は許
されていませんが、それは何らかの出所からメールを読んでいるときに起こるかも
しれません。Gnus はこの変数によって何が起こるかをカスタマイズできるように
なっています。もしそれが @code{nil}（これがディフォルトです）であれば、
gnus は @code{Message-ID} を付け替えて（表示のためだけに）記事を他の記事と
同じように表示します。この変数が @code{t} であると、それは記事を表示しませ
ん---最初から存在しなかったかのように。

@end table


@node Summary Group Information
@subsection 概略グループ情報

@table @kbd

@item H f
@kindex H f （概略）
@findex gnus-summary-fetch-faq
@vindex gnus-grou-faq-directory
現在のグループの FAQ（frequently asked questions（頻繁にされる質問）のリス
ト）を取得しようとします (@code{gnus-summary-fetch-faq})。Gnus は普通は遠
隔マシンのディレクトリである @code{gnus-group-faq-directory} から FAQ を取
得しようとします。この変数はディレクトリーのリストである事もできます。その
場合は、この命令に接頭引数を与える事でいろいろなサイト (site) から選ぶ事が
できます。おそらく @code{ange-ftp} もしくは @code{efs} がファイルの取得に
使われるでしょう。

@item H d
@kindex H d （概略）
@findex gnus-summary-describe-group
現在のグループに関する短い記述を与えます
(@code{gnus-summary-describe-group})。接頭引数が与えられると、サーバーから
強制的に記述の再読み込みをします。

@item H h
@kindex H h （概略）
@findex gnus-summary-describe-briefly
最重要概略打鍵の非常に短い記述を与えます
(@code{gnus-summary-describe-briefly})。

@item H i
@kindex H i （概略）
@findex gnus-info-find-node
Gnus の info の節 (node) に移動します (@code{gnus-info-find-node})。
@end table


@node Searching for Articles
@subsection 記事を探す

@table @kbd

@item M-s
@kindex M-s （概略）
@findex gnus-summary-search-article-forward
直後にある全ての記事を正規表現で検索します
(@code{gnus-summary-search-article-forward})。

@item M-r
@kindex M-r （概略）
@findex gnus-summary-search-article-backward
前にある全ての記事を正規表現で検索します
(@code{gnus-summary-search-article-backward})。

@item &
@kindex & （概略）
@findex gnus-summary-execute-command
この命令はあなたにヘッダー部分とその部分に合致する正規表現、合致した場合
に実行される命令の入力を促進します (@code{gnus-summary-execute-command})。
もし接頭引数を与えられれば、代わりに後ろ向きに探します。

@item M-&
@kindex M-& （概略）
@findex gnus-summary-universal-argument
プロセス印によって印付けられた全ての記事の操作を実行します
(@code{gnus-summary-universal-argument})。
@end table

@node Summary Generation Commands
@subsection 概略生成命令

@table @kbd

@item Y g
@kindex Y g （概略）
@findex gnus-summary-prepare
現在の概略バッファを再作成します (@code{gnus-summary-prepare})。

@item Y c
@kindex Y c （概略）
@findex gnus-summary-insert-cached-articles
全ての（現在のグループに）キャッシュされた記事 を概略バッファに挿入します 
(@code{gnus-summary-insert-cached-articles})。

@end table


@node Reallly various Summary Commands
@subsection 本当にいろいろな概略命令

@table @kbd

@item C-d
@kindex C-d （概略）
@findex gnus-summary-enter-digest-group
もし現在のグループが他の記事の集まりであるならば（例えば、摘要 (digest)）、
そのような記事でできているグループに入るためにこの命令を使うかもしれません 
(@code{gnus-summary-enter-digest-group})。Gnus はこの命令に接頭引数を与え
ない限り、どのような型の記事が現在表示されているかを推測しようとし、それは
強制的に『摘要』という解釈になります。基本的に、他の様式からなる他のメッセー
ジの集合であったときは、@kbd{C-d} とすることによりもっと便利な方法でそれら
のメッセージを読む事ができるようになります。

@item M-C-d
@kindex M-C-d （概略）
@findex gnus-summary-read-document
この命令は上のものに非常に似ていますが、いくつかの文書を一つの大ーきいグ
ループに集めます (@code{gnus-summary-read-read-document})。それはいくつ
かの @code{nndoc} グループをそれぞれの文書のために 開き、それからこれら
の @code{nndoc} グループの上に @code{nnvirtual} グループを開く事によって
この事を可能にしています。この命令はプロセス/接頭引数の習慣を理解します
(@pxref{Process/Prefix})。

@item C-t
@kindex C-t （概略）
@findex gnus-summary-togle-truncation
概略行の切断を切り替えます (@code{gnus-summary-toggle-truncation})。これ
はおそらく概略バッファの行中央表示関数を混乱させますので、記事を読んでい
る間に切断を切っているのは良い考えではないでしょう。

@item =
@kindex = （概略）
@findex gnus-summary-expand-window
概略バッファのウィンドウを拡大します
(@code{gnus-summary-expand-window})。接頭引数を与えられれば、@code{記事} 
ウィンドウを拡大します。

@item M-C-e
@kindex M-C-e （概略）
@findex gnus-summary-edit-parameters
現在のグループのグループの媒介変数 (parameter) (@pxref{Group
Parameters}) を編集します (@code{gnus-summary-edit-parameters})。

@end table


@node Exiting the Summary Buffer
@section 概略バッファを抜ける
@cindex summary exit
@cindex exiting groups

普通は概略バッファから抜けると、グループの全ての情報を更新してグループバッ
ファに戻ります。

@table @kbd

@item Z Z
@itemx q
@kindex Z Z (Summary)
@findex q （概略）
@findex gnus-summary-exit
@vindex gnus-summary-exit-hook
@vindex gnus-summary-prepare-exit-hook
@c @icon{gnus-summary-exit}
現在のグループを出て、グループの全ての情報を更新します
(@code{gnus-summary-exit})。抜け出るためのたいていの事をする前に 
@code{gnus-summary-prepare-exit-hook} が呼ばれ、それはディフォルトで 
@code{gnus-summary-expire-articles} を呼びます。抜け出る過程を追えた後に 
@code{gnus-summary-exit-hook} が呼ばれます。(未読の) グループが残ってい
ないときにグループモードに戻るときに 
@code{gnus-group-no-more-groups-hook} が実行されます。

@item Z E
@itemx Q 
@kindex Z E （概略）
@findex Q （概略）
@findex gnus-summary-exit-no-update
グループのどの情報も更新せずに現在のグループを抜け出ます
(@code{gnus-summary-exit-no-update})。

@item Z c
@itemx c
@kindex Z c （概略）
@kindex c （概略）
@findex gnus-summary-catchup-and-exit
@c @icon{gnus-summary-catchup-and-exit}
グループの全ての保留でない記事 (unticked article) に既読の印を付けて、そ
れから抜けます (@code{gnus-summary-catchup-and-exit})。

@item Z C
@kindex Z C （概略）
@findex gnus-summary-catchup-all-and-exit
保留記事も含めて、全ての記事に既読の印を付けて、それから抜けます 
(@code{gnus-summary-catchup-all-and-exit})。

@item Z n
@kindex Z n （概略）
@findex gnus-summary-catchup-and-goto-next-group
全ての記事に既読の印を付けて次のグループへ移動します 
(@code{gnus-summary-catchup-and-goto-next-group})。

@item Z R
@kindex Z R （概略）
@findex gnus-summary-reselect-current-group
現在のグループを出て、それから入り直します 
(@code{gnus-summary-reselect-current-group})。もし接頭引数を与えられれば、
既読と未読の両方の全ての記事を選択します。

@item Z G
@itemx M-g
@kindex Z G （概略）
@kindex M-g （概略）
@findex gnus-summary-rescan-group
@c @icon{gnus-summary-mail-get}
グループを抜け、グループの新しい記事を調べ、グループを選択します 
(@code{gnus-summary-rescan-group})。もし接頭引数を与えられれば、既読と未
読の両方の全ての記事を選択します。

@item Z N
@kindex Z N （概略）
@findex gnus-summary-next-group
グループを抜けて、次のグループへ移動します 
(@code{gnus-summary-next-group})。

@item Z P
@kindex Z P （概略）
@findex gnus-summary-prev-group
グループを抜けて、前のグループへ移動します 
(@code{gnus-summary-prev-group})。

@item Z s
@kindex Z s （概略）
@findex gnus-summary-save-newsrc
現在の既読/印付き記事の数をドリブルバッファ (dribble buffer) に保存し、
それからドリブルバッファを保存します (@code{gnus-summary-save-newrc})。
もし接頭引数を与えられれば、ファイル @file{.newsrc} も保存します。この命
令を使うと、更新なしで抜け出る事 (@kbd{Q} 命令) は意味が無くなります。
@end table

@vindex gnus-exit-group-hook
現在のグループを抜けるときに @code{gnus-exit-group-hook} が呼ばれます。

@findex gnus-summary-wake-up-the-dead
@findex gnus-dead-summary-mode
@vindex gnus-kill-summary-on-exit
あなたにグループを抜けて、それから考えを変える癖があるのであれば、 
@code{gnus-kill-summary-on-exit} を @code{nil} に設定するのが良いかもしれ
ません。もしそうすれば、gnus はそれから抜け出るときに概略バッファを削除し
ません。（何という驚き！）その代わりに、それはバッファの名前を 
@samp{*Dead Summary ... *} のようなものに変更し、
@code{gnus-dead-summary-mode} と呼ばれるマイナーモードを導入します。今や、
そのバッファに切り替えれば、全てのキーが関数 
@code{gnus-summary-wake-up-the-dead} に割り当てられていることに気付くでしょ
う。死んだ概略バッファ (dead summary buffer) でどれかのキーを叩く事と、生
きた普通の概略バッファになるでしょう。

死んだ概略バッファは同時に一つしか存在する事はできません。

@vindex gnus-use-cross-reference
概略バッファを抜け出ると、現在のグループのデータは更新されます（どの記事を
読んで、どの記事に返答したか、などなど。）もし変数 
@code{gnus-use-cross-reference} が @code{t} であると（それがディフォルトで
す）、そのグループに相互参照された (cross referenced) 記事は既読の印が付き、
それが相互投稿 (cross post) された他の購読しているグループでも既読の印が付
きます。この変数が @code{nil} でも @code{t} でなければ、記事は購読と未購読
の両方のグループで既読の印が付きます (@pxref{Crosspost Handling})。


@node Crosspost Handling
@section 相互投稿の扱い

@cindex velveeta
@cindex spamming
相互投稿 (cross post) された記事に既読の印を付ける事は、同じ記事を２回以上
読まないですむという事を保証します。もちろん、だれかがそれをいくつかのグルー
プに別々に投稿しない限りは。同じ記事をいくつかのグループに投稿する事（相互
投稿でなくて）は @dfn{spamming} と呼ばれ、あなたはそのような憎むべき犯罪を
行うものにに対して、法律によって不快な記事を送ることが義務づけられています。
spam を選別するために、NoCeM 取扱を試したいと思うかもしれません 
(@pxref{NoCeM})。

覚えてください： 相互投稿は構いませんが、同じ記事を別々にいくつかのグルー
プに投稿するのは許されません。大量の相互投稿 (@dfn{velveeta}) はどうしても
避けられるべきで、過剰相互投稿に対して不満を言うために命令 
@code{gnus-summary-mail-crosspost-complaint} を使うことさえできます。

@cindex cross-posting
@cindex Xref
@cindex @sc{nov}
相互投稿を gnus が正しく扱えないようになる原因の一つは、@sc{nov} 行に 
@code{Xref} 欄を含まない、@sc{xover}（これは非常に良いです、というのはそれ
は速度をとても速くするからです）の使用可能な @sc{nntp} サーバーを使ってい
ることです。これは害悪なのですが、あぁ、悲しいかな、非常に良くある事です。
Gnus はあなたが読んだ全ての記事に @code{Xref} 行を登録する事で、正しい事を
しよう としますが、記事を削除するか、読まないで既読の印を付けると、gnus は
これらの記事に @code{Xref} の行をのぞきまわる機会を得る事が無く、相互参照
機構を用いる事ができません。

@cindex LIST overview.fmt
@cindex overview.fmt
あなたの @sc{nntp} サーバーがその概観ファイル (overview file) に
@code{Xref} 欄を含んでいるかを調べるには、@samp{telnet your.nntp.server
nntp} として、@code{inn} サーバーで @samp{More READER} とし、それから 
@samp{LIST overview.fmt} とする事を試してください。これは動作しないでしょ
うが、もし動作して、取得した最後の行が @samp{Xref:full} でないならば、ニュー
スの管理者が概観ファイルに @code{Xref} 欄を含むようにするまで、ニュース管
理者に叫び、泣き付く事を続けるべきでしょう。

@vindex gnus-nov-is-evil
Gnus にいつでも正しい @code{Xref} を取得するようにさせたいのであれば、
@code{gnus-nov-is-evil} を @code{t} にする必要があり、それは非常に速度を
遅くします。

ま、人生はそのようなものです。

代替手段に付いては @pxref{Duplicate Suppression} を参照してください。


@node Duplicate Suppression
@section 重複の抑制

ディフォルトでは gnus は相互投稿機構を利用する事によって、同じ記事を２回以
上読まないようにしようとします (@pxref{Crosspost Handling})。しかし、その
単純で効果的な方法は、いろいろな理由により、満足する結果をもたらさないかも
知れません。

@enumerate
@item
@sc{nntp} サーバーは @code{Xref} 欄の生成に失敗するかも知れません。これは
悪い事で、あまり起こりません。

@item
@sc{nntp} サーバーは @file{.overview} データベースに @code{Xref} 欄を含め
るのに失敗するかも知れません。これは悪い事で、非常に良くある事です、あぁ悲
しい。

@item
同じグループ（もしくはいくつかの関連したグループ）を違った @sc{nntp} サー
バーから読んでいるかもしれません。

@item
グループに投稿された記事と重複するメールを受け取ったかもしれません。
@end enumerate

@code{Xref} の扱いに失敗する状況は他にもありますが、これら４つがとても良く
ある状況です。

もし、本当にもしも @code{Xref} の扱いに失敗したら、@dfn{重複抑制}に切り替
える事を考えるかもしれません。そうすれば、gnus はあなたが読んだ全ての記事
かそうでなければ、既読の印が付いた全ての記事の @code{Message-ID} を記憶し、
それから、魔法のように、その後のそれらと出会った全ての場合に、既読の印を付
けます――@emph{全て}のグループで。この機構を使うのは非常に非効率的ですが、
過度に非効率なわけではありません。もちろん同じ記事を一回以上読むほうが好ま
しいです。

重複抑制はあまり繊細なものではありません。どちらかというと、大槌のようなも
のです。それは非常に単純な方法で動作しています――もし記事に既読の印を付け
れば、それはこの Message-ID を キャッシュに加えます。次にこのMessage-ID に
であったときは、@samp{M} 印によって記事に既読の印を付けます。それはその記
事がどのグループにあるかは気にしません。

@table @code
@item gnus-suppress-duplicates
@vindex gnus-suppress-duplicates
@code{nil} でなければ、重複抑制をします。

@item gnus-save-duplicate-list
@vindex gnus-save-duplicate-list
@code{nil} でなければ、重複のリストをファイルに保存します。これは起動と終
了の時間を長くしますので、初期状態では @code{nil} です。しかし、これは単一
の gnus の実行期で読まれた重複記事だけが抑制されるという事です。

@item gnus-duplicate-list-length
@vindex gnus-duplicate-list-length
この変数はどのくらい多くの @code{Message-ID} を重複抑制リストに保ってお
くかも決定します。ディフォルトは 10000 です。

@item gnus-duplicate-file
@vindex gnus-duplicate-file
重複抑制のリストを蓄積しておくファイルの名前です。ディフォルトは 
@file{~/News/suppression} です。
@end table

何度も gnus を終了して起動する傾向があるのであれば、おそらく 
@code{gnus-save-duplicate-list} を @code{t} にするのは良い考えでしょう。
もし gnus を続けて何週間も走らせておくのであれば、それを @code{nil} にす
るかもしれません。一方で、リストを保存する事は起動と終了をずっと遅くしま
すので、よく gnus を終了して起動するのであれば、
@code{gnus-save-duplicate-list} を @code{nil} に設定するべきであるという
事になります。うーむ。私はあなたがどうするかに任せたい、と思います。


@node The Article Buffer
@chapter 記事バッファ
@cindex article buffer

記事は一つしかない記事バッファに表示されます。全ての概略バッファは（gnus 
に共有しないように指示しない限り）同じ記事バッファを共有します。

@menu
* Hiding Headers::        どのヘッダーを表示するかを決める。
* Using MIME::            @sc{mime} 記事として見せる。
* Customizing Articles::  記事の見栄えを仕立てる。
* Article Keymap::        記事バッファで使えるキー操作。
* Misc Article::          その他。
@end menu


@node Hiding Headers
@section 余分なヘッダーを隠す
@cindex hiding headers
@cindex deleting headers

各記事の頭の部分はヘッダー(@dfn{head})と呼ばれます（残りの部分はボディ
(@dfn{body})です。すでにお気づきでしょうが）。

@vindex gnus-show-all-headers
ヘッダーにはたくさんの便利な情報が含まれています。記事を書いた人の名前、そ
れが書かれた日付、記事の表題などです。これはとても良いんですが、ヘッダーに
は大部分の人には見たくもない情報――記事があなたのところに着くまでどんなシ
ステムを経由してきたか、@code{Message-ID}, @code{References} などなど…も
うやんなっちゃうくらい――もたくさん含まれています。たぶんあなたはこれらの
行はいくつか取り除いてしまいたいと思うでしょう。もしこれらの行を全て記事バッ
ファ内に残しておきたければ、@code{gnus-show-all-headers} を @code{t} に設
定してください。

Gnus はヘッダーを選り分けるために２つの変数を用意しています。

@table @code

@item gnus-visible-headers
@vindex gnus-visible-headers
この変数が @code{nil} 以外であれば、どのヘッダーを記事バッファに
残したいかを指定する正規表現であるとみなされます。この変数にマッ
チしないヘッダーは全て隠されます。

例えば、記事を書いた人の名前と表題のみを見たければ、こう指定します。

@lisp
(setq gnus-visible-headers "^From:\\|^Subject:")
@end lisp

この変数は、表示させたいヘッダーにマッチする正規表現をリストで指
定することもできます。

@item gnus-ignored-headers
@vindex gnus-ignored-headers
この変数は @code{gnus-visible-headers} の反対です。この変数が設定されてい
れば（かつ @code{gnus-visible-headers} が @code{nil} であれば）、これは隠
したいヘッダー行全てにマッチする正規表現であるとみなされます。この変数にマッ
チしない全てのヘッダー行は表示されます。

例えば、単に @code{References} 欄と @code{Xref} 欄のみを消し去りたければ、
以下のようにします：

@lisp
(setq gnus-ignored-headers "^References:\\|^Xref:")
@end lisp

この変数は消したいヘッダーにマッチする正規表現のリストでも構いま
せん。

なお、@code{gnus-visible-headers} が @code{nil} 以外の場合は、こ
の変数には効果が無いことに注意してください。

@end table

@vindex gnus-sorted-header-list
Gnus はヘッダーの並べ替え(sort)も行います（これはディフォルトで行われます）。
この並べ替えは @code{gnus-sorted-header-list} 変数を設定することで制御する
ことができます。これはヘッダーをどういう順序で表示するかを指定する正規表現
のリストです。

例えば、記事の著者名を最初に、次に表題を表示したければ、こんな風
になるでしょう。

@lisp
(setq gnus-sorted-header-list '("^From:" "^Subject:"))
@end lisp

表示するようになっているヘッダーでこの変数に指定されていないもの
は、この変数に指定されている全てのヘッダーの後に、適当な順序で表
示されるでしょう。

@findex gnus-article-hide-boring-headers
@vindex gnus-article-display-hook
@vindex gnus-boring-article-headers
@code{gnus-article-hide-boring-headers} を
@code{gnus-article-display-hook} に入れることによって、もっとつ
まらないヘッダーを隠すことができます。この関数が何をするかは
@code{gnus-boring-article-headers} 変数に依存します。この変数は
リストですが、このリストには実際のヘッダーの名前が入るのではあり
ません。代わりに gnus がチェックして視界から消し去るためのさまざ
まな「つまらない条件」@dfn{boring conditions} のリストを指定しま
す。

この条件には以下のようなものがあります。
@table @code
@item empty
空のヘッダーを全て消去します。
@item newsgroups
@code{Newsgroups} 欄が現在のグループ名しか含んでいない場合には消去します。
@item followup-to
@code{Followup-To} 欄が @code{Newsgroups} 欄と同一である場合には消去します。
@item reply-to
@code{Reply-To} 欄が @code{From} 欄と同じアドレスを示している場合には消去
します。
@item date
その記事が過去３日以内のものであれば、@code{Date} 欄を消去します。
@item long-to
@code{To} 欄があまりにも長い場合には消去します。
@item many-to
@code{To} 欄が一つよりも多ければ、それらを全て消去します。
@end table

上記の最初の４つの要素を入れたければ、こんな風になります。

@lisp
(setq gnus-boring-article-headers
      '(empty newsgroups followup-to reply-to))
@end lisp

これはこの変数のディフォルト値でもあります。


@node Using MIME
@section @sc{mime} を使う
@cindex @sc{mime}

パントマイム (mime) とは、意味も無く空中で手を振るものとして広く
知られており、その間観客はあくびをしながらぼんやりとしてます。

一方、@sc{mime} とは、意味も無く記事を符号化する標準であり、その
ために全てのニューズリーダが恐怖で死んでしまうものです。

@sc{mime} はその記事がどんな文字集合を使用しているか、その文字をどう符号化
しているかを指定することができ、さらには絵やその他のみだらなものを無邪気な
格好の記事で埋め込むことさえ可能にします。

@vindex gnus-show-mime
@vindex gnus-show-mime-method
@vindex gnus-strict-mime
@findex metamail-buffer
Gnus は @code{gnus-show-mime-method} に記事を押し付けることで @sc{mime} を
扱います。これはディフォルトでは @code{gnus-show-mime-method} です。この関
数は SEMI MIME-View プログラムを呼び出して実際の処理を行います。SEMI
MIME-View に関する詳しい情報は、マニュアルを参照してください（まだないけど
(;_;)）。

@sc{mime} を常に使用したければ、@code{gnus-show-mime} を 
@code{t} に設定してください。しかし、@code{gnus-strict-mime} が 
@code{nil} 以外であれば、@sc{mime} 処理は記事中に @sc{mime} ヘッ
ダーがあるときのみ使用されます。@code{gnus-show-mime} を設定して
いると、運が悪いと記事バッファには故障したような画面が見えること
もあるでしょう。これは避けようがありません。

GNUS や Gnus では、このたちの悪い問題で驚かされないようにするには、概略バッ
ファにおいて切り替え機能を使うというのが最善かも知れません（例えば、
@samp{alt.sing-a-long} グループに入ると、あなたの気づかないうちに
@sc{mime} は記事中のサウンドファイルを復号して、何やら怪しげな長い長い歌が
あなたのスピーカーから大音響で流れ出し、あなたはボリュームボタンを見つけら
れず、というのはそんなものはもともとついてないからで、みんなはあなたの方を
睨みはじめ、あなたはプログラムを止めようとするけどできなくて、ボリュームを
制御するプログラムも見つけられなくて、そして部屋中の全員は突然あなたのこと
を軽蔑の眼差しで見るようになってしまい、あなたはちょっと面白くない思いをす
る、とか）。

現実の出来事と実在の人物に類似しているかもしれませんが、これは全
てホントのことです。げほげほ。

まあ、そういう訳で、gnus では @code{metamail-buffer} を使うのを止めた訳で
す。そういう訳で、今では常に @code{gnus-show-mime} を @code{nil} 以外にし
ておき、周りに人がいない時を見計らって記事バッファに現われるボタンを押しま
しょう。


@node Customizing Articles
@section 記事のカスタマイズ
@cindex article customization

@vindex gnus-article-display-hook
@code{gnus-article-display-hook} は記事が記事バッファに書き込ま
れた直後に呼び出されます。これは記事が表示される前の処理を全て扱
う、ということです。

@findex gnus-article-maybe-highlight
ディフォルトではこのフックには @code{gnus-article-hide-headers}、
@code{gnus-article-treat-overstrike},
@code{gnus-article-maybe-highlight} だけが含まれていますが、このフックに入
れることができる関数は何千も、いや何百万もあります。各関数の概観は
@pxref{Article Highlighting}, @pxref{Article Hiding}, @pxref{Article
Washing}, @pxref{Article Buttons}, @pxref{Article Date} を参照してください。
注意点として、このフックでは関数の順序が影響することがあるので、お望みの結
果を得るにはちょっと手間取ってしまうかもしれません。

もちろん、あなた独自の関数を書くこともできます。この関数は記事バッファ内か
ら呼び出され、あなたのやりたいことをほとんど何でもできます。バッファに残し
ておかなければならない情報は何もありません――何でも変更することができます。
ですが、ヘッダーは消去しない方が良いです。その代わり、ヘッダーをどこかにやっ
てしまいたければ、それらを見えないようにしてください。

@node Article Keymap
@section 記事のキー操作

概略バッファにおけるキー操作のほとんどは記事バッファでも使用でき
ます。これらは概略バッファでそのキーを押したかのように動作します。
つまり、実は記事を読んでいる間、概略バッファを表示させておく必要
もないということです。全ての操作は記事バッファから行うことができ
るのです。

それらに加えていくつかのキー操作が利用できます。

@table @kbd

@item SPACE
@kindex SPACE (Article)
@findex gnus-article-next-page
一頁前にめくります (@code{gnus-article-next-page})。

@item DEL
@kindex DEL (Article)
@findex gnus-article-prev-page
一頁後ろに戻します (@code{gnus-article-prev-page})。

@item C-c ^
@kindex C-c ^ (Article)
@findex gnus-article-refer-article
カーソル位置が @code{Message-ID} の近辺にあるときに @kbd{r} を押
すと、gnus はサーバーからその記事を取ってこようとします
(@code{gnus-article-refer-article})。

@item C-c C-m
@kindex C-c C-m (Article)
@findex gnus-article-mail
カーソル位置の近くにあるアドレスに返信を送ります
(@code{gnus-article-mail})。接頭引数を与えると、そのメールに引用
します。

@item s
@kindex s (Article)
@findex gnus-article-show-summary
バッファを再構成して、概略バッファを見えるようにします
(@code{gnus-article-show-summary})。

@item ?
@kindex ? (Article)
@findex gnus-article-describe-briefly
利用できるキー操作のごく簡単な説明を出します
(@code{gnus-article-describe-briefly})。

@item TAB
@kindex TAB (Article)
@findex gnus-article-next-button
次のボタンがあればそこに移動します 
(@code{gnus-article-next-button})。これはボタン機能をオンにして
いるときのみ意味を持ちます。

@item M-TAB
@kindex M-TAB (Article)
@findex gnus-article-prev-button
一つ前のボタンがあればそこに移動します 
(@code{gnus-article-prev-button})。

@end table


@node Misc Article
@section 記事のその他

@table @code

@item gnus-single-article-buffer
@vindex gnus-single-article-buffer
@code{nil} 以外であれば、全てのグループに対して同じ記事バッファを使用しま
す（これはディフォルトです）。@code{nil} であれば、各グループ毎の固有の記
事バッファを持つようになります。

@vindex gnus-article-prepare-hook
@item gnus-article-prepare-hook
このフックは記事が記事バッファに書き込まれた直後に呼び出されます。
これは主に、何か記事の内容に依存する処理をする関数のために用意さ
れています。つまり記事バッファの内容を変更するような目的で使うべ
きではないでしょう。

@vindex gnus-article-display-hook
@item gnus-article-display-hook
このフックは記事を表示するときの最後に呼び出されるようになってい
て、記事バッファの内容の修正、ハイライト処理、ヘッダーを隠す、な
どといったことを行うために用意されています。

@item gnus-article-mode-hook
@vindex gnus-article-mode-hook
記事モードバッファで呼び出されるフックです。

@item gnus-article-mode-syntax-table
@vindex gnus-article-mode-syntax-table
記事バッファで用いられるシンタックステーブルです。これは
@code{text-mode-syntax-table} をもとに初期化されます。

@vindex gnus-article-mode-line-format
@item gnus-article-mode-line-format
この変数は @code{gnus-summary-mode-line-format} と同じ行に従った
様式文字列です。これは以下の一つの拡張を除いて、その変数と同じ様
式指定を受付けます。

@table @samp
@item w
記事の「洗濯状態」@dfn{wash status}。これは記事に対して行われた
であろう洗濯操作を示す一文字からなる短い文字列になります。
@end table

@vindex gnus-break-pages

@item gnus-break-pages
改頁 @dfn{page breaking} を行うかどうかを制御します。この変数が
@code{nil} 以外であれば、記事中に頁区切り文字が現れた場所ごとに
頁分割します。この変数が @code{nil} であれば頁分けは行われません。

@item gnus-page-delimiter
@vindex gnus-page-delimiter
これが上で触れた区切り文字です。ディフォルトでは @samp{^L} (フォー
ムフィード、改頁) です。
@end table


@node Composing Messages
@chapter メッセージの作成
@cindex composing messages
@cindex messages
@cindex mail
@cindex sending mail
@cindex reply
@cindex followup
@cindex post

@kindex C-c C-c (投稿)
全ての投稿とメールの命令は、@kbd{C-c C-c} を押す事によって、記事を送信する
前に記事を好きなように編集する事のできる、メッセージバッファに移動します。
@xref{Top, , Top, message, The Message Manual}。もし外部ニュースグループに
いて、記事を外部サーバーを使って投稿したいのであれば、@kbd{C-c C-c} に接頭
引数を与えて、gnus に外部サーバーを使って投稿しようと試させる事ができます。

@menu
* Mail::                 メールと返答。
* Post::                 投稿とフォローアップ。
* Posting Server::       どのサーバーを通して投稿するべきか？
* Mail and Post::        同時にメールを出し返答する。
* Archived Messages::    送ったメッセージを gnus が貯めておくところ。
* Drafts::               メッセージの延期と拒否されたメッセージ。
* Rejected Articles::    サーバーがあなたの記事を好きでないときに何が起こる？
@end menu

投稿するべきでなかった記事を削除するための情報は @pxref{Canceling and
Superseding} を参照してください。


@node Mail
@section メール

出て行くメールをカスタマイズする変数です：

@table @code
@item gnus-uu-digest-headers
@vindex gnus-uu-digest-headers
要約メッセージ (digested message) に含まれるヘッダーに合致する正規表現の
リストです。ヘッダーは合致した順に取り込まれます。

@item gnus-add-to-list
@vindex gnus-add-to-list
@code{nil} でなければ、@kbd{a} をしたときに、@code{to-list} グループパラ
メータをそれのないメールグループに付け加えます。

@end table


@node Post
@section 投稿

ニューズ記事作成のための変数：

@table @code
@item gnus-sent-message-ids-file
@vindex gnus-sent-message-ids-file
Gnus は送信した全てのメールの @code{Message-ID} 履歴ファイル (history
file) を保存します。もしメールを既に送った事が発見されたなら、利用者にメー
ルを再送するかどうかを尋ねます。（これは主に同じパケットを複数回送る傾向の
ある @sc{soup} パケットや、それに似たようなものを扱っているときに役に立ち
ます。）この変数はこの履歴ファイルがどこにあるかを指定します。ディフォルト
では @file{~/News/Sent-Message-IDs} です。Gnus が履歴ファイルを保持する事
を望まないのであれば、この変数を @code{nil} に設定する事ができます。

@item gnus-sent-message-ids-length
@vindex gnus-sent-messages-ids-length
この変数はどれくらい多くの @code{Message-ID} を履歴ファイルに保持するか
を指定します。ディフォルトでは 1000 です。

@end table


@node Posting Server
@section 投稿するサーバー

最新の（もちろん、非常に知的な）記事を送り出すために、あの魔法のような
@kbd{C-c C-c} キーを押した時、それはどこにいくのでしょう？

尋ねてくれてありがとう。あなたを恨みます。

@vindex gnus-post-method

それは非常に複雑になり得ます。普通は、gnus は同じ基本サーバーを使用します。
しかし。あなたの基本サーバーが投稿を許可せず、読むことのみを許可しているの
ならば、おそらくあなたの（非常に知的でとんでもなく興味深い）記事を投稿する
ために、他のサーバーを使いたいと思うでしょう。@code{gnus-post-method} を他
の方法に設定する事ができます。

@lisp
(setq gnus-post-method '(nnspool ""))
@end lisp

さて、この設定をした後でサーバーがあなたの記事を拒否したり、サーバーが落ち
ていたりしたら、どうしたらよいのでしょう？この変数を上書きするために、命令 
@kbd{C-c C-c} に零でない接頭引数を与える事で、投稿に『現在の』サーバーを使
わせる事ができます。

もし、零接頭引数をその命令に与えたなら（すなわち、@kbd{C-u 0 C-c C-c}）、
gnus は投稿にどの方法を使うかをあなたに尋ねます。

@code{gnus-post-method} を選択方法のリストにする事もできます。その場合は、
gnus は常に投稿にどの方法を使うかをあなたに尋ねます。


@node Mail and Post
@section メールと投稿

これはメールを出す事と投稿する事の両方に関連する変数のリストです：

@table @code
@item gnus-mailing-list-groups
@findex gnus-mailing-list-groups
@cindex mailing lists

もしあなたのニューズサーバーが本当にメーリングリストから @sc{nntp} サー
バーへのゲートウェイを提供しているのであれば、それらのグループは問題なく
読めるでしょう。しかし簡単にはそれらに投稿/フォローアップすることはでき
ません。一つの解決法は グループパラメータ (@pxref{Group Parameters}) に 
@code{to-address} を加える事です。簡単にできるのは、
@code{gnus-mailing-list-groups} を、本当にメーリングリストであるようなグ
ループに合致する正規表現に設定することです。その後は、すくなくとも、メー
リングリストへのフォローアップはたいていのときに動作します。これらのグルー
プに投稿する事は (@kbd{a}) それでも苦痛を引き起こすでしょうけど。

@end table

あなたは自分が送るメッセージの綴りを調べたいと思うかも知れません。もしく
は、もし手で綴り調べをしたくないのであれば、自動綴り調べを @code{ispell}
パッケージを使う事によって付け加える事ができます：

@cindex ispell
@findex ispell-message
@lisp
(add-hook 'message-send-hook 'ispell-message)
@end lisp


@node Archived Messages
@section メッセージの保管
@cindex archived messages
@cindex sent messages

Gnus はあなたが送ったメールとニュースを貯めておくためのいくつかの違った方
法を提供します。ディフォルトの方法はメッセージを保存するために@dfn{事実上
の書庫サーバー}(archive virtual server)を使います。これを完全に禁止したい
のであれば、変数 @code{gnus-message-archive-group} は @code{nil} になるべ
きで、これがディフォルトです。

@vindex gnus-message-archive-method
@code{gnus-message-archive-method} は送ったメッセージを蓄積するためにどの
事実上のサーバーを gnus が使うべきかを指定します。ディフォルトは：

@lisp
(nnfolder "archive"
          (nnfolder-directory   "~/Mail/archive")
          (nnfolder-active-file "~/Mail/archive/active")
          (nnfolder-get-new-mail nil)
          (nnfolder-inhibit-expiry t))
@end lisp

しかし、どのメール選択方法でも使う事ができます（@code{nnml},
@code{nnmbox} などなど）。しかし @code{nnfolder} はこのような事をするのに
とても好ましい選択方法です。ディフォルトのディレクトリー選択を好きでないな
らば、次のようにできます：

@lisp
(setq gnus-message-archive-method
      '(nnfolder "archive"
                 (nnfolder-inhibit-expiry t)
                 (nnfolder-active-file "~/News/sent-mail/active")
                 (nnfolder-directory "~/News/sent-mail/")))
@end lisp

@vindex gnus-message-archive-group
@cindex Gcc
Gnus は外へ出て行く全てのメッセージに、一つかそれ以上のそのサーバーのグルー
プへ向かう @code{Gcc} 欄を挿入します。どのグループを使うかは変数 
@code{gnus-message-archive-group} によって決まります。

この変数は次のような事をするために使われます：

@itemize @bullet
@item 文字列
メッセージはそのグループに保存されます。
@item 文字列のリスト
メッセージはそれらの全てのグループに保存されます。
@item 正規表現、関数、様式の連想リスト
キーが『合致』すると、結果が使われます。
@item @code{nil}
メッセージの保存は行われません。これがディフォルトです。
@end itemize

試してみましょう：

@samp{MisK} と呼ばれる一つのグループに保存するならば：
@lisp
(setq gnus-message-archive-group "MisK")
@end lisp

２つのグループ、@samp{MisK} と @samp{safe} に保存するならば：
@lisp
(setq gnus-message-archive-group '("MisK" "safe"))
@end lisp

どのグループにいるかによって違ったグループに保存するなら：
@lisp
(setq gnus-message-archive-group
      '(("^alt" "sent-to-alt")
        ("mail" "sent-to-mail")
        (".*" "sent-to-misc")))
@end lisp

もっと複雑なもの：
@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          "misc-mail")))
@end lisp

全てのニュースメッセージを一つのファイルに保存して、メールメッセージを一月
につき一つのファイルに保存するには：

@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          (concat "mail." (format-time-string
                           "%Y-%m" (current-time))))))
@end lisp

（XEmacs 19.13 には @code{format-time-string} はありませんので、その 
@code{gnus-message-archive-group} のために違った値を使わなければなりません。）

今や、メッセージを送ると、それは適切なグループに保存されます。（もし特定の
メッセージに対して保存をしたくないのであれば、挿入された @code{Gcc} 欄を取
り除いてください。）保管グループは次に gnus を起動したときか、次にグループ
バッファで @kbd{F} を押したときにグループバッファに現れます。他のグループ
と同じようにそのグループに入って、記事を読む事ができます。そのグループが本
当に大きくなって嫌になったら、なにか良いものにその名前を変更する事ができま
す（グループバッファで @kbd{G r} を使う事によって）――
@samp{misc-mail-september-1995} や他のもに。新しいメッセージは古い（今は空
になった）グループに溜められます。

以上が送ったメッセージを保管するディフォルトの方法です。Gnus はディフォ
ルトの方法を好きではない人には違ったやり方を勧めています。そのような場合
は、@code{gnus-message-archive-group} を @code{nil} に設定するべきです。
これは保管をしないようにします。

@table @code
@item gnus-outgoing-message-group
@vindex gnus-outgoing-message-group
全ての外にいくメッセージはこのグループに入れられます。もし全ての外に行く
メールと記事をグループ @samp{nnml:archive} に保管したいのであれば、この
変数をその値に設定する事ができます。この変数はグループ名のリストである事
もできます。

もしそれぞれのメッセージをどのグループに入れるかをもっと制御したいのであれ
ば、この変数を現在のニューズグループ名を調べて、適切なグループ名（もしくは
名前のリスト）を返す関数に設定する事ができます。

この変数は @code{gnus-message-archive-group} の代わりに使う事ができます
が、後者の方が好ましい方法です。
@end table


@c @node Posting Styles
@c @section Posting Styles
@c @cindex posting styles
@c @cindex styles
@c
@c All them variables, they make my head swim.
@c
@c So what if you want a different @code{Organization} and signature based
@c on what groups you post to?  And you post both from your home machine
@c and your work machine, and you want different @code{From} lines, and so
@c on?
@c
@c @vindex gnus-posting-styles
@c One way to do stuff like that is to write clever hooks that change the
@c variables you need to have changed.  That's a bit boring, so somebody
@c came up with the bright idea of letting the user specify these things in
@c a handy alist.  Here's an example of a @code{gnus-posting-styles}
@c variable:
@c
@c @lisp
@c ((".*"
@c   (signature . "Peace and happiness")
@c   (organization . "What me?"))
@c  ("^comp"
@c   (signature . "Death to everybody"))
@c  ("comp.emacs.i-love-it"
@c   (organization . "Emacs is it")))
@c @end lisp
@c
@c As you might surmise from this example, this alist consists of several
@c @dfn{styles}.  Each style will be applicable if the first element
@c ``matches'', in some form or other.  The entire alist will be iterated
@c over, from the beginning towards the end, and each match will be
@c applied, which means that attributes in later styles that match override
@c the same attributes in earlier matching styles.  So
@c @samp{comp.programming.literate} will have the @samp{Death to everybody}
@c signature and the @samp{What me?} @code{Organization} header.
@c
@c The first element in each style is called the @code{match}.  If it's a
@c string, then Gnus will try to regexp match it against the group name.
@c If it's a function symbol, that function will be called with no
@c arguments.  If it's a variable symbol, then the variable will be
@c referenced.  If it's a list, then that list will be @code{eval}ed.  In
@c any case, if this returns a non-@code{nil} value, then the style is said
@c to @dfn{match}.
@c
@c Each style may contain a arbitrary amount of @dfn{attributes}.  Each
@c attribute consists of a @var{(name . value)} pair.  The attribute name
@c can be one of @code{signature}, @code{organization} or @code{from}.  The
@c attribute name can also be a string.  In that case, this will be used as
@c a header name, and the value will be inserted in the headers of the
@c article.
@c
@c The attribute value can be a string (used verbatim), a function (the
@c return value will be used), a variable (its value will be used) or a
@c list (it will be @code{eval}ed and the return value will be used).
@c
@c So here's a new example:
@c
@c @lisp
@c (setq gnus-posting-styles
@c       '((".*"
@c           (signature . "~/.signature")
@c           (from . "user@@foo (user)")
@c           ("X-Home-Page" . (getenv "WWW_HOME"))
@c           (organization . "People's Front Against MWM"))
@c         ("^rec.humor"
@c           (signature . my-funny-signature-randomizer))
@c         ((equal (system-name) "gnarly")
@c           (signature . my-quote-randomizer))
@c         (posting-from-work-p
@c           (signature . "~/.work-signature")
@c           (from . "user@@bar.foo (user)")
@c           (organization . "Important Work, Inc"))
@c         ("^nn.+:"
@c           (signature . "~/.mail-signature"))))
@c @end lisp

@node Drafts
@section 下書き
@cindex drafts

もしメッセージ（メールもしくはニューズ）を書いているときに、突然オーブンに
ステーキが入っている事を思い出したなら（もしくは、あなたがとーってもすごい
菜食主義者で、茎をフードプロセッサーをいれているなら）、書いているメッセー
ジを保存する方法があれば良いと思うでしょう。そうすれば、いつか別の日に編集
を続ける事ができ、それが完成したと思ったときに送る事ができます。

えぇ、心配しないでください。Gnus のメールと投稿命令を使う何らかのメッセー
ジを書き始めたときに、手に入れるバッファは自動的に特別な @dfn{draft} グルー
プに関連付けられます。普通の方法でバッファを保存すれば（たとえば、
@kbd{C-x C-s}）、その記事はそこに保存されます。（自動保存ファイルも下書き
グループ (draft group) に行きます。）

@cindex nndraft
@vindex nndraft-directory
下書きグループは @samp{nndraft:draftx} と呼ばれる特別なグループ です（もし
あなたが全てを知らなければならないのであれば、それは @code{nndraft} グルー
プとして実装されています）。変数 @code{nndraft-directory} はそのファイルを 
@code{nndraft} がどこに保管するべきかを指定します。このグループが特別であ
るというのは、その中の記事を永可視にしたり既読の印を付けたりできないからで
す――グループの全ての記事は永久に未読です。

もしグループが存在しないなら、それは作成され、購読されます。グループバッ
ファからそれを消し去る唯一の方法は、それを未購読にすることです。

@c @findex gnus-dissociate-buffer-from-draft
@c @kindex C-c M-d (Mail)
@c @kindex C-c M-d (Post)
@c @findex gnus-associate-buffer-with-draft
@c @kindex C-c C-d (Mail)
@c @kindex C-c C-d (Post)
@c If you're writing some super-secret message that you later want to
@c encode with PGP before sending, you may wish to turn the auto-saving
@c (and association with the draft group) off.  You never know who might be
@c interested in reading all your extremely valuable and terribly horrible
@c and interesting secrets.  The @kbd{C-c M-d}
@c (@code{gnus-dissociate-buffer-from-draft}) command does that for you.
@c If you change your mind and want to turn the auto-saving back on again,
@c @kbd{C-c C-d} (@code{gnus-associate-buffer-with-draft} does that.
@c
@c @vindex gnus-use-draft
@c To leave association with the draft group off by default, set
@c @code{gnus-use-draft} to @code{nil}.  It is @code{t} by default.

@findex gnus-draft-edit-message
@kindex D e（下書き）
記事の編集を続けたいときは、下書きグループに入って @kbd{D e}
(@code{gnus-draft-edit-message}) を押すだけです。あなたが残した状態のバッ
ファに移動します。

拒否された記事もこの下書きグループに入れられます (@pxref{Rejected
Articles})。

@findex gnus-draft-send-all-messages
@findex gnus-draft-send-message
それ以上編集しないで投稿（もしくはメール）したい拒否されたメッセージがたく
さんあるのであれば、命令 @kbd{D s} を使う事ができます。この命令はプロセス
/接頭引数の習慣を理解します (@pxref{Process/Prefix})。命令 @kbd{D S}
(@code{gnus-draft-send-all-messages}) はバッファの全てのメッセージを送り出
します。

送りたくないメッセージがいくつかあるのであれば、命令 @kbd{D t}
(@code{gnus-draft-toggle-sending}) を使ってメッセージを配送不可の印を付
ける事ができます。これは切り替え命令です。


@node Rejected Articles
@section 拒否された記事
@cindex rejected articles

時々ニューズサーバーは記事を拒否します。おそらくサーバーはあなたの顔を好き
ではないのでしょう。おそらくそれは惨めに感じたからでしょう。おそらく 
@emph{悪魔 (demon) がいるのでしょう}。 おそらく引用文を入れすぎたのでしょ
う。おそらくディスクが一杯だったのでしょう。おそらくサーバーが落ちていたの
でしょう。

これらの状況は、もちろん、完全に gnus の扱える範囲外です。（Gnus は、もち
ろん、あなたの外見を愛しており、いつも機嫌が良く、中を飛び回る天使がいて、
どれくらい引用文が含まれていようと気にせず、一杯になったり、落っこちたり
しません。）ですから、gnus はこれらの記事を後でサーバーの気分がよくなる
まで保存します。

拒否された記事は自動的に特別な下書きグループ (@pxref{Drafts}) に入れられ
ます。サーバーが戻ってきたなら、普通はそのグループに入って全ての記事を送
ります。


