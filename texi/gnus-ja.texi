\input texinfo                  @c -*-texinfo-*-

@setfilename gnus-ja
@settitle Semi-gnus 6.3.2 Manual
@synindex fn cp
@synindex vr cp
@synindex pg cp
@c @direntry
@c * Gnus-ja: (gnus-ja).   The news reader gnus (日本語版).
@c @end direntry
@iftex
@finalout
@end iftex
@setchapternewpage odd

@iftex
@iflatex
\documentclass[twoside,a4paper,openright,11pt]{book}
\usepackage[latin1]{inputenc}
\usepackage{pagestyle}
\usepackage{epsfig}
\usepackage{bembo}
\usepackage{pixidx}

\makeindex
\begin{document}

\newcommand{\gnuschaptername}{}
\newcommand{\gnussectionname}{}

\newcommand{\gnusbackslash}{/}

\newcommand{\gnusxref}[1]{See ``#1'' on page \pageref{#1}}
\newcommand{\gnuspxref}[1]{see ``#1'' on page \pageref{#1}}

\newcommand{\gnuskindex}[1]{\index{#1}}
\newcommand{\gnusindex}[1]{\index{#1}}

\newcommand{\gnustt}[1]{{\fontfamily{pfu}\fontsize{10pt}{10}\selectfont #1}}
\newcommand{\gnuscode}[1]{\gnustt{#1}}
\newcommand{\gnussamp}[1]{``{\fontencoding{OT1}\fontfamily{pfu}\fontsize{10pt}{10}\selectfont #1}''}
\newcommand{\gnuslisp}[1]{\gnustt{#1}}
\newcommand{\gnuskbd}[1]{`\gnustt{#1}'}
\newcommand{\gnusfile}[1]{`\gnustt{#1}'}
\newcommand{\gnusdfn}[1]{\textit{#1}}
\newcommand{\gnusi}[1]{\textit{#1}}
\newcommand{\gnusstrong}[1]{\textbf{#1}}
\newcommand{\gnusemph}[1]{\textit{#1}}
\newcommand{\gnusvar}[1]{{\fontsize{10pt}{10}\selectfont\textsl{\textsf{#1}}}}
\newcommand{\gnussc}[1]{\textsc{#1}}
\newcommand{\gnustitle}[1]{{\huge\textbf{#1}}}
\newcommand{\gnusauthor}[1]{{\large\textbf{#1}}}

\newcommand{\gnusbullet}{{${\bullet}$}}
\newcommand{\gnusdollar}{\$}
\newcommand{\gnusampersand}{\&}
\newcommand{\gnuspercent}{\%}
\newcommand{\gnushash}{\#}
\newcommand{\gnushat}{\symbol{"5E}}
\newcommand{\gnusunderline}{\symbol{"5F}}
\newcommand{\gnusnot}{$\neg$}
\newcommand{\gnustilde}{\symbol{"7E}}
\newcommand{\gnusless}{{$<$}}
\newcommand{\gnusgreater}{{$>$}}

\newcommand{\gnushead}{\raisebox{-1cm}{\epsfig{figure=ps/gnus-head.eps,height=1cm}}}
\newcommand{\gnusinteresting}{
\marginpar[\mbox{}\hfill\gnushead]{\gnushead}
}

\newcommand{\gnuscleardoublepage}{\ifodd\count0\mbox{}\clearpage\thispagestyle{empty}\mbox{}\clearpage\else\clearpage\fi}

\newcommand{\gnuspagechapter}[1]{
{\mbox{}}
}

\newdimen{\gnusdimen}
\gnusdimen 0pt

\newcommand{\gnuschapter}[2]{
\gnuscleardoublepage
\ifdim \gnusdimen = 0pt\setcounter{page}{1}\pagestyle{gnus}\pagenumbering{arabic} \gnusdimen 1pt\fi
\chapter{#2}
\renewcommand{\gnussectionname}{}
\renewcommand{\gnuschaptername}{#2}
\thispagestyle{empty}
\hspace*{-2cm}
\begin{picture}(500,500)(0,0)
\put(480,350){\makebox(0,0)[tr]{#1}}
\put(40,300){\makebox(500,50)[bl]{{\Huge\bf{#2}}}}
\end{picture}
\clearpage
}

\newcommand{\gnusfigure}[3]{
\begin{figure}
\mbox{}\ifodd\count0\hspace*{-0.8cm}\else\hspace*{-3cm}\fi\begin{picture}(440,#2)
#3
\end{picture}
\caption{#1}
\end{figure}
}

\newcommand{\gnusicon}[1]{
\marginpar[\mbox{}\hfill\raisebox{-1.5cm}{\epsfig{figure=tmp/#1-up.ps,height=1.5cm}}]{\raisebox{-1cm}{\epsfig{figure=tmp/#1-up.ps,height=1cm}}}
}

\newcommand{\gnuspicon}[1]{
\margindex{\epsfig{figure=#1,width=2cm}}
}

\newcommand{\gnusxface}[2]{
\margindex{\epsfig{figure=#1,width=1cm}\epsfig{figure=#2,width=1cm}}
}

\newcommand{\gnussmiley}[2]{
\margindex{\makebox[2cm]{\hfill\epsfig{figure=#1,width=0.5cm}\hfill\epsfig{figure=#2,width=0.5cm}\hfill}}
}

\newcommand{\gnusitemx}[1]{\mbox{}\vspace*{-\itemsep}\vspace*{-\parsep}\item#1}

\newcommand{\gnussection}[1]{
\renewcommand{\gnussectionname}{#1}
\section{#1}
}

\newenvironment{codelist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{kbdlist}%
{\begin{list}{}{
\labelwidth=0cm
}
}{\end{list}}

\newenvironment{dfnlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{stronglist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{samplist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{varlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{emphlist}%
{\begin{list}{}{
}
}{\end{list}}

\newlength\gnusheadtextwidth
\setlength{\gnusheadtextwidth}{\headtextwidth}
\addtolength{\gnusheadtextwidth}{1cm}

\newpagestyle{gnuspreamble}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\mbox{}}\textbf{\hfill\roman{page}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\roman{page}\hfill\mbox{}}}
}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnusindex}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\gnuschaptername\hfill\arabic{page}}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnus}%
{
{
\ifodd\count0
{
\makebox[12cm]{\hspace*{3.1cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{chapter}.\arabic{section}} \textbf{\gnussectionname\hfill\arabic{page}}}}}
}
\else
{
\makebox[12cm]{\hspace*{-2.95cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo.eps,height=1cm}}
\hfill \mbox{}
\fi
}

\pagenumbering{roman}
\pagestyle{gnuspreamble}

@end iflatex
@end iftex

@iftex
@iflatex
\begin{titlepage}
{

%\addtolength{\oddsidemargin}{-5cm}
%\addtolength{\evensidemargin}{-5cm}
\parindent=0cm
\addtolength{\textheight}{2cm}

\gnustitle{\gnustitlename}\\
\rule{15cm}{1mm}\\
\vfill
\hspace*{0cm}\epsfig{figure=ps/gnus-big-logo.eps,height=15cm}
\vfill
\rule{15cm}{1mm}\\
\gnusauthor{by Lars Magne Ingebrigtsen}
\newpage
}

\mbox{}
\vfill

\thispagestyle{empty}

Copyright \copyright{} 1995,96,97 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果をこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

\newpage
\end{titlepage}
@end iflatex
@end iftex

@ifinfo

This file documents gnus, the GNU Emacs newsreader.

このファイルは GNU Emacs のニュースリーダである gnus に関する説明書です。

Copyright (C) 1995,96 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

@ignore
Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

この段落が取り除かれているのを除き、これと同じ複製に関する許可文が表示され
ている限り、このファイルを Tex にかけて、その結果を印刷することを許可する。

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果もこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

@end ifinfo

@tex

@titlepage
@title Semi-gnus 6.3.2 Manual

@author by Lars Magne Ingebrigtsen
@author by members of Semi-gnus mailing-list
@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1995,96,97 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

著作権表示とこの許可文がすべての複製に存在する限り、この説明書のまったく
同一の複製を作り、配布することを許可する。

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

同一複製の条件の下で、それによって得られた結果をこの許可文の表示と同一の
条件のもとで配布する限り、この説明書の修正版の複製をし、配布することを許
可する。

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

上記の修正版に関する条件の下で、この説明書の翻訳の複製を作り、配布するこ
とを許可する。

@end titlepage
@page

@end tex


@node Top
@top The gnus Newsreader

@ifinfo

Gnus を使うことによって Emacs でニュース (news) を（それにメール (mail) 
も）読むことができます。ニュースは @sc{nntp}、ローカルスプール、mbox ファ
イルなどのあらゆる極悪な手段を駆使して手に入れることができます。運試しを
してみようと思うならば、全てを同時に用いることもできます。

Semi-gnus は SEMI API に基づく MIME 機能を提供します。そういう訳で、
Semi-gnus は、大きな絵が入っていたりさまざまな形式を用いたりしているちょっ
と変わった記事を読む権利を擁護します。Semi-gnus は MULE API に基づく国際
化・地域化、および、多字化機能を提供します。よって、Semi-gnus はさまざま
な言語圏を差別しません。ああ、クリンゴンの方は Unicode Next Generationを
お待ちください。

この説明書は Semi-gnus 6.3.2 に対応します。

@end ifinfo

@iftex

@iflatex
\tableofcontents
\gnuscleardoublepage
@end iflatex

Gnus は GNU Emacs の先進的で、説明のある、カスタマイズ可能で、拡張可能な、
リアルタイムでないニュースリーダです。

おおっと。不思議なことに以前にも似たようなことを聞いたことがあるような気
がします。真似をしたと非難されないうちに説明を始めましょう：

Gnus はメッセージを読むことに関する実験場です。Gnus はすべてをニュースグ
ループのように表示します。Gnus でメールを読み、ディレクトリーをブラウズ
し、@code{ftp} をすることができます。ああ、それに、ニュースを読むことさ
えできます！

Emacs が文章を編集する人に力を与えるように、gnus はニュースを読む人に力
を与えようとしています。Gnus は利用者が実行可能なことに制限を設けません。
利用者が自分で望む動作をするように gnus を拡張することを奨励しています。
プログラムが人を操作するべきではありません。人がプログラムを使う（もしく
は濫用する）ことによって、やりたいことをできるようになっているべきです。

@end iftex


@menu
* Starting Up::           ニュースを見つけるのには苦労が伴うかも知れない
* The Group Buffer::      グループを選択し、講読し、削除する
* The Summary Buffer::    記事を読み、保存し、投稿する
* The Article Buffer::    記事を表示し、扱う
* Composing Messages::    メールとニュースを送るための情報
* Select Methods::        Gnus は全てのメッセージをいろいろな選択方法で読む
* Scoring::               記事に値をつける
* Various::               一般的な設定
* The End::               さらば、そしてさようなら
* Appendices::            用語、Emacs 入門、FAQ、歴史、内部構造
* Index::                 変数、関数、概念の索引
* Key Index::             キー索引
@end menu

@node Starting Up
@chapter Starting gnus
@cindex starting up

@kindex M-x gnus
@findex gnus
システム管理者が適切な設定をしていたならば、gnus を起動してニュースを読
むのは非常に簡単です。そう、Emacs で @kbd{M-x gnus} と打つだけです。

@findex gnus-other-frame
@kindex M-x gnus-other-frame
別のフレームで gnus を起動したいときは、コマンド @kbd{M-x
gnus-other-frame} を使うことができます。

開始時に何かがうまくいかないときは @file{~/.gnus} ファイルの中で変数をい
くつかいじくりまわさなければならないでしょう。このファイルは 
@file{~/.emacs} と似ていますが、これは gnus が起動するときに読み込まれま
す。

この説明書でよくわからない用語がでてきたときは、用語の項 
(@pxref{Terminology}) を参照してください。

@menu
* Finding the News::    ニュースを取得する方法を選ぶ
* The First Time::      最初に起動したときに gnus は何をするか
* The Server is Down::  どうすればそのようなときにメールを手に入れることができるか
* Slave Gnusae::        同時に一つ以上の gnus を作動させることができる
* Fetching a Group::    グループを読むためだけに gnus を起動する
* New Groups::          Gnus が新しいグループに対して何をするか
* Startup Files::       やっかいなスタートアップファイル--@file{.newsrc}
* Auto Save::           クラッシュからの回復
* The Active File::     遅い回線からのファイルの取得には時間がかかる
* Changing Servers::    あるサーバから別のサーバへ移りたいかもしれない
* Startup Variables::   変更したいと思うかもしれない変数
@end menu


@node Finding the News
@section Finding the News
@cindex finding news

@vindex gnus-select-method
@c @head
変数 @code{gnus-select-method} は gnus がどこでニュースを探すべきかを示
しています。この変数ははじめの要素が@dfn{どのようにして}、２番目の要素が
@dfn{どこで}を表すリストである必要があります。この方法はあなたの基本方法 
(native method) になります。この方法で取ってこないグループは全て外の
(foreign) グループです。

たとえば、@sc{nntp} サーバ @samp{news.somewhere.edu} から毎日一定の量の
ニュース（薬のように）を摂取したいのであれば、

@lisp
(setq gnus-select-method '(nntp "news.somewhere.edu"))
@end lisp

のようにすることができます。

ローカル・スプールのディレクトリを読み込みたい場合は、

@lisp
(setq gnus-select-method '(nnspool ""))
@end lisp

のようにできます。

ローカルのスプールを使えるのであれば、かなりの確率でその方がずっと速いで
しょうし、それを使うべきでしょう。

@vindex gnus-nntpserver-file
@cindex NNTPSERVER
@cindex @sc{nntp} server
もしこの変数が設定されていなければ、gnus は @code{NNTPSERVER} 環境変数を
読みにいきます。もしその変数が設定されていなければ、gnus は
@code{gnus-nntpserver-file}（設定されていない場合は 
@file{/etc/nntpserver}）がこの件に関して何かを言っていないかを調べます。
もしそれも失敗したなら、gnusは Emacs が動作しているサーバーを @sc{nntp} 
サーバーとして使おうとします。随分な当て推量ですけどね。

@vindex gnus-nntp-server
@code{gnus-nntp-server} が設定されていると、この変数は
@code{gnus-select-method} を上書きします。ですから、
@code{gnus-nntp-server} は @code{nil} に設定するべきで、標準設定でもその
ようになっています。

@vindex gnus-secondary-servers
Gnus に @sc{nntp} サーバーの名前の入力を対話的に指定することもできます。
@code{gnus} に数値でない接頭引数を渡すと（例：@kbd{C-u M-x gnus}）、gnus 
は @code{gnus-secondary-servers} リスト（もし存在するならば）からサーバー
を選ぶことができるようにします。ただ単に接続したいと思ったサーバーの名前
を打つこともできます。

@findex gnus-group-browse-foreign-server
@kindex B (Group)
しかし、普段日常的には一つの @sc{nntp} サーバを使い、違ったサーバーには興
味のあるグループが少ししかない場合、グループバッファで @kbd{B} 命令を使う
ことの方が良いでしょう。それは、選択可能なグループを表示し、その中からどれ
でも好きなものを購読することができます。これは、@file{.newsrc} の保持をずっ
とやりやすくします。@xref{Foreign Groups}.

@vindex gnus-secondary-select-methods
@c @head
外のグループに対する少し違ったやり方は、変数
@code{gnus-secondary-select-methods} を設定することです。この変数に表さ
れている選択方法は、多くの点で @code{gnus-select-method} サーバーとの選
択方法と同じように扱われます。起動中にアクティブファイルを探しにいきますし
（もし要求されていれば）、これらのサーバー上にできた新しいニュースグルー
プは元々のグループと同じように購読（もしくは不購読）されます。

たとえば、メールを読むために @code{nnmbox} バックエンド (backend) を使い
たいときは、普通、この変数を、

@lisp
(setq gnus-secondary-select-methods '((nnmbox "")))
@end lisp

と設定します。

@node The First Time
@section The First Time
@cindex first time usage

起動用ファイルが存在しないときは、gnus はディフォルトでどのグループが購
読されているべきかを決定しようとします。

@vindex gnus-default-subscribed-newsgroups
変数 @code{gnus-default-sebscribed-newsgroups} が設定されていると、gnus
はそのリストの中のグループを購読し、残りを削除します。システム管理者はこ
の変数を何か役に立つものに設定しておくべきです。

そうでないときは、gnus は少しの任意のグループを購読します（例：
@samp{*.newusers}）。（@dfn{任意}はここでは、@dfn{Lars さんが読むべきで
あると考えるもの}というように定義されています）

また、たいていの共通の問題の解決の手助けになるよう、gnus に関する文書の
グループも購読することになるでしょう。

@code{gnus-default-subscribed-newsgroups} が @code{t} のときは、gnus は新
しいグループを扱うのに普通の関数を使い、特別なことは何もしません。


@node The Server is Down
@section The Server is Down
@cindex server errors

標準 (default) のサーバーが落ちているときは、当然 gnus の起動にいくつか
の問題が発生します。しかし、ニュースグループの他にいくつかメールのグルー
プがあれば、それにもかかわらず gnus を起動したいと思うかもしれません。

Gnus は、信頼できるプログラムの一つとして、サーバーと接続できないときは
基本選択方法なしで続けるかどうかを尋ねます。これは実際にはサーバーが存在
しないとき（例えば、アドレスを間違えた場合）やサーバーが何らかの理由で一
時的に調子がおかしくなっているときに起こります。もしそのまま続行すること
にして、外のグループが一つも無い場合、実はグループバッファではほとんど何
もできないということに気がつくでしょう。でも、ねぇ、それはあなたの問題で
す。ハハハッ。

@findex gnus-no-server
@kindex M-x gnus-no-server
@c @head
サーバーが完全に落ちているのを知っているか、サーバーでわずらうことなくメー
ルだけを読みたいときは、gnus を起動するのに、@code{gnus-no-server} 命令を
使うことができます。急いでいるときにもぴったりでしょう。この命令は本来のサー
バーには接続しません――その代わりに、レベル１と２にあるすべてのグループを
活動状態にします（基本グループでないグループはその２つのレベルにしておくの
が望ましいでしょう）。


@node Slave Gnusae
@section Slave Gnusae
@cindex slave

あなたは２つ以上の Emacs と、２つ以上の gnus を同時に動かしたいと思うか
もしれません。違った @file{.newsrc} ファイルを使っているなら（例えば、２
つの違ったサーバーから読み込むために、２つの違った gnus を動作させている
場合）、まったく問題はありません。それを行えば良いだけです。

問題は、同じ @code{.newsrc} ファイルを使う２つの gnus を動かそうとしたと
きに起こります。

この問題に対処するために、gnus タワーのシンクタンクにいる我々は新しい概
念にたどりつきました。@dfn{マスター} と @dfn{スレーブ} です。（我々はこ
の概念に特許を申請しました。そして、その言葉の著作権を得ました。お互いに
関連してこれらの言葉を使いたいなら、１回使う毎に、私に $1 を送らなければ
なりません。もちろん、@dfn{コンピューターアプリケーションのマスター／ス
レーブ関係}の使用料はもっと高くなります。）

とにかく、@kbd{M-x gnus}（もしくは、普段やっている方法）で gnus を普通に
起動します。その後のスレーブ gnus はそれぞれ @kbd{M-x gnus-slave} で起動
します。スレーブは普通の @file{.newsrc} は保存しませんが、代わりに 
@dfn{スレーブファイル} にスレーブの起動中にどのようなグループが読まれた
かという情報だけを保存します。マスター gnus が起動するとき、それはそれら
のスレーブファイルを読み込み（そして消し）、それらからすべての情報を取り
込みます。（スレーブファイルは、最終的な変更が優先されるようにそれらが作
られた一連の動作の中で読まれます。） 

もちろん、スレーブファイルからの情報は普通の（例えば、マスターの）ファイ
ルよりも優先されます。


@node Fetching a Group
@section Fetching a Group
@cindex fetching a group

@findex gnus-fetch-group
時々、“このグループを読みたいのであって、gnus が起動しているかどうかを
気にしたくない。”ということができれば便利なことがあります。これは、利用
者よりもプログラムのコードを書く人に便利な機能ですが、どちらにしろ、コマ
ンド @code{gnus-fetch-group} はこの機能を提供します。そのコマンドは、グ
ループの名前を引数としてとります。


@node New Groups
@section New Groups
@cindex new groups
@cindex subscription

@vindex gnus-check-new-newsgroups
新しいニュースグループを全く見ないで満足であるならば、
@code{gnus-check-new-newsgroups} を @code{nil} に設定することができます。
これを設定した場合、起動にかかる時間が短くなります。この変数が nil に設
定されていても、グループバッファで @kbd{U} を押せばいつでも新しいグルー
プを購読することができます (@pxref{Group Maintenance})。設定されていない
場合 (default) ではこの変数は @code{ask-server} です。この変数が 
@code{always} に設定されていると、命令 @kbd{g} を実行したときでも gnus 
はバックエンドに新しいグループを探すことを求めます (@pxref{Scanning New
Messages})。

@menu
* Checking New Groups::      どのグループが新しいかを決定する。
* Subscription Methods::     新しいグループに対して gnus は何をすべきか
* Filtering New Groups::     Gnus に特定の新しいグループを無視させる
@end menu


@node Checking New Groups
@subsection Checking New Groups

Gnus は、普通はグループが新しいかどうかを、購読しているグループと削除され
ているグループのリストと現状ファイル (active file) を比較することにより決
定しています。この方法は特に速いというわけではありません。
@code{gnus-check-new-newsgroups} が @code{ask-server} であると、gnus はサー
バーに、最後に接続してから新しいグループができているかどうかを尋ねます。こ
の方法は速いし、安上がりです。これにより、削除されたグループのリストを保持
しておくことからから完全に開放されます。ですから、
@code{gnus-save-killed-list} を @code{nil} にすることができるでしょう。そ
うすれば、起動、終了の両方、そして全体にわたって時間を節約できます。ディス
ク消費量も少なくなります。それなら、どうしてこれが標準 (default) ではない
のでしょう？残念ながら、すべてのサーバーがこの命令を理解するわけではないの
です。

私は今あなたが何を考えているかを当てられます。どうすればサーバーが
@code{ask-server} を理解するかがわかるのでしょう？え、違うのですか？あぁ、
良かった。というのは、確実な答は存在しないのです。私に言えることは、この変
数を @code{ask-server} に設定して、数日間新しいグループが現れるかどうかを
調べてください、ということだけです。もしいくつかのグループが現れたなら、そ
れで動作しています。一つも現れなければ、それは動作しません。私は、gnus に
サーバーが @code{ask-server} を理解するかどうかを推量させる関数を書くこと
もできますが、それは単に推量しているにすぎません。ですから、その関数を書く
ことはないでしょう。他の方法としては、サーバーに @code{telnet} をして、
@code{HELP} と打ち、サーバーが理解するコマンドの中に @samp{NEWGROUPS} があ
るかどうかを調べることもできます。もしあれば、おそらく動作するでしょう（し
かし、適切に機能を提供することなく @samp{NEGROUPS} をリストに含めるサーバー
もあります）。

この変数は、選択方法のリストであることもできます。そのときは、gnus は命
令 @code{ask-server} をそれぞれの選択方法に対して実行し、普通の方法で購
読（もしくは、不購読）します。これの副作用は、起動にかなり時間がかかるの
で、待っている間に瞑想できることです。永久の幸福を達成するために、マント
ラ ``dingnusdingnusdingnus'' を使ってください。


@node Subscription Methods
@subsection Subscription Methods

@vindex gnus-subscribe-newsgroup-method
新しいグループに遭遇したときに gnus が何をするかは、変数
@code{gnus-subscribe-nesgroup-method} によって決定されます。

この変数は関数を含んでいる必要があります。この関数は新しいグループの名前
を唯一の引数として呼ばれます。

いくつかの手軽なプレハブ関数は、以下のようになっています。

@table @code

@item gnus-subscribe-zombies
@vindex gnus-subscribe-zombies
すべての新しいグループをゾンビ (zombie) にします。これが標準 (default) に
なっています。後でゾンビを (@kbd{A z} によって) 概観したり、（@kbd{S z} に
よって）適切に全てを削除したり、（@kbd{u} によって）購読したりできます。

@item gnus-subscribe-randomly
@vindex gnus-subscribe-randomly
任意の順番ですべての新しいグループを購読します。実際には、すべての新しい
グループはグループバッファの『一番上』に加えられます。

@item gnus-subscribe-alphabetically
@vindex gnus-subscribe-alphabetically
すべての新しいグループをアルファベット順に購読します。

@item gnus-subscribe-hierarchically
@vindex gnus-subscribe-hierarchically
すべての新しいグループを階層的に購読します。この関数と
@code{gnus-subscribe-alphabetically} の違いは少ししかありません。
@code{gnus-subscribe-alphabetically} は新しいグループを厳密にアルファベッ
ト順にならべますが、この関数はグループをその階層の中に入れます。ですから、
@samp{rec} の階層を @samp{comp} の階層の前に持ってきたい場合、この関数は
その配置をぐちゃぐちゃにはしません。もしくは、そのようなものです。

@item gnus-subscribe-interactively
@vindex gnus-subscribe-interactively
新しいグループを対話的に購読します。これは gnus が @strong{全て} のグルー
プに対して尋ねることを意味しています。購読するグループは階層的に購読され
ます。

@item gnus-subscribe-killed
@vindex gnus-subscribe-killed
すべての新しいグループを削除します。

@end table

@vindex gnus-subscribe-hierarchical-interactive
上の変数と良く関係した変数は、
@code{gnus-subscribe-hierarchical-interactive} です。この変数が
@code{nil} でないと、gnus は階層的な方法で新しいグループを購読するかどうか
を尋ねます。gnus はそれぞれの階層で、それを下に降りるかどうかを尋ねます。

良くある間違いは、数段落前の変数 (@code{gnus-subscribe-newsgroup-method}
) を @code{gnus-subscribe-herarchical-interactive} に設定することです。
これは誤りです。これは動作しません。これはおめでたい人のすることです。で
すから、絶対にしないでください。


@node Filtering New Groups
@subsection Filtering New Groups

どの新しいグループが購読（もしくは、無視）されるべきかを管理する快適で手
軽な方法は、ファイル @file{.newsrc} の先頭に @dfn{options} 行を挿入する
ことです。次は、例です。

@example
options -n !alt.all !rec.all sci.all
@end example

@vindex gnus-subscribe-options-newsgroup-method
この行は、明らかにまじめで理知的で科学的な人間（もしくは単なる古く退屈な
人間）が書いたものです。なぜなら、これは @samp{alt} と @samp{rec} で始ま
る名前を持つグループは全て無視され、@samp{sci} で始まる名前を持つグルー
プは全て購読する、ということを表しているからです。Gnus はこれらのグルー
プを購読するのに、普通の購読方法を用いません。代わりに、
@code{gnus-subscribe-options-newsgroup-method} が用いられます。この変数
は標準 (default) では @code{gnus-subscribe-alphabetically} です。

@vindex gnus-options-not-subscribe
@vindex gnus-options-subscribe
ファイル @file{.newrc} をいじりたくない場合は、
@code{gnus-options-subscribe} と @code{gnus-options-not-subscribe} の２
つの変数だけを設定することもできます。この２つの変数はファイル 
@file{.newrc} の @samp{optinos -n} 行と全く同じことをします。どちらの変
数も正規表現で、新しいグループは前者に合致すれば無条件に購読され、後者に
合致すると無視されます。

@vindex gnus-auto-subscribed-groups
さらにここでおせっかいをする変数は、@code{gnus-auto-subscribed-groups} 
です。それは @code{gnus-options-subscribe} と全く同じように動作しますの
で、本当は余分なものです。しかし、私はこの二つがあった方が良いと思いまし
た。もう一方の変数はユーザがいじくるのに使われるのに対して、この変数はい
くつかの基本的な規則を設定するためのものです。ディフォルトではこの変数は
メールバックエンド (@code{nnml} 、@code{nnbabyl} 、@code{nnfolder} 、
@code{nnmbox} と@code{nnmh}) からできる全ての新しいグループを購読するよ
うになっています。それが嫌であれば、この変数を @code{nil} に設定してくだ
さい。

この正規表現に合致する新しいグループは 
@code{gnus-subscribe-options-newsgroup-method} を使って購読されます。


@node Changing Servers
@section Changing Servers
@cindex changing servers

ときどき、ある @sc{nntp} サーバーから別のサーバーへ移動しなければならな
いことがあります。このようなことはめったにおきませんが、おそらくあなたが
仕事を変えたり、使っているサーバーがとても不安定で、別のものに乗り換えた
いというときに必要になるでしょう。

サーバーを変更するのはとても簡単ですよね？
@code{gnus-select-method} を新しいサーバーを指し示すように変更すればいい
だけですね？

@emph{違います！}

記事の番号は違った @sc{nntp} サーバーでも (どうにかして) 同じにしてある、
ということはありません。そして、 guns がどの記事を読んだかを記録する唯一
の方法は、記事番号を記録することです。ですから、
@code{gnus-select-method} を変更したときは、ファイル @file{.newsrc} は意
味がなくなります。

Gnusはファイル @file{.newsrc} をあるサーバー用から別のサーバー用に変換す
る関数を2、3用意しています。それらには一つ共通点があります---実行にながーー
い時間がかかることです。おそらく、どうしても必要になったとき以外にこの関
数を使おうとは思わないでしょう。

@kindex M-x gnus-change-server
@findex gnus-change-server
もし両方のサーバーに接続できるなら、gnusはあなたが読んだ記事全てに対して
ヘッダー (headers) を要求して、@code{Message-ID} を比較し、読んだ記事と
記事の印を新しく記録します。コマンド @kbd{M-x gnus-change-server} はこれ
をすべての基本グループに対して行います。そのコマンドは移動先の方法の入力
を促します。

@kindex M-x gnus-group-move-group-to-server
@findex gnus-group-move-group-to-server
個々のグループを命令 @kbd{M-x gnus-group-move-group-to-server} で移
動することもできます。これはあるサーバーから別のサーバーへ一つの (外の) 
グループを移動したいときに役に立ちます。

@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
古いサーバーと新しいサーバーの両方に接続することができないとき、印と読ん
だ範囲はすべて意味が無くなります。そのようなときは、コマンド @kbd{M-x
gnus-group-clear-data-on-native-groups} を使って、基本グループに関するデー
タをすべて消去することができます。このコマンドは注意して使ってください。 


@node Startup Files
@section Startup Files
@cindex startup files
@cindex .newsrc
@cindex .newsrc.el
@cindex .newsrc.eld

今や、あなたはファイル @file{.newrc} についてすべて知っています。すべて
の購読情報は伝統的にこのファイルに蓄積されます。

@sc{GNUS} では物事が少々複雑になっています。ファイル @file{.newsrc} を最
新のものにするだけではなく、ファイル @file{.newsrc} には合わない情報を保
存しておくために @file{.newsrc.el} と呼ばれるファイルを使います。 (実際
は、ファイル @file{.newsrc} の全ての情報を複製して保持しています。)
@sc{gnus}はこれらの中で一番最後に保存されたものを使います。これをするこ
とにより、@sc{GNUS} と他のニュースリーダーを切り替えて使うことができます。

これはちょっとばかな方法なので、gnus はもっと良い方法を編み出しました。
@file{.newsrc} と @file{.newsrc.el} ファイルに加えて、 Gnus は
@file{.newsrc.eld} と呼ばれるファイルも持っています。Gnus はこれらの中で
一番新しいファイルを読みますが、ファイル @file{.newsrc.el} に書き込むこ
とはありません。ファイル @file{.newsrc.eld} は絶対に消すべきではありませ
ん。---それはファイル @file{.newsrc} にはないたくさんの情報を保持してい
ます。 

@vindex gnus-save-newsrc-file
@code{gnus-save-newsrc-file} を @code{nil} にすることによってファイル
@file{.newsrc} に書き込むのを止めることができます。そうすれば、そのファ
イルを削除することができ、ディスク容量を節約することができ、gnus の終了
が速くなります。しかし、そうすると他のニュースリーダーを使えなくなります。
でも、ちょっと、誰かそうしたい人がいるでしょうか。 

@vindex gnus-save-killed-list
@code{gnus-save-killed-list} (ディフォルト では @code{t}) が @code{nil} 
であると、gnus は削除されたグループを起動ファイルに保存しません。これは、
(起動時と終了時の) 時間と、(ディスクの) 容量を節約します。こうすると、
gnusがどのグループが新しいかの記録を持っていないことになりますので、新し
いグループの自動購読方法は意味が無くなります。この変数を @code{nil} にし
たときは、@code{gnus-check-new-newsgroups} を常に @code{nil} か 
@code{ask-server} にしておくべきでしょう (@pxref{New Groups})。この変数
は正規表現であることもできます。そのような場合は、ファイルを保存する直前
にその正規表現に合致しないすべてのグループを消去します。これは、すべての
サーバーが @code{ask-server} を理解するわけではない、といったような、特
定のあいまいな状況のときに役に立つでしょう。 

@vindex gnus-startup-file
変数 @code{gnus-startup-file} は起動ファイルがどこにあるかを指定します。
ディフォルトの値は @file{~/.newsrc} で、それがどのようなものであれ、
末尾に @samp{.eld} をつけたものが gnus (El Dingo) の起動ファイルになりま
す。 

@vindex gnus-save-newsrc-hook
@vindex gnus-save-quick-newsrc-hook
@vindex gnus-save-standard-newsrc-hook
@code{gnus-save-newsrc-hook} は newsrc ファイルの中のどれかを保存する前に実
行されるのに対し、@code{gnus-save-quick-newsrc-hook} はファイル
@file{.newsrc.eld} を保存する前に実行され、
@code{gnus-save-standard-newsrc-hook} はファイル @file{.newsrc.eld} を保
存する前に実行されます。後の二つは普通は版管理を入れたり切ったりするのに
使われます。ディフォルトでは、起動ファイルを保存するときに版管理に入りま
す。バックアップファイルの作成を止めたいときは、次のようにしてください。 

@lisp
(defun turn-off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'gnus-save-quick-newsrc-hook 'turn-off-backup)
(add-hook 'gnus-save-standard-newsrc-hook 'turn-off-backup)
@end lisp

@vindex gnus-init-file
Gnus が起動すると、@code{gnus-site-init-file} (ディフォルトでは
@file{.../site-lisp/gnus}) と @code{gnus-init-file} (ディフォルトでは
@file{~/.gnus}) のファイルを読み込みます。これらは普通の Emacs Lisp ファ
イルで、@file{~/.emacs} や @file{site-init} ファイルを gnus 関係のもので
乱雑にしないようにするために使うことができます。Gnus はこれらと同じ名前
のファイルを調べますが、接尾語 @file{.elc} と @file{.el} がついているも
のも調べます。言い換えれば、@code{gnus-init-file} を @file{~/.gnus} に設
定すると、gnus は (この順番に) @file{~/.gnus.elc} 、@file{~/.gnus.el} を
探し、最後に @file{~/.gnus} を探します。



@node Auto Save
@section Auto Save
@cindex dribble file
@cindex auto-save

何か gnus のデータを変更すること (記事を読む、印を付ける、グループを削除
または購読する) をしたとき、変更は特別な@dfn{ドリブルバッファ (dribble
buffer)} に書き込まれます。このバッファはEmacs が普通するように自動保存
されます。ファイル @file{.newsrc} を保存する前に Emacsが落ちたときは、す
べての変更をこのファイルから回復することができるでしょう。

起動時に gnus がこのファイルの存在を発見すると、gnus はそれを読み込むか
どうかを利用者に尋ねます。本当の起動ファイルが保存されれば、自動保存ファ
イルは削除されます。 

@vindex gnus-use-dribble-file
@code{gnus-use-dribble-file} が @code{nil} であると、gnus はドリブルバッ
ファをつくったり、維持したりしません。ディフォルトは @code{t} です。

@vindex gnus-dribble-directory
Gnus はドリブルファイルを @code{gnus-dribble-directory} に置きます。ディ
フォルトではそのようになっていますが、この変数が @code{nil} であると、
gnus はファイル@file{.newsrc} の置かれているディレクトリ (これは普通は利
用者のホームディレクトリです) に入っていってドリブルファイルを作ります。
ドリブルファイルは @code{.newsrc} と同じ許可属性を与えられます。 


@node The Active File
@section The Active File
@cindex active file
@cindex ignored groups

Gnus は起動したときや、実際に新しい記事が到着しているかを決定しようとす
るときに、現状ファイルを読み込みます。これはとても大きなファイルで、その
サーバーの活動中のグループと記事のすべてのリストが入っています。

@vindex gnus-ignored-newsgroups
現状ファイルを検査する前に、gnus は正規表現 
@code{gnus-ignored-newsgroups} に合うすべての行を削除します。これは主に
偽の名前を持つグループを排除するために使われてきましたが、興味の無いグルー
プの階層を無視するために使うこともできます。しかし、これはお勧めできませ
ん。本当のことを言うと、全く賛成できません。代わりに、そのような用途に用
いられる変数の概略を知るために、@pxref{New Groups} を参照してください。

@c This variable is
@c @code{nil} by default, and will slow down active file handling somewhat
@c if you set it to anything else.

@vindex gnus-read-active-file
@c @head
現状ファイルは比較的大きくなる傾向があるので、遅い回線を使っているときは、
現状ファイルを読み込まないように @code{gnus-read-active-file} を 
@code{nil} に設定することができます。この変数はディフォルトでは
@code{some} です。

そのような時は、gnus は実際に購読されているグループに関する情報だけを得
てやっていこうとします。

気を付けてほしいのは、あなたが山ほどのたくさんのグループを購読していると
きにこの変数を @code{nil} 設定すると、gnus は速くなるどころか、遅くなっ
てしまうということです。現状では、ニューズを 2400bps 以上のモデムを通し
て読んでいるのでない限り、gnus の速度はかなり遅くなるでしょう。

この変数は @code{some} という値も取ることができます。その時は、gnus は現
状の情報を購読されているグループのものだけを得ようとします。いくつかのサー
バー (命令@code{LIST ACTIVE group} を使うことのできる、最新鋭の INN サー
バー) では、非常に早くなるでしょうが、他のサーバーでは速くはありません。
どのようにせよ、遅い回線では @code{some} は @code{nil} よりも速く、それ
はもちろん@code{t} よりも速くなります。

もしこの変数が @code{nil} であると、gnus は完全にがんじがらめの方法でグ
ループの情報を得ようとします。そして、これはあまり速くありません。もしそ
れが @code{some} で @sc{nntp} サーバーを使っているときは、gnus はできる
だけ速く命令を出し、一撃ですべての返答を読み込みます。この方が普通はより
良い結果をもたらしますが、サーバーが命令 @code{LIST ACTIVE group} を理解
しないなら、サーバーにとってはあまり良いとは言えません。

@code{some} か @code{nil} を使うのであれば、どちらにしろ速度を上げるため
にすべての興味の無いグループを必ず削除するべきでしょう。

この変数は2番目の (secondary) 方法の現状ファイル取得にも影響することに気
を付けてください。


@node Startup Variables
@section Startup Variables

@table @code

@item gnus-load-hook
@vindex gnus-load-hook
Gnus が読み込まれているときに実行されるフックです。何度 gnus を起動して
も、Emacsが起動してから終了するまでに普通はこのフックは一回しか実行され
ないことに注意してください。

@item gnus-before-startup-hook
@vindex gnus-before-startup-hook
Gnus の起動に成功した後に実行されるフックです。

@item gnus-startup-hook
@vindex gnus-startup-hook
Gnus が起動された後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook
Gnus の起動に成功した後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook

ファイル @file{.newsrc} を読み込んだ後で、グループバッファを作成する前に
実行されるフックです。

@item gnus-check-bogus-newsgroups
@vindex gnus-check-bogus-newsgroups
もし @code{nil} でないと、gnus は起動時に調べてすべての偽グループを削除
します。@dfn{偽グループ (bogus group)} はあなたの @file{.newsrc} ファイ
ルには存在するけれど、ニューズサーバーには実際には存在しない、というグルー
プのことです。偽グループを調べるのにはかなり時間がかかりますので、時間と
資源を節約するために、この機能は使わないほうがいいでしょう。そして、代わ
りにグループバッファで時々偽グループを調べるのが良いでしょう
(@pxref{Group Maintenance} を参照してください)。

@item gnus-inhibit-startup-message
@vindex gnus-inhibit-startup-message
もし @code{nil} でないと、起動時のメッセージは表示されません。そのように
すれば、仕事の代わりにニューズを読んでいるのを上司に気付かれにくくなるで
しょう。この変数は @file{.gnus.el} がロードされる前に使われますので、
@code{.emacs} に設定するべきである点を注意してください。

@item gnus-no-groups-message
@vindex gnus-no-groups-message
グループが一つも存在しないときに gnus が表示するメッセージです。

@item gnus-play-startup-jingle
@vindex gnus-play-startup-jingle
もし @code{nil} でないと、起動時に gnus の短い曲を演奏します。

@item gnus-startup-jingle
@vindex gnus-startup-jingle
上の変数が @code{nil} でないときに演奏される短い曲です。ディフォルトは
@samp{Tuxdemoon.Jingle4.au} です。

@end table


@node The Group Buffer
@chapter グループバッファ
@cindex group buffer

グループバッファ @dfn{group buffer} は有効なグループを全部(ある
いは一部を)一覧表示します。これは Gnus を起動したときに最初に表
示されるバッファで、Gnus が生きている限り決して消されることはあ
りません。


@iftex
@iflatex
\gnusfigure{The Group Buffer}{320}{
\put(75,50){\epsfig{figure=tmp/group.ps,height=9cm}}
\put(120,37){\makebox(0,0)[t]{Buffer name}}
\put(120,38){\vector(1,2){10}}
\put(40,60){\makebox(0,0)[r]{Mode line}}
\put(40,58){\vector(1,0){30}}
\put(200,28){\makebox(0,0)[t]{Native select method}}
\put(200,26){\vector(-1,2){15}}
}
@end iflatex
@end iftex

@menu
* Group Buffer Format::    表示されている情報と変更の方法。
* Group Maneuvering::      グループバッファを移動するコマンド。
* Selecting a Group::      実際にニュースを読む。
* Group Data::             グループの情報を変更する。
* Subscription Commands::  購読、購読中止、消去。
* Group Levels::           レベル? それって何?
* Group Score::            あなたの好きなグループを見つけ出す方法。
* Marking Groups::         グループに印をつけておいて、後で処理できます。
* Foreign Groups::         グループの作成と修正。
* Group Parameters::       グループ毎に違ったパラメータを持たせられます。
* Listing Groups::         Gnus はグループをいろいろな分け方で表示できます。
* Sorting Groups::         グループの順番の配置替え。
* Group Maintenance::      きれいな @file{.newsrc} の保ち方。
* Browse Foreign Server::  サーバをブラウズできます。何が読めるのか見てみよう。
* Exiting Gnus::           ニュース読むのをやめて、仕事をしよう。
* Group Topics::           グループを切り混ぜて、トピックごとに分割する。
* Misc Group Stuff::       他にできること。
@end menu


@node Group Buffer Format
@section グループバッファの形式

@menu
* Group Line Specification::       グループバッファの見え方を決める。
* Group Modeline Specification::   グループバッファのモード行。
* Group Highlighting::             グループバッファにきれいに色をつける。
@end menu


@node Group Line Specification
@subsection グループ行の仕様
@cindex group buffer format

グループバッファのデフォルトでの形式はきれいでつまんないけど、こ
れは君の好きなように、サイコーにダサくすることもできます。

これがグループ行の例です。

@example
     25: news.announce.newusers
 *    0: alt.fan.andrea-dworkin
@end example

とっても簡単でしょ?

@samp{news.announce.newusers} には 25 の未読記事があるのがわかり
ます。@samp{alt.fan.andrea-dworkin} には未読記事はないけれども、
印をつけた記事がいくつかあります(行頭のちっちゃなアスタリスクが
見える?)。

@vindex gnus-group-line-format
この形式は @code{gnus-group-line-format} 変数をいじることで、ど
んな風にでも変えられます。この変数は @code{format} の仕様風に
動作します。つまり(あのクソ)C言語を使う人たちのため、 printf の
仕様とほぼ同じです。@xref{Formatting Variables}

@samp{%M%S%5y: %(%g%)\n} という値で上記の行を生成します。

コロンは、この行の中に必ず無くてはいけません。カーソルは、何かの
操作をした後は常にコロンのところに移動するからです。他には何も必
要ではありません -- グループ名さえもです。表示されている文字は全
てただの画面の飾りであり、Gnus がそれを調べることはありません。
Gnus は必要とする全ての実情報を、テキスト属性を使って憶えていま
す。


(もし君が、すごくヘンな、素晴らしい、表計算風のレイアウトを作っ
たとしたら、みんな、君は会計の仕事が忙しくって、ニュースを読んで
時間を無駄使いしたりなんかしてない、って信じてくれるよ。)

以下が使用できるフォーマット文字のリストです。

@table @samp

@item M
そのグループが印のついた記事だけのときは、アスタリスク文字。

@item S
そのグループが購読されているかどうか。

@item L
購読度のレベル。

@item N
未読記事の数。

@item I
保留記事の数。

@item T
印付き記事の数。

@item R
既読記事の数。

@item t
推定全記事数。(これは実際は @var{max-number} - @var{min-number}
+ 1。)

@item y
未読でも、印付きでも、保留でもない記事の数。

@item i
印付き記事と保留記事の数。

@item g
グループ名のフルネーム。

@item G
グループ名。

@item D
ニューズグループの説明。

@item o
モデレーテッドの場合 @samp{m} 。

@item O
モデレーテッドの場合 @samp{(m)} 。

@item s
選択メソッド。

@item n
どこからの選択か。

@item z
外部選択メソッドが使われている場合、@samp{<%s:%n>} と同じ文字列。

@item P
トピック(@pxref{Group Topics})のレベルに応じた字下げ。

@item c
@vindex gnus-group-uncollapsed-levels
短い(省略した)グループ名。@code{gnus-group-uncollapsed-levels}
変数は、どのレベルまでグループ名を全部残すかを示します。デ
フォルトは 1 です -- この意味は、@samp{gnu.emacs.gnus} のような
グループ名を @samp{g.emacs.gnus} に短縮するということです。

@item m
@vindex gnus-new-mail-mark
@cindex %
そのグループに最近新着メールが届いている場合は @samp{%}
(@code{gnus-new-mail-mark})。

@item d
最後にいつこのグループを読んだかを示す文字列(@pxref{Group
Timestamp})。


@item u
ユーザ定義指定。フォーマット文字列中で、この次の文字はアルファベッ
ト文字でなければいけません。Gnus は
@code{gnus-user-format-function-}@samp{X} 関数を呼び出します。こ
こで @samp{X} は @samp{%u} に続いている文字です。この関数は引数
に、一つのダミーパラメータを渡されます。この関数は、他の各指定文
字の情報と同様に、バッファに挿入される文字列を返さなければなりま
せん。
@end table

@cindex *
全ての「〜の数」の指定で、もしその情報が利用できない場合にはアスタリ
スク(@samp{*}) が埋められます -- 例えば、起動されていない外部グ
ループや、不正なネイティブグループの場合です。


@node Group Modeline Specification
@subsection グループモード行の仕様
@cindex group modeline

@vindex gnus-group-mode-line-format
モード行は @code{gnus-group-mode-line-format} (@pxref{Formatting
Variables}) を設定することで変更できます。こいつは指定文字をあん
まりたくさん知ってません。

@table @samp
@item S
ネイティブのニュースサーバ。
@item M
ネイティブの選択メソッド。
@end table


@node Group Highlighting
@subsection グループのハイライト
@cindex highlighting
@cindex group highlighting

@vindex gnus-group-highlight
グループバッファのハイライトは @code{gnus-group-highlight} 変数
によって制御されています。これは @var{(form . face)} のようなも
のを要素に持つ連想リストです。@var{form} が何か @code{nil} 以外
に評価されるものなら、その行に対して @var{face} が使用されます。

以下がこの変数の値の例です。これは背景が暗い設定ではきれいに見え
るかも知れません。

@lisp
(face-spec-set 'my-group-face-1 '((t (:foreground "Red" :bold t))))
(face-spec-set 'my-group-face-2 '((t (:foreground "SeaGreen" :bold t))))
(face-spec-set 'my-group-face-3 '((t (:foreground "SpringGreen" :bold t))))
(face-spec-set 'my-group-face-4 '((t (:foreground "SteelBlue" :bold t))))
(face-spec-set 'my-group-face-5 '((t (:foreground "SkyBlue" :bold t))))

(setq gnus-group-highlight
      '(((> unread 200) . my-group-face-1)
	((and (< level 3) (zerop unread)) . my-group-face-2)
	((< level 3) . my-group-face-3)
	((zerop unread) . my-group-face-4)
	(t . my-group-face-5)))
@end lisp

@pxref{Faces and Fonts} も参照してください。

この form が評価されるときに動的に束縛されている変数には以下のも
のがあります。


@table @code
@item group
グループ名。
@item unread
そのグループの未読記事の数。
@item method
選択メソッド。
@item mailp
そのグループがメールのグループかどうか。
@item level
そのグループのレベル。
@item score
そのグループのスコア。
@item ticked
そのグループ中の印の付いた記事の数。
@item total
そのグループ中の全記事数。もっと正確に言うと、MAX-NUMBER -
MIN_NUMBER + 1。
@item topic
トピックマイナーモードを使用している時、この変数は挿入されてい
る現在のトピックに束縛されます。 
@end table

この form が @code{eval} されるときは、ポイントは問題のグループ
の行頭にあります。従って、通常の Gnus の関数のほとんどを使ってそ
のグループの情報を取ってくることができます。

@vindex gnus-group-update-hook
@findex gnus-group-highlight-line
@code{gnus-group-update-hook} はグループ行が変更されたときに呼び
出されます。これは @code{gnus-visual} が @code{nil} のときは呼び
出されません。このフックはデフォルトでは
@code{gnus-group-highlight-line} を呼び出します。

@node Group Maneuvering
@section グループ操作
@cindex group movement

全ての移動コマンドは数字プレフィックスを理解するので、期待する通
りの動作をします。たぶんね。

@table @kbd

@item n
@kindex n (Group)
@findex gnus-group-next-unread-group
次の未読記事のあるグループに移動します
(@code{gnus-group-next-unread-group})。

@item p
@itemx DEL
@kindex DEL (Group)
@kindex p (Group)
@findex gnus-group-prev-unread-group
一つ前の未読記事のあるグループに移動します
(@code{gnus-group-prev-unread-group})。

@item N
@kindex N (Group)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item P
@kindex P (Group)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item M-p
@kindex M-p (Group)
@findex gnus-group-next-unread-group-same-level
次の同じレベル(もしくはそれより小さいレベル)の未読グループに移動します
(@code{gnus-group-next-unread-group-same-level})。

@item M-n
@kindex M-n (Group)
@findex gnus-group-prev-unread-group-same-level
一つ前の同じレベル(もしくはそれより小さいレベル)の未読グループに移動します
(@code{gnus-group-prev-unread-group-same-level})。
@end table

グループにジャンプする 3 つのコマンドです。

@table @kbd

@item j
@kindex j (Group)
@findex gnus-group-jump-to-group
グループにジャンプします(それが見えるようになっていなかったら見
えるようにします) (@code{gnus-group-jump-to-group})。kill されて
いるグループも、生きてるグループと同様にジャンプできます。

@item ,
@kindex , (Group)
@findex gnus-group-best-unread-group
最も小さいレベルの未読グループにジャンプします
(@code{gnus-group-best-unread-group})。

@item .
@kindex . (Group)
@findex gnus-group-first-unread-group
最初の未読記事のあるグループにジャンプします
(@code{gnus-group-first-unread-group})。
@end table

@vindex gnus-group-goto-unread
@code{gnus-group-goto-unread} が @code{nil} にすると、全ての移動
コマンドは、次の未読グループではなく次のグループに移動するように
なります。そのコマンドが次の未読グループに移動する、と言い張って
いても、です。デフォルトは @code{t} です。


@node Selecting a Group
@section グループの選択
@cindex group selection

@table @kbd

@item SPACE
@kindex SPACE (Group)
@findex gnus-group-read-group
現在のグループを選択し、サマリバッファに切り替えて最初の未読記事
を表示します (@code{gnus-group-read-group})。もしそのグループに
未読記事が無い、もしくはこのコマンドに数字以外のプレフィックスを
与えると、Gnus はサーバからこのグループの全ての古い記事を取得し
ようとします。@var{N} の数字プレフィックスを与えると、Gnus の取
得する記事数は @var{N} になります。@var{N} が正の数であれば Gnus
は新しい方から @var{N} 個の記事を取得し、 @var{N} が負の数であれ
ばGnus は古い方から @var{N} 個の記事を取得します。


@item RET
@kindex RET (Group)
@findex gnus-group-select-group
現在のグループを選択し、サマリバッファに切り替えます
(@code{gnus-group-select-group})。@code{gnus-group-read-group}
と同じ引数を取ります -- 唯一の違いは、グループに入ったときに最初
の未読記事を表示しない、ということです。

@item M-RET
@kindex M-RET (Group)
@findex gnus-group-quick-select-group
これは上記のコマンドと同じ動作をしますが、「ゴタゴタ」は最低限に
しようとします (@code{gnus-group-quick-select-group})。スコア・
kill の処理は行われず、ハイライトも記事消去もしません。これは、
あなたが本当に急いでいて、どっかのやたらでっかいグループに入らな
ければいけないときに役に立つかもしれません。また、プレフィックス
に 0 を与えれば(すなわち @kbd{0 M-RET})、Gnus はサマリバッファを
作ろうとさえしません。これはサマリバッファを作る前にスレッド表示
を切り替えたいとき役に立ちます 
(@pxref{Summary Generation Commands})。

@item M-SPACE
@kindex M-SPACE (Group)
@findex gnus-group-visible-select-group
これは @kbd{RET} コマンドと同じ動作をするさらにもう一つのコマン
ドですが、このコマンドは記事消去と保留記事を隠す処理を行いません
(@code{gnus-group-visible-select-group})。

@item M-C-RET
@kindex M-C-RET (Group)
@findex gnus-group-select-group-ephemerally
最後にこのコマンドは、現在のグループを一度限り、その内容に一切の
処理をすることのないように選択します
(@code{gnus-group-select-group-ephemerally})。 スレッド表示さ
えも行われません。この方法で選択した後にこのグループに対して行っ
たことは全て、その後に影響を与えることはありません。

@end table

@vindex gnus-large-newsgroup
@code{gnus-large-newsgroup} 変数は、何を大きなグループと考えるべ
きか、を Gnus に与えます。これは デフォルトでは 200 です。グルー
プに(未読と印付きの)記事がこの数以上あれば、Gnus はそのグループ
に入る前にユーザに確認を求めます。ユーザはサーバからいくつの記事
を取得するかを指定できます。もしユーザが負の数 (@code{-n})を指定
すれば、古い方から @code{n} 個の記事を取得します。正の数であれば、
新しく到着した方から @code{n} 個の記事を取得します。

@vindex gnus-select-group-hook
@vindex gnus-auto-select-first
@code{gnus-auto-select-first} は、@kbd{SPACE} コマンドでグループ
に入ったときに、自動的に記事を選択するかどうかを制御します。

@table @code

@item nil
グループに入ったときにどの記事も選択しない。ただサマリバッファを
表示するだけ。

@item t
グループに入ったときに、最初の未読記事を選択する。

@item best
グループに入ったときに、そのグループで最も高いスコアの記事を選択
する。 
@end table

もしあるグループで自動記事選択をやめたいのであれば(例えばでっか
い記事のあるバイナリグループでは、とか)、グループが選択されたと
きに呼び出される@code{gnus-select-group-hook} の中でこの変数を 
@code{nil} に設定することができます。

@node Subscription Commands
@section 購読制御コマンド
@cindex subscription

@table @kbd

@item S t
@itemx u
@kindex S t (Group)
@kindex u (Group)
@findex gnus-group-unsubscribe-current-group
@c @icon{gnus-group-unsubscribe}
現在のグループの購読を切り替えます
(@code{gnus-group-unsubscribe-current-group})。

@item S s
@itemx U
@kindex S s (Group)
@kindex U (Group)
@findex gnus-group-unsubscribe-group
グループを購読するかどうかを確認し、購読します。すでに購読するよ
うになっている場合には、購読を止めます
(@code{gnus-group-unsubscribe-group})。

@item S k
@itemx C-k
@kindex S k (Group)
@kindex C-k (Group)
@findex gnus-group-kill-group
@c @icon{gnus-group-kill-group}
現在のグループを kill します (@code{gnus-group-kill-group})。

@item S y
@itemx C-y
@kindex S y (Group)
@kindex C-y (Group)
@findex gnus-group-yank-group
最後に kill したグループを yank します
(@code{gnus-group-yank-group})。

@item C-x C-t
@kindex C-x C-t (Group)
@findex gnus-group-transpose-groups
二つのグループの順序を置き換えます
(@code{gnus-group-transpose-groups})。 これはホントは購読コマン
ドではありませんが、kill と yank を何度か続ける代わりにこのコマ
ンドが使えます。

@item S w
@itemx C-w
@kindex S w (Group)
@kindex C-w (Group)
@findex gnus-group-kill-region
リージョン内の全てのグループを kill します
(@code{gnus-group-kill-region})。

@item S z
@kindex S z (Group)
@findex gnus-group-kill-all-zombies
全てのゾンビグループを kill します
(@code{gnus-group-kill-all-zombies})。

@item S C-k
@kindex S C-k (Group)
@findex gnus-group-kill-level
あるレベルのグループを全て kill します
(@code{gnus-group-kill-level})。 kill した後、これらのグループを
yank で戻すことはできないので、このコマンドはいくらか注意して使っ
てください。このコマンドが本当に便利になるのは、@file{.newsrc} 
に捨てちゃいたい未購読のグループがたくさんあるときだけです。レベ
ル 7で @kbd{S C-k} を行うと、@file{.newsrc} ファイル中にメッセー
ジ番号がない未購読グループを全て kill します。

@end table

@pxref{Group Levels} も参照してくください。


@node Group Data
@section グループデータ

@table @kbd

@item c
@kindex c (Group)
@findex gnus-group-catchup-current
@vindex gnus-group-catchup-group-hook
@c @icon{gnus-group-catchup-current}
そのグループ内の全ての無印の記事を既読にする
(@code{gnus-group-catchup-current})。
グループバッファから既読にした場合は
@code{gnus-group-catchup-group-hook}  が呼び出されます。

@item C
@kindex C (Group)
@findex gnus-group-catchup-current-all
そのグループの全記事を、印付きの記事も含めて既読にします
(@code{gnus-group-catchup-current-all})。

@item M-c
@kindex M-c (Group)
@findex gnus-group-clear-data
現在のグループの全てのデータをクリアします -- マークと既読記事の
リストを消し去ります (@code{gnus-group-clear-data})。

@item M-x gnus-group-clear-data-on-native-groups
@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
もし nntp サーバを別のものに切り替えたとすると、全てのマークと既
読情報はもう役には立ちません。このコマンドを使ってネイティブグルー
プの全てのデータをクリアすることができます。注意して使ってね。

@end table


@node Group Levels
@section グループレベル
@cindex group level
@cindex level

全てのグループは購読度 @dfn{subscribedness} のレベルを持ちます。
例えば、あるグループがレベル 2 だとすれば、それはレベル 5 のグルー
プよりも「より購読している」ということです。Gnus に対して、ある
レベルかそれより小さいレベルのグループのみ一覧表示するように頼む
こともできるし (@pxref{Listing Groups})、あるレベルかそれより小
さいレベルのグループの新着記事のみを確認することもできます
(@pxref{Scanning New Messages})。

忘れないで: グループのレベルが大きいほど、重要度は低くなるということ。

@table @kbd

@item S l
@kindex S l (Group)
@findex gnus-group-set-current-level
現在のグループのレベルを設定する。数字プレフィックスが与えられる
と、そこから @var{n} 個のグループのレベルが設定されます。レベル
を入力するためのプロンプトが出ます。

@end table

@vindex gnus-level-killed
@vindex gnus-level-zombie
@vindex gnus-level-unsubscribed
@vindex gnus-level-subscribed
Gnus はレベル 1 から @code{gnus-level-subscribed} (この値を含む)
(デフォルトは 5) までのグループを購読、
@code{gnus-level-subscribed} (この値を含まない) から
@code{gnus-level-unsubscribed} (この値を含む) (デフォルトは 7)ま
でのグループを非購読、@code{gnus-level-zombie} をゾンビ(歩く屍)
(デフォルトは8)、@code{gnus-level-killed} を kill されている(完
全に死んでる)(デフォルトは9)と判断します。Gnus は購読と非購読の
グループは全く同様に扱いますが、ゾンビと kill グループは、どの記
事を読んだか、存在するかなどの情報を一切持ちません。この死んでる
グループと生きてるグループの区別は、別にそれがきれいだからとか賢
いからというわけではなく、純粋に効率的な理由のためです。

メール用のグループは(もしあれば)非常に小さいレベル(例えば 1 か 
2)にしておくことをお勧めします。

もしレベル変数で遊びたいのであれば、多少注意をしてまわる必要があ
ります。一旦それを設定したら、二度とそれに触らないでください。さ
らに言えば、自分で何をやっているかを正確に理解していない限り、一
切触らないでください。

@vindex gnus-level-default-unsubscribed
@vindex gnus-level-default-subscribed
身近に関係する2つの変数は @code{gnus-level-default-subscribed}
(デフォルトは 3) と @code{gnus-level-default-unsubscribed} (デフォ
ルトは 6)です。これらは新しいグループが購読(あるいは非購読)され
たときのレベルです。もちろん、これら2つの変数の値は、意味のある
正しい範囲でなくてはなりません。

@vindex gnus-keep-same-level
@code{gnus-keep-same-level} が @code{nil} 以外であれば、移動コマ
ンドのいくつかは同一(あるいはそれより小さい)レベルのグループのみ
の移動になります。特に、あるグループの最後の記事から次のグループ
に移るとき、次の同一(あるいはそれより小さい)レベルのグループに移
動します。これは残りのグループを読むより先に、より重要なグループ
を読んでおきたいときには便利かもしれません。

@vindex gnus-group-default-list-level
デフォルトでは @code{gnus-group-default-list-level} と同じかそれ
より小さいレベルのグループが、グループバッファに一覧表示されます。

@vindex gnus-group-list-inactive-groups
@code{gnus-group-list-inactive-groups} が @code{nil} 以外であれ
ば、未読のグループに一緒にアクティブでないグループも表示します。
この変数はデフォルトで @code{t} です。もしこれが @code{nil} であ
れば、アクティブでないグループは表示されません。

@vindex gnus-group-use-permanent-levels
@code{gnus-group-use-permanent-levels} が @code{nil} 以外であれ
ば、一旦レベルを @kbd{g} や @kbd{l} のプレフィックスに与えると、
その後の全てのコマンドにおいてそのレベルが「作用する」レベルにな
ります。


@vindex gnus-activate-level
Gnus は通常、@code{gnus-activate-level} かそれより小さいレベルの
グループのみを起動します(つまりサーバに問い合わせをする)。購読し
ていないグループを起動したくなければ、この変数を例えば 5 に設定
するとよいかもしれません。デフォルトは 6 です。

@node Group Score
@section グループのスコア
@cindex group score
@cindex group rank
@cindex rank

普通は重要なグループは高レベルにしておくでしょうけれども、この方
法では少々制限がきついですよね。ひょっとしたら、グループをどれく
らい頻繁に読むかによってグループバッファをソートしたいなあ、なん
て思わない? 理にかなってるでしょ?

グループスコア @dfn{group score} はそのためのものです。それぞれ
のグループに対してスコアを指定することができます。そしてグループ
バッファをこのスコアを基にソートすることができます。あるいは、ス
コア順でソートしてその後レベルでソートすることもできます。(レベ
ルとスコアをひとまとめにして、グループのランク @dfn{rank} と呼び
ます。レベルが4でスコアが1のグループは、レベルが5でスコアが300の
グループよりも高いランクとなります。(レベルの方が重要度が高く、
スコアの方は重要度が低くなります。))

@findex gnus-summary-bubble-group
頻繁に読むグループに、めったに読まないグループよりも高いスコアを
与えたいときは、 @code{gnus-summary-exit-hook} フックに
@code{gnus-summary-bubble-group} 関数を追加することができます。
これでバブルソートの実行結果が(ソートの後で)得られるでしょう。サ
マリモードを終了するたびにこの活動をさせたいのであれば、同じフッ
クに @code{gnus-group-sort-groups-by-rank} か
@code{gnus-group-sort-groups-by-score} を追加できますが、いくら
か遅くなるでしょう。

@node Marking Groups
@section グループへのマーク
@cindex marking groups

もしいくつかのグループに対して何らかのコマンドを実行したい場合で、
それらがグループバッファに連続してある場合には、通常通りコマンド
に対して数字プレフィックスを与えるだけです。そうすればほとんどの
グループコマンドは、これらのグループに対してあなたの命令に従いま
す。

しかしそれらのグループが順番に並んでいない場合においても、いくつ
かのグループに対してコマンドを実行することができます。単に始めに
プロセスマークでグループにマークをつけておき、そしてコマンドを実
行するだけです。

@table @kbd

@item #
@kindex # (Group)
@itemx M m
@kindex M m (Group)
@findex gnus-group-mark-group
現在のグループにマークをつける (@code{gnus-group-mark-group})。

@item M-#
@kindex M-# (Group)
@itemx M u
@kindex M u (Group)
@findex gnus-group-unmark-group
現在のグループからマークを削除する (@code{gnus-group-unmark-group})。

@item M U
@kindex M U (Group)
@findex gnus-group-unmark-all-groups
全てのグループからマークを削除する (@code{gnus-group-unmark-all-groups})。

@item M w
@kindex M w (Group)
@findex gnus-group-mark-region
ポイントとマークに間の全てのグループにマークをつける
(@code{gnus-group-mark-region})。

@item M b
@kindex M b (Group)
@findex gnus-group-mark-buffer
バッファ内の全てのグループにマークをつける
(@code{gnus-group-mark-buffer})。

@item M r
@kindex M r (Group)
@findex gnus-group-mark-regexp
ある正規表現にマッチする全てのグループにマークをつける
(@code{gnus-group-mark-regexp})。
@end table

@pxref{Process/Prefix} も参照してください。

@findex gnus-group-universal-argument
プロセスマークが付けられている全てのグループに対して何かのコマン
ドを実行したいときは、 @kbd{M-&} 
(@code{gnus-group-universal-argument}) コマンドを使うことができ
ます。プロンプトから実行したいコマンドを入力します。

@node Foreign Groups
@section 外部グループ
@cindex foreign groups

以下では、一般的な外部グループの作成、変更を行うグループモードのコマンド
をいくつか、および特別な目的のグループの簡単に作成するコマンドを紹介しま
す。これらのコマンドは全て、新規に作成したグループをポイント位置に挿入し
ます --- @code{gnus-subscribe-newsgroup-method} は参照されません。

@table @kbd

@item G m
@kindex G m (Group)
@findex gnus-group-make-group
@cindex making groups
新しいグループを作成します (@code{gnus-group-make-group})。Gnus はプロン
プトを表示して、名前とメソッドと、場合によっては @dfn{address} の入力を
求めてきます。より簡単に @sc{nntp} グループを購読する方法は、 
@pxref{Browse Foreign Server} を参照してください。

@item G r
@kindex G r (Group)
@findex gnus-group-rename-group
@cindex renaming groups
現在のグループの名前を、何か別のものに変更します
(@code{gnus-group-rename-group})。これはある種のグループ --- 主にメール
グループに対してのみ有効です。このコマンドはバックエンドによっては非常に
遅いことも有り得ます。

@item G c
@kindex G c (Group)
@cindex customizing
@findex gnus-group-customize
グループパラメータをカスタマイズする (@code{gnus-group-customize})。

@item G e
@kindex G e (Group)
@findex gnus-group-edit-group-method
@cindex renaming groups
現在のグループの選択メソッドを修正するためのバッファに移動します
(@code{gnus-group-edit-group-method})。

@item G p
@kindex G p (Group)
@findex gnus-group-edit-group-parameters
グループパラメータを修正するためのバッファに移動します
(@code{gnus-group-edit-group-parameters})。

@item G E
@kindex G E (Group)
@findex gnus-group-edit-group
グループ情報を修正するためのバッファに移動します
(@code{gnus-group-edit-group})。

@item G d
@kindex G d (Group)
@findex gnus-group-make-directory-group
@cindex nndir
ディレクトリグループを作成します  (@pxref{Directory Groups})。ディレクト
リ名をプロンプト入力します (@code{gnus-group-make-directory-group})。

@item G h
@kindex G h (Group)
@cindex help group
@findex gnus-group-make-help-group

Gnus ヘルプグループを作成します (@code{gnus-group-make-help-group})。

@item G a
@kindex G a (Group)
@cindex (ding) archive
@cindex archive group
@findex gnus-group-make-archive-group
@vindex gnus-group-archive-directory
@vindex gnus-group-recent-archive-directory
Gnus アーカイブグループを作成します
(@code{gnus-group-make-archive-group})。デフォルトでは最も最近の記事を指
しているグループが作成されますが
(@code{gnus-group-recent-archive-directory})、プレフィックスを与えると全
ての記事を含むグループが @code{gnus-group-archive-directory} を基に作成
されます。

@item G k
@kindex G k (Group)
@findex gnus-group-make-kiboze-group
@cindex nnkiboze
kiboze グループを作成します。プロンプトで名前と、kiboze グループに「含めた
い」グループにマッチする正規表現と、ヘッダとマッチする文字列の組を入力し
ます (@code{gnus-group-make-kiboze-group})。@xref{Kibozed Groups}。

@item G D
@kindex G D (Group)
@findex gnus-group-enter-directory
@cindex nneething
任意のディレクトリを @code{nneething} バックエンドニューズグループである
かのように読み込みます (@code{gnus-group-enter-directory})。
@xref{Anything Groups}.

@item G f
@kindex G f (Group)
@findex gnus-group-make-doc-group
@cindex ClariNet Briefs
@cindex nndoc
ファイルなどをもとにグループを作成します
(@code{gnus-group-make-doc-group})。 このコマンドにプレフィックスを与え
た場合、ファイル名とファイルタイプをプロンプトで入力します。現在サポート
されているファイルタイプは、 @code{babyl}、 @code{mbox}、 @code{digest}、
@code{mmdf}、 @code{news}、 @code{rnews}、 @code{clari-briefs}、
@code{rfc934}、 @code{rfc822-forward}、@code{forward} です。プレフィック
スなしでこのコマンドを実行すると、Gnus はファイルタイプを推測します。
@xref{Document Groups}。

@item G w
@kindex G w (Group)
@findex gnus-group-make-web-group
@cindex DejaNews
@cindex Alta Vista
@cindex InReference
@cindex nnweb
ウェブ検索結果をもとに一時的なグループを作成します
(@code{gnus-group-make-web-group})。このコマンドにプレフィックスを与える
と、一時的ではなく固定したグループを作成します。プロンプトでサーチエンジ
ンのタイプと検索文字列を入力します。有効なサーチエンジンタイプには
@code{dejanews}、 @code{altavista}、@code{reference} があります。
@xref{Web Searches}。


@item G DEL
@kindex G DEL (Group)
@findex gnus-group-delete-group
この関数は現在のグループを削除します (@code{gnus-group-delete-group})。
プレフィックスが与えられると、この関数はそのグループ内の全記事を本当に削
除し、グループ自身をこの世から強制的に抹殺してしまいます。プレフィックス
は、あなたが何をやろうとしているか、本当に自信があるときにのみ使ってくだ
さい。まあ、このコマンドは( @code{nntp} グループのような)読み出し専用グ
ループには使えませんけど。

@item G V
@kindex G V (Group)
@findex gnus-group-make-empty-virtual
新しい、新鮮な、空の @code{nnvirtual} グループを作成します
(@code{gnus-group-make-empty-virtual})。@xref{Virtual Groups}。

@item G v
@kindex G v (Group)
@findex gnus-group-add-to-virtual
現在のグループを @code{nnvirtual} グループに追加します
(@code{gnus-group-add-to-virtual})。 これはプロセスマーク・プレ
フィックスルールに従います。

@end table



さまざまな選択メソッドに関するさらなる情報は @xref{Select Methods} を参
照してください。

@vindex gnus-activate-foreign-newsgroups
もし @code{gnus-activate-foreign-newsgroups} が正の数であれば、Gnus は起
動時に、この数かそれよりも小さいレベルの外部グループを全てチェックします。
これは特に違った @sc{nntp} サーバからたくさんのグループを購読している場
合など、しばらく時間がかかるかもしれません。

@node Group Parameters
@section グループパラメータ
@cindex group parameters

グループパラメータは、ある特定のグループローカルな情報を格納します。
これがグループパラメータリストの例です。

@example
((to-address . "ding@@gnus.org")
 (auto-expire . t))
@end example

それぞれの要素は「ドットペア」 --- つまりドットの前にキー、ドットの後
ろに値があるもの、で構成されます。全てのパラメータはこの形式を取りますが、
@emph{例外} としてローカル変数の指定はドットペアではなく通常のリストにな
ります。

以下のグループパラメータが使用されます。

@table @code
@item to-address
@cindex to-address
フォローアップとニューズへの投稿をするときに使用されるアドレス。

@example
(to-address .  "some@@where.com")
@end example

これは主に、クローズドなメーリングリストを表わすメールグループにおいて便
利なものです --- すなわちメーリングリストに投稿する人は全てそれを購読し
ているはず、というメーリングリストのことです。このパラメータを使用すると、
メールはそのメーリングリストにしか投稿されないことが保証されるので、メン
バーはあなたのフォローアップ記事を2通受け取ることはありません。

@code{to-address} を指定すると、そのグループが外部グループであるかどうか
に関わらず有効になります。例えば @samp{fa.4ad-l} というグループがサーバ
上にあったとしましょう。これは本当のニューズグループですが、サーバはメー
ルニューズゲートウェイを通して記事を受け付けます。つまりこのグループに対
して直接投稿することは不可能で、代わりにそのメーリングリストにメールを送
信しなければなりません。

@item to-list
@cindex to-list
そのグループで @kbd{a} を押したときに使用されるアドレス。

@example
(to-list . "some@@where.com")
@end example

これはフォローアップをしたときは完全に無視されます --- 例外はそれがニュー
ズグループを表わしているときは、@kbd{f} を押したときにメールグループのルー
ルが適用されるということです。

もし @kbd{a} コマンドをメールグループで実行したときに、@code{to-list} グ
ループパラメータも @code{to-address} もグループパラメータも無ければ、
@code{to-list} グループパラメータは、@code{gnus-add-to-list} が @code{t}
に設定されていればメッセージ送信時に自動的に付加されます。
@vindex gnus-add-to-list

もし @kbd{a} コマンドをメールグループで実行したとき、@code{to-list} グルー
プパラメータがなければ、送信時に自動的に付加されます。


@item visible
@cindex visible
グループパラメータのリスト中に @code{(visible . t)} という要素があれば、
そのグループはグループバッファにおいて、未読記事があるかどうかに関わらず、
常に表示されます。

@item broken-reply-to
@cindex broken-reply-to
@code{(broken-reply-to . t)} という要素があれば、そのグループで
は@code{Reply-To} は無視される、という意味です。これはある 
listserv によるメーリングリストを購読していて、それが 
@code{Reply-To} ヘッダを listserv 自身に返すようにつけられている
場合に有効でしょう。これはおかしな振る舞いです。だからこれが要る
んです!

@item to-group
@cindex to-group
@code{(to-group . "some.group.name")} という要素は、そのグループへの投稿
は全て @code{some.group.name} に送られる、という意味です。

@item newsgroup
@cindex newsgroup
グループパラメータリストに @code{(newsgroup . t)} があれば、Gnus は全て
のレスポンスをニューズ記事に対するレスポンスであるかのように扱います。こ
れは実際にはニューズグループのミラーであるメールグループに対して有効です。

@item gcc-self
@cindex gcc-self
グループパラメータリストに @code{(gcc-self . t)} があれば、新しく作成す
るメッセージは現在のグループに @code{Gcc} されます。もし @code{(gcc-self
. none)} があれば、@code{Gcc:} ヘッダは生成されず、
@code{(gcc-self . "string")} があればこの string はそのまま @code{gcc}
ヘッダに挿入されます。このパラメータは以下で説明する全ての @code{Gcc} の
デフォルトルールよりも優先されます (@pxref{Archived Messages})。

@item auto-expire
@cindex auto-expire
グループパラメータに @code{(auto-expire . t)} のような要素があれば、全て
の既読記事はエクスパイアされるようにマークされます。他の方法については
@pxref{Expiring Mail} を参照してください。

@item total-expire
@cindex total-expire
グループパラメータに @code{(total-expire . t)} のような要素があれば、既
読記事は、エクスパイアのマークがついていなくとも全てエクスパイア処理を施
されます。注意して使用してください。未読記事、印付き記事、保留記事はエク
スパイアされません。

@item expiry-wait
@cindex expiry-wait
@vindex nnmail-expiry-wait-function
グループパラメータに @code{(expiry-wait . 10)} のような要素があれば、こ
の値は記事をエクスパイアするときに @code{nnmail-expiry-wait} と
@code{nnmail-expiry-wait-function} の設定よりも優先されます。この値はエ
クスパイアの日数(整数である必要はない)かもしくは @code{never} か
@code{immediate} のシンボルを指定できます。

@item score-file
@cindex score file group parameter
@code{(score-file . "file")} のような要素は、 @file{file} を現在のグルー
プに適用されるスコアファイルにします。適用されるスコアエントリは全てこの
ファイルに入ります。

@item adapt-file
@cindex adapt file group parameter
@code{(adapt-file . "file")} のような要素は、@file{file}を現在のグループ
の適用ファイルにします。全ての適用スコアエントリはこのファイルに入ります。

@item admin-address
メーリングリストから脱会するときは、脱会通知メールをそのメーリングリスト
自身に送信してはいけません。代わりに管理用アドレスにメッセージを送信しま
す。このパラメータにはどこか便利な管理用アドレスを書いておくことができます。

@item display
 @code{(display . MODE)} のような要素は、グループに入るときにどの記事を
表示するかを指定します。有効な値は、

@table @code
@item all
未読、既読記事の両方を全て表示します。

@item default
デフォルトの表示記事を表示します。これは通常は未読記事と印付き記事です。
@end table

@item comment
@code{(comment . "This is a comment")} のような要素は、そのグループに対
する任意のコメントです。これは現在は Gnus には無視されますが、特定のグルー
プに対する情報を格納する場所を提供します。

@item @var{(variable form)}
グループに入るときに、そのグループローカルの変数を設定するグループパラメー
タを使用することができます。@samp{news.answers} においてスレッド表示を行
いたくないときは、そのグループにグループパラメータに 
@code{(gnus-show-threads nil)} と書けます。 @code{gnus-show-threads} は、
そのサマリバッファの中のローカル変数になり、form の @code{nil} はそこで
評価されます。

これはもし必要であれば、グループ毎のフック関数としても使用できます。もし
あるグループに入ったときにビープ音を鳴らしたければ、そのグループのパラメー
タに @code{(dummy-variable (ding))} みたいなものを書いておくこともできま
す。@code{dummy-variable} という変数に @code{(ding)} の評価結果が設定さ
れますが、まあ、誰も気にしないでしょ?

@end table

グループパラメータの修正には  @kbd{G p} コマンドを使ってください。トピッ
クパラメータについて読んでみることも面白いでしょう 
(@pxref{Topic Parameters})。

@node Listing Groups
@section グループの一覧表示
@cindex group listing

これらのコマンドは、利用できるグループをいろいろに切り分けて表示します。

@table @kbd

@item l
@itemx A s
@kindex A s (Group)
@kindex l (Group)
@findex gnus-group-list-groups
未読記事を持つ全てのグループを表示します (@code{gnus-group-list-groups})。
数字プレフィックスを使うと、このコマンドは引数の数かそれよりも小さいレベ
ルのグループのみを表示します。デフォルトでは、これはレベル 5 (つまり
@code{gnus-group-default-list-level}) かそれより小さいレベル(すなわち購
読しているグループのみ)を表示します。

@item L
@itemx A u
@kindex A u (Group)
@kindex L (Group)
@findex gnus-group-list-all-groups
未読記事のあるなしに関わらず、全てのグループを表示します
(@code{gnus-group-list-all-groups})。数字プレフィックスを使用すると、こ
のコマンドは引数の数かそれよりも小さいレベルのグループのみを表示します。
デフォルトでは 7 かそれよりも小さいレベルのグループ(すなわち購読、非購読
のグループのみ)が表示されます。

@item A l
@kindex A l (Group)
@findex gnus-group-list-level
ある特定のレベルの未読記事のあるグループを表示します
(@code{gnus-group-list-level})。プレフィックスを与えると、未読記事のない
グループも含めて表示します。

@item A k
@kindex A k (Group)
@findex gnus-group-list-killed
kill されたグループを全て表示します (@code{gnus-group-list-killed})。プ
レフィックス引数を与えると、現在購読、非購読となっていない全ての利用可能
なグループを表示します。これはサーバからアクティブファイルを読むことにな
るでしょう。

@item A z
@kindex A z (Group)
@findex gnus-group-list-zombies
全てのゾンビグループを表示します (@code{gnus-group-list-zombies})。

@item A m
@kindex A m (Group)
@findex gnus-group-list-matching
正規表現にマッチする名前を持つグループで、未読記事のある購読グループを全
て表示します (@code{gnus-group-list-matching})。

@item A M
@kindex A M (Group)
@findex gnus-group-list-all-matching
正規表現にマッチするグループを表示する
(@code{gnus-group-list-all-matching})。

@item A A
@kindex A A (Group)
@findex gnus-group-list-active
今接続しているサーバのアクティブファイルにあるグループを、本当に全部表示し
ます (@code{gnus-group-list-active})。これはしばらく時間がかかることも有
り得ます。たぶん @kbd{A M} を実行して、マッチさせたい部分を @samp{.} と
して全てのマッチするリストを表示させた方が良いでしょう。また、このコマン
ドは(まだ)存在しないグループも表示するかも知れません --- これは kill さ
れたグループであるかのように表示されます。出力は多少割り引いて受け取って
ね。

@item A a
@kindex A a (Group)
@findex gnus-group-apropos
正規表現にマッチする名前を持つグループを全て表示する
(@code{gnus-group-apropos})。

@item A d
@kindex A d (Group)
@findex gnus-group-description-apropos
正規表現にマッチする名前か説明文を持つグループを全て表示する
(@code{gnus-group-description-apropos})。

@end table

@vindex gnus-permanently-visible-groups
@cindex visible group parameter
@code{gnus-permanently-visible-groups} 正規表現にマッチするグループは、
未読記事があるかないかに関わらず常に表示されます。あるいはグループパラメー
タにおいて @code{visible} 要素を追加することでも同様の効果を得ることがで
きます。

@vindex gnus-list-groups-with-ticked-articles
印付きの記事のみを持つグループは通常グループバッファに表示されます。もし
@code{gnus-list-groups-with-ticked-articles} が @code{nil} であれば、そ
のグループは完全に空のグループであるかのように扱われます。デフォルトは
@code{t} です。

@node Sorting Groups
@section グループのソート
@cindex sorting groups

@kindex C-c C-s (Group)
@findex gnus-group-sort-groups
@vindex gnus-group-sort-function
@kbd{C-c C-s} (@code{gnus-group-sort-groups}) コマンドは、グループバッファを
@code{gnus-group-sort-function} 変数で与えられる関数に従ってソートします。
利用可能なソート関数には以下のものがあります。

@table @code

@item gnus-group-sort-by-alphabet
@findex gnus-group-sort-by-alphabet
グループ名でアルファベット順にソートします。これはデフォルトです。

@item gnus-group-sort-by-real-name
@findex gnus-group-sort-by-real-name
グループを本当の(前に何もついていない)グループ名でアルファベット順にソー
トします。

@item gnus-group-sort-by-level
@findex gnus-group-sort-by-level
グループレベルでソートします。

@item gnus-group-sort-by-score
@findex gnus-group-sort-by-score
グループのスコアでソートします @xref{Group Score}。

@item gnus-group-sort-by-rank
@findex gnus-group-sort-by-rank
グループのスコアでソートし、次にグループレベルでソートします。レベルとス
コアは、ひとまとめにして @dfn{ランク} と呼ばれます @xref{Group Score}。

@item gnus-group-sort-by-unread
@findex gnus-group-sort-by-unread
未読記事の数でソートします。

@item gnus-group-sort-by-method
@findex gnus-group-sort-by-method
選択メソッドのアルファベット順でソートします。

@end table

@code{gnus-group-sort-function} はソート関数のリストであっても構いません。
この場合、もっとも重要なソートキーを持つ関数は最後でなくてはなりません。

ある種のソート用には、直接ソートするコマンドもいくつかあります。

@table @kbd
@item G S a
@kindex G S a (Group)
@findex gnus-group-sort-groups-by-alphabet
グループバッファをグループ名のアルファベット順でソートします
(@code{gnus-group-sort-groups-by-alphabet})。

@item G S u
@kindex G S u (Group)
@findex gnus-group-sort-groups-by-unread
グループバッファを未読記事の数でソートします
(@code{gnus-group-sort-groups-by-unread})。

@item G S l
@kindex G S l (Group)
@findex gnus-group-sort-groups-by-level
グループバッファをグループレベルでソートします
(@code{gnus-group-sort-groups-by-level})。

@item G S v
@kindex G S v (Group)
@findex gnus-group-sort-groups-by-score
グループバッファをグループのスコアでソートします
(@code{gnus-group-sort-groups-by-score})。 @xref{Group Score}。

@item G S r
@kindex G S r (Group)
@findex gnus-group-sort-groups-by-rank
グループバッファをグループのランクでソートします
(@code{gnus-group-sort-groups-by-rank})。 @xref{Group Score}。

@item G S m
@kindex G S m (Group)
@findex gnus-group-sort-groups-by-method
グループバッファをバックエンドの名前でアルファベット順にソートします
(@code{gnus-group-sort-groups-by-method})。

@end table

プレフィックスを与えたときは、これらのコマンドは全て逆順にソートします。

また、グループの一部に対してソートすることもできます。

@table @kbd
@item G P a
@kindex G P a (Group)
@findex gnus-group-sort-selected-groups-by-alphabet
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、
グループ名のアルファベット順でソートします
(@code{gnus-group-sort-selected-groups-by-alphabet})。

@item G P u
@kindex G P u (Group)
@findex gnus-group-sort-selected-groups-by-unread
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、
未読記事の数でソートします
(@code{gnus-group-sort-selected-groups-by-unread})。

@item G P l
@kindex G P l (Group)
@findex gnus-group-sort-selected-groups-by-level
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、
グループレベルでソートします (@code{gnus-group-sort-selected-groups-by-level})。

@item G P v
@kindex G P v (Group)
@findex gnus-group-sort-selected-groups-by-score
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、
グループのスコアでソートします
(@code{gnus-group-sort-selected-groups-by-score})。  @xref{Group Score}。

@item G P r
@kindex G P r (Group)
@findex gnus-group-sort-selected-groups-by-rank
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、
グループのランクでソートします
(@code{gnus-group-sort-selected-groups-by-rank})。  @xref{Group Score}。

@item G P m
@kindex G P m (Group)
@findex gnus-group-sort-selected-groups-by-method
グループバッファ内のプロセスマーク・プレフィックス指定されたグループを、
バックエンドの名前でアルファベット順にソートします
(@code{gnus-group-sort-selected-groups-by-method})。

@end table



@node Group Maintenance
@section グループの整理
@cindex bogus groups

@table @kbd
@item b
@kindex b (Group)
@findex gnus-group-check-bogus-groups
不正なグループを見つけて、削除します
(@code{gnus-group-check-bogus-groups})。

@item F
@kindex F (Group)
@findex gnus-group-find-new-groups
新しいグループを見つけて、それらを処理します
(@code{gnus-group-find-new-groups})。プレフィックスを与えると、サーバに
新規グループを問い合わせるのに @code{ask-server} の方法を使用します。

@item C-c C-x
@kindex C-c C-x (Group)
@findex gnus-group-expire-articles
現在のグループのエクスパイア記事に対して(もしあれば)全てエクスパイア処理を行い
ます (@code{gnus-group-expire-articles})。

@item C-c M-C-x
@kindex C-c M-C-x (Group)
@findex gnus-group-expire-all-groups
全てのグループの全ての記事に対して、エクスパイア処理を行います
(@code{gnus-group-expire-all-groups})。

@end table


@node Browse Foreign Server
@section 外部サーバのブラウズ
@cindex foreign servers
@cindex browsing servers

@table @kbd
@item B
@kindex B (Group)
@findex gnus-group-browse-foreign-server
選択メソッドとサーバ名を聞かれます。Gnus はこのサーバに接続し、そこにあ
るグループをブラウズしようとします (@code{gnus-group-browse-foreign-server})。

@end table

@findex gnus-browse-mode
利用可能なグループのリストを持った新しいバッファが現れます。このバッファ
は @code{gnus-browse-mode} を使用します。このバッファは通常のグループバッ
ファにちょっと(というか、とっても)似ています。

これがブラウズモードで使用できるキー操作のリストです。

@table @kbd
@item n
@kindex n (Browse)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item p
@kindex p (Browse)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item SPACE
@kindex SPACE (Browse)
@findex gnus-browse-read-group
現在のグループに入り、最初に記事を表示します
(@code{gnus-browse-read-group})。

@item RET
@kindex RET (Browse)
@findex gnus-browse-select-group
現在のグループに入ります (@code{gnus-browse-select-group})。

@item u
@kindex u (Browse)
@findex gnus-browse-unsubscribe-current-group
現在のグループを非購読にする、つまりこの場合は購読することになるのだけれ
ど (@code{gnus-browse-unsubscribe-current-group})。

@item l
@itemx q
@kindex q (Browse)
@kindex l (Browse)
@findex gnus-browse-exit
ブラウズモードを終了します (@code{gnus-browse-exit})。

@item ?
@kindex ? (Browse)
@findex gnus-browse-describe-briefly
ブラウズモードを簡単に説明します(まあ、大して説明することもないんだけどさ)
(@code{gnus-browse-describe-briefly})。

@end table


@node Exiting Gnus
@section Gnus の終了
@cindex exiting Gnus

そう、Gnus は最後(サイコー)です(訳注: く、苦しい。原文は "Yes,
Gnus is ex(c)iting.")。

@table @kbd
@item z
@kindex z (Group)
@findex gnus-group-suspend
Gnus を中断します (@code{gnus-group-suspend})。これは Gnus は本
当には終了せず、グループバッファ以外の全てのバッファを消すだけで
す。僕はこれで何が得するのかよくわかんないんだけど、誰か分かる人
いる?

@item q
@kindex q (Group)
@findex gnus-group-exit
@c @icon{gnus-group-exit}
Gnus を終了します(@code{gnus-group-exit})。

@item Q
@kindex Q (Group)
@findex gnus-group-quit
@file{.newsrc} ファイルをセーブせずに Gnus を終了します
(@code{gnus-group-quit})。ドリブルファイルはセーブされますけど
(@pxref{Auto Save})。
@end table

@vindex gnus-exit-gnus-hook
@vindex gnus-suspend-gnus-hook
Gnus を中断するときは @code{gnus-suspend-gnus-hook} が呼び出されます。Gnus
を終了するときは @code{gnus-exit-gnus-hook} が呼び出され、さらに Gnus を
終了するときの最後として @code{gnus-after-exiting-gnus-hook} が呼び出さ
れます。

@findex gnus-unload
@cindex unloading
もし Gnus とそれに関連するものを完全に処分したいのであれば、
@code{gnus-unload} コマンドが使えます。このコマンドは、メタ変数をカスタ
マイズしようとしているときにも便利です。

Note:  

@quotation
ミス Lisa Cannifax は英語の授業中、後ろに座っている少年が彼女の
プラスティックの椅子の背越しに、鉛筆で繰り返し線を描くのにつられ
て、足がしびれて重くなり、意識が朦朧としてきました。
@end quotation


@node Group Topics
@section Group Topics
@cindex topics

もしあなたがたーくさんのグループを読んでいるのであれば、グループをトピッ
ク毎に階層分けできると便利でしょう。Emacs のグループをこっちへ、セックス
のグループをあっちへ、で、残りを(え? グループが2つくらいしかないの?)邪魔
にならないようにその他のセクションに入れましょう。あるいは Emacs セック
スのグループを Emacs グループ、セックスグループのどちらかの副トピックと
することさえもできます --- あるいは両方に! すんごいでしょう!

@iftex
@iflatex
\gnusfigure{Group Topics}{400}{
\put(75,50){\epsfig{figure=tmp/group-topic.ps,height=9cm}}
}
@end iflatex
@end iftex

これが例です。

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

@findex gnus-topic-mode
@kindex t (Group)
この @emph{素晴らしい}機能を使うには、@code{gnus-topic} マイナーモー
ドを(何と!)単にスイッチオンするだけ --- グループバッファで、 @kbd{t} を
押してください(これはトグルコマンドです)。

さあやってみよう。とにかく試してみて。 君が戻ってくるまで、僕はここで待っ
てるからさ。ララ、タララン…ん、いい曲だね、これ…ラ、ラ、ラ…え? 戻って
きた? よし、じゃ次は @kbd{l} を押してみて。ほら。これで全てのグルー
プが @samp{misc} の下に表示されました。興奮してクラクラしてこない? アツ
くって、いまいましいくらいでしょ?

これをずっと有効にしたければ、グループモードのフックにこのマイナーモード
を追加してください。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@menu
* Topic Variables::    Lisp でトピックをカスタマイズする方法。
* Topic Commands::     超簡単対話型コマンド
* Topic Sorting::      トピック毎別々にソートする。
* Topic Topology::     全世界の地図。
* Topic Parameters::   あるトピックの全てのグループに適用されるパラメータ。
@end menu


@node Topic Variables
@subsection トピック変数
@cindex topic variables

さて、トピックを選ぶと、トピックは折り畳まれます。これ、とっても
ステキだと思うんだけど。

@vindex gnus-topic-line-format
トピック行は、@code{gnus-topic-line-format} 変数の値に従って作成されます
(@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item i
字下げ。
@item n
トピック名。
@item v
見えるかどうか。
@item l
レベル。
@item g
トピック中のグループの数。
@item a
トピック中の未読記事の数。
@item A
トピックと全ての副トピックの未読記事の数。
@end table

@vindex gnus-topic-indent-level
各副トピック(と副トピック内のグループ)は、トピックレベル数の
@code{gnus-topic-indent-level} 倍の空白分の字下げが行われます。デフォル
トは 2 です。

@vindex gnus-topic-mode-hook
@code{gnus-topic-mode-hook} はトピックマイナーモードバッファで呼び出され
ます。

@vindex gnus-topic-display-empty-topics
@code{gnus-topic-display-empty-topics} はトピックの中に未読記事
が無い場合でもそのトピックを表示するようにします。デフォルトは
@code{t} です。

@node Topic Commands
@subsection トピックコマンド
@cindex topic commands

トピックマイナーモードが有効であるときは、@kbd{T} サブマップが新
しく利用できるようになります。さらに標準キーの中でも、定義がちょっ
と変わるものが少しあります。

@table @kbd

@item T n
@kindex T n (Topic)
@findex gnus-topic-create-topic
新しいトピックの名前をプロンプト入力し、それを作成します
(@code{gnus-topic-create-topic})。

@item T m
@kindex T m (Topic)
@findex gnus-topic-move-group
現在のグループを、どこか他のトピックに移動させます
(@code{gnus-topic-move-group})。このコマンドはプロセスマーク・プ
レフィックスルールに従います (@pxref{Process/Prefix})。

@item T c
@kindex T c (Topic)
@findex gnus-topic-copy-group
現在のグループを、どこか他のトピックにコピーします
(@code{gnus-topic-copy-group})。このコマンドはプロセスマーク・プ
レフィックスルールに従います (@pxref{Process/Prefix})。

@item T D
@kindex T D (Topic)
@findex gnus-topic-remove-group
グループを現在のトピックから削除します
(@code{gnus-topic-remove-group})。このコマンドはプロセスマーク・
プレフィックスルールに従います (@pxref{Process/Prefix})。

@item T M
@kindex T M (Topic)
@findex gnus-topic-move-matching
正規表現にマッチする全てのグループを、あるトピックに移動させます
(@code{gnus-topic-move-matching})。 

@item T C
@kindex T C (Topic)
@findex gnus-topic-copy-matching
正規表現にマッチする全てのグループを、あるトピックにコピーします
(@code{gnus-topic-copy-matching})。

@item T h
@kindex T h (Topic)
@findex gnus-topic-toggle-display-empty-topics
空のトピックの表示・非表示を切り替えます
(@code{gnus-topic-toggle-display-empty-topics})。

@item T #
@kindex T # (Topic)
@findex gnus-topic-mark-topic
現在のトピックにあるグループ全てにプロセスマークをつけます
(@code{gnus-topic-mark-topic})。

@item T M-#
@kindex T M-# (Topic)
@findex gnus-topic-unmark-topic
現在のトピックにある全てのグループからプロセスマークを消します
(@code{gnus-topic-unmark-topic})。

@item RET
@kindex RET (Topic)
@findex gnus-topic-select-group
@itemx SPACE
グループを選択するか、あるいはトピックを折りたたみます
(@code{gnus-topic-select-group})。グループの上でこのコマンドを実
行すると、通常通りそのグループに入ります。トピック行の上で行うと、
そのトピックは(既に表示されているときは)折りたたまれるか、(既に
折りたたまれているときは)展開されます。つまりトピックに対しては
これはトグルコマンドです。さらに、数字プレフィックスを与えると、
そのレベル(とそれよりも小さいレベル)のグループが表示されます。

@item T TAB
@kindex T TAB (Topic)
@findex gnus-topic-indent
現在のトピックの「字下げ」を行い、その前のトピックの副トピックに
します (@code{gnus-topic-indent})。プレフィックスを与えると、反
対にそのトピックの字下げを戻します。

@item C-k
@kindex C-k (Topic)
@findex gnus-topic-kill-group
グループあるいはトピックを kill します
(@code{gnus-topic-kill-group})。トピック内にあったグループも全て、
トピックと一緒に削除されます。

@item C-y
@kindex C-y (Topic)
@findex gnus-topic-yank-group
直前の kill されたグループあるいはトピックを yank します
(@code{gnus-topic-yank-group})。全てのトピックは、全てのグループ
の前に yank されることに気をつけてください。

@item T r
@kindex T r (Topic)
@findex gnus-topic-rename
トピックの名前を変更する (@code{gnus-topic-rename})。

@item T DEL
@kindex T DEL (Topic)
@findex gnus-topic-delete
空のトピックを削除する (@code{gnus-topic-delete})。

@item A T
@kindex A T (Topic)
@findex gnus-topic-list-active
Gnus が知っているトピック化されたグループを全て表示します
(@code{gnus-topic-list-active})。

@item G p
@kindex G p (Topic)
@findex gnus-topic-edit-parameters
@cindex group parameters
@cindex topic parameters
@cindex parameters
トピックパラメータを修正します (@code{gnus-topic-edit-parameters})。
@xref{Topic Parameters}。

@end table


@node Topic Sorting
@subsection トピックのソート
@cindex topic sorting

以下に示すコマンドで、各トピック毎に別々にグループをソートできます。


@table @kbd
@item T S a
@kindex T S a (Topic)
@findex gnus-topic-sort-groups-by-alphabet
現在のトピックをグループ名のアルファベット順でソートします
(@code{gnus-topic-sort-groups-by-alphabet})。 

@item T S u
@kindex T S u (Topic)
@findex gnus-topic-sort-groups-by-unread
現在のトピックを未読記事の数でソートします
(@code{gnus-topic-sort-groups-by-unread})。

@item T S l
@kindex T S l (Topic)
@findex gnus-topic-sort-groups-by-level
現在のトピックをグループのレベルでソートします
(@code{gnus-topic-sort-groups-by-level})。

@item T S v
@kindex T S v (Topic)
@findex gnus-topic-sort-groups-by-score
現在のトピックをグループのスコアでソートします
(@code{gnus-topic-sort-groups-by-score})。 @xref{Group Score}。

@item T S r
@kindex T S r (Topic)
@findex gnus-topic-sort-groups-by-rank
現在のトピックをグループのランクでソートします
(@code{gnus-topic-sort-groups-by-rank})。 @xref{Group Score}。

@item T S m
@kindex T S m (Topic)
@findex gnus-topic-sort-groups-by-method
現在のトピックをバックエンドの名前でアルファベット順にソートしま
す (@code{gnus-topic-sort-groups-by-method})。

@end table

グループのソートについてのさらなる情報は、@xref{Sorting Groups}
を参照してください。

@node Topic Topology
@subsection トピックの位相構造
@cindex topic topology
@cindex topology

それでは、グループバッファの例を見ていきましょう。

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

つまり、ここでは一つのトップレベルのトピック (@samp{Gnus}) があ
り、その下に2つのトピックがあり、そのうちの一方の副トピック中に
一つ副トピックがあります(トップレベルトピックは常に一つしかあり
ません)。この構造は、以下のように表現できます。

@lisp
(("Gnus" visible)
 (("Emacs -- こいつはすげーぜ!" visible)
  (("えっちな Emacs" visible)))
 (("その他" visible)))
@end lisp

@vindex gnus-topic-topology
これは実に、上記の表示を行うための、変数
@code{gnus-topic-topology} の値そのものなのです。この変数は
@file{.newsrc.eld} ファイルに保存され、手でいじくり回してはいけ
ません --- 本当にやりたいときは別ですが。この変数は
@file{.newsrc.eld} ファイルから読み込まれるので、その他のスター
トアップファイルの設定には全く影響を与えません。

この構造は、どのトピックがどのトピックの副トピックであるかと、ど
のトピックが表示されているかを示しています。現在は二つの設定値
--- @code{visible} と @code{invisible} が許されています。


@node Topic Parameters
@subsection トピックパラメータ
@cindex topic parameters

トピック内の全てのグループはグループパラメータを、その親(と先祖)
のトピックパラメータから継承します。グループパラメータとして正し
いものは全て、トピックパラメータとしても正しいものです
(@pxref{Group Parameters})。

グループパラメータは(もちろん)トピックパラメータよりも優先され、
副トピックのトピックパラメータは親トピックのトピックパラメータよ
りも優先されます。分かるよね。ごく普通の継承ルールです(ルール 
@dfn{Rules} はここでは名詞であって、動詞の「線を引く」ではありま
せん。このルールには反対したくなるかも知れないけど、それはご自由
に)。

@example
Gnus
  Emacs
     3: comp.emacs
     2: alt.religion.emacs
   452: alt.sex.emacs
    息抜き
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
   452: alt.sex.emacs
@end example

@samp{Emacs} トピックはトピックパラメータ @code{(score-file
. "emacs.SCORE")} を持っています。@samp{息抜き} トピックはトピッ
クパラメータ @code{(score-file . "relief.SCORE")} を持ち、
@samp{その他} トピックはトピックパラメータ @code{(score-file
. "emacs.SCORE")} を持っています。さらに、
@samp{alt.religion.emacs} はグループパラメータ @code{(score-file
. "religion.SCORE")} を持っています。

さて、ここで @samp{息抜き} トピックの @samp{alt.sex.emacs} グルー
プに入ったとき、@file{relief.SCORE} が基本スコアファイルとなりま
す。もし @samp{Emacs} トピックの同じグループに入ると、
@file{emacs.SCORE} が基本スコアファイルになるでしょう。
@samp{alt.religion.emacs} グループに入れば、
@file{religion.SCORE} が基本スコアファイルになるでしょう。

これってとっても簡単で自明のことのように見えるでしょ? まあ、その
通りです。ですが問題がある場合もあります。特に
@code{total-expiry} パラメータに関してです。例えばあるメールグルー
プを二つのトピックの中に、一方は @code{total-expiry} ありで、も
う一方はそれなしで持っているとしましょう。ここで @kbd{M-x
gnus-expire-all-expirable-groups} を実行すると、何が起こるでしょ
うか? Gnus は、あなたがどちらのトピックから記事をエクスパイアし
たいのかを知る方法がないため、最悪の事態が発生するかもしれません。
実際、私はこのとき何が起こるのかは「未定義 @dfn{undefined}」であ
る、とここに宣言します。この手のことをやりたい場合には十分注意し
なければなりません。


@node Misc Group Stuff
@section その他のグループ関連

@menu
* Scanning New Messages:: Gnus に新しいメッセージが到着したかどうかを聞く。
* Group Information::     グループと Gnus に関する情報とヘルプ。
* Group Timestamp::       Gnus に最後にいつグループを読んだかを記録させる。
* File Commands::         Gnus のファイルの読み書き。
@end menu

@table @kbd

@item ^
@kindex ^ (Group)
@findex gnus-group-enter-server-mode
サーババッファモードに入る (@code{gnus-group-enter-server-mode})。
@xref{The Server Buffer}。

@item a
@kindex a (Group)
@findex gnus-group-post-news
あるグループに記事を投稿する (@code{gnus-group-post-news})。プレ
フィックスを与えると、現在のグループ名がデフォルトとして使用されます。

@item m
@kindex m (Group)
@findex gnus-group-mail
メールをどこかに送る (@code{gnus-group-mail})。

@end table

以下、グループバッファのための変数です。

@table @code

@item gnus-group-mode-hook
@vindex gnus-group-mode-hook
グループバッファが作成された時に呼び出されます。


@item gnus-group-prepare-hook
@vindex gnus-group-prepare-hook


グループバッファが生成されたあとに呼び出されます。これはバッファ
を何か変な、自然じゃない方法で修正したいときに使われるかもしれません。

@item gnus-group-prepared-hook
@vindex gnus-group-prepare-hook
グループバッファが生成された後の一番最後に呼び出されます。例えば
ポイントをどこかに移動させたいときなどに使えます。

@item gnus-permanently-visible-groups
@vindex gnus-permanently-visible-groups
この正規表現にマッチするグループは、それが空であるかどうかに関わ
らず、常にグループバッファに表示されます。

@end table


@node Scanning New Messages
@subsection 新着メッセージを探す
@cindex new messages
@cindex scanning new news

@table @kbd

@item g
@kindex g (Group)
@findex gnus-group-get-new-news
@c @icon{gnus-group-get-new-news}
サーバの新着記事をチェックします。数字プレフィックスを使用すると、
このコマンドは引数 @var{arg} かそれより小さいレベルのグループの
みをチェックします (@code{gnus-group-get-new-news})。数字以外の
プレフィックスを与えると、このコマンドはそのバックエンドからアク
ティブファイルを強制的に全部読み直します。

@item M-g
@kindex M-g (Group)
@findex gnus-group-get-new-news-this-group
@vindex gnus-goto-next-group-when-activating
@c @icon{gnus-group-get-new-news-this-group}
現在のグループに新着記事があるかどうかをチェックします
(@code{gnus-group-get-new-news-this-group})。
@code{gnus-goto-next-group-when-activating} はこのコマンドが次の
グループ位置へ移動するかどうかを決めます。デフォルトは @code{t} です。

@findex gnus-activate-all-groups
@cindex activating groups
@item C-c M-g
@kindex C-c M-g (Group)
無条件に全てのグループを起動します (@code{gnus-activate-all-groups})。

@item R
@kindex R (Group)
@cindex restarting
@findex gnus-group-restart
Gnus をリスタートします  (@code{gnus-group-restart})。これは
@file{.newsrc} ファイルをセーブし、全てのサーバの接続を閉じ、全
ての Gnus ランタイム変数をクリアした後、Gnus をもう一度最初から
開始します。

@end table

@vindex gnus-get-new-news-hook
@code{gnus-get-new-news-hook} は新着ニューズをチェックする直前に
実行されます。

@vindex gnus-after-getting-new-news-hook
@code{gnus-after-getting-new-news-hook} 新着ニューズをチェックし
た後に実行されます。


@node Group Information
@subsection グループ情報
@cindex group information
@cindex information on groups

@table @kbd


@item H f
@kindex H f (Group)
@findex gnus-group-fetch-faq
@vindex gnus-group-faq-directory
@cindex FAQ
@cindex ange-ftp
現在のグループの FAQ を取得しようとします
(@code{gnus-group-fetch-faq})。Gnus は FAQ を
@code{gnus-group-faq-directory} から取得しようとします。これは通
常リモートマシン上のディレクトリです。この変数はディレクトリのリ
ストであっても構いません。この場合、このコマンドにプレフィックス
を与えることでいくつかのサイトの中から選ぶことができます。
ファイルの取得には @code{ange-ftp} (または @code{efs}) が使用さ
れます。

もし最初のサイトからの取得が失敗した場合、Gnus は
@code{gnus-group-faq-directory} の値を全て、一つ一つオープンして
みようとします。

@item H d
@itemx C-c C-d
@c @icon{gnus-group-describe-group}
@kindex H d (Group)
@kindex C-c C-d (Group)
@cindex describing groups
@cindex group description
@findex gnus-group-describe-group
現在のグループの説明を表示する
(@code{gnus-group-describe-group})。プレフィックスを与えると、説
明文をサーバから強制的に再読み込みします。

@item M-d
@kindex M-d (Group)
@findex gnus-group-describe-all-groups
全てのグループの説明を表示します
(@code{gnus-group-describe-all-groups})。プレフィックスを与える
と、説明文ファイルをサーバから強制的に再読み込みします。

@item H v
@itemx V
@kindex V (Group)
@kindex H v (Group)
@cindex version
@findex gnus-version
現在の Gnus のバージョン番号を表示します (@code{gnus-version})。

@item ?
@kindex ? (Group)
@findex gnus-group-describe-briefly
とても短いヘルプメッセージを与えます (@code{gnus-group-describe-briefly})。

@item C-c C-i
@kindex C-c C-i (Group)
@cindex info
@cindex manual
@findex gnus-info-find-node
Gnus の info ノードに移動します (@code{gnus-info-find-node}).。

@end table


@node Group Timestamp
@subsection グループの日付
@cindex timestamps
@cindex group timestamps

Gnus に、あなたが最後にいつグループを読んだかを記録させると便利
かもしれません。この活動を始めさせるには、
@code{gnus-group-set-timestamp}を @code{gnus-select-group-hook}
に追加してください。

@lisp
(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)
@end lisp

これを行った後、あなたがグループに入るたびにそれが記録されます。

この情報はさまざまな方法で表示できます --- もっとも簡単なのは、
グループ行フォーマットで @samp{%d} 指定を使う方法です。

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %d\n")
@end lisp

この結果として、各行は以下のように表示されます。

@example
*        0: mail.ding                                19961002T012943
         0: custom                                   19961002T012713
@end example

見て分かるとおり、日付はコンパクトな ISO 8601 形式で表示されます。
これではちょっとあんまりなので、以下のような感じにすると日付だけ
を表示できます。

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %6,6~(cut 2)d\n")
@end lisp


@node File Commands
@subsection ファイルコマンド
@cindex file commands

@table @kbd

@item r
@kindex r (Group)
@findex gnus-group-read-init-file
@vindex gnus-init-file
@cindex reading init file
初期化ファイルの再読み込みを行う (@code{gnus-init-file}、このデ
フォルトは @file{~/.gnus}) (@code{gnus-group-read-init-file})。

@item s
@kindex s (Group)
@findex gnus-group-save-newsrc
@cindex saving .newsrc
Save the @file{.newsrc.eld} file (and @file{.newsrc} if wanted)
(@code{gnus-group-save-newsrc}).  If given a prefix, force saving the
file(s) whether Gnus thinks it is necessary or not.

 @file{.newsrc.eld}ファイル(と、もしそうしたければ
@file{.newsrc} ファイル)をセーブする
(@code{gnus-group-save-newsrc})。

@c @item Z
@c @kindex Z (Group)
@c @findex gnus-group-clear-dribble
@c ドリブルファイルをクリアする
@c (@code{gnus-group-clear-dribble})。

@end table


@node The Summary Buffer
@chapter 概略バッファ
@cindex summary buffer

概略バッファ (summary buffer) ではそれぞれの記事が一行で表示されます。そ
の中を動き回り、記事を読み、投稿し、返答をすることができます。

概略バッファに移る一番普通の方法は、グループバッファでグループを選択する
ことです (@pxref{Selecting a Group})。

概略バッファは望むだけたくさん開いた状態にしておくことができます。

@menu
* Summary Buffer Format::       概略バッファの外観を決定する。
* Summary Maneuvering::         概略バッファを動き回る。
* Choosing Articles::           記事を読む。
* Paging the Article::          読んでいる記事をスクロールする。
* Reply Followup and Post::     記事を投稿する。
* Canceling and Superseding::   ``あぁ、あんなふうに言うんじゃなかった。''
* Marking Articles::            記事に既読や期限切れ削除可能等の印を付ける。
* Limiting::                    概略バッファに制限を加えることができる。
* Threading::                   スレッドがどのように作られるか。
* Sorting::                     スレッドと記事がどのように並びかえられるか。
* Asynchronous Fetching::       Gnus は記事を先に取得することができる。
* Article Caching::             キャッシュに記事を貯めておける。
* Persistent Articles::         記事を期限切れ消去しなくさせる。
* Article Backlog::             既に読んだ記事を残しておく。
* Saving Articles::             記事の保存をカスタマイズする方法。
* Decoding Articles::           Gnus は一連の (uu) エンコードされた記事を扱える。
* Article Treatment::           記事バッファはお望みどおりに目茶苦茶にできる。
* Article Commands::            記事バッファでいろいろなことをする。
* Summary Sorting::             いろいろな方法で概略バッファを並べ替える。
* Finding the Parent::          子記事に援助が無いって? 親記事を取得しなさい。
* Alternative Approaches::      ディフォルトでない概略を使って読む。
* Tree Display::                もっと視覚的なスレッドの表示。
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる。
* Various Summary Stuff::       他のどの場所にも合わなかったもの。
* Exiting the Summary Buffer::  グループバッファに戻る。
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか。
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段。
@end menu


@node Summary Buffer Format
@section 概略バッファの様式
@cindex summary buffer format

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{180}{
\put(0,0){\epsfig{figure=tmp/summary.ps,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=tmp/summary-article.ps,width=7.5cm}}}
}
@end iflatex
@end iftex

@menu
* Summary Buffer Lines::     概略バッファがどのように見えるべきかを指定できる。
* Summary Buffer Mode Line:: モード行の見え方を決められる。
* Summary Highlighting::     概略バッファをきれいで素敵にする。
@end menu

@findex mail-extract-address-components
@findex gnus-extract-address-components
@vindex gnus-extract-address-components
Gnus は変数 @code{gnus-extract-address-components} の値を @code{From} ヘッ
ダーの名前とアドレスの部分を手に入れるための関数として使います。すでに定
義されている関数が2つ存在します: 
@code{gnus-extract-address-components} はディフォルトですが、とても簡単
に割り切った解決法で、非常に速く動作します。そして、 
@code{mail-extract-address-components} はとても良く動作しますが、遅くな
ります。ディフォルトの関数は 5% の割合で間違って答えます。もしこれに我慢
ならないのであれば、他の関数を代わりに使うことができます。

@vindex gnus-summary-same-subject
@code{gnus-summary-same-subject} は今読んでいる記事が、その前の記事と同
じ表題 (subject) であることを示す文字列です。この文字列は仕様がこれを要
求するときに使われます。ディフォルトでは @code{""} です。


@node Summary Buffer Lines
@subsection 概略バッファの行

@vindex gnus-summary-line-format
変数 @code{gnus-summary-line-format} の値を変えることによって、概略バッ
ファでの行の様式 (format) を変更することができます。いくつかの拡張 
(@pxref{Formatting Variables}) を除いて、普通の @code{format} 文字列と同
じように動作します。

ディフォルトの文字列は @samp{%U%R%z%I%(%[%4L: %-20,20n%]%) %s\n} です。

以下の様式指示文字を使うことができます:

@table @samp
@item N
記事数。
@item S
表題の文字列。
@item s
スレッド (thread) の基記事であるときか直前の記事が違う表題のときはその題
名で、それ以外は @code{gnus-summary-same-subject}。
(@code{gnus-summary-same-subject} のディフォルトの値は @code{""}。)
@item F
完全な @code{From} ヘッダー。
@item n
名前 (@code{From} ヘッダーより)。
@item a
名前 (@code{From} ヘッダーより)。これと @code{n} との違いは、これは変数
@code{gnus-extract-address-components} で指定されている関数を使って名前
を取得することです。この方が遅いですが、おそらくより完全に近いでしょう。
@item A
名前 (@code{From} ヘッダーより)。これは @code{a} と同じように動作しま
す。
@item L
記事の行数。
@item c
記事の文字数。
@item I
スレッドのレベルによる字下げ (@pxref{Customizing Threading})。
@item T
記事が本記事であれば何も表示せず、そうでない場合はたくさんの空白です (後
のものをすべて画面の外に追い出してしまいます)。
@item [
開き括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます (@pxref{Customizing Threading})。
@item ]
閉じ括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます。
@item >
それぞれのスレッドのレベルに対して一つの空白。
@item <
二十引くスレッドレベルの空白。
@item U
未読。
@item R
返答済み。
@item i
数字としてのスコア (@pxref{Scoring})。
@item z
@vindex gnus-summary-zcore-fuzz
これは、zcore でディフォルトのレベルよりも上であれば @samp{+} で、ディフォ
ルトのレベルよりも下であれば @samp{-} です。
@code{gnus-summary-default-zcore}との差が@code{gnus-summary-zcore-fuzz}
よりも小さいと、この仕様は使われません。
@item V
スレッド全体のスコア。
@item x
@code{Xref}。
@item D
@code{日付} (@code{Date})。
@item d
@code{DD-MM}様式による@code{日付}。
@item o
@var{YYYYMMDD}@code{T}@var{HHMMSS}様式による@code{日付}。
@item M
@code{Message-ID}。
@item r
@code{References}。
@item t
現在の副スレッドの記事の数。この仕様を使うと概略バッファの生成が幾分遅く
なります。
@item e
記事に子記事があると、@samp{=} (@code{gnus-not-empty-thread-mark}) が表
示されます。
@item P
行数。
@item O
ダウンロードの印。
@item u
利用者の定義の指定。フォーマット文字列の中の次の文字が英字である必要があ
ります。これにより gnus は関数 @code{gnus-user-format-function-}@samp{X}
を呼び出しますが、ここで @samp{X} は @samp{%U} の次の文字です。関数には
現在の記事のヘッダーが引数として渡されます。関数は文字列を返し、他の概略
指定と同様に概略に挿入されます。
@end table

@samp{%U} (状態)、@samp{%R} (返答済み)、@samp{%z} (zcore) の扱いには気を
付ける必要があります。効率のために、gnus はこれらの文字がどの桁に現れる
かを計算し、''ハード・コード'' します。これは、可変長の仕様の後では、こ
れらは意味を持たないということです。まぁ、さすがに逮捕はされないでしょう
が、概略バッファは変になります。それでも十分悲しいでしょうけど。

賢い選択はこれらの指定をできるだけ左に持ってくることです。 (でも、そうい
うことはすべてに当てはまるのではないでしょうか。閑話休題。)

この制限は後のバージョンでは無くなるかも知れません。


@node Summary Buffer Mode Line
@subsection 概略バッファのモード行

@vindex gnus-summary-mode-line-format
概略のモード行の様式も変更することができます。
@code{gnus-summary-mode-line-format} を何でも好きなものに変更してくださ
い。ディフォルトは @samp{Gnus: %%b [%A] %Z} です。

以下があなたが遊ぶことのできるそれぞれの要素です。

@table @samp
@item G
グループ名。
@item p
接頭語を取り除いた名前。
@item A
現在の記事番号。
@item V
Gnus バージョン。
@item U
そのグループでの未読記事の数。
@item e
概略バッファに表示されていない未読記事の数。
@item Z
未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記事があ
る場合は @samp{<%U(+%e) more>} で、未読記事のみの場合は @samp{<%U more>}
です。
@item g
短縮グループ名。例えば、@samp{rec.arts.anime} は @samp{r.a.anime} に短縮
されます。
@item S
現在の記事の表題。
@item u
利用者定義の仕様 (@pxref{User-Defined Specs})。
@item s
現在のスコアファイルの名前 (@pxref{Scoring})。
@item d
保留記事の数 (@pxref{Unread Articles})。
@item t
可視印付き記事の数 (@pxref{Unread Articles})。
@item r
その一連の動作の間に既読として印がついた記事の数。
@item E
スコアファイルによって抹消された記事の数。
@end table


@node Summary Highlighting
@subsection 概略のハイライト

@table @code

@item gnus-visual-mark-article-hook
@vindex gnus-visual-mark-article-hook
このフックは記事を選択した後に実行されます。これは何らかの方法で記事をハ
イライトするように意図されています。もし @code{gnus-visual} が
@code{nil} である場合は実行されません。

@item gnus-summary-update-hook
@vindex gnus-summary-update-hook
このフックは概略行が変更されたときに呼ばれます。もし @code{gnus-visual} が
@code{nil} である場合は実行されません。

@item gnus-summary-selected-face
@vindex gnus-summary-selected-face
これは概略バッファでの現在の記事をハイライトするために使われるフェイス 
(face) (もしくは、いくらかの人々が @dfn{フォント} (font) と呼ぶよ
うなもの) です。

@item gnus-summary-highlight
@vindex gnus-summary-highlight
概略行はこの変数にしたがってハイライトされます。この変数は要素が
@var{(FORM . FACE)} の形式のリストです。例えば、もし印付きの記事をイタリッ
ク、高いスコアの記事をボールドにしたければ、この変数を次のようにできます。
@lisp
(((eq mark gnus-ticked-mark) . italic)
 ((> score default) . bold))
@end lisp
ご想像のとおり、もし @var{FORM} が @code{nil} でない値を返すと、
@var{FACE} がその行に適用されます。
@end table


@node Summary Maneuvering
@section 概略間の移動
@cindex summary movement

すべての直接移動命令は数値接頭引数を受け付け、あなたの期待によくしたがっ
て動作するでしょう。

これらの命令はどれも記事を選択しません。


@table @kbd
@item G M-n
@item M-n
@kindex M-n (概略)
@kindex G M-n (概略)
@findex gnus-summary-next-unread-subject
概略行の次の未読記事に移る
(@code{gnus-summary-next-unread-subject})。

@item G M-p
@itemx M-p
@kindex M-p (概略)
@kindex G M-p (概略)
@findex gnus-summary-prev-unread-subject
概略行の前の未読記事に移る
(@code{gnus-summary-prev-unread-subject})。

@item G j
@item j
@kindex j (概略)
@kindex G j (概略)
@findex gnus-summary-goto-article
記事番号か @code{Message-ID} を尋ね、それからその記事に行く。
(@code{gnus-summary-goto-article})。

@item G g
@kindex G g (概略)
@findex gnus-summary-goto-subject
記事番号か @code{Message-ID} を尋ね、それからその記事を表示すること無く、
概略行に行く (@code{gnus-summary-goto-subject})。
@end table

Gnusが次のグループに移動することを確認をするために、キーを押すことを要求
するときがあります。その時は、@kbd{C-n} と @kbd{C-p} を使って、グループ
バッファに戻ること無く次に読むグループを探すことができます。

概略の移動に関連した変数:

@table @code

@vindex gnus-auto-select-next
@item gnus-auto-select-next
もし移動命令の一つ (@kbd{n} のような) を出し、現在の記事の後に未読が無け
れば、gnus は次のグループに移動することを奨めます。この変数が @code{t}
で次のグループが空であると、gnus は概略モードを終了して、グループバッファ
に戻ります。この変数が @code{t} や @code{nil} でないと、次のグループに記
事があろうが無かろうが、gnus はそれを選択します。特別な場合として、この
変数が @code{quietly} であると、gnus は確認をせずに、次のグループを選択
します。この変数が @code{almost-quietly} であると、グループの一番最後の
記事を読んでいたときに限り同じことが起こります。最後に、もしこの変数が
@code{slightly-quietly} であると、命令 @kbd{Z n} は確認をせずに次のグルー
プに移ります。@pxref{Group Levels} も参照してください。

@item gnus-auto-select-same
@vindex gnus-auto-select-same
@code{nil} でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
しようとします。 (@dfn{同じ} はここでは @dfn{大体同じ} という意味かも知
れません。詳細は @code{gnus-summary-gather-subject-limit} を見てください
(@pxref{Customizing Threading} も参照してください)。) この変数は、スレッ
ド表示を行っているときはあまり役に立たないでしょう。

@item gnus-summary-check-current
@vindex gnus-summary-check-current
@code{nil} でないと、すべての ``未読'' 移動命令は、次 (もしくは前) の記
事に移動しません。その代わりに、それらは現在の記事を選びます。

@item gnus-auto-center-summary
@vindex gnus-auto-center-summary
@code{nil} でないと、gnus は概略バッファでのポイントを常に真中に保ちます。
これをすると、とてもこぎれいになりますが、遅いネットワーク接続であったり、
単にこの Emacsism でない行為を好きになれないのであれば、普通の Emacs の
スクロールにするために、この変数を @code{nil} にすることができます。これ
は概略バッファの水平方向の真中への再移動も禁止しますので、非常に長いスレッ
ドを読むときは不便かもしれません。

@end table


@node Choosing Articles
@section 記事の選択
@cindex selecting articles

@menu
* Choosing Commands::        記事を選択するための命令。
* Choosing Variables::       これらの命令に影響を及ぼす変数。
@end menu


@node Choosing Commands
@subsection 命令の選択

以下の移動コマンドはどれも数値接頭引数を受け付けず、記事を選択し、表示しま
す。


@table @kbd
@item SPACE
@kindex SPACE (概略)
@findex gnus-summary-next-page
現在の記事か、それが既に読まれている場合は次の未読記事を選択します
(@code{gnus-summary-next-page}。

@item G n
@itemx n
@kindex n (概略)
@kindex G n (概略)
@findex gnus-summary-next-unread-article
@c @icon{gnus-summary-prev-unread}
前の未読記事に移動します (@code{gnus-summary-prev-unread-article})。

@item G N
@itemx N
@kindex N (概略)
@kindex G N (概略)
@findex gnus-summary-next-article
次の記事に移動します (@code{gnus-summary-next-article})。

@item G P
@itemx P
@kindex P (概略)
@kindex G P (概略)
@findex gnus-summary-prev-article
前の記事に移動します (@code{gnus-summary-prev-article})。

@item G C-n
@kindex G C-n (概略)
@findex gnus-summary-next-same-subject
同じ表題の次の記事に移動します (@code{gnus-summary-next-same-subject})。

@item G f
@itemx .
@kindex G f (概略)
@kindex . (概略)
@findex gnus-summary-first-unread-article
最初の未読記事に移動します (@code{gnus-summary-first-unread-article})。

@item G b
@item ,
@kindex G b (概略)
@kindex , (概略)
@findex gnus-summary-best-unread-article
最高スコアの記事に移動します (@code{gnus-summary-best-unread-article})。

@item G l
@itemx l
@kindex l (概略)
@kindex G l (概略)
@findex gnus-summary-goto-last-article
直前の記事に移動します (@code{gnus-summary-goto-last-article})。

@item G o
@kindex G o (概略)
@findex gnus-summary-pop-article
概略の履歴 (history) から最後の記事を一つ取り出して選択します。
(@code{gnus-summary-pop-article})。この命令が上の命令と違うのは、@kbd{l} 
が最終2つの記事の間を移動するのに対して、これは好きなだけ前の記事を履歴
から選び出すことができる点です。何らかのこれに関係したことは (もしこれ
らの命令をたくさん使うのであれば)、@pxref{Article Backlog} を参照してく
ださい。
@end table


@node Choosing Variables
@subsection 選ぶための変数

記事を移動し、選択するのに関連したいくつかの変数:

@table @code
@item gnus-auto-extended-newsgroup
@vindex gnus-auto-extend-newsgroup
この変数が @code{nil} でないと、すべての移動命令は、もしその記事が概略バッ
ファに表示されていない場合でも、前 (もしくは次) の記事に移動しようとしま
す。その命令の後で、gnus はサーバーから記事を取得して、記事バッファに表
示します。

@item gnus-select-article-hook
@vindex gnus-select-article-hook
このフックは記事が選択されたときに常に呼ばれます。ディフォルトでは、選択
された記事の下に隠れているスレッドを見せるようになっています。

@item gnus-mark-article-hook
@vindex gnus-mark-article-hook
@findex gnus-summary-mark-unread-as-read
@findex gnus-summary-mark-read-and-unread-as-read
@findex gnus-unread-mark
このフックは記事が選択されたときに常に呼ばれます。それは記事に既読の印を
付けるためにあります。ディフォルトの値は
@code{gnus-summary-mark-read-and-unread-as-read} で、ほとんどすべての読
んだ記事の印を @code{gnus-read-mark} に変更します。この関数に影響されな
い記事は、可視、保留、期限切れ削除可能記事だけです。もし、未読に既読の
印を付けたいだけであれば、代わりに
@code{gnus-summary-mark-unread-as-read} を使うことができます。それは、
@code{gnus-low-score-mark} や @code{gnus-del-mark} (などなど) の印をその
まま残します。

@end table


@node Paging the Article
@section 記事のスクロール
@cindex article scrolling

@table @kbd

@item SPACE
@kindex SPACE (概略)
@findex gnus-summary-next-page
@kbd{SPACE} は記事を一ページ先にスクロールします。記事の最後にいる場合は
次の記事を選択します (@code{gnus-summary-prev-page})。

@item DEL
@kindex DEL (概略)
@findex gnus-summary-prev-page
現在の記事を一ページ前にスクロールします (code{gnus-summary-prev-page})。

@item RET
@kindex RET (概略)
@findex gnus-summary-scroll-up
現在の記事を一行先にスクロールします。 (@code{gnus-summary-scroll-up})。

@item A g
@itemx g
@kindex A g (概略)
@kindex g (概略)
@findex gnus-summary-show-article
現在の記事を (再) 取得します。もし接頭引数が与えられると、現在の記事を取
得しますが、記事を扱う関数は実行しません。これは、サーバーからきたままの、 
``生の'' 記事を与えます。

@item A <
@itemx <
@kindex < (概略)
@kindex A < (概略)
@findex gnus-summary-beginning-of-article
記事の最初までスクロールします。
(@code{gnus-summary-beginning-of-article})。

@item A >
@itemx >
@kindex > (概略)
@kindex A > (概略)
@findex gnus-summary-end-of-article
記事の最後までスクロールします。 (@code{gnus-summary-end-of-article})。

@item A s
@itemx s
@kindex A s (概略)
@kindex s (概略)
@findex gnus-summary-isearch-article
記事バッファでインクリメンタルサーチ (isearch) を行います。
(@code{gnus-summary-isearch-article})。

@item h
@kindex h (概略)
@findex gnus-summary-select-article-buffer
記事バッファを選択します (@code{gnus-summary-select-article-buffer})。

@end table


@node Reply Followup and Post
@section 返答、フォローアップ、投稿

@menu
* Summary Mail Commands::            メールを送る。
* Summary Post Commands::            ニューズを送る。
@end menu


@node Summary Mail Commands
@subsection 概略でのメールの命令
@cindex mail
@cindex composing mail

メールメッセージを作成するための命令:

@table @kbd

@item S r
@item r
@kindex S r (概略)
@kindex r (概略)
@findex gnus-summary-reply
@c @icon{gnus-summary-mail-reply}
@c @icon{gnus-summary-reply}
現在の記事を書いた人に返答のメールを送ります (@code{gnus-summary-reply})。

@item S R
@itemx R
@kindex R (概略)
@kindex S R (概略)
@findex gnus-summary-reply-with-original
@c @icon{gnus-summary-reply-with-original}
現在の記事を書いた人に、本記事を含んだ返答のメールを出します
(@code{gnus-summary-reply-with-original})。 この命令はプロセス/接頭引数
の習慣を使います。

@item S w
@kindex S w (概略)
@findex gnus-summary-wide-reply
現在の記事を書いた人に対して、広い返答 (wide reply) をします
(@code{gnus-summary-wide-reply})。@dfn{広い返答} とはヘッダーの
@code{To}、@code{From}、(もしくは @code{Reply-to}) と、@code{Cc} の
すべての人に返答をすることです。

@item S W
@kindex S W (概略)
@findex gnus-summary-wide-reply-with-original
現在の記事に本記事を含んだ広い返答のメールを送ります
(@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引数の
習慣を使います。

@item S o m
@kindex S o m (概略)
@findex gnus-summary-mail-forward
@c @icon{gnus-summary-mail-forward}
誰か他の人に現在の記事を転送します (@code{gnus-summary-mail-forward})。
接頭引数があると、転送記事の完全なヘッダーを取り込みます。

@item S m
@itemx m
@kindex m (概略)
@kindex S m (概略)
@findex gnus-summary-mail-other-window
@c @icon{gnus-summary-mail-originate}
誰か他の人にメールを送ります (@code{gnus-summary-mail-other-window})。

@item S D b
@kindex S D b (概略)
@findex gnus-summary-resend-bounced-mail
@cindex bouncing mail
メールを送ったのに、何らかの理由 (間違ったアドレス、一時的な失敗) で戻っ
てきたときに、この命令を使って戻ってきたメールをもう一回送ることができま
す (@code{gnus-summary-resend-bonced-mail})。 もう一度メールを送る前にヘッ
ダーを編集できるように、メールバッファにそのメールが現れるでしょう。この
命令に接頭引数を与えて、戻ってきたメールが誰かへの返答であった場合、gnus
はそのメールを取得して、それのヘッダーの精密調査ができるように画面に表示
します。ま、これはとてもよく失敗しますけど。

@item S D r
@kindex S D r (概略)
@findex gnus-summary-resend-message
上の命令と混同しないように、@code{gnus-summary-resend-message} は現在の
メッセージを送る先のアドレスの入力を促し、それからその場所にメールを送り
ます。メッセージのヘッダーは変更されません---しかし、@code{Resent-To}、
@code{Resent-From} 等のヘッダーが付け加えられます。これは、(おそらく) あ
なた自身を @code{To} ヘッダーに書いた本人にもメールを送ってしまうという
ことです。これは混乱を招くでしょう。ですから、もちろん、本当に 邪悪 な気
分のときにだけこれを使うでしょう。

この命令は主に、あなたがいくつかのメールアカウント (account) を持ってい
て、自分自身の違ったアカウントにメールを転送したいときに用いられます。
(もしあなたが、@code{ルート} (root) であり、@code{ポストマスター}
(postmaster) でもあり、@code{ルート} に @code{ポストマスター} へのメール
を受け取った場合は、それを @code{ポストマスター} にも再送したいと思うで
しょう。Ordnung mu_ sein!)

この命令はプロセス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S O m
@kindex S O m (概略)
@findex gnus-uu-digest-mail-forward
現在の一連の記事 (@pxref{Decoding Articles}) の要約を作り、メールでその
結果を送ります (@code{gnus-uu-digest-mail-forward})。 この命令はプロセス
/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S M-c
@kindex S M-c (概略)
@findex gnus-summary-mail-crosspost-complaint
@cindex crossposting
@cindex excessive crossposting
現在の記事の書き手に、過剰クロスポストへの苦情のメールを送ります
(@code{gnus-summary-mail-crosspost-complaint})。

@findex gnus-crosspost-complaint
この命令は、現在 Usenet に横行している、クロスポストの世界的流行に対して
反撃を行う手段として提供されています。これは変数
@code{gnus-crosspost-complaint} を序文にして、返答を作成します。この命令
はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) に従い、それぞれのメー
ルを送る前に送信するかどうかの確認をします。

@end table


@node Summary Post Commands
@subsection 概略の投稿命令
@cindex post
@cindex composing news

ニューズの記事を投稿するための命令:

@table @kbd
@item S p
@itemx a
@kindex a (概略)
@kindex S p (概略)
@findex gnus-summary-post-news
@c @icon{gnus-summary-post-news}
現在のグループに記事を投稿します (@code{gnus-summary-post-news})。

@item S f
@itemx f
@kindex f (概略)
@kindex S f (概略)
@findex gnus-summary-followup
@c @icon{gnus-summary-followup}
現在の記事のフォローアップを投稿します (@code{gnus-summary-followup})。

@item S F
@itemx F
@kindex S F (概略)
@kindex F (概略)
@c @icon{gnus-summary-followup-with-original}
@findex gnus-summary-followup-with-original
本記事を取り込んで、現在の記事にフォローアップをします
(@code{ggnus-summary-followup-with-original})。 この命令はプロセス/接頭
引数の習慣を用います。

@item S n
@kindex S n (概略)
@findex gnus-summary-followup-to-mail
メールのメッセージを受け取っていたとしても、本記事を引用して、現在の記事
のフォローアップをニューズに投稿します
(@code{gnus-summary-followup-to-mail-with-original})。
この命令はプロセス/接頭引数の習慣を用います。

@item S o p
@kindex S o p (概略)
@findex gnus-summary-post-forward
現在の記事をニューズグループに転送します
(@code{gnus-summary-post-forward})。接頭引数が与えられたときは、転送記事
のヘッダーを完全に取り込みます。

@item S O p
@kindex S O p (概略)
@findex gnus-uu-digest-summary-post-forward
@cindex digests
@cindex making digests
現在の一連の記事を要約して、その結果をニューズグループに送ります
(@code{gnus-uu-digest-mail-forward})。この命令はプロセス/接頭引数の習慣
を用います。

@item S u
@kindex S u (概略)
@findex gnus-uu-post-news
@c @icon{gnus-uu-post-news}
ファイルを Uuencode し、分割して、組にして投稿します
(@code{gnus-uu-post-news})。(@pxref{Uuencoding and Posting})。
@end table


@node Canceling and Superseding
@section 記事を取り消す
@cindex canceling articles
@cindex superseding articles

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなければ
なぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニューズの投稿は取り消す
ことができます。

@findex gnus-summary-cancel-article
@kindex C (概略)
@c @icon{gnus-summary-cancel-article}
取り消したい記事を見つけてください (取り消すことができるのは自分の記事だ
けです。変なことは試さないでください)。それから、 @kbd{C} か @kbd{S c}
を押してください (@code{gnus-summary-cancel-article})。 あなたの記事が取
り消されます---世界中の機械があなたの記事を取り消します。この命令はプロ
セス/接頭引数の習慣を用います (@pxref{Process/Prefix})。

しかし、注意してほしいのはすべてのサイト (site) が取り消しを扱っているわ
けではないことです。ですから、たいていのサイトが問題の記事を取り消しても、
あちこちであなたの記事は生き残るかもしれません。

Gnus は、取り消すときに ``現在'' の選択方法を使います。標準の投稿方法を
使いたいのであれば、文字接頭引数 @samp{a} を使ってください
(@pxref{Symbolic Prefixes})。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、@dfn{代替} 記
事を投稿して本記事を置き換えることができます。

@findex gnus-summary-supersede-article
@kindex S (概略)
本記事のところへ移動して、@kbd{S s} を押してください
(@code{gnus-summary-supersede-article})。普通の方法でそれを送る前に、記
事を好きなように編集することができます。代替に関しても、取り消しと同じこ
とが当てはまります。こちらの方がもっとよく当てはまるかもしれません: いく
つかのサイトは代替を受け付けません。これらのサイトでは、あなたがほとんど
同じ記事を2回投稿したようになります。

もしさっき記事を投稿したばかりですぐに変更したくなた場合、記事が最初にあ
なたのサイトに現れる前に取り消し/代替をするための巧妙な手段があります。
まず、投稿バッファ (@code{*sent ... *} のようになっています) に戻ります。
そこにはあなたがちょうど投稿した記事があり、すべてのヘッダーがそのままあ
ります。それらの中の @code{Message-ID} という語のところを変更することに
よって @code{Message-ID} ヘッダーを @code{Cancel} もしくは
@code{Supersedes} に変更してください。

ちょっと覚えておいてください: 'supersede' (代替) という語の中に 'c' は無
いということを。


@node Marking Articles
@section 記事に印を付ける
@cindex article marking
@cindex article ticking
@cindex marks

記事に付けられる印はいくつかあります。

記事の @dfn{購読度} (おぉ、ニート・キーノ新語句だ!) を決定する印がありま
す。英字の印は一般的には @dfn{既読} を意味し、英字でない文字は一般的に
@dfn{未読} を意味します。

加えて、購読度に影響しない印もあります。

@menu
* Unread Articles::      未読記事への印
* Read Articles::        既読記事への印
* Other Marks::          購読度に影響しない印
@end menu

@ifinfo
これらの印を操作する過剰なくらいの命令があります:
@end ifinfo

@menu
* Setting Marks::           印の付け方と消し方
* Setting Process Marks::   後の実行のための記事の印の付け方
@end menu


@node Unread Articles
@subsection 未読記事

以下の印はいろいろな方法で記事に未読の (ような) 印を付けます。

@table @samp
@item !
@vindex gnus-ticked-mark
可視記事 (Ticked article} として印をつけます (@code{gnus-ticked-mark})。

@dfn{可視記事} とは、常に可視状態である記事のことです。おもしろいと思
う記事があった場合や、単に読むのを先に延ばしたいときや、後で返答をしたい
ときに、普通は可視印を付けます。しかし、記事は期限切れ消去されることもあ
りますので、永遠に記事を保存しておきたい場合は、その記事を永続にする必要
があります (@pxref{Persistent Articles})。

@item ?
@vindex gnus-dormant-mark
保留として印を付けます (@code{gnus-dormant-mark})。

@dfn{保留記事} はフォローアップがあったときにだけ概略バッファに現れます。
フォローアップが無いときも表示させたいときは、命令 @kbd{/ D} を使うこと
ができます。

@item SPACE
@vindex gnus-unread-mark
未読として印を付けます (@code{gnus-unread-mark})。

@dfn{未読記事} は今まで全く読まれていない記事のことです。
@end table


@node Read Articles
@subsection 既読記事
@cindex expirable mark

以下のすべての印は記事に既読の印を付けます。

@table @samp

@item r
@vindex gnus-del-mark
利用者が手動やそのようなもので命令 @kbd{d} によって既読の印を付けた記事
です (@code{gnus-del-mark})。

@item R
@vindex gnus-read-mark
実際に読まれた記事 (@code{gnus-read-mark})。

@item O
@vindex gnus-ancient-mark
前回のセッションで既読の印を付けて、今は @dfn{古く} なってしまった記事。

@item K
@vindex gnus-killed-mark
削除の印 (@code{gnus-killed-mark})。

@item X
@vindex gnus-kill-file-mark
削除ファイルによって削除の印がついた記事
(@code{gnus-kill-file-mark})。

@item Y
@vindex gnus-low-score-mark
低すぎるスコアのために既読の印がついた記事
(@code{gnus-low-score-mark})。

@item C
@vindex gnus-catchup-mark
キャッチアップによって既読の印がついた記事
(@code{gnus-catchup-mark})。

@item G
@vindex gnus-canceled-mark
取り消された記事 (@code{gnus-canceled-mark})。

@item F
@vindex gnus-souped-mark
@sc{SOUP} されている記事 (@code{gnus-souped-mark})。 @xref{SOUP}。

@item Q
@vindex gnus-sparse-mark
まばらに参照された記事 (@code{gnus-sparse-mark})。
@xref{Customizing Threading}。

@item M
@vindex gnus-duplicate-mark
重複抑制により既読の印のついた記事 (@code{gnus-duplicated-mark})。
@xref{Duplicate Suppression}。

@end table

これらのすべての印は、本当はただ記事が既読として印がついていることを意味
するだけです。適応スコアリングをしたときには違ったように解釈されますけれ
ど。

もう一つ、特別な印があります:

@table @samp
@item E
@vindex gnus-expirable-mark
期限切れ削除可能として印のついた記事 (@code{gnus-expirable-mark})。

記事を @dfn{期限切れ削除可能} として印を付ける (もしくは、自動的にそのよ
うに印を付ける) ことは、普通のグループではあまり意味がありません---利用
者はニューズ記事の期限による削除を制御していません。しかし、例えばメール
グループでは、@dfn{期限切れ削除可能} として印のついた記事は、いつでも
gnus によって削除されることがあります。
@end table


@node Other Marks
@subsection 他の印
@cindex process mark
@cindex bookmarks

記事が読まれたかどうかには関係しない印がいくつかあります。

@itemize @bullet

@item
現在の記事にしおりを挟むことができます。あなたは猫の尿の習慣に関する長い
論文を読んでいて、それを読み終わる前に夕食を食べるために家に帰らなければ
ならなかったとしましょう。そのときに、記事にしおりを挟むことができ、次に
その記事に出くわしたときに、gnus はそのしおりのところへ移動するでしょう。
@xref{Setting Marks}

@item
@vindex gnus-replied-mark
返答をしたか、フォローアップをした (例えば、答えた) 記事はすべて2桁目に
@samp{A} の印がつきます (@code{gnus-replied-mark})。

@item
@vindex gnus-cached-mark
記事キャッシュに貯められている記事は2桁目に @samp{*} の印がつきます
(@code{gnus-replied-mark})。 @xref{Article Caching}

@item
@vindex gnus-saved-mark
(何らかの方法によって; 必ずしも宗教的というわけではなく) ``保存された'' 
記事は2桁目に @samp{S} の印がつきます (@code{gnus-saved-mark})。

@item
@vindex gnus-not-empty-thread-mark
@vindex gnus-empty-thread-mark
もし @samp{%e} の仕様が使われると、スレッドがあるかどうかは、3桁目に
@code{gnus-not-empty-thread-mark} と @code{gnus-empty-thread-mark} のそ
れぞれによって印がつきます。

@item
@vindex gnus-process-mark
最後に @dfn{プロセス印} があります。(@code{gnus-process-mark})。 いろい
ろな種類の命令がプロセス印があるとそれに対して実行されます。例えば、
@kbd{X u} (@code{gnus-uu-decode-uu}) はプロセス印の付いたすべての記事を
uudecode して、表示します。プロセス印の付いた記事は2桁目に @samp{#} があ
ります。

@end itemize

これらの ``非購読度'' の印はディフォルトではたいてい2桁目に現れるという
ことに気付いたかもしれません。ですから、キャッシュされていて、保存されて
いて、返答をした記事にプロセス印が付いている場合、どのようになるのでしょ
う?

たいしたことはありません。優先順位は次のようになっています: プロセス ->
キャッシュ -> 返答済み -> 保存。ですから、ある記事がキャッシュに入ってい
て、返答されていた場合、キャッシュ印があるだけで、返答済み印はありません。


@node Setting Marks
@subsection 印を付ける
@cindex setting marks

すべての印つけ命令は数値接頭引数を受け付けます。

@table @kbd
@item M c
@itemx M-u
@kindex M c (概略)
@kindex M-u (概略)
@findex gnus-summary-clear-mark-forward
@cindex mark as read
現在の記事から、すべての購読度印を消去します
(@code{gnus-summary-clear-mark-forward})。要するに、記事に未読の印を付け
ます。

@item M t
@itemx !
@kindex ! (概略)
@kindex M t (概略)
@findex gnus-summary-tick-article-forward
現在の記事に可視記事印を付けます
(@code{gnus-summary-tick-article-forward})。 @xref{Article Caching}

@item M ?
@item ?
@kindex ? (概略)
@kindex M ? (概略)
@findex gnus-summary-mark-as-dormant
現在の記事に保留記事印を付けます
(@code{gnus-summary-mark-as-read-forward})。

@item D
@kindex D (概略)
@findex gnus-summary-mark-as-read-backward
現在の記事に既読の印を付け、前の行にポイントを移動します
(@code{gnus-summary-mark-as-read-backward})。

@item M k
@itemx k
@kindex k (概略)
@kindex M k (概略)
@findex gnus-summary-kill-same-subject-and-select
現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未読記事
を選択します (@code{gnus-summary-kill-same-subject-and-select})。

@item M K
@itemx C-k
@kindex M K (概略)
@kindex C-k (概略)
@findex gnus-summary-kill-same-subject
現在の記事と同じ表題を持つすべての記事を既読として印を付けます
(@code{gnus-summary-kill-same-subject})。

@item M C
@kindex M C (概略)
@findex gnus-summary-catchup
@c @icon{gnus-summary-catchup}
すべての未読記事に既読の印を付けます (@code{gnus-summary-catchup})。

@item M C-c
@kindex M C-c (概略)
@findex gnus-summary-catchup-all
グループのすべての記事に---可視記事や保留記事でさえも、既読の印を付けま
す (@code{gnus-summary-catchup-all})。

@item M H
@kindex M H (概略)
@findex gnus-summary-catchup-to-here
現在のグループのポイントまでを既読として印を付けます
(@code{gnus-summary-catchup-to-here})。

@item C-w
@kindex C-w (概略)
@findex gnus-summary-mark-region-as-read
ポイントとマークの間の記事に既読の印を付けます
(@code{gnus-summary-mark-region-as-read})。

@item M V k
@kindex M V k (概略)
@findex gnus-summary-kill-below
ディフォルトのスコア (もしくは数値接頭引数) よりも低いスコアの記事を削除
します。

@item M e
@itemx E
@kindex M e (概略)
@kindex E (概略)
@findex gnus-summary-mark-as-expirable
現在の記事を期限切れ削除可能として印を付けます
(@code{gnus-summary-mark-as-expirable})。

@item M b
@kindex M b (概略)
@findex gnus-summary-set-bookmark
現在の記事にしおりを設定します (@code{gnus-summary-set-bookmark})。

@item M B
@kindex M B (概略)
@findex gnus-summary-remove-bookmark
現在の記事のしおりを削除します (@code{gnus-summary-remobe-bookmark})。

@item M V c
@kindex M V c (概略)
@findex gnus-summary-clear-above
ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持つ記事
のすべての印を消去します (@code{gnus-summary-clar-above})。

@item M V u
@kindex M V u (概略)
@findex gnus-summary-tick-above
ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持つすべ
ての記事に可視印を付けます (@code{gnus-summary-tick-above})。

@item M V m
@kindex M V m (概略)
@findex gnus-summary-mark-above
印の入力を促し、ディフォルトのスコア (もしくは数値接頭引数) よりも大きな
スコアを持つすべての記事にその印を付けます
(@code{gnus-summary-mark-above})。
@end table

@vindex gnus-summary-goto-unread
変数 @code{gnus-summary-goto-unread} は印が付けられた後にどのような動作
がなされるかを決定します。もし @code{nil} でないと、ポイントは次/前の未
読記事に移動します。もし @code{nil} であると、ポイントは一行上か下に行く
だけです。特別な場合として、この変数が @code{never} であると、すべての印
を付ける命令と (@kbd{SPACE} のような) 他の命令は次の記事が未読であろうが
無かろうがその記事に移動します。ディフォルトは @code{t} です。


@node Setting Process Marks
@subsection プロセス印を付ける
@cindex setting process marks

@table @kbd

@item M P p
@itemx #
@kindex # (概略)
@kindex M P p (概略)
@findex gnus-symmary-mark-as-processable
現在の記事にプロセス印を付けます
(@code{gnus-summary-mark-as-processable})。
@findex gnus-summary-unmark-as-processable

@item M P u
@itemx M-#
@kindex M P u (概略)
@kindex M-# (概略)
もし現在の記事にプロセス印があれば取り除きます
(@code{gnus-summary-unmark-as-processable})。

@item M P U
@kindex M P U (概略)
@findex gnus-summary-unmark-all-processable
すべての記事からプロセス印を取り除きます
(@code{gnus-summary-unmark-all-processable})。

@item M P i
@kindex M P i (概略)
@findex gnus-uu-invert-processable
プロセス印の付いている記事とそうでない記事を逆にします
(@code{gnus-uu-mark-by-regexp})。

@item M P R
@kindex M P R (概略)
@findex gnus-uu-mark-by-regexp
正規表現によって記事に印を付けます (@code{gnus-uu-mark-by-regexp})。

@item M P r
@kindex M P r (概略)
@findex gnus-uu-mark-region
リージョンの記事に印を付けます (@code{gnus-uu-mark-region})。

@item M P t
@kindex M P t (概略)
@findex gnus-uu-mark-thread
現在の (副) スレッドのすべての記事に印を付けます
(@code{gnus-uu-mark-thread})。

@item M P T
@kindex M P T (概略)
@findex gnus-uu-unmark-thread
現在の (副) スレッドのすべての記事から印を取り除きます
(@code{gnus-uu-unamrk-thread})。

@item M P v
@kindex M P v (概略)
@findex gnus-uu-mark-over
接頭引数よりも大きなスコアを持つすべての記事に印を付けます
(@code{gnus-uu-mark-over})。

@item M P s
@kindex M P s (概略)
@findex gnus-uu-mark-series
現在の一連の記事に印を付けます (@code{gnus-uu-mark-series})。

@item M P S
@kindex M P S (概略)
@findex gnus-uu-mark-sparse
既にいくつか印の付いた記事を持つ一連の記事群全てに印を付けます
(@code{gnus-uu-mark-sparse})。

@item M P a
@kindex M P a (概略)
@findex gnus-uu-mark-all
一連の記事が出てくる順番にそれに属するすべての記事に印を付けます
(@code{gnus-uu-mark-all})。

@item M P b
@kindex M P b (概略)
@findex gnus-uu-mark-buffer
バッファのすべての記事を現れている順番に印を付けます
(@code{gnus-uu-mark-buffer})。

@item M P k
@kindex M P k (概略)
@findex gnus-summary-kill-process-mark
現在のプロセス印をスタックに積んで、すべての記事を無印にします
(@code{gnus-summary-kill-process-mark})。

@item M P y
@kindex M P y (概略)
@findex gnus-summary-yank-process-mark
スタックから前回のプロセス印を取り出して、それを復元します
(@code{gnus-summary-yank-process-mark})。

@item M P w
@kindex M P w (概略)
@findex gnus-summary-save-process-mark
現在のプロセス印をスタックに積みます
(@code{gnus-summary-save-process-mark})。

@end table


@node Limiting
@section 制限をする
@cindex  limiting

概略バッファが現在グループにある記事の一部だけを表示するように制限できれ
ば便利なことがあります。多くの制限命令が持つ効果は概略バッファから少し 
(もしくは多く) の記事を概略バッファから削除することです。

すべての制限命令はサーバーから既に取得された記事の一部分に作用します。こ
れらの命令はどれもサーバーに追加の記事を要求しません。

@table @kbd

@item / /
@itemx / s
@kindex / / (概略)
@findex gnus-summary-limit-to-subject
概略バッファをいくつかの表題と合致するものだけに制限します
(@code{gnus-summary-limit-to-subject})。

@item / a
@kindex / a (概略)
@findex gnus-summary-limit-to-author
概略バッファを何人かの著者に合致するものだけに制限します
(@code{gnus-summary-limit-to-author})。

@item / u
@itemx x
@kindex / u (概略)
@kindex x (概略)
@findex gnus-summary-limit-to-unread
概略バッファを既読の印が付いていない記事に制限します
(@code{gnus-summary-limit-to-unread})。もし接頭引数が与えられれば、バッ
ファを厳密に未読記事のみに制限します。これは、可視と保留の記事は含まれな
いということです。

@item / m
@kindex / m (概略)
@findex gnus-summary-limit-to-marks
印を尋ねて、その印が付いていない記事に制限します
(@code{gnus-summary-limit-to-marks})。

@item / t
@kindex / t (概略)
@findex gnus-summary-limit-to-age
数字を尋ねて、概略バッファをその数字の日より古い (もしくは同じ) 記事に制
限します (@code{gnus-summary-limit-to-marks})。もし接頭引数が与えられれ
ば、その数字の日よりも新しい記事に制限します。

@item / n
@kindex / n (概略)
@findex gnus-summary-limit-to-articles
概略バッファを現在の記事に制限します
(@code{gnus-summary-limit-to-articles})。プロセス/接頭引数の習慣を使いま
す (@pxref{Process/Prefix})。

@item / w
@kindex / w (概略)
@findex gnus-summary-pop-limit
前の制限をスタックから取り出して、復元します
(@code{gnus-summary-pop-limit})。もし接頭引数を与えられれば、すべての制
限をスタックから取り出します。

@item / v
@kindex / v (概略)
@findex gnus-summary-limit-to-score
概略バッファをあるスコアと同じか、それより大きなスコアを持つ記事に制限し
ます (@code{gnus-summary-limit-to-score})。

@item / E
@itemx M S
@kindex M S (概略)
@kindex / E (概略)
@findex gnus-summary-limit-include-expunged
すべての消去された記事を表示します
(@code{gnus-summary-limit-include-expunged})。

@item / D
@kindex / D (概略)
@findex gnus-summary-limit-include-dormant
すべての保留記事を表示します (@code{gnus-summary-limit-include-dormant})。

@item / *
@kindex / * (概略)
@findex gnus-summary-limit-include-cached
すべてのキャッシュに入っている記事を表示します
(@code{gnus-summary-limit-include-cached})。

@item / d
@kindex / d (概略)
@findex gnus-summary-limit-exclude-dormant
すべての保留記事を隠します (@code{gnus-summary-limit-exclude-dormant})。

@item / T
@kindex / T (概略)
@findex gnus-summary-limit-include-thread
現在のスレッドのすべての記事を表示します
(@code{gnus-summary-limit-include-thread})。

@item / c
@kindex / c (概略)
@findex gnus-summary-limit-exclude-childless-dormant
子記事の無いすべての保留記事を隠します
(@code{gnus-summary-limit-exclude-childless-dormant})。


@item / C
@kindex / C (概略)
@findex gnus-summary-limit-mark-excluded-as-read
すべての未読のみの印の記事を既読として印を付けます
(@code{gnus-summary-limit-mark-excluded-as-read})。もし接頭引数が与えら
れれば、可視と保留のみの印の記事も既読として印を付けます。

@end table


@node Threading
@section スレッド
@cindex threading
@cindex article threading

Gnus はディフォルトで記事をスレッドにします。@dfn{スレッドにする} とは、
ある記事への応答を応答した記事の直後に置く---階層的流儀で ということです。

スレッドは記事の @code{References} ヘッダーを調べることによって行われま
す。完全な世界では、これだけで良い木を作り上げるのに十分なのですが、不運
なことに、@code{References} ヘッダーはしばしば壊れているか、時には単にな
いということがあります。不思議なニューズの増殖が問題を増やしますので、喜
ばしい結果を得るためには他の発見法を採用しなければなりません。過剰な対策
法は存在していて、その恐るべき詳細は @pxref{Customizing Threading} に詳
しく書いてあります。

まず、概念の概観です:

@table @dfn
@item ルート (root)
スレッドで一番頂点にある記事です; スレッドの最初の記事です。

@item スレッド (thread)
木のような記事の構成です。

@item 副スレッド (sub-thread)
木のような構造の (より) 小さな部分です。

@item 無束縛スレッド (loose threads)
記事の期限切れ削除や、ルートが既に前回のセッションで読まれたことにより概
略バッファに表示されない、等の理由により、スレッドはしばしばルートを失い
ます。そのようなときには、普通は多くの副スレッドがあって、本当は1つのス
レッドに属しているのですが、ルートにはつながっていない、ということになり
ます。こういうスレッドが無束縛スレッドと呼ばれています。

@item スレッド集め (thread gathering)
まばらスレッドを大きなスレッドに集めようとする試みです。

@item まばらスレッド (sparse threads)
無い記事が ''推測された'' スレッドで、概略バッファに空行で表示されます。

@end table


@menu
* Customizing Threading::     変更可能なスレッドに影響する変数
* Thread Commands::           概略バッファでのスレッドに基づいた命令
@end menu


@node Customizing Threading
@subsection スレッドをカスタマイズする
@cindex customizing threading

@menu
* Loose Threads::        Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::   スレッドを埋める
* More Threading::       スレッドをいじくるさらに多くの変数
* Low-Level Threading::  これで終わったと思ったでしょう... でもあなたは間違っていた!
@end menu


@node Loose Threads
@subsection 無束縛スレッド
@cindex <
@cindex >
@cindex loose threads

@table @code
@item gnus-summary-make-false-root
@vindex gnus-summary-make-false-root
もし @code{nil} でないと、gnus は全てのつながっていない副木を1つの大きな
木にして、頂上にみせかけのルートを作ります。 (ちょっと待ってください。頂
上に根元 (root) ですって? ええ、そうなのです。) つながっていない副木は本
当のルートが期限切れ削除されたか、前回のセッションでルートを読んだり削除
したときにできます。

本当のスレッドが無いときは、gnus は何かでっち上げをする必要があります。
この変数は gnus が使うべきごまかしの方法を示しています。値としてとること
ができる4つの候補があります。

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{390}{
\put(0,0){\epsfig{figure=tmp/summary-adopt.ps,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=tmp/summary-empty.ps,width=7.5cm}}}
\put(0,400){\makebox(0,0)[tl]{\epsfig{figure=tmp/summary-none.ps,width=7.5cm}}}
\put(445,400){\makebox(0,0)[tr]{\epsfig{figure=tmp/summary-dummy.ps,width=7.5cm}}}
}
@end iflatex
@end iftex

@cindex adopting articles

@table @code

@item 養子 (adopt)
Gnus は最初の孤児を親にします。この親はすべての他の記事を養子にします。
この養子記事は、標準の角括弧 (@samp{[]}) の代わりに、先の尖った括弧
(@samp{<>}) で印付けられます。これがディフォルトの方法です。

@item みせかけ (dummy)
@vindex gnus-summary-dummy-line-format
Gnus は親のふりをするみせかけの概略行をつくります。みせかけの行はどの本
当の記事にも対応しませんので、それを選択することは、みせかけの記事の後の
最初の本当の記事を選択をするだけになります。みせかけのルートの様式を指定
するために、 @code{gnus-summary-dummy-line-format} が使われます。これは
たった一つだけのフォーマットの仕様を受け付けます: @samp{S} で、これは記
事の表題です。 @xref{Formatting Variables}。

@item 空 (empty)
Gnus は実際にはどの記事も親にはせず、単に最初の孤児を除いてすべての孤児
の表題欄を空のままにします。 (実際は、 @code{gnus-summary-same-subject} 
を表題として使います。 (@pxref{Summary Buffer Format})。)

@item none
全くどの記事も親にしません。スレッドを集めて、一つの記事の後に他の記事を
表示するだけです。

@item nil
無束縛スレッドを集めません。
@end table

@item gnus-summary-gather-subject-limit
@vindex gnus-summary-gather-subject-limit
無束縛スレッドは記事の表題を比較することによって集められます。もしこの変
数が @code{nil} であると、gnus は無束縛スレッドを一つの大きな超スレッド
に集める前に、無束縛スレッドの表題が完全に一致することを要求します。これ
は、長い表題の行を切り落としてしまう間抜けなニューズリーダーが存在する現
在では、あまりに厳しい要求かも知れません。もしそう思うのなら、この変数を
例えば20に設定して、表題の最初の20文字だけが一致することを要求するように
することができます。この変数を本当に低い数字に設定すると、gnus が目に入
る全てを一つのスレッドに集めるのを見ることができるでしょう。そして、それ
はあまり有用ではありません。

@cindex fuzzy article gathering
この変数を特別な値 @code{fuzzy} に設定すれば、gnus は表題にあいまいな文
字列比較アルゴリズムを使います (@pxref{Fuzzy Matching})。

@item gnus-sumplify-subject-fuzzy-regexp
@vindex gnus-simplify-subject-fuzzy-regexp
これは正規表現か、あいまい表題指定が使われているときに表題から合致したも
のが取り除かれる、正規表現のリストであることができます。

@item gnus-simplify-ignored-prefixes
@vindex gnus-simplify-igonored-prefixes
もし @code{gnus-summary-gather-subject-limit} を10くらいに低く設定したな
らば、この変数を何か意味のあるものに設定することを考えるでしょう:

@c Written by Michael Ernst <mernst@cs.rice.edu>
@lisp
(setq gnus-simplify-ignored-prefixes
      (concat
       "\\`\\[?\\("
       (mapconcat
        'identity
        '("looking"
          "wanted" "followup" "summary\\( of\\)?"
          "help" "query" "problem" "question"
          "answer" "reference" "announce"
          "How can I" "How to" "Comparison of"
          ;; ...
          )
        "\\|")
       "\\)\\s *\\("
       (mapconcat 'identity
                  '("for" "for reference" "with" "about")
                  "\\|")
       "\\)?\\]?:?[ \t]*"))
@end lisp

この正規表現に合致するすべての語は、2つの表題を比較する前に取り除かれます。

@item gnus-simplify-subject-functions
@vindex gnus-simplify-subject-functions
@code{nil} でないと、この変数は @code{gnus-summary-gather-subject-limit} 
を上書きします。この変数は文字列 @code{Subject} を反復して簡単な形にたど
り着くために適用する関数のリストである必要があります。

このリストに入れて役に立つような関数は次のようなものです:

@table @code
@item gnus-simplify-subject-re
@findex gnus-simplify-subject-re
前の方にある @samp{Re:} を取り除きます。

@item gnus-simplify-subject-fuzzy
@findex gnus-simplify-subject-fuzzy
あいまいに簡単にします。

@item gnus-simplify-whitespace
@findex gnus-simplify-whitespace
余分な空白 (whitespace) を取り除きます。
@end table

もちろん、あなた自身の関数を書くこともできます。


@item gnus-summary-gather-exclude-subject
@vindex gnus-summary-gather-exclude-subject
無束縛スレッド集めは表題のみに行われますので、特に @samp{} や 
@samp{(none)}のような良くある表題のときは、多くの間違いを起こす可能性が
あります。この状況を少しよくするために、どの表題が集める過程から除かれる
かを決める正規表現 @code{gnus-summary-gather-exclude-subject} を使うこと
ができます。ディフォルトは @samp{^ *$\\|^(none)$} です。


@item gnus-summary-thread-gathering-funcion
@vindex gnus-summmary-thread-gathering-function
Gnus は @code{Subject} ヘッダーを見ることによってスレッドを集めます。こ
れは、結果的に全く関係の無い記事が同じ ``スレッド'' に含まれることがある
ということで、これは混乱の元です。代替手段は、合致するものを見つけるため
に @code{References} ヘッダーにある @code{Message-ID} をすべて探すことで
す。これは関係の無い記事が集められたスレッドに含まれることは全く無いこと
を保証しますが、こわれたニューズリーダーで投稿した記事は適切に集められな
いということでもあります。選択権はあなたにあります---疫病かコレラか。

@table @code
@item gnus-gather-threads-by-subject
@findex gnus-gather-threads-by-subject
この関数はディフォルトの収集関数で、排他的に @code{Subject} を見ます。

@item gnus-gather-threads-by-references
この関数は排他的に @code{References} ヘッダーを見ます。
@end table

@code{References} によって集めることを試してみたいのであれば、次のように
することができます:

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp

@end table


@node Filling In Threads
@subsubsection スレッドを埋める

@table @code
@item gnus-fetch-old-headers
@vindex gnus-fetch-old-headers
もし @code{nil} でないと、gnus は古いスレッドをもっと古いヘッダー---既読
印の付いている記事のヘッダー を取得することで大きくしようとします。もし
できるだけ少ない概略行を表示したいけれど、できるだけたくさんの非密スレッ
ドに接続しておきたいときは、この変数を @code{some} か数字に設定すること
ができます。もし数字に設定したときは、それより多い追加のヘッダーは取得さ
れません。どちらの場合でも、古いヘッダーの取得が動作するのは、使っている
バックエンド (backend) が overview ファイルを使っているかどうかです---こ
れは普通は @code{nntp}、@code{nnspool} と @code{nnml} です。スレッドのルー
トがサーバーによって期限切れ削除されたときは、gnus はどうしようもないこ
とを覚えておいてください。

この変数は @code{invisible} に設定することもできます。これは視覚的な効果
は何もありませんが、命令 @kbd{A T} をよく使うのであれば役に立つでしょう
(@pxref{Finding the Parent})。

@item gnus-build-sparse-threads
@vindex gnus-build-sparse-threads
古いヘッダーを取得すると遅くなることがあります。同じような低賃金の効果を
得るために、この変数を @code{some} に設定することができます。そうすると、
gnus は全ての記事の完全な @code{References} ヘッダーを見て、同じスレッド
に属する記事をつなごうとします。これは gnus が記事がスレッドから失われて
いると推測したところのスレッド表示に @dfn{ずれ} を残すでしょう。 (これら
のずれは普通の概略行のように現れます。もしずれを選択したときは、 gnus は
その当の記事を取得しようとします。) この変数が @code{t} であると、gnus
は全ての ``ずれ'' をスレッドを補完するのに役に立つかを考慮せずに表示しま
す。最後に、この変数が @code{more} であると、 gnus はどこにもつながって
いない枝葉のまばらな節を切り落としません。この変数はディフォルトでは
@code{nil} です。

@end table


@node More Threading
@subsection もっとスレッドを

@table @code
@item gnus-show-threads
@vindex gnus-show-threads
この変数が @code{nil} であると、スレッドは作られず、ここにある残りのすべ
ての変数は全く効果が無くなります。スレッド作りを止めるとグループの選択が
少し速くなりますが、記事を読むのがもっと遅く、不便になることは確実です。

@item gnus-thread-hide-subtree
@vindex gnus-thread-hide-subtree
これが @code{nil} でないと、すべてのスレッドは概略バッファが生成されたと
きに隠れます。

@item gnus-thread-expunge-below
@vindex gnus-thread-expunge-below
この数字より少ない総合的スコア (@code{gnus-thread-score-function}) を持
つすべてのスレッドは消去されます。この変数はディフォルトでは @code{nil}
で、これはどのスレッドも消去されないということです。

@item gnus-thread-hide-killed
@vindex gnus-thread-hide-killed
もしスレッドを削除して、この変数が @code{nil} でないと、副木は隠されます。

@item gnus-thread-ignore-subject
@vindex gnus-thread-ignore-subject
時々、誰かがスレッドの真中で表題を変更することがあります。もしこの変数が
@code{nil} でないと、表題の変更は無視されます。もし @code{nil} だと、こ
れがディフォルトですが、表題の変更をすると別のスレッドになります。

@item gnus-thread-indent-level
@vindex gnus-thread-indent-level
この数字は副スレッドがどれくらい字下げ (indent) されるべきかを決めます。
ディフォルトは4です。

@end table


@node Low-Level Threading
@subsection 低レベルにおけるスレッド作成

@table @code

@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
すべてのヘッダーを解析する前に実行されるフックです。ディフォルトの値は
@code{(gnus-set-summary-default-charset)} です。これは変数 
@code{gnus-newsgroup-default-charset-alist} で指定されている値から概略バッ
ファの @code{default-mime-charset} を設定します。

@item gnus-alter-header-function
@vindex gnus-alter-header-function
これが @code{nil} でないと、ヘッダー構造の交換を可能にするようにこの関数
が呼ばれます。関数は一つの引数、記事ヘッダーのベクトル、とともに呼ばれ、
それが何らかの方法で交換されます。例えば、(接頭語やその他のものを付け加
えることによる) 体系的な方法で @code{Message-ID} を交換するメールからニュー
ズへのゲートウェイがある場合、@code{Message-ID} がもっと意味のあるものに
するために、この変数を設定して元に戻すことができます。これは一つの例です:

@lisp
(setq gnus-alter-header-function 'my-alter-message-id)

(defun my-alter-message-id (header)
  (let ((id (mail-header-id header)))
    (when (string-match
           "\\(<[^<>@@]*\\)\\.?cygnus\\..*@@\\([^<>@@]*>\\)" id)
      (mail-header-set-id
       (concat (match-string 1 id) "@@" (match-string 2 id))
       header))))
@end lisp

@end table


@node Thread Commands
@subsection スレッドの命令
@cindex thread commands

@table @kbd

@item T k
@itemx M-C-k
@kindex T k (概略)
@kindex M-C-k (概略)
@findex gnus-summary-kill-thread
現在の (副) スレッドに既読の印を付けます
(@code{gnus-summary-kill-thread})。もし接頭引数が正であると、代わりにす
べての印を取り除きます。接頭引数が負であると、代わりに記事を可視にします。

@item T l
@itemx M-C-l
@kindex T l (概略)
@kindex M-C-l (概略)
@findex gnus-summary-lower-thread
現在の (副) スレッドのスコアを下げます
(@code{gnus-summary-lower-thread})。

@item T i
@kindex T i (概略)
@kindex gnus-summary-raise-thread
現在の (副) スレッドのスコアを上げます
(@code{gnus-summary-raise-thread})。

@item T #
@kindex T # (概略)
@findex gnus-uu-mark-thread
プロセス印を現在の (副) スレッドに付けます (@code{gnus-uu-mark-thread})。

@item T M-#
@kindex T M-# (概略)
@findex gnus-uu-unmark-thread
現在の (副) スレッドからプロセス印を取り除きます
(@code{gnus-uu-unmark-thread})。

@item T T
@kindex T T (概略)
@findex gnus-summary-toggle-threads
スレッド表示を切り替えます (@code{gnus-summary-toggle-threads})。

@item T s
@kindex T s (概略)
@findex gnus-summary-show-thread
もしあれば、現在の記事の下に隠れているスレッドを表示します
(@code{gnus-summary-show-thread})。

@item T h
@kindex T h (概略)
@findex gnus-summary-hide-thread
現在の (副) スレッドを隠します (@code{gnus-summary-hide-thread})。

@item T S
@kindex T S (概略)
@findex gnus-summary-show-all-threads
すべての隠されているスレッドを表示します
(@code{gnus-summary-show-all-threads})。

@item T H
@kindex T H (概略)
@findex gnus-summary-hide-all-threads
すべてのスレッドを隠します (@code{gnus-summary-hide-all-threads})。

@item T t
@kindex T t (概略)
@findex gnus-summary-rethread-current
現在の記事のスレッドをもう一度作り直します
(@code{gnus-summary-rethread-current})。 これは概略バッファがスレッド表
示されていないときでも動作します。

@item T ^
@kindex T ^ (概略)
@findex gnus-summary-reparent-thread
現在の記事を印付き (もしくは前の) 記事の子記事にします
(@code{gnus-summary-reparent-thread})。

@end table

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付けま
す。

@table @kbd

@item T n
@kindex T n (概略)
@findex gnus-summary-next-thread
次のスレッドに移動します (@code{gnus-summary-next-thread})。

@item T p
@kindex T p (概略)
@findex gnus-summary-prev-thread
前のスレッドに移動します (@code{gnus-summary-prev-thread})。

@item T d
@kindex T d (概略)
@findex gnus-summary-down-thread
スレッドを降下します (@code{gnus-summary-down-thread})。

@item T u
@kindex T u (概略)
@findex gnus-summary-up-thread
スレッドを上昇します (@code{gnus-summary-up-thread})。

@item T o
@kindex T o (概略)
@findex gnus-summary-top-thread
スレッドの頂上に移動します (@code{gnus-summary-top-thread})。
@end table

@vindex gnus-thread-operation-ignore-subject
スレッドを作成するときに表題を無視すると、自然にスレッドにはいくつかの違っ
た表題があることになります。それから `T k'
(@code{gnus-summary-kill-thread}) のような命令を発するときに、全体のスレッ
ドを削除するのではなく、現在の記事と同じ表題を持つ部分だけを削除したいと
きがあるかもしれません。もしこの発想が良いと思うのであれば、
@code{gnus-thread-operation-ignore-subject} をいじくることができます。こ
れが @code{nil} でないと (これがディフォルトですが) 、スレッドの命令を実
行しているときに表題は無視されます。この変数が @code{fuzzy} であると、あ
いまいに等しい表題を持つ記事だけが含まれます (@pxref{Fuzzy Matching})。


@node Sorting
@section 並び替え

@findex gnus-thread-sort-by-total-score
@findex gnus-thread-sort-by-date
@findex gnus-thread-sort-by-score
@findex gnus-thread-sort-by-subject
@findex gnus-thread-sort-by-author
@findex gnus-thread-sort-by-number
@vindex gnus-thread-sort-functions
もしスレッドの概略表示を使っているのであれば、関数のリストである
@code{gnus-thread-sort-functions} を設定することでスレッドを並び替えるこ
とができます。ディフォルトでは、並び替えは記事番号によってなされます。既
に作られている並び替え述語関数は @code{gnus-thread-sort-by-number}、
@code{gnus-thread-sort-by-author}、 @code{gnus-thread-sort-by-subject}、
@code{gnus-thread-sort-by-date}、 @code{gnus-thread-sort-by-score}、と 
@code{gnus-thread-sort-by-total-score} です。


それぞれの関数は2つのスレッドをとり、最初のスレッドが他のスレッドより先
に並び替えられるべきであれば、@code{nil} でない値をかえします。普通、並
び替えは本当はそれぞれのスレッドのルートを見るだけによりなされることに気
を付けてください。もし2つ以上の関数を使う場合、優先的並び替えキーはリス
トの最後の関数です。おそらくいつも @code{gnus-thread-sort-by-number} を
並び替え関数のリスト---最初が好ましい に入れておくべきでしょう。これは他
の並び替え基準に関して等しいスレッドは記事が上がっていく順番に表示される
ことを保証します。

スコア、表題、そして最後に番号、の順に並び替えたいのであれば、次のように
できます:

@lisp
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-number
        gnus-thread-sort-by-subject
        gnus-thread-sort-by-total-score))
@end lisp

最高スコアのスレッドが概略バッファの最初に表示されます。スレッドが同じス
コアの場合は、英字順に並びかえられます。スコアと表題が同じスレッドは番号
で並び替えられ、(普通は) 記事が到着した順番になります。

スコア、到着の逆順に並び替えたいのであれば、次のようにできます:

@lisp
(setq gnus-thread-sort-functions
      '((lambda (t1 t2)
          (not (gnus-thread-sort-by-number t1 t2)))
        gnus-thread-sort-by-score))
@end lisp

@vindex gnus-thread-score-function
変数 @code{gnus-thread-score-function} (ディフォルトは @code{+}) に入っ
ている関数はスレッドの総合のスコアを計算するために用いられます。役に立つ
関数は、@code{max}、 @code{min}、もしくは2乗、もしくはあなたの好奇心をく
すぐるような何かでしょう。

@findex gnus-article-sort-functions
@findex gnus-article-sort-by-date
@findex gnus-article-sort-by-score
@findex gnus-article-sort-by-subject
@findex gnus-article-sort-by-author
@findex gnus-article-sort-by-number
何か奇妙な理由などでスレッド表示を使っていないのなら、変数
@code{gnus-article-sort-functions} をいじくる必要があります。これは
@code{gnus-thread-sort-functions} と非常に似ていますが、記事の比較には少々
違った関数を使います。使用可能な並び替え述語関数は
@code{gnus-article-sort-by-number}、 @code{gnus-article-sort-by-author}、
@code{gnus-article-sort-by-subject}、 @code{gnus-article-sort-by-date}、
そして @code{gnus-article-sort-by-score} です。

スレッドを使っていない表題の概略表示を並び替えたいのであれば、次のような
ことをすることができます:

@lisp
(setq gnus-article-sort-functions
      '(gnus-article-sort-by-number
        gnus-article-sort-by-subject))
@end lisp



@node Asynchronous Fetching
@section 非同期記事取得
@cindex asynchronous article fetching
@cindex article pre-fetch
@cindex pre-fetch

もしニューズを遠くの @sc{nntp} サーバーから取得しているのであれば、ネッ
トワークの待ち時間が記事を読むことは骨の折れることにしてしまうかもしれま
せん。@kbd{n} を押して次の記事が現れるまで、しばらく待たなければなりませ
ん。どうして前の記事を読んでいる間に gnus が先に行って記事を取得しないの
でしょう? 本当に、そうした方が良いのではないのでしょうか。

まず、いくつかの警告です。非同期記事取得、特に gnus がそれを行っている方
法にはいくつかの落とし穴があります。

例えば、あなたは短い記事1を読んでいて、記事2はとても長くあなたはそれを読
むことには興味が無いとしましょう。Gnus はこのことはわからないので、先に
行って記事2を取得します。あなたは記事3を読むことにしますが、gnus は記事2
を取得している最中なので、接続は封鎖されています。

この状況を避けるために、gnus はサーバーに2つの (それは2と数えてください)
接続を張ることができます。これはあまりして良いことではないと考える人もい
るでしょうが、私には実際の代替手段が見つからないのです。余分な接続をする
ためには何らかの時間がかかりますので、gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先-取得を使わないときよりも、あなたのマシンと @sc{nntp} サーバー間
にもっと負荷がかかるということになるでしょう。サーバー自身ももっと負荷が
かかるようになります---余分な記事の要求と、余分な接続で。

はい、これで本当はこのようなことをすべきで無い事が分かったでしょう... 本
当にそうしたいと思わない限りは。

@vindex gnus-asynchronous
これが方法です:  @code{gnus-asynchronous} を @code{t} に設定してください。
残りのことは自動的に起こります。

@vindex gnus-use-article-prefetch
@code{gnus-use-article-prefetch} を設定することにより、どれくらいの記事
が先に取得されるべきかを操作することができます。これはディフォルトでは30
で、グループの記事を読んでいるときに、バックエンドが次の30記事を先-取得
するということです。この変数が @code{t} であると、バックエンドは制限無く
取得できるすべての記事を先-取得しようとします。これが @code{nil} である
と、先-取得は行われません。

@vindex gnus-async-prefetch-article-p
@findex gnus-async-read-p
おそらく、先-取得をしたくない記事がいくつかあるでしょう---例えば、既読記
事。変数 @code{gnus-async-prefetch-article-p} は記事が先に取得されるべき
かどうかを制御します。この関数は問題の記事が先-取得されるべきであれば
@code{nil} でない値をかえすべきです。ディフォルトは
@code{gnus-async-read-p} で、それは既読記事には @code{nil} をかえします。
この関数は記事のデータ構造を唯一の引数として呼ばれます。

例えば、もし100行よりも短い未読記事のみを先に取得したいのであれば、次の
ようにできます:

@lisp
(defun my-async-short-unread-p (data)
  "Return non-nil for short, unread articles."
  (and (gnus-data-unread-p data)
       (< (mail-header-lines (gnus-data-header data))
          100)))

(setq gnus-async-prefetch-article-p 'my-async-short-unread-p)
@end lisp

これらの関数は何度も何度も呼ばれますので、gnus を遅くしすぎないように、
短く甘美であるのが好ましいです。おそらく、このようなものをバイトコンパイ
ル(byte-compile) するのは良い着想でしょう。

@vindex gnus-prefetched-article-deletion-strategy
記事は非同期バッファから遅かれ早かれ削除されなければなりません。
@code{gnus-prefetched-article-deletion-strategy} はいつ記事を削除するか
を指定しています。これは以下の要素を含むようなリストです:

@table @code
@item read
記事が読まれたときに削除します。

@item exit
グループを抜けたときに記事を削除します。
@end table

ディフォルトの値は @code{(read exit)} です。

@vindex gnus-use-header-prefetch
@code{gnus-use-header-prefetch} が @code{nil} でないと、次のグループから
記事を先に取得します。


@node Article Caching
@section 記事のキャッシュ
@cindex article caching
@cindex caching

もし @emph{非常に} 遅い @sc{nntp} 接続であるならば、記事キャッシュをする
ことを考えるかもしれません。そうすると、それぞれの記事はあなたのホームディ
レクトリの下にローカルに溜めらます。既に推測されているかも知れませんが、
これは @emph{巨大な} ディスクスペースを食い、iノードも非常に速く食いつぶ
す可能性があるため、それはあなたの頭を泳がせる事になるかもしれません。
ウォッカの中で。

でも注意深く使われれば、それは記事を保存する簡単な方法になり得ます。

@vindex gnus-use-long-file-name
@vindex gnus-cache-directory
@vindex gnus-use-cache
キャッシュを実行するためには、@code{gnus-use-cache} を @code{t} に設定し
ます。ディフォルトでは、すべての可視または保留として印の付いている記事は
ローカルのキャッシュに複写されます。このキャッシュが平らな構造か階層的で
あるかは、いつもどおり、変数 @code{gnus-use-long-file-name} で制御されま
す。

可視か保留記事を再選択した場合は、サーバーの代わりにキャッシュから取得さ
れます。キャッシュにある記事は期限切れ削除されませんので、記事が属してい
るところに残したままで記事を保存する方法として使う事ができるかもしれませ
ん。保存したい記事をすべて保留の印を付けて、後は心配は要りません。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょうか。

@vindex gnus-cache-remove-articles
@vindex gnus-cache-enter-articles
キャッシュ へ入る/から削除される は変数 @code{gnus-cache-enter-articles}
と @code{gnus-cache-remove-articles} によって制御されます。これらは両方
ともシンボルのリストです。前者はディフォルトでは @code{(ticked dormant)}
で、可視と保留記事はキャッシュに入れられるという事です。後者はディフォル
トでは @code{(read)} で、既読の印が付いた記事はキャッシュから削除される
という事です。おそらくこれらの2つのリストは @code{ticked}、
@code{dormant}、@code{unread} と @code{read} からなるでしょう。

@findex gnus-jog-cache
それで、どうやって大量の記事取得と貯蓄実現されるのでしょうか。命令
@code{gnus-jog-cache} は全ての購読グループに対して、すべての未読記事を要
求し、スコアを付け、キャッシュに保存します。この命令を実際に、実際に実際
に実際に、使うのは、 1) @sc{nntp} サーバーとの接続が本当に、本当に、本当
に遅く 2)本当に、本当に、本当に巨大なディスクを持っているときだけにする
べきです。これは真面目にいっています。ダウンロードされる記事の数を少なく
する一つの方法は、欲しくない記事のスコアを低くし、既読の印を付ける事です。
そうした場合、それらはこの命令ではダウンロードされません。

@vindex gnus-uncacheable-groups
いくつかのグループではキャッシュをしたくないというのは良くある事です。例
えば、@code{nnml} メールディレクトリーがホームディレクトリーの下にあれば、
それをあなたのホームディレクトリーの下の別の場所にキャッシュするのは意味
の無い事です。あなたが2倍の容量を使う事が良いと感じない限りは。キャッシュ
を制限するために、正規表現 @code{gnus-uncacheable-groups} を例えば
@samp{^nnml} と設定してください。この変数はディフォルトでは @code{nil} 
です。

@findex gnus-cache-generate-nov-databases
@findex gnus-cache-generate-active
@vindex gnus-cache-active-file
キャッシュはどの記事が含まれているかの情報を現状ファイル (active file) 
(@code{gnus-cache-active-file}) に溜めます。このファイル (もしくはキャッ
シュの他の部分) が何らかの理由でぐちゃぐちゃになってしまった場合、gnus
は物事を正しくするために2つの関数をお勧めします。 @kbd{M-x
gnus-cache-generate-nov-databases} はすべての @sc{nov} ファイルを (再)
作成し、@kbd{gnus-cache-generate-active} は 現状ファイルを (再) 作成しま
す。


@node Persistent Articles
@section 永続記事
@cindex persistent articles
記事のキャッシュと近い関係にあるもに、@dfn{永続記事} があります。実際、
それはキャッシュの別の見方で、私の意見ではその方がもっと役に立ちます。

例えば、ニューズグループを読んでいて、そのまま永遠に保存して秘蔵したい、
いくつかの価値ある宝石に出会ったとしましょう。普通はそれをファイルに保存
します (多くの保存命令の一つを使って)。それの問題は、単にあの、嫌なだけ
です。理想的には、記事はグループであなたが見つけた場所に永遠に残っている
べきでしょう。ニューズサーバーにおける期限削除には影響されないで。

これが @dfn{永続記事} です---記事は削除されません。それは普通のキャッシュ
命令を使って実装されていますが、永続記事の管理をするために2つの明示的な
命令を使います。

@table @kbd

@item *
@kindex * (概略)
@findex gnus-cache-enter-article
現在の記事を永続にします (@code{gnus-cache-enter-article})。

@item M-*
@kindex M-* (概略)
@findex gnus-cache-remove-article
現在の記事を永続記事から取り除きます (@code{gnus-cache-remove-articles})。
これは普通は記事を削除します。
@end table

この命令は両方ともプロセス/接頭引数の習慣を理解します。

もし永続記事にだけ興味があるのでしたら、可視記事 (やその他のもの) がキャッ
シュに入るのを避けるために、@code{gnus-use-cache} を @code{passive} に設
定するのが良いでしょう:

@lisp
(setq gnus-use-cache 'passive)
@end lisp


@node Article Backlog
@section 記事のバックログ
@cindex backlog
@cindex article backlog
もし遅い接続しかない場合で、キャッシュを使うという発想はあまり魅力的では
ないとき (実際そうなのですが)、@dfn{バックログ} に切り替える事によって状
況を何とかすることができます。これは既に読んだ記事を再取得しなくて良いよ
うに、gnus が既に読んだ記事を一時保存しておくところです。これはもちろん、
あなたに最近読んだ記事を再び選択する癖があるときだけに役立ちます。もし絶
対にそれをしないのであれば、バックログをすることは gnus を少し遅くし、メ
モリーの使用量をいくらか増やします。

@vindex gnus-keep-backlog
もし @code{gnus-keep-backlog} を数字 @var{n} に設定すると、gnus は最大で 
@var{n} の古い記事を後の再取得のためにバッファに溜めておきます。この変数
が @code{nil} ではなく、数字でもない場合、gnus は @emph{全て} の既読記事
をたくわえます。これはあなたの Emacs が、暴発してあなたのマシンが落ちる
まで制限なく膨れ上がるということです。私はあなた方全てが元気でいられるよ
うにここに書き加えました。

この変数はディフォルトでは @code{nil} です。

@node Saving Articles
@section 記事の保存
@cindex saving articles

Gnus はたくさんの方法で記事を保存する事ができます。以下のものは非常に率
直な方法 (例えば、記事が保存する前にほとんど何もなされない) で記事を保存
するための説明です。違った手段 (uudecodeする、shar ファイルを展開する)
については@code{gnus-uu} を使うのが良いでしょう (@pxref{Decoding
Articles})。

@vindex gnus-save-all-headers
@code{gnus-save-all-headers} が @code{nil} でないと、gnus は記事を保存す
る前に望ましくないヘッダーを消去しません。

@vindex gnus-saved-headers
もし上の変数が @code{nil} であると、正規表現 @code{gnus-saved-headers}
に合致するすべてのヘッダーは残され、残りのものは保存する前に削除されます。

@table @kbd

@item O o
@itemx o
@kindex O o (概略)
@kindex o (概略)
@findex gnus-summary-save-article
@c @icon{gnus-summary-save-article}
ディフォルトの記事保存を用いて現在の記事を保存します
(@code{gnus-summary-save-article})。

@item O m
@kindex O m (概略)
@findex gnus-summary-save-article-mail
現在の記事をメールの様式で保存します
(@code{gnus-summary-save-article-mail})。

@item O r
@kindex O r (概略)
@findex gnus-summary-save-article-rmail
現在の記事を rmail の様式で保存します
(@code{gnus-summary-save-article-rmail})。

@item O f
@kindex O f (概略)
@findex gnus-summary-save-article-file
@c @icon{gnus-summary-save-article-file}
現在の記事を普通のファイル (plain file) 様式で保存します
(@code{gnus-summary-save-article-file})。

@item O F
@kindex O F (概略)
@findex gnus-summary-write-article-file
現在の記事を普通のファイル様式で保存し、以前のファイルの内容を上書きしま
す (@code{gnus-summary-write-article-file})。

@item O b
@kindex O b (概略)
@findex gnus-summary-save-article-body-file
現在の記事の本文 (body) を普通のファイル様式で保存します
(@code{gnus-summary-save-article-body-file})。

@item O h
@kindex O h (概略)
@findex gnus-summary-save-article-folder
現在の記事を mh のフォルダーの様式で保存します
(@code{gnus-summary-save-article-folder})。

@item O v
@kindex O v (概略)
@findex gnus-summary-save-article-vm
現在の記事を VM フォルダーに保存します
(@code{gnus-summary-save-article-vm})。

@item O p
@kindex O p (概略)
@findex gnus-summary-pipe-output
現在の記事をパイプに保存します。うーんと、あのぉ、私が言おうとしている事
は---現在の記事をプロセスにパイプするということです
(@code{gnus-summary-pipe-output})。
@end table

@vindex gnus-prompt-before-saving
すべてのこれらの命令はプロセス/接頭引数の習慣を使います
(@pxref{Process/Prefix})。もしこれらの関数を使ってたくさんの記事を保存し
た場合、それぞれのすべての記事に対してファイル名の入力を要求される事に飽
き飽きするでしょう。入力促進動作は変数 @code{gnus-prompt-before-saving} 
によって制御されます。これはディフォルトでは @code{always} で、あなたが
知っていて嫌がっている、過剰な促進動作をします。代わりにこの変数を
@code{t} に設定すると、あなたが保存するそれぞれの一連の記事に対して一回
だけ促されます。本当に gnus にすべての思考をさせたいのであれば、この変数
を@code{nil} にすることさえできます。そして、記事を保存するためのファイ
ルを促される事はありません。Gnus は単純にすべての記事をディフォルトのファ
イルに保存します。


@vindex gnus-default-article-saver
Gnus があなたの望むとおりになるように、変数 
@code{gnus-default-article-saver} をカスタマイズする事ができます。下の4
つの既製関数を使う事ができますし、自分自身の関数を作る事もできます。

@table @code

@item gnus-summary-save-in-rmail
@findex gnus-summary-save-in-rmail
@vindex gnus-rmail-save-name
@findex gnus-plain-save-name
これはディフォルトの様式、@dfn{babyl} です。変数
@code{gnus-ramil-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルトは 
@code{gnus-plain-save-name} です。


@item gnus-summary-save-in-mail
@findex gnus-summary-save-in-mail
@vindex gnus-mail-save-name
Unix メール (mbox) ファイルに保存します。変数 @code{gnus-mail-save-name}
に入っている関数を、記事を保存するためのファイル名を取得するために使用し
ます。ディフォルトは @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-file
@findex gnus-summary-save-in-file
@vindex gnus-file-save-name
@findex gnus-numeric-save-name
記事を通常のファイルの後に追加します。変数 @code{gnus-file-save-name} に
入っている関数を、記事を保存するためのファイル名を取得するために使用しま
す。ディフォルトは @code{gnus-numeric-save-name} です。

@item gnus-summary-save-body-in-file
@findex gnus-summary-save-body-in-file
記事の本体を通常のファイルの後に追加します。変数
@code{gnus-file-save-name} に入っている関数を、記事を保存するためのファ
イル名を取得するために使用します。ディフォルトは 
@code{gnus-numeric-save-name} です。


@item gnus-summary-save-in-folder
@findex gnus-summary-save-in-folder
@findex gnus-folder-save-name
@findex gnus-Folder-save-name
@vindex gnus-folder-save-name
@cindex rcvstore
@cindex MH folders
MH ライブラリーの @code{rcvstore} を用いる事によって記事を MH フォルダー
に保存します。変数 @code{gnus-folder-save-name} に入っている関数を、記事
を保存するファイル名を取得するために使用します。ディフォルトは
@code{gnus-folder-save-name} ですが、@code{gnus-Folder-save-name} も使う
事ができて、こちらは先頭が大文字、残りが小文字になった名前をつくります。

@item gnus-summary-save-in-vm
@findex gnus-summary-save-in-vm
記事を VM フォルダーに保存します。この設定を使うためには VM メールリーダー
が必要です。
@end table

@vindex gnus-article-save-directory
これらの全ての関数は最後の一つを除いて、環境変数 @code{SAVEDIR} によって
初期化される @code{gnus-article-save-directory} に記事を保存します。これ
はディフォルトでは @file{~/News/} です。

上にあるように、記事を保存するためのファイルの適切な名前を見つけるために、
関数は違った関数を用います。以下は名前を生成するために使用可能な関数のリ
ストです:

@table @code

@item gnus-Numeric-save-name
@findex gnus-Numeric-save-name
@file{~/News/Alt.andera-dworkin/45} のようなファイル名。

@item gnus-numeric-save-name
@findex gnus-numeric-save-name
@file{~/News/alt.andera-dworkin/45} のようなファイル名。

@item gnus-Plain-save-name
@findex gnus-Plain-save-name
@file{~/News/Alt.andera-dworkin} のようなファイル名。

@item gnus-plain-save-name
@findex gnus-plain-save-name
@file{~/News/alt.andera-dworkin} のようなファイル名。
@end table

@vindex gnus-split-methods
連想リスト @code{gnus-split-methods} に正規表現を放り込む事によって、
gnus に記事を保存する場所を提案する事ができます。例えば、gnus に関連した
記事をファイル @file{gnus-stuff} に、VM に関連した記事を @code{vm-stuff}
保存したければ、この変数を以下のようにする事ができます:

@lisp
(("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
 ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
 (my-choosing-function "../other-dir/my-stuff")
 ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))
@end lisp

これはそれぞれの要素が、2つの要素---@dfn{合致} と @dfn{ファイル} を持つ
リストであるリストであるという事がわかります。合致は文字列 (この場合は記
事のヘッダーに合致する正規表現として使われます) および、シンボル (グルー
プ名を引数として、関数として呼ばれます) および、リスト (これは@code{評価} 
されます) であることができます。もしこれらの動作の一つでも @code{nil} で
ない結果を返すと、@dfn{ファイル}がディフォルトの促進として使われます。加n
えて、呼ばれた関数か式が文字列か文字列のリストを返したときは、演算の結果
自体が使われます。

基本的には、現在の記事を保存するのに使われる可能性のあるファイル名のリス
トを手に入れる事になります。 (すべての ``合致'' が使われます。) それから
本当に名前として使いたいものを促され、この変数を適用する事により得られた
結果からファイル名補完をして入力します。

この変数はディフォルトでは @code{((gnus-article-archive-name))} で、gnus
保存する記事の @code{Archive-name} 行を調べて、それをファイル名の提案と
して使うという事です。

これはファイル名を少しきれいにする関数の例です。
@samp{nnml:mail.whatever} のようなメールグループがたくさんあるのであれば、
保存するためのファイル名を作る前にこれらのグループ名の最初を切り落とした
いかもしれません。次の物はちょうどそれをします:

@lisp
(defun my-save-name (group)
  (when (string-match "^nnml:mail." group)
    (substring group (match-end 0))))

(setq gnus-split-methods
      '((gnus-article-archive-name)
        (my-save-name)))
@end lisp


@vindex gnus-use-long-file-name
最後に @code{gnus-use-long-file-name} という変数があります。これが
@code{nil} であると、すべての上記の関数はグループ名のすべてのピリオド
(@samp{.}) をスラッシュ (@samp{/}) で置き換えます---これは関数はすべての
ファイルを一番上のディレクトリーに置くのではなく、階層的なディレクトリー
を作るという事です (@file{~/News/alt.andrea-dworkin} の代わりに
@file{~/News/alt/andrea-dworkin}。)この変数はたいていのシステムにおいて
ディフォルトで @code{t} です。しかし、歴史的な理由から Xenix と
usg-unix-v マシンではディフォルトで @code{nil} です。

この関数は削除とスコアのファイル名に影響します。この変数がリストで、リス
トに要素 @code{not-score} があると、長いファイル名はスコアファイルには使
われず、リストに要素 @code{not-save} があると、長いファイル名は保存には
使われず、要素 @code{not-kill} があると、長いファイル名は削除ファイルに
は使われません。

もし記事をスプールのような階層に保存したいのであれば、次のようにできます

@lisp
(setq gnus-use-long-file-name '(not-save)) ; to get a hierarchy
(setq gnus-default-article-saver 'gnus-summary-save-in-file) ; no encoding
@end lisp

それから @kbd{o} によって記事を保存するだけです。それからこの階層を短命
な @code{nneething} グループによって読む事ができます---グループバッファ
で @kbd{G D} とし、一番上のディレクトリーを引数 (@file{~/News/}) として
渡します。


@node Decoding Articles
@section 記事の復号化
@cindex decoding articles

ときどき利用者は何らかの方法で符号化された記事 (もしくは記事群) を投稿し
ます。Gnus はあなたのためにそれらを復号化する事ができます。

@menu
* Uuencoded Articles::    記事を uuencode する。
* Shell Archives::        shar 記事を解凍する。
* PostScript Files::      ポストスクリプトを分割する。
* Other Files::           普通の保存と binhex。
* Decoding Variables::    幸せな復号化のための変数。
* Viewing Files::         復号化の結果を見たい?
@end menu

@cindex series
@cindex article series
これらすべての関数はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) を、 
``一つの記事'' を ``一つの群'' と解釈する拡張をして、どの記事に操作をす
るかを見つけるために使います。Gnus は自分自身でどの記事がその群に属して
いるかを判断し、すべての記事を復号化して、その結果のファイルを 展開/閲覧
/保存 することができます。

Gnus は以下の簡単な規則に則ってどの記事が群に属するのかを推測します: 表
題は行の最後の2つの数字を除いて (ほとんど) 同じである必要があります。
(空白は大体無視されますが。)

例えば: @samp{cat.gif (2/3)} というような表題を選ぶと、gnus は正規表現
@samp{^cat.gif ([0-9]+/[0-9]+).*$} に合致するすべての記事を見つけようと
します。

@samp{cat.gif (2/3) Part 6 of a series} のような標準でない表題はどの自動
閲覧命令によっても適切に認識されないため、手で記事に @kbd{#} の印を付け
なければなりません。


@node Uuencoded Articles
@subsection uuencode された記事
@cindex uudecode
@cindex uuendoded articles

@table @kbd

@item X u
@kindex X u (概略)
@findex gnus-uu-decode-uu
@c @icon{gnus-uu-decode-uu}
現在の群を uudecode します (@code{gnus-uu-decode-uu})。

@item X U
@kindex X U (概略)
@findex gnus-uu-decode-uu-and-save
現在の群を uudecode して保存します (@code{gnus-uu-decode-uu-and-save})。

@item X v u
@kindex X v u (概略)
@findex gnus-uu-decode-uu-view
現在の群を uudecode して、閲覧します (@code{gnus-uu-decode-uu-view})。

@item X v U
@kindex X v U (概略)
@findex gnus-uu-decode-uu-and-save-view
現在の記事を uudecode して、閲覧して保存します
(@code{gnus-uu-decode-uu-and-save-view})。

@end table

これらすべてはプロセス印によって印付けられた記事の存在に対して反応すると
いうことを覚えておいてください。例えば、もしニューズグループ全体を復号化
して保存したいのであれば、普通は @kbd{M P a} (@code{gnus-uu-mark-all})
とし、それから @kbd{X U} (@code{gnus-uu-decode-uu-and-save}) とします。

この全ては、白日の下に明白にキーを打っていた @sc{gnus 4.1} のときとは
@code{gnus-uu} の動作が全く違っています。この版の @code{gnus-uu} は普通
は何かの方法 (@pxref{Setting Process Marks}) で記事に印を付けて、それか
ら @kbd{X u} を押す事を前提としています。

@vindex gnus-uu-notify-files
注意: @code{gnus-uu-notify-files} に合致する名前、
@samp{[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)} にハードコードされる、
を持つ記事を復号化しようとしたときは、@code{gnus-uu} は問題の記事をちょ
うど閲覧した事を知らせるために、自動的に @samp{comp.unix.wizards} に記事
を投稿します。この機能を使わないようにする事はできません。


@node Shell Archives
@subsection シェルアーカイブ
@cindex unshar
@cindex shell archives
@cindex shared articles

シェルアーカイブ (``shar ファイル'') はソースを配布するための人気のある
方法でしたが、今日ではそんなに使われていません。とにかくこれらを扱うため
の命令があります:

@table @kbd

@item X s
@kindex X s (概略)
@findex gnus-uu-decode-unshar
現在の群を解凍します (@code{gnus-uu-decode-unshar})。

@item X S
@kindex X S (概略)
@findex gnus-uu-decode-unshar-and-save
現在の群を解凍し保存します (@code{gnus-uu-decode-unshar-and-save})。

@item X v s
@kindex X v s (概略)
@findex gnus-uu-decode-unshar-view
現在の群を解凍し閲覧します (@code{gnus-uu-decode-unshar-view})。

@item X v S
@kindex X v S (概略)
@findex gnus-uu-decode-unshar-and-save-view
現在の群を解凍し、閲覧して保存します
(@code{gnus-uu-decode-unshar-and-save-view})。
@end table


@node PostScript Files
@subsection ポストスクリプトファイル
@cindex PostScript

@table @kbd

@item X p
@kindex X p (概略)
@findex gnus-uu-decode-postscript
現在のポストスクリプト群を展開します (@code{gnus-uu-decode-postscript})。

@item X P
@kindex X P (概略)
@findex gnus-uu-decode-postscript-and-save
現在のポストスクリプト群を展開して保存します
(@code{gnus-uu-decode-postscript-and-save})。

@item X v p
@kindex X v p (概略)
@findex gnus-uu-decode-postscript-view
現在のポストスクリプト群を閲覧します
(@code{gnus-uu-decode-postscript-view})。

@item X v P
@kindex X v P (概略)
@findex gnus-uu-decode-ostscript-and-save-view
現在のポストスクリプト群を閲覧し保存します
(@code{gnus-uu-decode-postscript-and-save-view})。
@end table


@node Other Files
@subsection 他のファイル

@table @kbd
@item X o
@kindex X o (概略)
@findex gnus-uu-decode-save
現在の群を保存します (@code{gnus-uu-decode-save})。

@item X b
@kindex X b (概略)
@findex gnus-uu-decode-binhex
現在の記事を binhex 解凍します (@code{gnus-uu-decode-binhex})。これは本
当は動作しません。
@end table


@node Decoding Variables
@subsection 復号化のための変数

形容詞です。動詞ではありません。

@menu
* Rule Variables::          ファイルがどのように閲覧されるかを決める変数。
* Other Decode Variables::  他の復号化の変数。
* Uuencoding and Posting::  uuencode するのをカスタマイズする変数。
@end menu


@node Rule Variables
@subsubsection 規則変数
@cindex rule variables

Gnus はファイルを閲覧するのを決定するのに @dfn{規則変数} を用います。こ
れらの変数はすべて以下のような様式です

@lisp
      (list '(regexp1 command2)
            '(regexp2 command2)
            ...)
@end lisp

@table @code

@item gnus-uu-user-view-rules
@vindex gnus-uu-user-view-rules
@cindex sox
この変数はファイルを閲覧するときに最初に調べられます。例えば、もし
@samp{.au} 音ファイルを変換するために @code{sox} を使いたいときは、次の
ようにできます:
@lisp
(setq gnus-uu-user-view-rules
      (list '(\"\\\\.au$\" \"sox %s -t .aiff > /dev/audio\")))
@end lisp

@item gnus-uu-user-view-rules-end
@vindex gnus-uu-user-view-rules-end
この変数は gnus が利用者とディフォルトの閲覧規則から合致するものを見つけ
られなかったときに調べられます。

@item gnus-uu-user-archive-rules
@vindex gnus-uu-user-archive-rules
この変数はアーカイブを展開するときにどの命令が使われるべきかを決めるため
に使う事ができます。
@end table


@node Other Decode Variables
@subsection 他の復号化の変数

@table @code
@vindex gnus-uu-grabbled-file-functions

@item gnus-uu-grabbled-file-functions
このリストのすべての関数はそれぞれのファイルが上手く復号化された直後に呼
ばれます---ですから、すぐにファイルを移動や閲覧したりすることができ、何
かをする前にすべてのファイルが復号化されるのを待つ必要はありません。この
リストに入れる事のできる既製関数は:

@table @code

@item gnus-uu-grab-view
@findex gnus-uu-grab-view
ファイルを閲覧します。

@item gnus-uu-grab-move
@findex gnus-uu-grab-move
ファイルを移動します (もし保存関数を使っているのであれば)。
@end table

@item gnus-uu-be-dangerous
@vindex gnus-uu-be-dangerous
復号化の最中に変な状況が起こったときに何をするかを指定します。もし
@code{nil} であると、できるだけ保守的になります。もし @code{t} であると、
動作しないものは無視して、現存するファイルを上書きします。その他の場合は、
それぞれのときに尋ねます。

@item gnus-uu-ignore-files-by-name
@vindex gnus-uu-ignore-files-by-name
この正規表現に合致する名前のファイルは閲覧されません。

@item gnus-uu-igonore-files-by-type
@vindex gnus-uu-ignore-files-by-type
この変数に合致する @sc{mime} の型を持つファイルは閲覧されません。Gnus は
ファイル名に基づいて型を推測している事に注意してください。
@code{gnus-uu} は (まだ) @sc{mime} パッケージではありませんので、これは
少し変です。

@item gnus-uu-tmp-dir
@vindex gnus-uu-tmp-dir
@code{gnus-uu} がその仕事をする場所です。

@item gnus-uu-do-not-unpack-archives
@vindex gnus-uu-do-not-unpack-archives
@code{nil} でないのは、@code{gnus-uu} は表示するためのファイルを探すため
にアーカイブの中までは入っていかないという事です。

@item gnus-uu-view-and-save
@vindex gnus-uu-view-and-save
@code{nil} でないのは、利用者はファイルを閲覧した後に常に保存するかどう
かを尋ねられるという事です。

@item gnus-uu-ignore-default-view-rules
@vindex gnus-uu-ignore-default-view-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトの閲覧規則を無視する
という事です。

@item gnus-uu-ignore-default-archive-rules
@vindex gnus-uu-ignore-default-archive-rules
@code{nil} でないのは、@code{gnus-uu} はディフォルトのアーカイブ展開命令
を無視するという事です。

@item gnus-uu-kill-carriage-return
@vindex gnus-uu-kill-carriage-return
@code{nil} でないのは、@code{gnus-uu} は記事からすべてのキャリッジリター
ン (carriage return) を取り去るという事です。

@item gnus-uu-unmark-articles-not-decoded
@vindex gnus-uu-unmark-articles-not-decoded
@code{nil} でないのは、@code{gnus-uu} は復号化に失敗した記事に未読の印を
付けるという事です。

@item gnus-uu-correct-stripped-uucode
@vindex gnus-uu-correct-stripped-uucode
@code{nil} でないというのは、@code{gnus-uu} は続く空白が削除されてしまっ
ている uuencode されたファイルを修復しようと @emph{試す} という事です。

@item gnus-uu-pre-uudecode-hook
@vindex gnus-uu-pre-uudecode-hook
@code{uudecode} にメッセージを送る前に実行されるフックです。

@item gnus-uu-view-with-metamail
@vindex gnus-uu-view-with-metamail
@cindex metamail
@code{nil} でないのは、@code{gnus-uu} は規則変数で定義された閲覧命令を無
視して、ファイル名に基づいた @sc{mime} 内容の型に取り替えるという事です。
その結果は閲覧のために @code{metamail} にかけられます。

@item gnus-uu-save-in-digest
@vindex gnus-uu-save-in-digest
@code{nil} でないのは、@code{gnus-uu} が復号化をしないで保存をするように
言われたときに、要約を保存するという事です。この変数が @code{nil} である
と、@code{gnus-uu} は 何も飾りをしないで全てをファイルに保存します。要約
は RFC1153 準じています---意味のある量を指定して、番号を発行する簡単な方
法が見つからなかったので、単純にそれらは切り落としています。

@end table


@node Uuencoding and Posting
@subsection uuencode と投稿

@table @code

@item gnus-uu-post-include-before-composing
@vindex gnus-uu-post-include-before-composing
@code{nil} でないのは、@code{gnus-uu} が記事を作成する前に符号化するファ
イルを尋ねるという事です。この変数が @code{t} であると、@kbd{C-c C-i} に
よって符号化されたファイルを取り込むか、記事を投稿するときに取り込むか、
どちらかをする事ができます。

@item gnus-uu-post-length
@vindex gnus-uu-post-length
記事の最大の長さです。符号化されたファイルは全体のファイルを投稿するのに
必要な量のファイルに分割されます。

@item gnus-uu-post-threaded
@vindex gnus-uu-post-threaded
@code{nil} でないのは、@code{gnus-uu} が符号化されたファイルをスレッドで
投稿するという事です。これはあまり賢い方法ではないかも知れません。という
のは、今まで私が見た中で uuencode された記事を集めるのに、スレッドを追っ
ていく事のできる他の復号装置が存在しないからです。 (えーと、私はそれをす
る一つのパッケージを見た事があります---@code{gnus-uu} です。しかしなぜか、
それが数のうちに入るとは思えないのです...) ディフォルトは @code{nil} で
す。

@item gnus-uu-post-separate-description
@vindex gnus-uu-post-separate-description
@code{nil} でないのは、記述は別の記事で投稿されるという事です。最初の記
事は普通は (0/x) のように番号が付けられます。もしこの変数が @code{nil}
であると、利用者の書いた記述は最初のファイルの始めに取り込まれ、(1/x) の
番号が付けられます。ディフォルトは @code{t} です。

@end table


@node Viewing Files
@subsection ファイルの閲覧
@cindex viewing files
@cindex pseudo-articles

復号化した後でファイルが何らかのアーカイブである場合、gnus はアーカイブ
を展開しようと試み、アーカイブの中に閲覧できるファイルがあるかを調べます。
例えば、gzip された tar ファイル @file{pics.tar.gz} があって、ファイル 
@file{pic1.jpg} と @file{pic2.gif} を含んでいる場合、gnus は主ファイルを
解凍して tar を展開し、それから2つの絵を閲覧します。この展開の過程は再帰
的なので、アーカイブにアーカイブのアーカイブがあると、それはすべて展開さ
れます。

最後に、gnus は普通はそれぞれの抽出された記事ごとに @dfn{疑似記事} を概
略バッファに挿入します。これらの ``記事'' に移動した場合は、実行する命令 
(普通は gnus が提案をします) を入力するように促進され、それから命令が実
行されます。

@vindex gnus-view-pseudo-asynchronously
@code{gnus-view-pseudo-asynchronously} が @code{nil} であると、Emacs は
先へ進む前に閲覧が終わるまで待ちます。

@vindex gnus-view-pseudos
@code{gnus-view-pseudos} が @code{automatic} であると、gnus は概略バッファ
に疑似記事を挿入しませんが、それらをすぐに閲覧します。この変数が
@code{not-confirm} であると、利用者は閲覧が済む前に確認さえも求められま
せん。

@vindex gnus-view-pseudos-separately
@code{gnus-view-pseudos-separately} が @code{nil} でないと、一つの疑似記
事が閲覧されるそれぞれのファイルに対して作成されます。@code{nil} である
と、同じ閲覧命令を使うすべての命令がその命令の引数のリストとして渡されま
す。

@vindex gnus-insert-pseudo-articles
@code{gnus-insert-pseudo-articles} が @code{nil} でないと、復号化のとき
に疑似記事を挿入します。ディフォルトでは @code{t}です。

それで、そのような感じです。@emph{実質サーバー} からの  @emph{実質グルー
プ} の @emph{疑似記事} 読んでいます。そして考えます: どうして全てが現実
ではなくなってしまったのだろうか? どうしてここに来てしまったのだろうか?


@node Article Treatment
@section 記事の扱い

この巨大な説明文書を読んできて、人々が書いた事を読む、といったようなニュー
ズリーダーの本当の目的を完全に忘れてしまったかも知れません。記事を読む事
です。残念な事に、人々は書く事は非常に苦手としていますので、記事を読みや
すくするための関数と変数が山のようにあります。

@menu
* Article Highlighting::    記事を果物サラダのように見えるようにしたい。
* Article Fontisizing::     強調された文を素敵にする。
* Article Hiding::          特定の情報は消し去りたいとも思う。
* Article Washing::         人生をもっとよくするたくさんの気の利いた関数。
* Article Buttons::         URL や Message-ID や アドレスなどをクリックする。
* Article Date::            ぐずぐず言うな、標準時だ!
* Article Signature::       署名って何?
@end menu


@node Article Highlighting
@subsection 記事のハイライト
@cindex highlight

記事バッファを果物サラダのようにしたいだけでなく、華やかな果物サラダのよ
うに見えるようにしたいでしょう。

@table @kbd

@item W H a
@kindex W H a (概略)
@findex gnus-article-highlight
現在の記事をハイライト (highlight) します
(@code{gnus-article-highlight})。

@item W H h
@kindex W H h (概略)
@findex gnus-article-highlight-headers
@vindex gnus-header-face-alist
ヘッダーをハイライトします (@code{gnus-article-highlight-headers})。ハイ
ライトは変数 @code{gnus-header-face-alist} にしたがってなされ、それはそ
れぞれの要素が @var{(正規表現 名前 内容)} という様式のリストです。 
@var{正規表現} はヘッダーに合致する正規表現、@var{名前} はヘッダーの名前
をハイライトするのに使われるフェイス (face) (@pxref{FacesandFonts})、
@var{内容} はヘッダーの値をハイライトするフェイスです。最初に合致したも
のが使われます。@var{正規表現} は @samp{^} が付けられるべきではない事に
注意してください---gnus がそれを付け加えます。

@item W H c
@kindex W H c (概略)
@findex gnus-article-highlight-citation
引用された文をハイライトします (@code{gnus-article-highlight-citation})。

引用ハイライトをカスタマイズするいくつかの変数は:

@table @code
@vindex gnus-cite-parse-max-size

@item gnus-cite-parse-max-size
記事の大きさがこの変数 (ディフォルトでは25000) より大きい記事は、引用ハ
イライトは行われません。

@item gnus-cite-prefix-regexp
@vindex gnus-cite-prefix-regexp
ある行が取り得る最大の引用接頭語に合致する正規表現です。

@item gnus-cite-max-prefix
@vindex gnus-cite-max-prefix
引用接頭語の最大の長さです (ディフォルトでは20です)。

@item gnus-cite-face-list
@vindex gnus-cite-face-list
引用をハイライトするために使われるフェイスのリストです (@pxref{Faces and
Fonts})。同じメッセージの中に複数の記事からの引用があると、gnus はそれぞ
れの記事からの引用をそれ用のフェイスで表示しようとします。これにより、誰
が何を書いたかが分かりやすくなるでしょう。

@item gnus-supercite-regexp
@vindex gnus-supercite-regexp
普通の Supercite 属性行に合致する正規表現です。

@item gnus-supercite-secondary-regexp
@vindex gnus-supercite-secondary-regexp
引き裂かれた Supercite 属性行に合致する正規表現です。

@item gnus-cite-minimum-match-count
@vindex gnus-cite-minimum-match-count
それが引用であると決定する前に調べなければならない最小の同一接頭語です。

@item gnus-cite-attribution-prefix
@vindex gnus-cite-attribution-prefix
属性行の始まりに合致する正規表現です。

@item gnus-cite-attribution-suffix
@vindex gnus-cite-attribution-suffix
属性行の最後に合致する正規表現です。

@item gnus-cite-attribution-face
@vindex gnus-cite-attribution-face
属性行に使われるフェイスです。その属性に属する文のためのフェイスと融合さ
れます。

@end table


@item W H s
@kindex W H s (概略)
@vindex gnus-signature-separator
@vindex gnus-signature-face
@findex gnus-article-highlight-signature
署名 (signature) をハイライトします
(@code{gnus-article-highlight-signature})。
@code{gnus-signature-separator} (@pxref{Article Signature}) の後の全ての
ものは署名と考えられ、@code{gnus-signature-face} でハイライトされます。
それはディフォルトでは @code{italic} です。

@end table


@node Article Fontisizing
@subsection 記事のフォント変更
@cindex emphasis
@cindex article emphasis

@cindex gnus-article-emphasize
@kindex W e (概略)
人々はよくニューズの記事で @samp{_これ_} や @samp{*これ*} のようなものを
使って単語を強調します。Gnus は 記事を命令 @kbd{W e}
(@code{gnus-article-emphasize}) にかける事によって素敵に見えるようにでき
ます。

@vindex gnus-article-emphasis
強調がどのように演算されるかは変数 @code{gnus-article-emphasis} によって
制御されます。これは最初の要素が合致するべき正規表現である連想リストです。
2番目の要素はどの正規表現のグループが強調語全体を見つけるために使われる
かを示す数字です。3番目はどの正規表現のグループが表示されハイライトされ
るかを決める数字です。 (この2つのグループの間の記事は隠されます。) 4番目
はハイライトのフェイスです。

@lisp
(setq gnus-article-emphasis
      '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
        ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))
@end lisp

@vindex gnus-emphasis-underline
@vindex gnus-emphasis-bold
@vindex gnus-emphasis-italic
@vindex gnus-emphasis-underline-bold
@vindex gnus-emphasis-underline-italic
@vindex gnus-emphasis-bold-italic
@vindex gnus-emphasis-underline-bold-italic
ディフォルトでは7つの規則があり、それらは以下のフェイスを用います:
@code{gnus-emphasis-bold}, @code{gnus-emphasis-italic},
@code{gnus-emphasis-underline}, @code{gnus-emphasis-bold-italic},
@code{gnus-emphasis-underline-italic},
@code{gnus-emphasis-underline-bold},
@code{gnus-emphasis-underline-bold-italic}.

これらのフェイスを変更したいのであれば、@kbd{M-x customize} か
@code{copy-face} を使う事ができます。例えば、@code{gnus-emphasis-italic} に代わりに赤のフェイスを使うようにしたいときは、次のようにできます:
@lisp
(copy-face 'red 'gnus-emphasis-italic)
@end lisp


@node Article Hiding
@subsection 記事を隠す
@cindex article hiding

もしくは、それぞれの記事の特定のものを隠したいかもしれません。たいていの
記事には普通はありすぎるくらい作りかえるものがあります。

@table @kbd

@item W W a
@kindex W W a (概略)
@findex gnus-article-hide
概略バッファで最大限隠します (@kbd{gnus-article-hide})。

@item W W h
@kindex W W h (概略)
@findex gnus-article-hide-headers
ヘッダーを隠します (@code{gnus-article-hide-headers})。 @xref{Hiding
Headers}。

@item W W b
@kindex W W b (概略)
@findex gnus-article-hide-boring-headers
あまり興味のもてないヘッダーを隠します
(@code{gnus-article-hide-boring-headers})。 @xref{Hiding Headers}。

@item W W s
@kindex W W s (概略)
@findex gnus-article-hide-signature
署名を隠します (@code{gnus-article-hide-signature})。 @xref{Article
Signature}。

@item W W p
@kindex W W p (概略)
@findex gnus-article-hide-pgp
@vindex gnus-article-hide-pgp-hook
@sc{pgp} 署名を隠します (@code{gnus-article-hide-pgp})。 @sc{pgp} 署名が
隠された後にフック @code{gnus-article-hide-pgp-hook} が実行されます。

@item W W P
@kindex W W P (概略)
@findex gnus-article-hide-pem
@sc{pem} (privacy enhanced messages) (プライバシー拡張メッセージ) 部分を
隠します (@code{gnus-article-hide-pem})。

@item W W c
@kindex W W c (概略)
@findex gnus-article-hide-citation
引用を隠します (@code{gnus-article-hide-citation})。 隠蔽をカスタマイズ
するいくつかの変数は:

@table @code

@item gnus-cite-hide-percentage
@vindex gnus-cite-hide-percentage
引用された文がこの変数 (ディフォルトでは50) より大きい割合のときは、引用
された分を隠します。

@item gnus-cite-hide-absolute
@vindex gnus-cite-hide-absolute
引用された文は少なくともこの長さ (ディフォルトでは10) でなければ隠されま
せん。

@item gnus-cited-text-button-line-format
@vindex gnus-cited-text-button-line-format
Gnus はどこの引用文が隠されているかを示すためにボタンを付け加え、文章の
隠蔽を切り替えられるようにします。この変数の様式はこれらのフォーマットの
ような変数によって指定されます (@pxref{Formatting Variables})。次の指定
は有効です:

@table @samp
@item b
隠された文の最初のポイントです。
@item e
隠された文の最後のポイントです。
@item l
隠された文の長さです。
@end table

@item gnus-cited-lines-visible
@vindex gnus-cited-lines-visible
引用文の最初からの表示される行数です。

@end table

@item W W C
@kindex W W C (概略)
@findex gnus-article-hide-citation-in-followups
ルートでない記事の引用文を隠します
(@code{gnus-article-hide-citation-in-followups})。これは対話的命令として
はあまり役に立たないかもしれませんが、@code{gnus-article-display-hook}
に入れる事のできる手軽な関数であるでしょう (@pxref{Customizing
Articles})。

@end table

これらの全ての ``隠蔽'' 命令は切り替え命令ですが、これらの命令に負の接頭
引数を与えると、それらは前に隠されていたものを表示します。正の接頭引数を
与えれば、それらは常に隠します。

引用カスタマイズのための他の変数の情報のために @pxref{Article
Highlighting} も参照してください。


@node Article Washing
@subsection 記事洗濯
@cindex washing
@cindex article washing

私たちはこれをもっともな理由の下で ``記事洗濯'' (article washing} と呼ん
でいます。すなわち、キー @kbd{A} は使われているので、代わりにキー
@kbd{W} を使う必要があるのです。

私たちは @dfn{洗濯} を``何かの何かを何か別のものに変換する'' と定義して
いますが、普通はもっと良く見える何かに落ち着きます。それにもっときれいで
す、たぶん。

@table @kbd

@item W l
@kindex W l (概略)
@findex gnus-summary-stop-page-breaking
ページの区切りを現在の記事から取り除きます
(@code{gnus-summary-stop-page-breaking})。

@item W r
@kindex W r (概略)
@findex gnus-summary-caesar-message
@c @icon{gnus-summary-caesar-message}
記事バッファでシーザー変換 (Caesar rotate) (rot13) をします
(@code{gnus-summary-caesar-message})。シーザー変換か rot13 を用いて読む
事のできる、判読不可能な記事です (典型的には、攻撃的な冗談などです。)

普通は ``rot13'' と呼ばれています。それはアルファベットの位置が13個回転
するからです。例えば、@samp{B} (2番目の文字) -> @samp{O} (15番目の文字)。
これは時々シーザー変換と呼ばれる事もあります。というのは、シーザーがこの
形式の、えーと、ちょっと簡単な暗号化を採用したという噂があるからです。

@item W t
@kindex W t (概略)
@findex gnus-summary-toggle-header
記事バッファにすべてのヘッダーを表示するかどうかを切り替えます
(@code{gnus-summary-toggle-header})。

@item W v
@kindex W v (概略)
@findex gnus-summary-verbose-header
記事バッファにすべてのヘッダーを永遠に表示するかどうかを切り替えます
(@code{gnus-summary-verbose-header})。

@item W m
@kindex W m (概略)
@findex gnus-summary-toggle-mime
記事を表示する前に @sc{mime} を実行するかどうかを切り替えます
(@code{gnus-summary-toggle-mime})。

@item W o
@kindex W o (概略)
@findex gnus-article-treat-overstrike
オーバーストライクを処理します (@code{gnus-article-treat-overstrike})。

@item W d
@kindex W d (概略)
@findex gnus-article-treat-dumbquotes
M******** sm*rtq**t*s を処理します
(@code{gnus-article-treat-dumbquotes})。

@item W w
@kindex W w (概略)
@findex gnus-article-fill-cited-article
語の折り返しをします (@code{gnus-article-fill-cited-articles})。もしこの
関数を @code{gnus-article-display-hook} の中で使った場合、それはかなり後
の方で実行されるべきで、当然すべてのハイライトの後になります。

折り返しをするときに、幅を指定するために命令に数値接頭引数を与える事がで
きます。

@item W c
@kindex W c (概略)
@findex gnus-article-remove-cr
キャリッジリターン (CR) (すなわち、行の最後の @samp{^M}) を取り除きます
(@code{gnus-article-remove-cr})。

@item W q
@kindex W q (概略)
@findex gnus-article-de-quoted-unreadable
quoted-printable の処理をします
(@code{gnus-article-de-quoted-unreadable})。Quoted-Printable は ASCII で
ない (すなわち、8-bitの) 記事を送るときに良く採用される @sc{mime} 符号化
です。それは普通  @samp{d\351j\340 vu} のような文字列を 
@samp{d=E9j=E0 vu} のようにし、それは私にはあまり読めるものとは思えませ
ん。

@item W f
@kindex W f (概略)
@cindex x-face
@findex gnus-article-display-x-face
@findex gnus-article-x-face-command
@vindex gnus-article-x-face-command
@vindex gnus-article-x-face-too-ugly
@iftex
@iflatex
\include{xface}
@end iflatex
@end iftex
すべての X-Face ヘッダーを探して表示します
(@code{gnus-article-display-x-face})。この命令は変数
@code{gnus-article-x-face-command} によって与えられた関数によって実行さ
れます。この変数が文字列ならば、この文字列がサブシェルで実行されます。関
数ならば、この関数が顔を引数として呼ばれます。もし
@code{gnus-article-x-face-too-ugly} (これは正規表現です) が @code{From}
ヘッダーに合致すれば、顔は表示されません。Emacs でのディフォルトの動作は
@code{xv} をフォークして見ようとします。XEmacs でのディフォルトの動作は
@code{From} ヘッダーの前に顔を表示します。(XEmacs が X-Face 機能付きでコ
ンパイルされていると良いでしょう---それは表示を少し早くします。もし根本
的 X-Face 機能がないのであれば、gnus は @code{pbmplus} やその仲間の外部
プログラムを使って  @code{X-Face} ヘッダーを変換しようと試みます。) この
関数を表示フックに入れたいのであれば、おそらくそれあ最後になるべきでしょ
う。

@item W b
@kindex W b (概略)
@findex gnus-article-add-buttons
クリックできるボタンを記事に加えます (@code{gnus-article-add-buttons})。
@xref{Article Buttons}

@item W B
@kindex W B (概略)
@findex gnus-article-add-buttons-to-head
クリックできるボタンを記事のヘッダーに加えます
(@code{gnus-article-add-buttons-to-head})。

@item W E l
@kindex W E l (概略)
@findex gnus-article-strip-leading-blank-lines
記事の始めからのすべての空白行を取り除きます
(@code{gnus-article-strip-leading-blank-lines})。

@item W E m
@kindex W E m (概略)
@findex gnus-article-strip-multiple-blank-lines
すべての空白行を空行で置き換え、すべての複数の空行を一つの空行で置き換え
ます (@code{gnus-article-strip-multiple-blank-lines})。

@item W E t
@kindex W E t (概略)
@findex gnus-article-remove-trailing-blank-lines
記事の最後のすべての空白行を取り除きます
(@code{gnus-article-remove-trailing-blank-lines})。

@item W E a
@kindex W E a (概略)
@findex gnus-article-strip-blank-lines
上の3つの命令をすべて行います (@code{gnus-article-strip-blank-lines})。

@item W E A
@kindex W E A (概略)
@findex gnus-article-strip-all-blank-lines
すべての空白行を取り除きます (@code{gnus-article-strip-all-blank-lines})。

@item W E s
@kindex W E s (概略)
@findex gnus-article-strip-leading-space
記事の本体のすべての行の始めからのすべての空白を取り除きます
(@code{gnus-article-strip-leading-space})。

@end table


@node Article Buttons
@subsection 記事のボタン
@cindex buttons

よく記事の中に他のものへの参照が入れられる事があります。そして、gnus が
それに関する事を、それらの参照の上で @kbd{RET} を打つか、マウスの真中の
ボタンを使う事によって、最小限の努力で取得する事ができれば素敵でしょう。

Gnus はディフォルトで特定の標準の参照に @dfn{ボタン} を付けます: ちゃん
とした URL、メールアドレス、Message-ID です。これは2つの変数によって制御
されていて、その一つは記事の本体を扱い、もう一つは記事のヘッダーを扱いま
す。

@table @code

@item gnus-button-alist
@vindex gnus-button-alist
それぞれの入力要素が次のような様式の連想リストです:

@lisp
(REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@table @var

@item regexp
この正規表現 (regexp) に合致するすべての文は外部参照であるとみなされます。
これは埋め込まれた URL に合致する典型的な正規表現です
@samp{<URL:\\([^\n\r>]*\\)>}。

@item button-par
Gnus は合致したもののどの部分がハイライトされるのかを知らなければなりま
せん。これは正規表現のどの副表現がハイライトされるかを指定する番号です。
全てをハイライトしたいのなら、ここで0を使ってください。

@item use-p
この式は @code{評価} され、結果が @code{nil} でなければ、これは合致であ
るとみなされます。これは間違った合致を避けるために特別な選別をしたいとき
に役に立ちます。

@item function
この関数 (function) はこのボタンをクリックしたときに呼ばれます。

@item data-par
@var{button-par} のように、これは副表現の番号ですが、これは合致のどの部
分が @var{function} にデータとして送られるかを指定します。

@end table

ですから、URL をボタンにする完全な入力要素は

@lisp
("<URL:\\([^\n\r>]*\\)>" 0 t gnus-button-url 1)
@end lisp

@item gnus-header-button-alist
@vindex gnus-header-button-alist
それが記事のヘッダーだけに適用され、それぞれの入力要素がどのヘッダーにボ
タン化を適用するかを示す追加の要素がある事を除き、これは他の連想リストと
同じようなものです:

@lisp
(HEADER REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)
@end lisp

@var{HEADER} は正規表現です。

@item gnus-button-url-regexp
@vindex gnus-button-url-regexp
埋め込まれた URL に合致する正規表現です。それは上の変数のディフォルトの
値で使われます。

@item gnus-article-button-face
@vindex gnus-article-button-face
ボタンに使われるフェイスです。

@item gnus-article-mouse-face
@vindex gnus-article-mouse-face
マウスのカーソルがボタンの上にあるときに使われるフェイスです。

@end table


@node Article Date
@subsection 記事の日付

日付は聞いた事の無い何か無名な標準時で作成されている事が良くあるので、記
事が送られたときに何時であったかを知る事ができるのは非常に良い事でしょう。

@table @kbd

@item W T u
@kindex W T u (概略)
@findex gnus-article-date-ut
UT (別名 GMT, ZULU) で日付を表示します (@code{gnus-article-date-ut})。

@item W T i
@kindex W T i (概略)
@findex gnus-article-date-iso-8601
@cindex ISO 8601
日付を国際的な形式、ISO 8601 で表示します
(@code{gnus-article-date-iso8601})。

@item W T l
@kindex W T l (概略)
@findex gnus-article-date-local
日付をその地域の標準時で表示します (@code{gnus-article-date-local})。

@item W T s
@kindex W T s (概略)
@vindex gnus-article-time-format
@findex gnus-article-date-user
@findex format-time-string
日付を利用者定義の様式を使って表示します (@code{gnus-article-date-user})。
その様式は変数 @code{gnus-article-time-format} で指定され、
@code{format-time-string} に渡される文字列です。様式指定をする事ができる
一覧は変数の説明文を見てください。

@item W T e
@kindex W T e (概略)
@findex gnus-article-date-lapsed
@findex gnus-start-date-timer
@findex gnus-stop-date-timer
記事が投稿されてから今までどれくらいの時間が経過したかを表示します
(@code{gnus-article-date-lapsed})。この行が連続して更新されるようにした
いのであれば、

@lisp
(gnus-start-date-timer)
@end lisp

をあなたの @file{.gnus.el} ファイルに入れるか、何かのフックで実行するよ
うにする事ができます。タイマーを止めたいのであれば、命令
@code{gnus-stop-date-timer} を使う事ができます。

@item W T o
@kindex W T o (概略)
@findex gnus-article-date-original
本来の日付を表示します (@code{gnus-article-date-original})。これはあなた
が普通は他の変換関数を使っていて、それが完全に間違った事をしているのでは
ないかと心配しているときに役に立ちます。例えば、記事が1854年に投稿された
となっているとしましょう。しかし、そのような事は @emph{完全に} 不可能で
す。私が信用できませんか? *くすくす(笑)*

@end table


@node Article Signature
@subsection 記事の署名
@cindex signatures
@cindex article signature

@vindex gnus-signature-separator
それぞれの記事は2つの部分に分けられます---ヘッダーと本体です。本体は署名
部分と文章部分に分けられます。どれが署名とみなされるかを決める変数は
@code{gnus-signature-separator} です。これは普通は RFC-1036 の後継で指示
されている標準の @samp{^-- $} です。しかし、多くの人が標準でない署名分離
を用いますので、この変数は一つ一つ試される、正規表現のリストであることも
できます。(探索は本体の最後から始めへとなされます。) よくありそうな値は:

@lisp
(setq gnus-signature-separator
      '("^-- $"         ; 標準
        "^-- *$"        ; 普通の壊し方
        "^-------*$"    ; 多くの人は長ーーい横棒の
                        ; 行を使います。あぁ!
        "^ *--------*$" ; 2倍のあぁぁ!
        "^________*$"   ; 下線も人気があります
        "^========*$")) ; 邪道!
@end lisp

あなたが許容的であればあるほど、間違った結果を得る事になるでしょう。

@vindex gnus-signature-limit
@code{gnus-signature-limit} はどれが署名とみなされるかへの制限を提供しま
す。

@enumerate
@item
これが整数であれば、署名はこの整数より (文字で) 長くなっていてはいけませ
ん。
@item
これが浮動小数点数であれば、署名はその数字より (行で) 長くなっていてはい
けません。
@item
これが関数であれば、その関数は引数なしで呼ばれ、それが @code{nil} を返せ
ば、バッファには署名がありません。
@item
これが文字列であれば、それは正規表現として使われます。もしそれが合致すれ
ば、その当の文字列は署名ではありません。
@end enumerate

この変数は要素が上に挙げられた型のリストである事もできます。これは例です:

@lisp
(setq gnus-signature-limit
      '(200.0 "^---*Forwarded article"))
@end lisp

これは署名分離物の後に200を超える行か、署名分離物の後の文章が正規表現
@samp{^---*Forwarded article} に合致すれば、結局それは署名ではないという
事です。


@node Article Commands
@section 記事命令

@table @kbd

@item A P
@cindex PostScript
@cindex printing
@kindex A P (概略)
@vindex gnus-ps-print-article
@findex gnus-summary-print-article
記事バッファのポストスクリプト (PostScript) イメージを作成して印刷します 
(@code{gnus-summary-print-article})。 @code{gnus-ps-print-hook} がバッファ
を印刷する直前に実行されるでしょう。

@end table


@node Summary Sorting
@section 概略の並び替え
@cindex summary sorting

私はどうしてあなたがそうしたいのかはわからないのですが、それでもあなたは
たくさんの方法で概略バッファを並び替える事ができます。

@table @kbd

@item C-c C-s C-n
@kindex C-c C-s C-n (概略)
@findex gnus-summary-sort-by-number
記事番号によって並び替えます (@code{gnus-summary-sort-by-number})。

@item C-c C-s C-a
@kindex C-c C-s C-a (概略)
@findex gnus-summary-sort-by-author
著者によって並び替えます (@code{gnus-summary-sort-by-author})。

@item C-c C-s C-s
@kindex C-c C-s C-s (概略)
@findex gnus-summary-sort-by-subject
表題によって並び替えます (@code{gnus-summary-sort-by-subject})。

@item C-c C-s C-d
@kindex C-c C-s C-d (概略)
@findex gnus-summary-sort-by-date
日付によって並び替えます (@code{gnus-summary-sort-by-date})。

@item C-c C-s C-l
@kindex C-c C-s C-l (概略)
@findex gnus-summary-sort-by-lines
行によって並び替えます (@code{gnus-summary-sort-by-lines})。

@item C-c C-s C-i
@kindex C-c C-s C-i (概略)
@findex gnus-summary-sort-by-score
スコアによって並び替えます (@code{gnus-summary-sort-by-score})。
@end table

これらの関数はスレッドを使っているときと使っていないときの両方で動作しま
す。後者の場合は、すべての概略行が一行一行並び替えられます。前者の場合は、
ルートとルートを基本として並び替えられ、それはあなたが求めている事とは異
なっているかもしれません。スレッドを使う事を切り替えるには @kbd{T T} を
打ってください (@pxref{Thread Commands})。


@node Finding the Parent
@section 親記事を探す
@cindex parent articles
@cindex referring articles

@table @kbd
@item ^
@kindex ^ (概略)
@findex gnus-summary-refer-parent-article
現在の記事の親記事を読みたくて、それが概略バッファに表示されていないくて
も、おそらくそれは可能でしょう。というのは、現在のグループが @sc{nntp}
で取得されていて、親がまだ期限消去されていない上、現在の記事の
@code{References} がぶち壊されていなければ、ただ、@kbd{^} か @kbd{A r}
を押せば良いだけです (@code{gnus-summary-refer-parent-article})。もし全
てが上手く行けば、親記事を取得できるでしょう。もし親記事が既に概略バッファ
に表示されているのであれば、ポイントがその記事に移動するでしょう。

正の数値接頭引数を与えられれば、祖先まで多くの記事を戻って取得します。負
の数字接頭引数が与えられれば、その祖先の記事だけを取得します。ですから、
@kbd{3 ^} とすれば、gnus は現在の記事の親と、祖父母と、曾祖父母を取得し
ます。 @kbd{-3 ^} とすれば、gnus は現在の記事の曾祖父母だけを取得します。

@item A R (概略)
@findex gnus-summary-refer-references
@kindex A R (概略)
記事の @code{References} ヘッダーにある全ての記事を取得します
(@code{gnus-summary-refer-references})。

@item A T (概略)
@findex gnus-summary-refer-thread
@kindex A T (概略)
現在の記事が出てきているスレッドの、完全なスレッドを表示します
(@code{gnus-summary-refer-thread})。この命令は動作するために現在のグルー
プのすべてのヘッダーを取得しなければなりませんので、普通は少し時間がかか
ります。もし、これをしばしば行うのであれば、
@code{gnus-fetch-old-headers} を @code{invisible} に設定することを考えた
ほうが良いでしょう (@pxref{Filling In Threads})。これは普通は視覚的な効
果はありませんが、この命令の動作をかなり速くするでしょう。もちろん、グルー
プに入るのは少し遅くなります。

@vindex gnus-refer-thread-limit
変数 @code{gnus-refer-thread-limit} はこの命令を実行するときにどのくらい
古い (すなわち、現在の記事で最初に表示されたよりも前の記事) ヘッダーを取
得するかを指定します。ディフォルトは200です。もし @code{t} であれば、取
得可能なすべてのヘッダーを取得します。この変数は命令 @code{A T} に数値接
頭引数を与える事により上書きする事ができます。

@item M-^ (概略)
@findex gnus-summary-refer-article
@kindex M-^ (概略)
@cindex Message-ID
@cindex fetching by Message-ID
どのグループに属しているかに関わらず、任意の記事を @sc{nntp} サーバーに
尋ねる事ができます。@kbd{M-^} (@code{gnus-summary-refer-article}) は
@code{Message-ID}、それはあの長く、なかなか読む事のできない
@samp{<38o6up$6f2@@hymir.ifi.uio.no>} のような参照をあなたに尋ねます。
あなたはすべてを正確に打ち込まなければなりません。残念ながら、あいまいな
検索はできないのです。
@end table

ニューズでない選択方法から @code{Message-ID} で取得するときには現在の選
択方法が使われますが、この命令に接頭引数を与える事でこれを上書きする事が
できます。

@vindex gnus-refer-article-method
もしあなたの読んでいるグループが @code{Message-ID} での取得があまり良く
できないようなグループ (@code{nnspool} など) である場合、
@code{gnus-refer-article-method} を @sc{nntp} に設定する事ができます。お
そらく、あなたが会話している @sc{nntp} サーバーがあなたの読んでいるスプー
ルを更新していると非常に良いでしょう。しかし、それはどうしても必要なわけ
ではありません。

ほとんどのメールバックエンドは @code{Message-ID} での取得が可能ですが、
あまり優雅な方法でやっているわけではありません。@code{nnmbox} と
@code{nnbabyl} はどのグループからの記事も位置を得ることができますが、
@code{nnml} と @code{nnfolder} は現在のグループに投稿した記事の位置しか
得る事ができません。 (その他のものは時間がかかりすぎます。) @code{nnmh}
では全く不可能です。

@node Alternative Approaches
@section 代替手段

違った人は違った方法を使ってニューズを読もうとします。これは gnus でもそ
うであるので、我々は概略バッファーのためのマイナーモード (minor mode) に
少しの選択肢を与えてあります。

@menu
* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動-復号化する
@end menu


@node Pick and Read
@subsection 選んで読む
@cindex pick and read

いくつかのニューズリーダー (@code{nn} や、あのぉ、VM/CMS での
@code{Netnews} など) は2相の読む面を使います。利用者はまず概略バッファで
読みたい記事に印を付けます。それから、記事バッファだけを表示して記事を読
みます。

@vindex gnus-pick-mode
@kindex M-x gnus-pick-mode
Gnus はこれをするための概略バッファマイナーモードを提供します---
@code{gnus-pick-mode} です。これは基本的には簡単に印を付けられるように少
しのプロセス印命令が1打鍵命令になり、概略バッファへ切り替えるための追加
命令を1つ提供します。

これが pick mode を使ったときに使用可能なキーです:

@table @kbd
@item .
@kindex . (選択)
@findex gnus-summary-mark-as-processable
現在の行の記事を選択します (@code{gnus-summary-mark-as-processable})。数
値接頭引数を与えられれば、その行に移動して選択します。 (行数は普通は概略
選択行の最初に表示されています。)

@item SPACE
@kindex SPCE (選択)
@findex gnus-pick-next-page
概略バッファを一ページ次にスクロールします (@code{gnus-pick-next-page})。
もしバッファの最後であれば、選択記事を読み始めます。

@item u
@kindex u (選択)
@findex gnus-summary-unmark-as-processable
記事を未選択にします (@code{gnus-summary-unmark-as-processable})。

@item U
@kindex U (選択)
@findex gnus-summary-unmark-all-processable
すべての記事を未選択にします
(@code{gnus-summary-unmark-all-processable})。

@item t
@kindex t (選択)
@findex gnus-uu-mark-thread
スレッドを選択します (@code{gnus-uu-mark-thread})。

@item T
@kindex T (選択)
@findex gnus-uu-unmark-thread
スレッドを未選択にします (@code{gnus-uu-unmark-thread})。

@item r
@kindex r (選択)
@findex gnus-uu-mark-region
リージョンを選択します (@code{gnus-uu-mark-region})。

@item R
@kindex R (選択)
@findex gnus-uu-unmark-region
リージョンを未選択にします (@code{gnus-uu-unmark-region})。

@item e
@kindex e (選択)
@findex gnus-uu-mark-by-regexp
正規表現に合致する記事を選択します (@code{gnus-uu-mark-by-regexp})。

@item E
@kindex E (選択)
@findex gnus-uu-unmrak-by-regexp
正規表現に合致する記事を未選択にします (@code{gnus-uu-unmark-by-regexp})。

@item b
@kindex b (選択)
@findex gnus-uu-mark-buffer
バッファを選択します (@code{gnus-uu-mark-buffer})。

@item B
@kindex B (選択)
@findex gnus-uu-unmark-buffer
バッファを未選択にします (@code{gnus-uu-unmark-buffer})。

@item RET
@kindex RET (選択)
@findex gnus-pick-start-reading
@vindex gnus-pick-display-summary
選択された記事を読み始めます (@code{gnus-pick-start-reading})。接頭引数
を与えられれば、まずすべての未選択記事に既読の印を付けます。
@code{gnus-pick-display-summary} が @code{nil} でないと、概略バッファは
読んでいる間も表示されます。

@end table

これが良い考えだと思うのであれば、次のようにする事ができます:

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@vindex gnus-pick-mode-hook
@code{gnus-pick-minor-mode-hook} は pick マイナーモードバッファで実行さ
れます。

@vindex gnus-summary-pick-line-format
pick モードでの概略行の様式は標準の様式とは少し違います。それぞれの行の
最初に行数が表示されます。 Pick モードの行の様式は変数
@code{gnus-summary-pick-line-format} で制御されます (@pxref{Formatting
Variables})。これは @code{gnus-summary-line-format} と同じ様式指定を受け
付けます (@pxref{Summary Buffer Lines})。


@node Binary Groups
@subsection バイナリーグループ
@cindex binary groups

@findex gnus-binary-mode
@kindex M-x gnus-binary-mode
もし多くの時間をバイナリーグループ (binary group) で過ごしているのなら、
いつも @kbd{X u}、@kbd{n}、@kbd{RET} を叩くのが嫌になっているでしょう。
@kbd{M-x gnus-binary-mode} は記事を普通の方法で表示する代わりに、普通の
gnus の記事選択関数を記事群を uudecode しその結果を表示するように変更す
る、概略バッファのためのマイナーモードです。

@kindex g (バイナリー)
@findex gnus-binary-show-article
実際は、このモードにしたときに、現実の記事を見るための唯一の命令が 
@kbd{g} です (@code{gnus-binary-show-article})。

@vindex gnus-binary-mode-hook
@code{gnus-binary-mode-hook} がバイナリーマイナーモードバッファで呼ばれ
ます。


@node Tree Display
@section 木表示
@cindex trees

@vindex gnus-use-trees
もし普通の gnus の概略表示を好きでないならば、@code{gnus-use-trees} を
@code{t} に設定してみると良いかもしれません。これは (ディフォルトで) 追
加の @dfn{木バッファ} (tree buffer) を作成します。木バッファではすべての
概略モード命令を実行する事ができます。

もちろん、木表示をカスタマイズする変数が少しあります:

@table @code
@item gnus-tree-mode-hook
@vindex gnus-tree-mode-hook
すべての木モードバッファで実行されるフックです。

@item gnus-tree-mode-line-format
@vindex gnus-tree-mode-line-format
木モードバッファでのモード行のためのフォーマット文字列です。ディフォルト
は @samp{Gnus: %%b %S %Z} です。使用可能な指定は 
@pxref{Summary Buffer ModeLine} を参照してください。

@item gnus-selected-tree-face
@vindex gnus-selected-tree-face
木バッファで選択された記事をハイライトするために使われるフェイスです。ディ
フォルトでは @code{modeline} です。

@item gnus-tree-line-format
@vindex gnus-tree-line-format
木の節のためのフォーマット文字列です。でもこの名前は少し誤った名称です---
それは行ではなく、ただ節を定義するだけです。ディフォルトの値は
@samp{%(%[%3,3n%]%)} で、それは投稿者の名前の最初の3文字を表示します。す
べての節が同じ長さであるのは重要ですので、@samp{%4,4n} のような指定を 
@emph{使わなければならない} のです。

有効な指定は:

@table @samp
@item n
投稿者の名前。
@item f
@code{From} ヘッダー。
@item N
記事の番号。
@item [
開き括弧。
@item ]
閉じ括弧。
@item s
表題。
@end table

@xref{Formatting Variables}。

表示に関連した変数は:

@table @code
@item gnus-tree-brackets
@vindex gnus-tree-brackets
これは ``本当の'' 記事と ``まばら記事'' に違いを付けるために使われます。
様式は 
@var{((本当の開 . 本当の閉) (まばら開 . まばら閉) (偽の開 . 偽の閉))}
となっていて、ディフォルトは 
@code{((?[ . ?]) (?( . ?)) (?@{ . ?@}) (?< . ?>))} です。

@item gnus-tree-parent-child-cdges
@vindex gnus-tree-parent-chlid-edges
これは親の節を子に接続するために使われる文字を含んだリストです。ディフォ
ルトは @code{(?- ?\\ ?|)} です。

@end table

@item gnus-tree-minimize-window
@vindex gnus-tree-minimize-winodw
もしこの変数が @code{nil} でないと、他の gnus ウィンドウがもっと場所を取
れるように gnus は木バッファをできるだけ小さくします。もしこの変数が数字
であると、木バッファはその数字より大きくなる事はありません。ディフォルト
は @code{t} です。フレームでいくつかのウィンドウが横に並んで表示されてい
て、木バッファがそのうちの一つである場合、木ウィンドウを最小化することは
その隣に表示されているすべてのウィンドウの大きさを変更する事に注意してく
ださい。

@item gnus-generate-tree-function
@vindex gnus-generate-tree-function
@findex gnus-generate-horizontal-tree
@findex gnus-generate-vertical-tree
実際にスレッドの木を作成する関数です。2つの既定義の使用可能な関数は:
@code{gnus-generate-horizontal-tree} と
@code{gnus-generate-vertical-tree} (これがディフォルトです) です。

@end table

水平木バッファ (horizontal tree buffer) の例です:

@example
@{***@}-(***)-[odd]-[Gun]
     |      \[Jan]
     |      \[odd]-[Eri]
     |      \(***)-[Eri]
     |            \[odd]-[Paa]
     \[Bjo]
     \[Gun]
     \[Gun]-[Jor]
@end example

同じスレッドが垂直木バッファ (vertical tree buffer) で表示されたものです:

@example
@{***@}
  |--------------------------\-----\-----\
(***)                         [Bjo] [Gun] [Gun]
  |--\-----\-----\                          |
[odd] [Jan] [odd] (***)                   [Jor]
  |           |     |--\
[Gun]       [Eri] [Eri] [odd]
                          |
                        [Paa]
@end example

もし水平木を使っているのなら、概略バッファで木を隣り合わせで表示できれば
嬉しいでしょう。次のようなものをファイル @file{.gnus.el} に加える事がで
きます:

@lisp
(setq gnus-use-trees t
      gnus-generate-tree-function 'gnus-generate-horizontal-tree
      gnus-tree-minimize-window nil)
(gnus-add-configuration
 '(article
   (vertical 1.0
             (horizontal 0.25
                         (summary 0.75 point)
                         (tree 1.0))
             (article 1.0))))
@end lisp

@xref{Windows Configuration}。


@node Mail Group Commands
@section メールグループ命令
@cindex mail group commands

いくつかの命令はメールグループのみで意味を持ちます。これらの命令が現在の
グループで有効でないなら、それらは大騒ぎをしてあなたに知らせるでしょう。

すべてのこれらの命令は (期限削除と編集命令は除く) プロセス/接頭引数の習
慣を使います (@pxref{Process/Prefix})。

@table @kbd

@item B e
@kindex B e (概略)
@findex gnus-summay-expire-articles
グループのすべての期限削除可能な記事を期限切れ削除します
(@code{gnus-summary-expire-articles})。

@item B M-C-e
@kindex B M-C-e (概略)
@findex gnus-summary-expire-article-now
グループのすべての期限削除可能な記事削除します
(@code{gnus-summay-expire-articles-now})。これは現在のグループの該当する
@strong{全て} の期限削除記事は永遠に空の大きな @file{/dev/null} へ消え去
るという事です。

@item B DEL
@kindex B DEL (概略)
@findex gnus-summary-delete-article
@c @icon{gnus-summary-mail-delete}
メール記事を削除します。これは ''あなたのディスクから今から永遠に削除し
て、二度と戻らない'' の``削除'' です。注意して使ってください 
(@code{gnus-summary-delete-article})。

@item B m
@kindex B m (概略)
@cindex move mail
@findex gnus-summary-move-article
あるメールグループから別のところへ記事を移動します
(@code{gnus-summary-move-article})。

@item B c
@kindex B c (概略)
@cindex copy mail
@findex gnus-summary-copy-article
@c @icon{gnus-summary-mail-copy}
あるグループ (メールグループや他のもの) からメールグループに記事を複製し
ます (@code{gnus-summary-copy-article})。

@item B B
@kindex B B (概略)
@cindex crosspost mail
@findex gnus-summary-crosspost-article
現在の記事を他のグループにクロスポストします
(@code{gnus-summary-crosspost-article})。これは他のグループ記事の新しい
複製を作成し、記事の Xref ヘッダーも適切に更新されます。

@item B i
@kindex B i (概略)
@findex gnus-summary-import-article
任意のファイルを現在のメールグループに取り込みます
(@code{gnus-summary-import-article})。あなたはファイル名と、@code{From}
ヘッダーと @code{Subject} ヘッダー の入力を促進されます。

@item B r
@kindex B r (概略)
@findex gnus-summary-respool-article
メール記事をスプールし直します (@code{gnus-summary-move-article})。
@code{gnus-summary-respool-default-method} が再スプールするときのディフォ
ルトの選択方法として使用されます。この変数はディフォルトで @code{nil} で、
これは現在のグループの選択方法が代わりに使われるという事です。

@item B w
@itemx e
@kindex B w (概略)
@kindex e (概略)
@findex gnus-summary-edit-article
@kindex C-c C-c (記事)
現在の記事を編集します (@code{gnus-summary-edit-article})。編集を終了し
て変更を永遠にするために、@kbd{C-c C-c} を打ちます。もし命令 
@kbd{C-c C-c} に数値接頭引数を与えると、gnus は記事を再ハイライトしませ
ん。

@item B q
@kindex B q (概略)
@findex gnus-summary-respool-query
もし記事を再スプールしたいときは、再スプールをする前にどのグループに記事
が移るかに興味があるでしょう。この命令でそれがわかります
(@code{gnus-summary-respool-query})。

@item B p
@kindex B p (概略)
@findex gnus-summary-article-posted-p
一部の人はあなたの投稿へのフォローアップをするときに、``親切な'' 複製を
送る傾向があります。これらは普通はそこに @code{Newsgroups} ヘッダーが付
いているのですが、いつも相であるとは限りません。この命令
(@code{gnus-summary-article-posted-p}) は現在の記事をあなたのニューズサー
バーから (というよりは、むしろ @code{gnus-refer-article-method} や
@code{gnus-select-method} から) 取得しようとし、記事を発見できたかどうか
を報告します。それが記事を発見しなかったとしても、それはとにかく投稿され
ているかもしれません---メールの伝達はニューズの伝達よりもずっと速く、ニュー
ズの複製がまだ到着していないだけかもしれないのです。

@end table

@vindex gnus-move-split-methods
@cindex moving articles
もし、規則的に記事を移動 (もしくは複製) するのであれば、gnus に記事をど
こに入れれば良いか提案させたいと思うでしょう。
@code{gnus-move-split-methods} は @code{gnus-split-methods} と同じ構文
を使う変数です (@pxref{Saving Articles})。あなたが妥当だと思うような提案
をするようにその変数をカスタマイズする事ができます。

@lisp
(setq gnus-move-split-methods
      '(("^From:.*Lars Magne" "nnml:junk")
        ("^Subject:.*gnus" "nnfolder:important")
        (".*" "nnml:misc")))
@end lisp


@node Various Summary Stuff
@section いろいろな概略の物件

@menu
* Summary Group Information::         情報指向の命令。
* Searching for Articles::            複数記事命令。
* Summary Generation Commands::       概略バッファの (再) 作成。
* Really Various Summary Commands::   あのやっかいな他に適合しない命令。
@end menu

@table @code
@vindex gnus-summary-mode-hook
@item gnus-summary-mode-hook
概略モードバッファを作成するときにこのフックが呼ばれます。

@vindex gnus-summary-generate-hook
@item gnus-summary-generate-hook
これはスレッド作成と概略バッファ作成の前に実行する最後のものとして呼ばれ
ます。これはニューズグループの持っているデータに基づいてスレッドの変数を
カスタマイズするために非常に便利です。このフックはほとんどの概略バッファ
変数が設定された後に呼ばれます。

@vindex gnus-summary-prepare-hook
@item gnus-summary-prepare-hook
それは概略バッファが作成された後に呼ばれます。例えば、それは何か他の邪悪
な方法で行をハイライトしたり、バッファの見え方を修正したりするのに使った
りするかも知れません。

@vindex gnus-summary-ignore-cuplicates
@item gnus-summary-ignore-duplicates
Gnus が同じ @code{Message-ID} を持つ2つの記事を発見したときは、何か思い
切った事をしなければなりません。別の記事が同じ @code{Message-ID} を持つ
事は許されていませんが、それは何らかの出所からメールを読んでいるときに起
こるかもしれません。Gnus はこの変数によって何が起こるかをカスタマイズで
きるようになっています。もしそれが @code{nil} (これがディフォルトです)
であれば、gnus は @code{Message-ID} を付け替えて (表示のためだけに) 記事
を他の記事と同じように表示します。この変数が @code{t} であると、それは記
事を表示しません---最初から存在しなかったかのように。

@end table


@node Summary Group Information
@subsection 概略グループ情報

@table @kbd

@item H f
@kindex H f (概略)
@findex gnus-summary-fetch-faq
@vindex gnus-grou-faq-directory
現在のグループの FAQ (frequently asked questions (頻繁にされる質問) のリ
スト) を取得しようとします (@code{gnus-summary-fetch-faq})。Gnus は普通
は遠隔マシンのディレクトリである @code{gnus-group-faq-directory} から 
FAQ を取得しようとします。この変数はディレクトリーのリストである事もでき
ます。その場合は、この命令に接頭引数を与える事でいろいろなサイト (site) 
から選ぶ事ができます。おそらく @code{ange-ftp} もしくは @code{efs} がファ
イルの取得に使われるでしょう。

@item H d
@kindex H d (概略)
@findex gnus-summary-describe-group
現在のグループに関する短い記述を与えます
(@code{gnus-summary-describe-group})。 接頭引数が与えられると、サーバー
から強制的に記述の再読み込みをします。

@item H h
@kindex H h (概略)
@findex gnus-summary-describe-briefly
最重要概略打鍵の非常に短い記述を与えます
(@code{gnus-summary-describe-briefly})。

@item H i
@kindex H i (概略)
@findex gnus-info-find-node
Gnus の info の節 (node) に移動します (@code{gnus-info-find-node})。
@end table

@node Searching for Articles
@subsection 記事を探す

@table @kbd

@item M-s
@kindex M-s (概略)
@findex gnus-summary-search-article-forward
直後にある全ての記事を正規表現で検索します
(@code{gnus-summary-search-article-forward})。

@item M-r
@kindex M-r (概略)
@findex gnus-summary-search-article-backward
前にある全ての記事を正規表現で検索します
(@code{gnus-summary-search-article-backward})。

@item &
@kindex & (概略)
@findex gnus-summary-execute-command
この命令はあなたにヘッダー部分とその部分に合致する正規表現、合致した場合
に実行される命令の入力を促進します (@code{gnus-summary-execute-command})。
もし接頭引数を与えられれば、代わりに後ろ向きに探します。

@item M-&
@kindex M-& (概略)
@findex gnus-summary-universal-argument
プロセス印によって印付けられた全ての記事の操作を実行します
(@code{gnus-summary-universal-argument})。
@end table

@node Summary Generation Commands
@subsection 概略生成命令

@table @kbd

@item Y g
@kindex Y g (概略)
@findex gnus-summary-prepare
現在の概略バッファを再作成します (@code{gnus-summary-prepare})。

@item Y c
@kindex Y c (概略)
@findex gnus-summary-insert-cached-articles
全ての (現在のグループに) キャッシュされた記事 を概略バッファに挿入しま
す (@code{gnus-summary-insert-cached-articles})。

@end table


@node Reallly various Summary Commands
@subsection 本当にいろいろな概略命令

@table @kbd

@item C-d
@kindex C-d (概略)
@findex gnus-summary-enter-digest-group
もし現在のグループが他の記事の集まりであるならば (例えば、摘要 (digest))、
そのような記事でできているグループに入るためにこの命令を使うかもしれませ
ん (@code{gnus-summary-enter-digest-group})。Gnus はこの命令に接頭引数を
与えない限り、どのような型の記事が現在表示されているかを推測しようとし、
それは強制的に ``摘要'' という解釈になります。基本的に、他の様式からなる
他のメッセージの集合であったときは、@kbd{C-d} とすることによりもっと便利
な方法でそれらのメッセージを読む事ができるようになります。

@item M-C-d
@kindex M-C-d (概略)
@findex gnus-summary-read-document
この命令は上のものに非常に似ていますが、いくつかの文書を一つの大ーきいグ
ループに集めます (@code{gnus-summary-read-read-document})。それはいくつ
かの @code{nndoc} グループをそれぞれの文書のために 開き、それからこれら
の @code{nndoc} グループの上に @code{nnvirtual} グループを開く事によって
この事を可能にしています。この命令はプロセス/接頭引数の習慣を理解します
(@pxref{Process/Prefix})。

@item C-t
@kindex C-t (概略)
@findex gnus-summary-togle-truncation
概略行の切断を切り替えます (@code{gnus-summary-toggle-truncation})。これ
はおそらく概略バッファの行中央表示関数を混乱させますので、記事を読んでい
る間に切断を切っているのは良い考えではないでしょう。

@item =
@kindex = (概略)
@findex gnus-summary-expand-window
概略バッファのウィンドウを拡大します
(@code{gnus-summary-expand-window})。接頭引数を与えられれば、@code{記事} 
ウィンドウを拡大します。

@item M-C-e
@kindex M-C-e (概略)
@findex gnus-summary-edit-parameters
現在のグループのグループの媒介変数 (parameter) (@pxref{Group
Parameters}) を編集します (@code{gnus-summary-edit-parameters})。

@end table


@node Exiting the Summary Buffer
@section 概略バッファを抜ける
@cindex summary exit
@cindex exiting groups

普通は概略バッファから抜けると、グループの全ての情報を更新してグループバッ
ファに戻ります。

@table @kbd

@item Z Z
@itemx q
@kindex z z (概略)
@findex q (概略)
@findex gnus-summary-exit
@vindex gnus-summary-exit-hook
@vindex gnus-summary-prepare-exit-hook
@c @icon{gnus-summary-exit}
現在のグループを出て、グループの全ての情報を更新します
(@code{gnus-summary-exit})。抜け出るためのたいていの事をする前に 
@code{gnus-summary-prepare-exit-hook} が呼ばれ、それはディフォルトで 
@code{gnus-summary-expire-articles} を呼びます。抜け出る過程を追えた後に 
@code{gnus-summary-exit-hook} が呼ばれます。(未読の) グループが残ってい
ないときにグループモードに戻るときに 
@code{gnus-group-no-more-groups-hook} が実行されます。

@item Z E
@itemx Q 
@kindex Z E (概略)
@findex Q (概略)
@findex gnus-summary-exit-no-update
グループのどの情報も更新せずに現在のグループを抜け出ます
(@code{gnus-summary-exit-no-update})。

@item Z c
@itemx c
@kindex Z c (概略)
@kindex c (概略)
@findex gnus-summary-catchup-and-exit
@c @icon{gnus-summary-catchup-and-exit}
グループの全ての保留でない記事 (unticked article) に既読の印を付けて、そ
れから抜けます (@code{gnus-summary-catchup-and-exit})。

@item Z C
@kindex Z C (概略)
@findex gnus-summary-catchup-all-and-exit
保留記事も含めて、全ての記事に既読の印を付けて、それから抜けます 
(@code{gnus-summary-catchup-all-and-exit})。

@item Z n
@kindex Z n (概略)
@findex gnus-summary-catchup-and-goto-next-group
全ての記事に既読の印を付けて次のグループへ移動します 
(@code{gnus-summary-catchup-and-goto-next-group})。

@item Z R
@kindex Z R (概略)
@findex gnus-summary-reselect-current-group
現在のグループを出て、それから入り直します 
(@code{gnus-summary-reselect-current-group})。 もし接頭引数を与えられれ
ば、既読と未読の両方の全ての記事を選択します。

@item Z G
@itemx M-g
@kindex Z G (概略)
@kindex M-g (概略)
@findex gnus-summary-rescan-group
@c @icon{gnus-summary-mail-get}
グループを抜け、グループの新しい記事を調べ、グループを選択します 
(@code{gnus-summary-rescan-group})。もし接頭引数を与えられれば、既読と未
読の両方の全ての記事を選択します。

@item Z N
@kindex Z N (概略)
@findex gnus-summary-next-group
グループを抜けて、次のグループへ移動します 
(@code{gnus-summary-next-group})。

@item Z P
@kindex Z P (概略)
@findex gnus-summary-prev-group
グループを抜けて、前のグループへ移動します 
(@code{gnus-summary-prev-group})。

@item Z s
@kindex Z s (概略)
@findex gnus-summary-save-newsrc
現在の既読/印付き記事の数をドリブルバッファ (dribble buffer) に保存し、
それからドリブルバッファを保存します (@code{gnus-summary-save-newrc})。
もし接頭引数を与えられれば、ファイル @file{.newsrc} も保存します。この命
令を使うと、更新なしで抜け出る事 (@kbd{Q} 命令) は意味が無くなります。
@end table

@vindex gnus-exit-group-hook
現在のグループを抜けるときに @code{gnus-exit-group-hook} が呼ばれます。

@findex gnus-summary-wake-up-the-dead
@findex gnus-dead-summary-mode
@vindex gnus-kill-summary-on-exit
あなたにグループを抜けて、それから考えを変える癖があるのであれば、 
@code{gnus-kill-summary-on-exit} を @code{nil} に設定するのが良いかもし
れません。もしそうすれば、gnus はそれから抜け出るときに概略バッファを削
除しません。 (何という驚き!) その代わりに、それはバッファの名前を 
@samp{*Dead Summary ... *} のようなものに変更し、
@code{gnus-dead-summary-mode} と呼ばれるマイナーモードを導入します。今や、
そのバッファに切り替えれば、全てのキーが関数 
@code{gnus-summary-wake-up-the-dead} に割り当てられていることに気付くで
しょう。死んだ概略バッファ (dead summary buffer) でどれかのキーを叩く事
と、生きた普通の概略バッファになるでしょう。

死んだ概略バッファは同時に一つしか存在する事はできません。

@vindex gnus-use-cross-reference
概略バッファを抜け出ると、現在のグループのデータは更新されます (どの記事
を読んで、どの記事に返答したか、などなど。) もし変数 
@code{gnus-use-cross-reference} が @code{t} であると (それがディフォルト
です)、そのグループに相互参照された (cross referenced) 記事は既読の印が
付き、それが相互投稿 (cross post) された他の購読しているグループでも既読
の印が付きます。この変数が @code{nil} でも @code{t} でなければ、記事は購
読と未購読の両方のグループで既読の印が付きます (@pxref{Crosspost
Handling})。


@node Crosspost Handling
@section 相互投稿の扱い

@cindex velveeta
@cindex spamming
相互投稿 (cross post) された記事に既読の印を付ける事は、同じ記事を2回以
上読まないですむという事を保証します。もちろん、だれかがそれをいくつかの
グループに別々に投稿しない限りは。同じ記事をいくつかのグループに投稿する
事 (相互投稿でなくて) は @dfn{spamming} (スパミング) と呼ばれ、あなたは
そのような憎むべき犯罪を行うものにに対して、法律によって不快な記事を送る
ことが義務づけられています。spam (スパム) を選別するために、NoCeM 取扱を
試したいと思うかもしれません (@pxref{NoCeM})。

覚えてください: 相互投稿は構いませんが、同じ記事を別々にいくつかのグルー
プに投稿するのは許されません。大量の相互投稿 (@dfn{velveeta} (ベルベータ))
はどうしても避けられるべきで、過剰相互投稿に対して不満を言うために命令 
@code{gnus-summary-mail-crosspost-complaint} を使うことさえできます。

@cindex cross-posting
@cindex Xref
@cindex @sc{nov}
相互投稿を gnus が正しく扱えないようになる原因の一つは、@sc{nov} 行に 
@code{Xref} ヘッダーを含まない、@sc{xover} (これは非常に良いです、という
のはそれは速度をとても速くするからです) の使用可能な @sc{nntp} サーバー
を使っていることです。これは害悪なのですが、あぁ、悲しいかな、非常に良く
ある事です。Gnus はあなたが読んだ全ての記事に @code{Xref} 行を登録する事
で、正しい事をしよう としますが、記事を削除するか、読まないで既読の印を
付けると、gnus はこれらの記事に @code{Xref} の行をのぞきまわる機会を得る
事が無く、相互参照機構を用いる事ができません。

@cindex LIST overview.fmt
@cindex overview.fmt
あなたの @sc{nntp} サーバーがその概観ファイル (overview file) に
@code{Xref} ヘッダーを含んでいるかを調べるには、
@samp{telnet your.nntp.server nntp} として、@code{inn} サーバーで 
@samp{More READER} とし、それから @samp{LIST overview.fmt} とする事を試
してください。これは動作しないでしょうが、もし動作して、取得した最後の行
が @samp{Xref:full} でないならば、ニューズの管理者が概観ファイルに 
@code{Xref} ヘッダーを含むようにするまで、ニューズの管理者に叫び、泣き付
く事を続けるべきでしょう。

@vindex gnus-nov-is-evil
Gnus にいつでも正しい @code{Xref} を取得するようにさせたいのであれば、
@code{gnus-nov-is-evil} を @code{t} にする必要があり、それは非常に速度を
遅くします。

ま、人生はそのようなものです。

代替手段に付いては @pxref{Duplicate Suppression} を参照してください。


@node Duplicate Suppression
@section 重複の抑制

ディフォルトでは gnus は相互投稿機構を利用する事によって、同じ記事を2回
以上読まないようにしようとします (@pxref{Crosspost Handling})。しかし、
その単純で効果的な方法は、いろいろな理由により、満足する結果をもたらさな
いかも知れません。

@enumerate
@item
@sc{nntp} サーバーは @code{Xref} ヘッダーの生成に失敗するかも知れません。
これは悪い事で、あまり起こりません。

@item
@sc{nntp} サーバーは @file{.overview} データベースに @code{Xref} ヘッダー
を含めるのに失敗するかも知れません。これは悪い事で、非常に良くある事です、
あぁ悲しい。

@item
同じグループ (もしくはいくつかの関連したグループ) を違った @sc{nntp} サー
バーから読んでいるかもしれません。

@item
グループに投稿された記事と重複するメールを受け取ったかもしれません。
@end enumerate

@code{Xref} の扱いに失敗する状況は他にもありますが、これら4つがとても良
くある状況です。

もし、本当にもしも @code{Xref} の扱いに失敗したら、@dfn{重複抑制} に切り
替える事を考えるかもしれません。そうすれば、gnus はあなたが読んだ全ての
記事かそうでなければ、既読の印が付いた全ての記事の @code{Message-ID} を
記憶し、それから、魔法のように、その後のそれらと出会った全ての場合に、既
読の印を付けます---@emph{全て} のグループで。この機構を使うのは非常に非
効率的ですが、過度に非効率なわけではありません。もちろん同じ記事を一回以
上読むほうが好ましいです。

重複抑制はあまり繊細なものではありません。どちらかというと、大槌のような
ものです。それは非常に単純な方法で動作しています---もし記事に既読の印を
付ければ、それはこの Message-ID を キャッシュに加えます。次にこの
Message-ID にであったときは、@samp{M} 印によって記事に既読の印を付けます。
それはその記事がどのグループにあるかは気にしません。

@table @code
@item gnus-suppress-duplicates
@vindex gnus-suppress-duplicates
@code{nil} でなければ、重複抑制をします。

@item gnus-save-duplicate-list
@vindex gnus-save-duplicate-list
@code{nil} でなければ、重複のリストをファイルに保存します。これは起動と
終了の時間を長くしますので、でぉフォルトでは @code{nil} です。しかし、こ
れは単一の gnus の実行期で読まれた重複記事だけが抑制されるという事です。

@item gnus-duplicate-list-length
@vindex gnus-duplicate-list-length
この変数はどのくらい多くの @code{Message-ID} を重複抑制リストに保ってお
くかも決定します。ディフォルトは10000です。

@item gnus-duplicate-file
@vindex gnus-duplicate-file
重複抑制のリストを蓄積しておくファイルの名前です。ディフォルトは 
@file{~/News/suppression} です。
@end table

何度も gnus を終了して起動する傾向があるのであれば、おそらく 
@code{gnus-save-duplicate-list} を @code{t} にするのは良い考えでしょう。
もし gnus を続けて何週間も走らせておくのであれば、それを @code{nil} にす
るかもしれません。一方で、リストを保存する事は起動と終了をずっと遅くしま
すので、よく gnus を終了して起動するのであれば、
@code{gnus-save-duplicate-list} を @code{nil} に設定するべきであるという
事になります。うーむ。私はあなたがどうするかに任せたい、と思います。


@node The Article Buffer
@chapter 記事バッファ
@cindex article buffer

記事は一つしかない記事バッファに表示されます。全ての概略バッファ
は(gnus に共有しないように指示しない限り)同じ記事バッファを共有
します。

@menu
* Hiding Headers::        どのヘッダーを表示するかを決める。
* Using MIME::            記事を読む前に @sc{mime} 処理をする。
* Customizing Articles::  記事の見栄えを仕立てる。
* Article Keymap::        記事バッファで使えるキー操作。
* Misc Article::          その他。
@end menu


@node Hiding Headers
@section 余分なヘッダーを隠す
@cindex hiding headers
@cindex deleting headers

各記事の頭の部分はヘッダー(@dfn{head})と呼ばれます(残りの部分は
ボディ(@dfn{body})です。すでにお気づきでしょうが)。

@vindex gnus-show-all-headers
ヘッダーにはたくさんの便利な情報が含まれています。記事を書いた人
の名前、それが書かれた日付、記事の表題などです。これはとても良い
んですが、ヘッダーには大部分の人には見たくもない情報 --- 記事が
あなたのところに着くまでどんなシステムを経由してきたか、
@code{Message-ID}、@code{References} などなど…もうやんなっちゃう
くらい --- もたくさん含まれています。たぶんあなたはこれらの行は
いくつか取り除いてしまいたいと思うでしょう。もしこれらの行を全て
記事バッファ内に残しておきたければ、@code{gnus-show-all-headers}
を @code{t} に設定してください。

Gnus はヘッダーを選り分けるために 2 つの変数を用意しています。

@table @code

@item gnus-visible-headers
@vindex gnus-visible-headers
この変数が @code{nil} 以外であれば、どのヘッダーを記事バッファに
残したいかを指定する正規表現であるとみなされます。この変数にマッ
チしないヘッダーは全て隠されます。

例えば、記事を書いた人の名前と表題のみを見たければ、こう指定します。

@lisp
(setq gnus-visible-headers "^From:\\|^Subject:")
@end lisp

この変数は、表示させたいヘッダーにマッチする正規表現をリストで指
定することもできます。

@item gnus-ignored-headers
@vindex gnus-ignored-headers
この変数は @code{gnus-visible-headers} の反対です。この変数が設
定されていれば(かつ @code{gnus-visible-headers} が @code{nil} で
あれば)、これは隠したいヘッダー行全てにマッチする正規表現である
とみなされます。この変数にマッチしない全てのヘッダー行は表示され
ます。

例えば、単に @code{References} 行と @code{Xref} 行のみを消し去り
たければ、このようにします。

@lisp
(setq gnus-ignored-headers "^References:\\|^Xref:")
@end lisp

この変数は消したいヘッダーにマッチする正規表現のリストでも構いま
せん。

なお、@code{gnus-visible-headers} が @code{nil} 以外の場合は、こ
の変数には効果が無いことに注意してください。

@end table

@vindex gnus-sorted-header-list
Gnus はヘッダーの並べ替え(ソート)も行います(これはディフォルトで
行われます)。この並べ替えは @code{gnus-sorted-header-list} 変数
を設定することで制御することができます。これはヘッダーをどういう
順序で表示するかを指定する正規表現のリストです。

例えば、記事の著者名を最初に、次に表題を表示したければ、こんな風
になるでしょう。

@lisp
(setq gnus-sorted-header-list '("^From:" "^Subject:"))
@end lisp

表示するようになっているヘッダーでこの変数に指定されていないもの
は、この変数に指定されている全てのヘッダーの後に、適当な順序で表
示されるでしょう。

@findex gnus-article-hide-boring-headers
@vindex gnus-article-display-hook
@vindex gnus-boring-article-headers
@code{gnus-article-hide-boring-headers} を
@code{gnus-article-display-hook} に入れることによって、もっとつ
まらないヘッダーを隠すことができます。この関数が何をするかは
@code{gnus-boring-article-headers} 変数に依存します。この変数は
リストですが、このリストには実際のヘッダーの名前が入るのではあり
ません。代わりに gnus がチェックして視界から消し去るためのさまざ
まな「つまらない条件」@dfn{boring conditions} のリストを指定しま
す。

この条件には以下のようなものがあります。
@table @code
@item empty
空のヘッダーを全て消去します。
@item newsgroups
@code{Newsgroups} ヘッダーが現在のグループ名しか含んでいない場合
には消去します。
@item followup-to
@code{Followup-To} ヘッダーが @code{Newsgroups} ヘッダーと同一で
ある場合には消去します。
@item reply-to
@code{Reply-To} ヘッダーが @code{From} ヘッダーと同じアドレスを
示している場合には消去します。
@item date
その記事が過去 3 日以内のものであれば、@code{Date} ヘッダーを消
去します。
@item long-to
@code{To} ヘッダーがあまりにも長い場合には消去します。
@item many-to
@code{To} ヘッダーが一つよりも多ければ、それらを全て消去します。
@end table

上記の最初の 4 つの要素を入れたければ、こんな風になります。

@lisp
(setq gnus-boring-article-headers
      '(empty newsgroups followup-to reply-to))
@end lisp

これはこの変数のディフォルト値でもあります。


@node Using MIME
@section @sc{mime} を使う
@cindex @sc{mime}

パントマイム (mime) とは、意味も無く空中で手を振るものとして広く
知られており、その間観客はあくびをしながらぼんやりとしてます。

一方、@sc{mime} とは、意味も無く記事を符号化する標準であり、その
ために全てのニューズリーダが恐怖で死んでしまうものです。

@sc{mime} はその記事がどんな文字集合を使用しているか、その文字を
どう符号化しているかを指定することができ、さらには絵やその他の邪
悪なものを無邪気な格好の記事で埋め込むことさえ可能にします。

@vindex gnus-show-mime
@vindex gnus-show-mime-method
@vindex gnus-strict-mime
@findex metamail-buffer
Gnus は @code{gnus-show-mime-method} に記事を押し付けることで 
@sc{mime} を扱います。これはディフォルトでは 
@code{metamail-buffer} です。この関数は外部 @code{metamail} プロ
グラムを呼び出して実際の処理を行います。このプログラムに関するあ
りがちな問題は、このプログラムは Emacs のバッファが 8ビットのも
のを表示できない、と思っていることです。真実を教えてあげるには、
@file{.bash_profile} ファイルに以下のようなものを書いてください
(あなた、@code{bash} 使ってるよねえ?)。

@example
export MM_CHARSET="iso-8859-1"
@end example

@code{metamail} に関する詳しい情報は、マニュアルを参照してくださ
い。

@sc{mime} を常に使用したければ、@code{gnus-show-mime} を 
@code{t} に設定してください。しかし、@code{gnus-strict-mime} が 
@code{nil} 以外であれば、@sc{mime} 処理は記事中に @sc{mime} ヘッ
ダーがあるときのみ使用されます。@code{gnus-show-mime} を設定して
いると、運が悪いと記事バッファには故障したような画面が見えること
もあるでしょう。これは避けようがありません。

このたちの悪い問題で驚かされないようにするには、概略バッファにお
いて切り替え機能を使うというのが最善かも知れません(例えば、
@samp{alt.sing-a-long} グループに入ると、あなたの気づかないうち
に@sc{mime} は記事中のサウンドファイルを復号して、何やら怪しげな
長い長い歌があなたのスピーカーから大音響で流れ出し、あなたはボ
リュームボタンを見つけられず、というのはそんなものはもともとつい
てないからで、みんなはあなたの方を睨みはじめ、あなたはプログラム
を止めようとするけどできなくて、ボリュームを制御するプログラムも
見つけられなくて、そして部屋中の全員は突然あなたのことを軽蔑の眼
差しで見るようになってしまい、あなたはちょっと面白くない思いをす
る、とか)。

現実の出来事と実在の人物に類似しているかもしれませんが、これは全
てホントのことです。げほげほ。

@node Customizing Articles
@section 記事のカスタマイズ
@cindex article customization

@vindex gnus-article-display-hook
@code{gnus-article-display-hook} は記事が記事バッファに書き込ま
れた直後に呼び出されます。これは記事が表示される前の処理を全て扱
う、ということです。

@findex gnus-article-maybe-highlight
ディフォルトではこのフックには @code{gnus-article-hide-headers}、
@code{gnus-article-treat-overstrike}、
@code{gnus-article-maybe-highlight} だけが含まれていますが、この
フックに入れることができる関数は何千も、いや何百万もあります。各
関数の概観は@pxref{Article Highlighting}、 @pxref{Article
Hiding}、@pxref{Article Washing}、 @pxref{Article Buttons}、 
@pxref{Article Date} を参照してください。注意点として、このフッ
クでは関数の順序が影響することがあるので、お望みの結果を得るには
ちょっと手間取ってしまうかもしれません。

もちろん、あなた独自の関数を書くこともできます。この関数は記事バッ
ファ内から呼び出され、あなたのやりたいことをほとんど何でもできま
す。バッファに残しておかなければならない情報は何もありません --- 
何でも変更することができます。ですが、ヘッダーは消去しない方が良
いです。その代わり、ヘッダーをどこかにやってしまいたければ、それ
らを見えないようにしてください。

@node Article Keymap
@section 記事のキー操作

概略バッファにおけるキー操作のほとんどは記事バッファでも使用でき
ます。これらは概略バッファでそのキーを押したかのように動作します。
つまり、実は記事を読んでいる間、概略バッファを表示させておく必要
もないということです。全ての操作は記事バッファから行うことができ
るのです。

それらに加えていくつかのキー操作が利用できます。

@table @kbd

@item SPACE
@kindex SPACE (Article)
@findex gnus-article-next-page
一頁前にめくります (@code{gnus-article-next-page})。

@item DEL
@kindex DEL (Article)
@findex gnus-article-prev-page
一頁後ろに戻します (@code{gnus-article-prev-page})。

@item C-c ^
@kindex C-c ^ (Article)
@findex gnus-article-refer-article
カーソル位置が @code{Message-ID} の近辺にあるときに @kbd{r} を押
すと、gnus はサーバーからその記事を取ってこようとします
(@code{gnus-article-refer-article})。

@item C-c C-m
@kindex C-c C-m (Article)
@findex gnus-article-mail
Send a reply to the address near point (@code{gnus-article-mail}).  If
given a prefix, include the mail.

カーソル位置の近くにあるアドレスに返信を送ります
(@code{gnus-article-mail})。接頭引数を与えると、そのメールに引用
します。

@item s
@kindex s (Article)
@findex gnus-article-show-summary
バッファを再構成して、概略バッファを見えるようにします
(@code{gnus-article-show-summary})。

@item ?
@kindex ? (Article)
@findex gnus-article-describe-briefly
利用できるキー操作のごく簡単な説明を出します
(@code{gnus-article-describe-briefly})。

@item TAB
@kindex TAB (Article)
@findex gnus-article-next-button
次のボタンがあればそこに移動します 
(@code{gnus-article-next-button})。これはボタン機能をオンにして
いるときのみ意味を持ちます。

@item M-TAB
@kindex M-TAB (Article)
@findex gnus-article-prev-button
一つ前のボタンがあればそこに移動します 
(@code{gnus-article-prev-button})。

@end table


@node Misc Article
@section 記事のその他

@table @code

@item gnus-single-article-buffer
@vindex gnus-single-article-buffer
@code{nil} 以外であれば、全てのグループに対して同じ記事バッファ
を使用します(これはディフォルトです)。 @code{nil} であれば、各グ
ループ毎の固有の記事バッファを持つようになります。

@vindex gnus-article-prepare-hook
@item gnus-article-prepare-hook
このフックは記事が記事バッファに書き込まれた直後に呼び出されます。
これは主に、何か記事の内容に依存する処理をする関数のために用意さ
れています。つまり記事バッファの内容を変更するような目的で使うべ
きではないでしょう。

@vindex gnus-article-display-hook
@item gnus-article-display-hook
このフックは記事を表示するときの最後に呼び出されるようになってい
て、記事バッファの内容の修正、ハイライト処理、ヘッダーを隠す、な
どといったことを行うために用意されています。

@item gnus-article-mode-hook
@vindex gnus-article-mode-hook
記事モードバッファで呼び出されるフックです。

@item gnus-article-mode-syntax-table
@vindex gnus-article-mode-syntax-table
記事バッファで用いられるシンタックステーブルです。これは
@code{text-mode-syntax-table} をもとに初期化されます。

@vindex gnus-article-mode-line-format
@item gnus-article-mode-line-format
この変数は @code{gnus-summary-mode-line-format} と同じ行に従った
様式文字列です。これは以下の一つの拡張を除いて、その変数と同じ様
式指定を受付けます。

@table @samp
@item w
記事の「洗濯状態」@dfn{wash status}。これは記事に対して行われた
であろう洗濯操作を示す一文字からなる短い文字列になります。
@end table

@vindex gnus-break-pages

@item gnus-break-pages
改頁 @dfn{page breaking} を行うかどうかを制御します。この変数が
@code{nil} 以外であれば、記事中に頁区切り文字が現れた場所ごとに
頁分割します。この変数が @code{nil} であれば頁分けは行われません。

@item gnus-page-delimiter
@vindex gnus-page-delimiter
これが上で触れた区切り文字です。ディフォルトでは @samp{^L} (フォー
ムフィード、改頁) です。
@end table


